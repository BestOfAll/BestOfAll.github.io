<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>博客图片不显示问题</title>
      <link href="/2020/picnotshow.html"/>
      <url>/2020/picnotshow.html</url>
      
        <content type="html"><![CDATA[<p>因为我是自己上传的 github ，然后打不开了，所以查了一下 ip 和相关文章。网上文章都是在 <code>C:\Windows\System32\drivers\etc\hosts</code> 文件中复制固定内容，不同网段的用户查到的IP可能不一样，所以需要自己去查，而不是简单的copy。</p><ol><li>首先检测是哪个链接问题，这里我是调整好的。</li></ol><p><img src="https://raw.githubusercontent.com/CalmCenter/picGo/master/pictures/20200330134722.png" alt=""></p><ol start="2"><li>打开 <a href="http://tool.chinaz.com/dns/" target="_blank" rel="noopener">DNS查询网站</a> ，搜索 <code>avatars2.githubusercontent.com</code> </li></ol><p><img src="https://raw.githubusercontent.com/CalmCenter/picGo/master/pictures/20200330135205.png" alt=""></p><p>选择一个可以使用的 <code>IP</code>，在 <code>C:\Windows\System32\drivers\etc\hosts</code> 末尾 加上</p><p>在末尾加上</p><pre><code>151.101.108.133 avatars0.githubusercontent.com 151.101.108.133 avatars1.githubusercontent.com 151.101.108.133 avatars2.githubusercontent.com 151.101.108.133 avatars3.githubusercontent.com 151.101.108.133 avatars4.githubusercontent.com 151.101.108.133 avatars5.githubusercontent.com 151.101.108.133 avatars6.githubusercontent.com 151.101.108.133 avatars7.githubusercontent.com 151.101.108.133 avatars8.githubusercontent.com </code></pre><p>不同网段的用户查到的 <code>IP</code> 可能不一样，所以需要自己去查，而不是简单的copy，这是我最终的</p><pre><code># GitHub Start 192.30.253.112 github.com 192.30.253.119 gist.github.com 185.199.111.154 github.githubassets.com 185.199.108.154 github.githubassets.com 185.199.109.154 github.githubassets.com 185.199.110.154 github.githubassets.com 151.101.108.133 assets-cdn.github.com 151.101.108.133 raw.githubusercontent.com 151.101.108.133 gist.githubusercontent.com 151.101.108.133 cloud.githubusercontent.com 151.101.108.133 camo.githubusercontent.com 151.101.108.133 avatars0.githubusercontent.com 151.101.108.133 avatars1.githubusercontent.com 151.101.108.133 avatars2.githubusercontent.com 151.101.108.133 avatars3.githubusercontent.com 151.101.108.133 avatars4.githubusercontent.com 151.101.108.133 avatars5.githubusercontent.com 151.101.108.133 avatars6.githubusercontent.com 151.101.108.133 avatars7.githubusercontent.com 151.101.108.133 avatars8.githubusercontent.com # GitHub End</code></pre><ol start="3"><li>刷新 DNS</li></ol><p>在 <code>cmd</code> 中输入<code>ipconfig /flushdns</code> 即可刷新，不行的话再重启电脑，这样就能成功打开<code>github</code> 或博客了，所有图片和内容都能加载。</p>]]></content>
      
      
      <categories>
          
          <category> github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>App 内存检测优化</title>
      <link href="/2020/memory-optimization2.html"/>
      <url>/2020/memory-optimization2.html</url>
      
        <content type="html"><![CDATA[<h1 id="本文主要记载"><a href="#本文主要记载" class="headerlink" title="本文主要记载"></a>本文主要记载</h1><hr><ul><li><strong>1 什么是 Memory Profiler？</strong><ul><li>1.1 使用介绍<ul><li>1.1.1 启用高级分析</li><li>1.1.2 计算内存(每个内存类别当前使用多少内存)</li><li>1.1.3 查看内存分配(分配的对象数)</li><li>1.1.4 在分析时提高应用性能</li><li>1.1.5 捕获堆转储</li><li>1.1.6 将堆转储另存为 HPROF 文件</li></ul></li></ul></li><li><strong>2 什么是 MAT？</strong><ul><li>2.1 使用前提</li><li>2.2 使用介绍</li></ul></li><li><strong>3 什么是 LeakCanary？</strong><ul><li>3.1 LeakCanary 原理</li><li>3.2 LeakCanary 使用</li></ul></li><li><strong>4 自定义实现 Demo</strong><ul><li>4.1 自动化监测 Demo</li><li>4.2 重复图片监测 Demo</li></ul></li><li><strong>5 优化思路</strong><ul><li>5.1 设备分级</li><li>5.2 Bitmap 优化</li></ul></li><li><strong>6 更多</strong></li></ul><blockquote><p>一个好的架构可以减少甚至避免我们犯错，而一个好的监控可以帮助我们及时发现问题。</p></blockquote><p>检测工具常见的有 <code>Memory Profiler</code> <code>MAT</code> <code>LeakCanary</code></p><h2 id="1-什么是-Memory-Profiler"><a href="#1-什么是-Memory-Profiler" class="headerlink" title="1  什么是 Memory Profiler?"></a>1  什么是 Memory Profiler?</h2><hr><p><code>Profiler</code> 是 <code>Android Studio</code> 为我们提供的性能分析工具，它包含了 <code>CPU</code>、<code>内存</code>、<code>网络</code>以及 <code>电量</code> 的分析信息，而 <code>Memory Profiler</code> 则是 <code>Profiler</code> 中的其中一个版块。</p><p>打开 <code>Profiler</code>  方式</p><ol><li>View &gt; Tool Windows &gt; Android Profiler</li><li>下方的 Profiler 标签</li><li>双击 shift 搜索 profiler</li></ol><h3 id="1-1-使用介绍"><a href="#1-1-使用介绍" class="headerlink" title="1.1 使用介绍"></a>1.1 使用介绍</h3><hr><img src="https://raw.githubusercontent.com/CalmCenter/picGo/master/pictures/20200413144637.png" style="zoom:70%"><ol><li><p>用于强制执行垃圾回收事件的按钮（强制 <code>GC</code> ）。</p></li><li><p>用于 <code>1.1.5 捕获堆转储</code> 的按钮。</p><p><strong>注意</strong>：只有在连接到搭载 <code>Android 7.1</code>（<code>API</code> 级别 25）或更低版本的设备时，才会在堆转储按钮右侧显示用于 <code>记录内存分配</code> 的按钮。</p></li><li><p>用于指定分析器多久捕获一次内存分配的下拉菜单。选择适当的选项可 <code>1.1.4 在分析时提高应用性能</code>。</p></li><li><p>用于缩放时间轴的按钮。</p></li><li><p>用于跳转到实时内存数据的按钮。</p></li><li><p>事件时间轴，显示活动状态、用户输入事件和屏幕旋转事件。</p></li><li><p>内存使用量时间轴，它会显示以下内容：</p><ul><li>一个堆叠图表，显示 <code>1.1.2 每个内存类别当前使用多少内存</code> ，如左侧的 y 轴以及顶部的彩色键所示。</li><li>一条虚线，表示 <code>1.1.3 分配的对象数</code>，如右侧的 y 轴所示。</li><li>每个垃圾回收事件的图标。</li></ul></li></ol><p>如果使用的是搭载 Android 7.1 或更低版本的设备，则并非所有分析数据在默认情况下都可见。如果看到一条消息，显示“Advanced profiling is unavailable for the selected process”，需要 <code>1.1.1 启用高级分析</code> 才能看到以下内容：</p><ul><li>事件时间轴</li><li>分配的对象数</li><li>垃圾回收事件</li></ul><p>在 Android 8.0 及更高版本上，始终为可调试应用启用高级分析。</p><h4 id="1-1-1-启用高级分析"><a href="#1-1-1-启用高级分析" class="headerlink" title="1.1.1  启用高级分析"></a>1.1.1  启用高级分析</h4><hr><ol><li>依次选择 <strong>Run &gt; Edit Configurations</strong>。</li><li>在左侧窗格中选择本应用模块。</li><li>点击 <strong>Profiling</strong> 标签，然后勾选 <strong>Enable advanced profiling</strong>。</li><li>重新编译并运行应用。</li></ol><h4 id="1-1-2-计算内存-每个内存类别当前使用多少内存"><a href="#1-1-2-计算内存-每个内存类别当前使用多少内存" class="headerlink" title="1.1.2 计算内存(每个内存类别当前使用多少内存)"></a>1.1.2 计算内存(每个内存类别当前使用多少内存)</h4><hr><img src="https://raw.githubusercontent.com/CalmCenter/picGo/master/pictures/20200414112438.png" style="zoom:90%"><p>内存计数中的类别如下：</p><ul><li><p><strong>Java</strong>：从 <code>Java</code> 或 <code>Kotlin</code> 代码分配的对象的内存。</p></li><li><p><strong>Native</strong>：从 <code>C</code> 或 <code>C++</code> 代码分配的对象的内存。</p><p>即使应用中不使用 <code>C++</code>，也可能会看到此处使用的一些原生内存，因为 <code>Android</code> 框架使用原生内存处理各种任务，如处理图像资源和其他图形时。</p></li><li><p><strong>Graphics</strong>：图形缓冲区队列向屏幕显示像素（包括 <code>GL</code> 表面、<code>GL</code> 纹理等等）所使用的内存。（请注意，这是与 <code>CPU</code> 共享的内存，不是 <code>GPU</code> 专用内存。）</p></li><li><p><strong>Stack</strong>：应用中的原生堆栈和 <code>Java</code> 堆栈使用的内存。这通常与应用运行多少线程有关。</p></li><li><p><strong>Code</strong>：应用用于处理代码和资源（如 <code>dex</code> 字节码、经过优化或编译的 <code>dex</code> 代码、<code>.so</code> 库和字体）的内存。</p></li><li><p><strong>Others</strong>：应用使用的系统不确定如何分类的内存。</p></li><li><p><strong>Allocated</strong>：应用分配的 <code>Java/Kotlin</code> 对象数。此数字没有计入 C 或 C++ 中分配的对象。</p><p>如果连接到搭载 <code>Android 7.1</code> 及更低版本的设备，只有在 <code>Memory Profiler</code> 连接到运行的应用时，才开始此分配计数。因此，开始分析之前分配的任何对象都不会被计入。不过，<code>Android 8.0</code> 及更高版本附带一个设备内置分析工具，该工具可跟踪所有分配，因此，在 <code>Android 8.0</code> 及更高版本上，此数字始终表示应用中待处理的 Java 对象总数。</p></li></ul><p><strong>注意：</strong>高级分析配置会使编译过程变慢，所以仅在想要开始分析应用时，才应启用该配置。</p><h4 id="1-1-3-查看内存分配-分配的对象数"><a href="#1-1-3-查看内存分配-分配的对象数" class="headerlink" title="1.1.3 查看内存分配(分配的对象数)"></a>1.1.3 查看内存分配(分配的对象数)</h4><hr><p>对于 <code>Android 8.0</code> 及更高版本，选择一个现有时间轴区域以查看对象分配</p><p>对于 <code>Android 7.1</code> 及更低版本，必须明确记录内存分配，点击 <code>Memory Profiler</code> 工具栏中的 <code>Record memory allocations</code> 图标或者 一个 <code>Record</code> 的按钮。记录时，<code>Memory Profiler</code> 会跟踪应用中发生的所有分配。完成后，请点击 <code>Stop recording</code> 图标或者一个 <code>Stop</code> 的按钮，查看分配。</p><p><strong>注意</strong>：在 <code>Android 7.1</code> 及更低版本上，最多可以记录 <code>65535</code> 个分配。 如果记录会话超出此限制，则记录中仅保存最新的 <code>65535</code> 个分配。（在 <code>Android 8.0</code> 及更高版本上，则没有实际的限制。）</p><img src="https://raw.githubusercontent.com/CalmCenter/picGo/master/pictures/20200414135710.png" style="zoom:70%"><ol><li>浏览列表以查找堆计数异常大且可能存在泄露的对象。为帮助查找已知类，点击 <code>Class Name</code> 列标题以按字母顺序排序。然后，点击一个类名称。此时右侧将出现 <code>Instance View</code> 窗格，显示该类的每个实例。</li><li>在 <code>Instance View</code> 窗格中，点击一个实例。此时下方将出现 <code>Call Stack</code> 标签页，显示该实例被分配到何处以及在哪个线程中。</li><li>在 <code>Call Stack</code> 标签页中，右键点击任意行并选择 <code>Jump to Source</code>，以在编辑器中打开该代码。</li></ol><p><code>Live Allocation</code> 第一个选择框是选择要检查的堆：</p><ul><li><strong>default heap</strong>：当系统未指定堆时。</li><li><strong>image heap</strong>：系统启动映像，包含启动期间预加载的类。此处的分配保证绝不会移动或消失。</li><li><strong>zygote heap</strong>：写时复制堆，其中的应用进程是从 <code>Android</code> 系统中派生的。</li><li><strong>app heap</strong>：您的应用在其中分配内存的主堆。</li><li><strong>JNI heap</strong>：显示 Java 原生接口 (<code>JNI</code>) 引用被分配和释放到什么位置的堆。</li></ul><p>第二个选择框选择如何安排分配：</p><ul><li><strong>Arrange by class</strong>：根据类名称对所有分配进行分组。这是默认选项。</li><li><strong>Arrange by package</strong>：根据软件包名称对所有分配进行分组。</li><li><strong>Arrange by callstack</strong>：将所有分配分组到其对应的调用堆栈。只有在记录分配期间 <code>捕获堆转储</code> 时，此选项才有效。即便如此，堆中也很可能有在开始记录之前分配的对象，所以会先显示这些分配，直接按类名称列出它们。</li></ul><h4 id="1-1-4-在分析时提高应用性能"><a href="#1-1-4-在分析时提高应用性能" class="headerlink" title="1.1.4 在分析时提高应用性能"></a>1.1.4 在分析时提高应用性能</h4><hr><p>为了在分析时提高应用性能，<code>Memory Profiler</code> 在默认情况下会定期对内存分配进行采样。在运行 <code>API</code> 级别 <code>26</code> 或更高级别的设备上进行测试时，可以使用 <code>Allocation Tracking</code> 下拉菜单来更改此行为。可用选项如下：</p><ul><li><strong>Full</strong>：捕获内存中的所有对象分配。这是 <code>Android Studio 3.2</code> 及更低版本中的默认行为。如果您有一个分配了大量对象的应用，则可能会在分析时观察到应用的运行速度明显减慢。</li><li><strong>Sampled</strong>：定期对内存中的对象分配进行采样。这是默认选项，在分析时对应用性能的影响较小。在短时间内分配大量对象的应用仍可能会表现出明显的速度减慢。</li><li><strong>Off</strong>：停止跟踪应用的内存分配。</li></ul><h4 id="1-1-5-捕获堆转储"><a href="#1-1-5-捕获堆转储" class="headerlink" title="1.1.5 捕获堆转储"></a>1.1.5 捕获堆转储</h4><hr><p>堆转储显示在捕获堆转储时应用中哪些对象正在使用内存。特别是在长时间的用户会话后，堆转储会显示认为不应再位于内存中却仍在内存中的对象，从而帮助识别内存泄露。</p><img src="https://raw.githubusercontent.com/CalmCenter/picGo/master/pictures/20200414161957.png" style="zoom:40%"><p>要捕获堆转储，请点击 Memory Profiler 工具栏中的 <strong>Dump Java heap</strong> 图标 <img src="https://developer.android.google.cn/studio/images/buttons/profiler-heap-dump.png" style="zoom:70%">  在转储堆期间，Java 内存量可能会暂时增加。 这很正常，因为堆转储与您的应用发生在同一进程中，并需要一些内存来收集数据。</p><ul><li><p><strong>Allocations</strong>：堆中的分配数。</p></li><li><p><strong>Native Size</strong>：此对象类型使用的原生内存总量（以字节为单位）。只有在使用 <code>Android 7.0</code> 及更高版本时，才会看到此列。</p><p>您会在此处看到采用 <code>Java</code> 分配的某些对象的内存，因为 <code>Android</code> 对某些框架类（如 <code>Bitmap</code>）使用原生内存。</p></li><li><p><strong>Shallow Size</strong>：此对象类型使用的 Java 内存总量（以字节为单位）。</p></li><li><p><strong>Retained Size</strong>：为此类的所有实例而保留的内存总大小（以字节为单位）。</p></li></ul><p>点击一个类名称可在右侧打开 <strong>Instance View</strong> 窗口。</p><ul><li><strong>Depth</strong>：从任意 <code>GC</code> 根到选定实例的最短跳数。</li><li><strong>Native Size</strong>：原生内存中此实例的大小。 只有在使用 Android 7.0 及更高版本时，才会看到此列。</li><li><strong>Shallow Size</strong>：<code>Java</code> 内存中此实例的大小。</li><li><strong>Retained Size</strong>：此实例所支配内存的大小。</li></ul><p>如果你 <code>ClassName</code> 选中的是 <code>Bitmap</code> ,在 <code>7.1</code> 及以下版本的设备中 <code>Call Sack</code>位置会出现 <code>Bitmap Preview</code> 功能，来预览是哪张图片</p><p><code>References</code> 标签页，显示对该对象的每个引用，如果发现某个引用可能在泄露内存，右键点击它并选择 <code>Go to Instance</code>。这样会从堆转储中选择相应的实例，从而显示它自己的实例数据。</p><h4 id="1-1-6-将堆转储另存为-HPROF-文件"><a href="#1-1-6-将堆转储另存为-HPROF-文件" class="headerlink" title="1.1.6 将堆转储另存为 HPROF 文件"></a>1.1.6 将堆转储另存为 HPROF 文件</h4><hr><p>在 Android Studio 3.1 及更低版本中，<code>Export capture to file</code> 按钮 <img src="https://developer.android.google.cn/studio/images/buttons/profiler-export-hprof.png" alt="img"> 位于时间轴下方工具栏的左侧</p><p>在 Android Studio 3.2 及更高版本中，<code>Sessions</code> 窗格中每个 <code>Heap Dump</code>条目的右侧都有一个 <code>Export Heap Dump</code> 按钮。在随即显示的 <code>Export As</code> 对话框中，使用 <code>.hprof</code>  文件扩展名保存文件。</p><h2 id="2-什么是-MAT"><a href="#2-什么是-MAT" class="headerlink" title="2 什么是 MAT?"></a>2 什么是 MAT?</h2><hr><p>对于内存泄漏问题，Memory Profiler 只能给我们提供一个简单的分析，不能够帮我们确认具体发生问题的地方。</p><p>而 MAT 就可以帮我们做到这一点，MAT 的全称是 Memory Analyzer Tool，它是一款功能强大的 Java 堆内存分析工具，可以用于查找内存泄漏以及查看内存消耗情况。</p><h3 id="2-1-使用前提"><a href="#2-1-使用前提" class="headerlink" title="2.1 使用前提"></a>2.1 使用前提</h3><hr><ol><li><p>到 MAT 的官网 <a href="https://www.eclipse.org/mat/downloads.php" target="_blank" rel="noopener">下载 MAT</a>。</p></li><li><p>使用 <code>Memory Profiler</code> 的堆转储功能，导出 <code>hprof（Heap Profile）</code>文件。</p></li><li><p>配置 <code>platform-tools</code> 环境变量</p></li><li><p>使用命令将 <code>Memory Profiler</code> 中导出来的 <code>hprof</code> 文件转换为 MAT 可以解析的 hprof 文件，命令如下</p></li></ol><pre><code>hprof-conv ../原始文件.hprof ../输出文件.hprof</code></pre><ol start="5"><li>打开 MAT</li></ol><p><code>File &gt; open Heap dump</code> ，选择我们转换后的文件</p><h3 id="2-2-使用介绍"><a href="#2-2-使用介绍" class="headerlink" title="2.2 使用介绍"></a>2.2 使用介绍</h3><hr><img src="https://raw.githubusercontent.com/CalmCenter/picGo/master/pictures/20200414173426.png" style="zoom:60%"><ul><li><p><strong>Overview</strong>：概览信息</p><ul><li><strong>Unreachable Objects Histogram</strong>：可被回收的对象，但是仍在内存当中</li></ul></li><li><p><strong>Histogram</strong>：直方图，基于类来分析，会显示该类有多少个实例</p><p>第一行输入可以搜索，<code>Tool Bar</code> 中会多出一个 <code>Group by...</code>  选择 <code>package</code> 会变成已报名的形式来进行分类。</p><ul><li><strong>Object</strong>：有多少实例</li><li><strong>Shallow Heap</strong>：自己占了多少内存</li><li><strong>Retained Heap</strong>：应用链总共占了多少内存</li><li>选择一个类条目右键会出现 <code>List objects</code><ul><li><strong>with outgoing references</strong>：引用了些什么</li><li><strong>with incoming references</strong>：被谁引用着</li></ul></li></ul></li><li><p><strong>dominator_tree</strong>：基于实例来分析，会显示具体的实例是哪个</p><p>第一行输入可以搜索，<code>Tool Bar</code> 中会多出一个 <code>Group by...</code>  选择 <code>package</code> 会变成已报名的形式来进行分类。</p><ul><li><strong>Percentage</strong>：当前所有对象中，此对象内存占用百分比，可以发现那些内存占用过大的对象</li><li>右键点击会出现 <code>List objects</code> ，会显示出具体事例</li></ul></li><li><p><strong>OQL</strong>：对象查询语言</p><ul><li>例如 <code>slect * from com.package.Activity</code> ，会查询出该类所有的实例</li></ul></li><li><p><strong>thread_overview</strong>：<code>dump</code> 内存这个时刻的所有线程</p></li><li><p><strong>top_consumers</strong>：用图形列出占用内存比较大的实例</p><ul><li><strong>Biggest Objects</strong>：详细信息，点击出现 <code>List objects</code></li></ul></li><li><p><strong>Leak Suspects</strong>：更详细的分析，可以从这里找到可以的泄漏点</p><ul><li><strong>Probleam Suspect (x)</strong> ：点击 <code>Details</code> 会出现可疑的 引用链，找到泄漏点</li></ul></li></ul><h2 id="3-什么是-LeakCanary？"><a href="#3-什么是-LeakCanary？" class="headerlink" title="3 什么是 LeakCanary？"></a>3 什么是 LeakCanary？</h2><hr><p>如果使用 MAT 来分析内存问题，会有一些难度，而且效率也不是很高。</p><p>为了能迅速发现内存泄漏，Square 公司基于 MAT 开源了 <a href="https://square.github.io/leakcanary" target="_blank" rel="noopener">LeakCanary</a>。</p><p><code>LeakCanary</code> 是一个内存泄漏检测框架。</p><h3 id="3-1-LeakCanary-原理"><a href="#3-1-LeakCanary-原理" class="headerlink" title="3.1 LeakCanary 原理"></a>3.1 LeakCanary 原理</h3><hr><ol><li><p><strong>检测保留的实例</strong></p><p><code>LeakCanary</code> 是基于 <code>LeakSentry</code> 开发的，<code>LeakSentry</code> 会 <code>hook Android</code> 生命周期，自动检测当 <code>Activity</code> 或 <code>Fragment</code> 被销毁时，它们的实例是否被回收了。</p><p>销毁的实例会传给 <code>RefWatcher</code>，<code>RefWatcher</code> 会持有它们的弱引用。</p><p>你也可以观察所有不再需要的实例，比如一个不再使用的 <code>View</code>，不再使用的 <code>Presenter</code> 等。</p><p>如果等待了 5 秒，并且 <code>GC</code> 触发了之后，弱引用还没有被清理，那么 <code>RefWatcher</code> 观察的实例就可能处于内存泄漏状态了。</p></li><li><p><strong>堆转储</strong></p><p>当保留对象的数量达到阈值时，<code>LeakCanary</code> 将 <code>Java</code> 堆转储到<code>.hprof</code> 存储在 <code>Android</code> 文件系统中的文件中。</p><p>当应用程序可见时，默认的阈值是5个被保留的对象，当应用程序不可见时，默认的阈值是 1 个被保留的对象。如果您看到保留的对象通知，然后将应用程序放在后台(例如通过按Home按钮)，那么阈值将从 5 更改为 1 ，<code>LeakCanary</code> 将在 5 秒内转储堆。点击通知将迫使<code>LeakCanary</code> 立即转储堆。</p></li><li><p><strong>分析堆</strong></p><p><code>LeakCanary</code>  <code>.hprof</code>使用 <a href="https://square.github.io/leakcanary/shark/" target="_blank" rel="noopener">Shark</a> 解析文件，并在该堆转储中找到保留的对象。</p><p>对于每个保留的对象，<code>LeakCanary</code> 会找到引用的路径，以防止对该保留的对象进行垃圾回收：其<strong>泄漏跟踪</strong>。泄漏跟踪是<em>从垃圾回收根到保留对象</em>的<em>最佳强引用路径的</em>另一个名称。</p></li><li><p><strong>泄漏分组</strong></p><p>当有两个泄漏分析结果相同时，<code>LeakCanary</code> <strong>为每个泄漏跟踪</strong>创建一个<strong>签名</strong>，并将具有相同签名的泄漏（即，由同一 <code>bug</code> 引起的泄漏）组合在一起，以免重复显示同样的泄漏信息。</p></li></ol><h3 id="3-2-LeakCanary-使用"><a href="#3-2-LeakCanary-使用" class="headerlink" title="3.2 LeakCanary 使用"></a>3.2 LeakCanary 使用</h3><hr><pre class=" language-groovy"><code class="language-groovy">dependencies <span class="token punctuation">{</span>  debugImplementation <span class="token string">'com.squareup.leakcanary:leakcanary-android:2.2'</span><span class="token punctuation">}</span></code></pre><p><code>2.2</code> 不需要初始化，如果你添加了</p><pre class=" language-groovy"><code class="language-groovy">apply plugin<span class="token punctuation">:</span> <span class="token string">'android-aspectjx'</span></code></pre><p>需要在文章添加</p><pre class=" language-groovy"><code class="language-groovy">aspectjx <span class="token punctuation">{</span>     exclude <span class="token string">'com.squareup'</span>     exclude <span class="token string">'leakcanary'</span><span class="token punctuation">}</span></code></pre><p>否则会报 <code>Unable to get provider leakcanary.internal.LeakCanaryFileProvider: java.lang.ClassNotFoundException: Didn&#39;t find class &quot;leakcanary.internal.LeakCanaryFileProvider&quot;</code></p><h2 id="4-自定义实现-Demo"><a href="#4-自定义实现-Demo" class="headerlink" title="4 自定义实现 Demo"></a>4 自定义实现 Demo</h2><hr><p><code>Profiler</code> 中使用了 <code>Allocation Tracker</code> 技术，<a href="https://mp.weixin.qq.com/s/b_lFfL1mDrNVKj_VAcA2ZA?" target="_blank" rel="noopener">Android内存申请分析</a> 这篇文章讲述了 <code>Allocation Tracker</code> 的使用方式，并且讲解了 <code>Android Studio</code> 是如何使用 <code>Allocation Tracker</code> 的。可以让我们更加熟悉 <code>Android Studio</code> 中 <code>Profiler</code> 各种工具的实现原理后。</p><p>文中提到了 <code>Allocation Tracker</code> 的三个缺点。</p><ul><li>获取的信息过于分散，中间夹杂着不少其他的信息，很多信息不是应用申请的，可能需要进行不少查找才能定位到具体的问题。</li><li>跟 <code>Traceview</code> 一样，无法做到自动化分析，每次都需要开发者手工开始 / 结束，这对于某些问题的分析可能会造成不便，而且对于批量分析来说也比较困难。</li><li>虽然在 <code>Allocation Tracking</code> 的时候，不会对手机本身的运行造成过多的性能影响，但是在停止的时候，直到把数据 <code>dump</code> 出来之前，经常会把手机完全卡死，如果时间过长甚至会直接 <code>ANR</code>。</li></ul><p>因此我们希望可以做到脱离 <code>Android Studio</code>，实现一个自定义的 <code>Allocation Tracker</code>，实现对象内存的自动化分析。通过这个工具可以获取所有对象的申请信息（大小、类型、堆栈等），可以找到一段时间内哪些对象占用了大量的内存。</p><p>我们可以用自定义的 <code>Allocation Tracker</code> 来监控 Java 内存的监控，也可以拓展成实时监控 <code>Java</code> 内存泄漏。不过任何一个工具如果只需要做到线下自动化测试，实现起来会相对简单，但想要移植到线上使用，那就要更加关注兼容性、稳定性和性能。</p><h3 id="4-1-自动化检测Demo"><a href="#4-1-自动化检测Demo" class="headerlink" title="4.1 自动化检测Demo"></a>4.1 自动化检测Demo</h3><hr><p>这是一个自定义 <code>Allocation Tracker</code> 的 <code>Demo</code> <a href="https://github.com/AndroidAdvanceWithGeektime/Chapter03" target="_blank" rel="noopener">极客时间 Android 高手课 Chapter03</a></p><blockquote><p>项目使用了 inline hook 来拦截内存对象分配时候的 RecordAllocation 函数，通过拦截该接口可以快速获取到当时分配对象的类名和分配的内存大小。<br>在初始化的时候我们设置了一个分配对象数量的最大值，如果从 start 开始对象分配数量超过最大值就会触发内存 dump，然后清空 alloc 对象列表，重新计算。该功能和 Android Studio 里的 Allocation Tracker 类似，只不过可以在代码级别更细粒度的进行控制。可以精确到方法级别。</p></blockquote><ul><li><code>ndk_dlopen</code> 用来获取动态链接库</li><li><code>ndk_dlsym</code> 通过动态链接库和函数签名拿到函数地址</li><li><code>Substrate</code> <a href="http://www.cydiasubstrate.com/api/c/MSHookFunction/" target="_blank" rel="noopener">MSHookFunction</a>  一款经典的 <code>hook</code> 框架，支持 <code>hook C/C++</code> 代码 </li><li><a href="https://github.com/facebookincubator/profilo/tree/master/deps/fbjni" target="_blank" rel="noopener">fbjni</a> 是从 <code>Facebook</code> 开源的一款jni工具类库，主要提供了工具类，ref utils ，Global JniEnv。</li><li><code>native-lib</code> 中 <code>JNI_OnLoad</code>  在 <code>System.loadLibrary(&quot;xxx&quot;);</code> 时执行</li></ul><p>代码运行流程：</p><ol><li><p>在 <code>MainActivity</code> 中调用 <code>AllocTracker.initForArt</code> 去初始化，然后通过 <code>ndk_dlopen</code> 和<code>ndk_dlsym</code> 拿到所有需要的函数，只是拿到函数并没有调用</p></li><li><p><code>JNI_OnLoad</code> 调用 <code>hookFunc();</code>这个方法就是真正的把系统的 <code>tracking</code> 函数 <code>hook</code> 住的地方</p><ol><li>通过 <code>ndk_dlsym</code> 拿到函数地址。</li><li>通过 <code>MSHookFunction</code> 把 <code>newArtRecordAllocation26</code> <code>hook</code> 进原函数地址里，同时拿到旧函数的实现并导向 <code>oldArtRecordAllocation26</code> 。这样做可以保留旧函数。</li><li>在新函数中有一句 <code>allocObjectCount &gt; setAllocRecordMax</code> ，当分配对象数量大于初始化时设置的最大值，就把数据保存在 <code>log</code> 文件中。</li></ol></li></ol><p><code>C/C++</code> 的 <code>hook</code> 和 <code>java</code> 反射一样，如果系统在新版本把函数名，或者函数签名改了那就无法使用了，所以在文件中出现了很多版本适配的地方。</p><p><code>Logcat</code> 中 <code>saveARTAllocationData write file to XXXX</code> 能找到对应的日志文件路径</p><p>看不到日志的输出情况，每个人设备内存情况不一样，<code>GC</code> 回收的频率也不一致，在你不停生产对象的时候，<code>GC</code> 不断的跟随回收，导致无法达到设置的最大的数据量，所以一直没有日志的写入。</p><p><strong>总结：</strong></p><p>这个 <code>Demo</code>  主要学习了 <code>Substrate</code> <a href="https://github.com/facebookincubator/profilo/tree/master/deps/fbjni" target="_blank" rel="noopener">fbjni</a> <code>ndk_dlopen</code> 这几个库的简单使用，<code>CmakeList</code>  的很多写法，以及 <code>native</code> 函数简写</p><pre><code>#define JNI_METHOD_DECL(ret_type, method_name) \     extern &quot;C&quot; JNIEXPORT ret_type JNICALL Java_##com_dodola_alloctrack##_##AllocTracker##_##method_name</code></pre><p>还了解了一些 <code>hook</code> 点以及 <code>hook</code> 方法。</p><h3 id="4-2-重复图片检测Demo"><a href="#4-2-重复图片检测Demo" class="headerlink" title="4.2 重复图片检测Demo"></a>4.2 重复图片检测Demo</h3><hr><p><a href="https://github.com/simplezhli/Chapter04" target="_blank" rel="noopener">极客时间 Android 高手课 Chapter04</a> 已完成的 <code>Demo</code> </p><blockquote><p>通过分析内存文件 hprof 快速判断内存中是否存在重复的图片，并且将这些重复图片的 PNG 、堆栈等信息输出。</p><p><strong>需要注意的是需要使用8.0以下的机器，因为8.0以后Bitmap中的buffer已经放到native内存中了</strong></p></blockquote><p>代码在开始加载了两张相同的图片。</p><pre><code>Bitmap bitmap1 = BitmapFactory.decodeResource(getResources(), R.mipmap.test); Bitmap bitmap2 = BitmapFactory.decodeResource(getResources(), R.mipmap.test);imageView1.setImageBitmap(bitmap1); imageView2.setImageBitmap(bitmap2);</code></pre><p>然后手动 <code>GC</code> 生成 <code>hprof</code> 文件</p><pre><code>// 手动触发GCRuntime.getRuntime().gc();System.runFinalization();// 生成Hprof文件Debug.dumpHprofData(file.getAbsolutePath());</code></pre><p>接下来在<code>DuplicatedBitmapAnalyzer</code> 的一个 <code>java</code> 项目里，利用 <a href="https://github.com/square/haha" target="_blank" rel="noopener">HAHA</a> 库进行文件分析，并输入重复图片。</p><p>作者已经将代码打成 <code>JAR</code> 包，可以直接调用</p><pre><code>java -jar tools/DuplicatedBitmapAnalyzer-1.0.jar hprof文件路径</code></pre><p>对于更多的信息，可以参看 <a href="https://github.com/square/leakcanary" target="_blank" rel="noopener">LeakCanary</a> 源码</p><p><strong>总结：</strong></p><p>这个 <code>Demo</code> 主要学到了如何主动生成 <code>hprof</code> 文件，以及如何用 <a href="https://github.com/square/haha" target="_blank" rel="noopener">HAHA</a> 这个库解析 <code>hprof</code> 文件。</p><p>联想：可以在特定场合去 <code>dump</code> 文件，比如内存大于最大内存 80%，因为 <code>hprof</code> 文件可能会很大，所以在用户 <code>wifi</code> 情况下回传。</p><p><a href="https://github.com/Tencent/matrix#matrix_android_cn" target="_blank" rel="noopener">Tencent/matrix</a> 这个框架拥有更丰富的检测方式。</p><h2 id="5-优化思路"><a href="#5-优化思路" class="headerlink" title="5 优化思路"></a>5 优化思路</h2><hr><h3 id="5-1-设备分级"><a href="#5-1-设备分级" class="headerlink" title="5.1 设备分级"></a>5.1 设备分级</h3><hr><p>内存优化首先需要根据设备环境来综合考虑</p><ul><li><strong>设备分级</strong>。使用类似 <a href="http://github.com/facebook/device-year-class" target="_blank" rel="noopener">device-year-class</a> 的策略对设备分级，对于低端机用户可以关闭复杂的动画，或者是某些功能；使用 565 格式的图片，使用更小的缓存内存等。<ul><li><code>device-year-class</code> 会根据手机的内存、CPU 核心数和频率等信息决定设备属于哪一个年份，这个示例表示对于 2013 年之后的设备可以使用复杂的动画，对于 2010 年之前的低端设备则不添加任何动画。</li><li>565 格式图片：一张图片中每一个像素的大小取决于它的解码选项，而 Android 中能够选择的 Bitmap 解码选项有四种。<ul><li>ARGB_8888 ：ARGB 四个通道的值都是 8 位，加起来 32 位，也就是每个像素占 4 个字节</li><li>ARGB_4444： ARGB 四个通道的值都是 4 位，加起来 16 位，也就是每个像素占 2 个字节</li><li>RGB_565： RGB 三个通道分别是 5 位、6 位、5 位，加起来 16 位，也就是每个像素占 2 个字节</li><li>ALPHA_8：只有 A 通道，占 8 位，也就是每个像素占 1 个字节</li></ul></li></ul></li><li><strong>缓存管理</strong>。我们需要有一套统一的缓存管理机制，可以适当地使用内存；当“系统有难”时，也要义不容辞地归还。我们可以使用 <code>OnTrimMemory(本文 4.1.1 会讲到)</code> 回调，根据不同的状态决定释放多少内存。</li><li><strong>进程模型</strong>。一个空的进程也会占用 10MB 的内存，而有些应用启动就有十几个进程，甚至有些应用已经从双进程保活升级到四进程保活，所以减少应用启动的进程数、减少常驻进程、有节操的保活，对低端机内存优化非常重要。</li><li><strong>安装包大小</strong>。安装包中的代码、资源、图片以及 so 库的体积，跟它们占用的内存有很大的关系。一个 80MB 的应用很难在 512MB 内存的手机上流畅运行。这种情况我们需要考虑针对低端机用户推出 4MB 的轻量版本，例如 <code>Facebook Lite</code>、今日头条极速版都是这个思路。</li></ul><h3 id="5-2-Bitmap-优化"><a href="#5-2-Bitmap-优化" class="headerlink" title="5.2 Bitmap 优化"></a>5.2 Bitmap 优化</h3><hr><p><code>Bitmap</code> 内存一般占应用总内存很大一部分，所以做内存优化永远无法避开图片内存这个“永恒主题”。</p><ol><li>统一图片库</li></ol><p>图片内存优化的前提是收拢图片的调用，这样我们可以做整体的控制策略。就如设备分级中说的，低端设备策略等。</p><ol start="2"><li><p>统一监控</p><ul><li><p><strong>大图片监控</strong>。我们需要注意某张图片内存占用是否过大，例如长宽远远大于 View 甚至是屏幕的长宽。在开发过程中，如果检测到不合规的图片使用，应该立即弹出对话框提示图片所在的 Activity 和堆栈，让开发同学更快发现并解决问题。<code>Glide</code> 可以有效的解决此类问题，因为 <code>Glide</code> 会根据 <code>ImageView</code> 的大小把图片大小调整成<code>ImageView</code> 的大小加载图片，并且 <code>Glide</code> 有三级缓存，在内存缓存中，<code>Glide</code> 会根据屏幕大小选择合适的大小作为图片内存缓存区的大小。</p></li><li><p><strong>重复图片监控</strong>。重复图片指的是 <code>Bitmap</code> 的像素数据完全一致，但是有多个不同的对象存在。这个监控不需要太多的样本量，一般只在内部使用。在检测模块中实现过一个内存 <code>Hprof</code> 的分析工具，它可以自动将重复 <code>Bitmap</code> 的图片和引用链输出。</p></li><li><p><strong>图片总内存</strong>。通过收拢图片使用，我们还可以统计应用所有图片占用的内存，这样在线上就可以按不同的系统、屏幕分辨率等维度去分析图片内存的占用情况。在 <code>OOM</code> 崩溃的时候，也可以把图片占用的总内存、Top N 图片的内存都写到崩溃日志中，帮助我们排查问题。</p></li></ul></li></ol><h2 id="6-更多"><a href="#6-更多" class="headerlink" title="6 更多"></a>6 更多</h2><hr><h3 id="6-1-监听系统内存状态"><a href="#6-1-监听系统内存状态" class="headerlink" title="6.1 监听系统内存状态"></a>6.1 监听系统内存状态</h3><hr><p>Android 提供了两种方式让我们可以监听系统内存状态</p><h4 id="6-1-1-ComponentCallback2"><a href="#6-1-1-ComponentCallback2" class="headerlink" title="6.1.1 ComponentCallback2"></a>6.1.1 ComponentCallback2</h4><hr><p>在 <code>Android 4.0</code> 后，<code>Android</code> 应用可以通过在 <code>Activity</code> 中实现 <code>ComponentCallback2</code> 接口获取系统内存的相关事件，这样就能在系统内存不足时提前知道这件事，提前做出释放内存的操作，避免我们自己的应用被系统干掉。</p><p><code>ComponentCallnback2</code> 提供了 <code>onTrimMemory(level)</code> 回调方法，在这个方法里我们可以针对不同的警告等级做出不同的释放内存操作。</p><p>原文是 <code>kotlin</code> 版，这里给出一个 <code>java</code> 版</p><pre><code>public class MainActivity2 extends AppCompatActivity implements ComponentCallbacks2 {    @Override    public void onTrimMemory(int level) {        super.onTrimMemory(level);        switch (level) {            case ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN:                // 应用界面处于后台                // 可以在这里释放 UI 对象                break;            case ComponentCallbacks2.TRIM_MEMORY_RUNNING_MODERATE:                // 应用正常运行中，不会被杀掉，但是系统内存已经有点低了                break;            case ComponentCallbacks2.TRIM_MEMORY_RUNNING_LOW:                // 应用正常运行中，不会被杀掉，但是系统内存已经非常低了，                // 这时候应该释放一些不必要的资源以提升系统性能                break;            case ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL:                // 应用正常运行，但是系统内存非常紧张，                // 系统已经开始根据 LRU 缓存杀掉了大部分缓存的进程                // 这时候我们要释放所有不必要的资源，不然系统可能会继续杀掉所有缓存中的进程                break;            case ComponentCallbacks2.TRIM_MEMORY_BACKGROUND:                // 系统内存很低，系统准备开始根据 LRU 缓存清理进程，                // 这时我们的程序在 LRU 缓存列表的最近位置，不太可能被清理掉，                // 但是也要去释放一些比较容易恢复的资源，让系统内存变得充足                break;            case ComponentCallbacks2.TRIM_MEMORY_MODERATE:                // 系统内存很低，并且我们的应用处于 LRU 列表的中间位置，                // 这时候如果还不释放一些不必要资源，那么我们的应用可能会被系统干掉                break;            case ComponentCallbacks2.TRIM_MEMORY_COMPLETE:                // 系统内存非常低，并且我们的应用处于 LRU 列表的最边缘位置，                // 系统会有限考虑干掉我们的应用，如果想活下来，就要把所有能释放的资源都释放了                break;            default:                // 应用从系统接收到一个无法识别的内存等级值，                // 跟一般的低内存消息提醒一样对待这个事件                // 释放所有不重要的数据结构。                break;        }    }}</code></pre><h4 id="6-1-2-ActivityManager-getMemoryInfo"><a href="#6-1-2-ActivityManager-getMemoryInfo" class="headerlink" title="6.1.2 ActivityManager.getMemoryInfo()"></a>6.1.2 ActivityManager.getMemoryInfo()</h4><hr><p>Android 提供了一个 <code>ActivityManager.getMemoryInfo()</code> 方法给我们查询内存信息，这个方法会返回一个 <code>ActivityManager.MemoryInfo</code> 对象，这个对象包含了系统当前内存状态，这些状态信息包括可用内存、总内存以及低杀内存阈值。</p><p><code>MemoryInfo</code> 中包含了一个 <code>lowMemory</code> 布尔值，这个布尔值用于表明系统是否处于低内存状态。</p><p>原文是 <code>kotlin</code> 版，这里给出一个 <code>java</code> 版</p><pre><code>public void doSomethingMemoryIntensive() {        // 在做一些需要很多内存的任务前，        // 检查设备是否处于低内存状态、        if (!getAvailableMemory().lowMemory) {            // 做需要很多内存的任务        }    }    private ActivityManager.MemoryInfo getAvailableMemory() {        ActivityManager activityManager = (ActivityManager) getSystemService(Context.ACTIVITY_SERVICE);        ActivityManager.MemoryInfo MemoryInfo = new ActivityManager.MemoryInfo();        activityManager.getMemoryInfo(MemoryInfo);        return MemoryInfo;    }</code></pre><h3 id="6-2-内存优化技巧"><a href="#6-2-内存优化技巧" class="headerlink" title="6.2 内存优化技巧"></a>6.2 内存优化技巧</h3><hr><h4 id="6-2-1-谨慎使用-Service"><a href="#6-2-1-谨慎使用-Service" class="headerlink" title="6.2.1 谨慎使用 Service"></a>6.2.1 谨慎使用 Service</h4><hr><p>让一个没用的 <code>Service</code> 在后台运行对于一个应用的内存管理来说是一件最糟糕的事情。</p><p>要在 <code>Service</code> 的任务完成后停止它，不然 <code>Service</code> 占用的这块内存会泄漏。</p><p>当你的应用中运行着一个 <code>Service</code>，除非系统内存不足，否则它不会被干掉。</p><p>这就导致对于系统来说 <code>Service</code> 的运行成本很高，因为 <code>Service</code> 占用的内存其他的进程是不能使用的。</p><p><code>Android</code> 有一个缓存进程列表，当可用内存减少时，这个列表也会随之缩小，这就会导致应用间的切换变得很慢。</p><p>如果我们是用 <code>Service</code> 监听一些系统广播，希望在特定情况下再启动事务，可以考虑使用 <code>JobScheduler</code>。</p><p>如果你真的要用 <code>Service</code>，可以考虑使用 <code>IntentService</code>，<code>IntentService</code> 是 <code>Service</code> 的一个子类，在它的内部有一个工作线程来处理耗时任务，当任务执行完后，<code>IntentService</code> 就会自动停止。</p><h4 id="6-2-2-选择优化后的数据容器"><a href="#6-2-2-选择优化后的数据容器" class="headerlink" title="6.2.2 选择优化后的数据容器"></a>6.2.2 选择优化后的数据容器</h4><hr><p><code>Java</code> 提供的部分数据容器并不适合 <code>Android</code>，比如 <code>HashMap</code>，<code>HashMap</code> 需要中存储每一个键值对都需要一个额外的 <code>Entry</code> 对象。</p><p>Android 提供了几个优化后的数据容器，包括 <code>SparseArray</code>、<code>SparseBooleanArray</code> 以及 <code>LongSparseArray</code>。</p><p><code>SparseArray</code> 之所以更高效，是因为它的设计是只能使用整型作为 <code>key</code>，这样就避免了自动装箱的开销。</p><h4 id="6-2-3-小心代码抽象"><a href="#6-2-3-小心代码抽象" class="headerlink" title="6.2.3 小心代码抽象"></a>6.2.3 小心代码抽象</h4><hr><p>抽象可以优化代码的灵活性和可维护性，但是抽象也会带来其他成本。</p><p>抽象会导致更多的代码需要被执行，也就是需要更多的时间和把更多的代码映射到内存中。</p><p>如果某段抽象代码带来的好处不大，比如一个地方可以直接实现而不需要用到接口的，那就不用接口。</p><h4 id="6-2-4-使用-protobuf-作为序列化数据"><a href="#6-2-4-使用-protobuf-作为序列化数据" class="headerlink" title="6.2.4 使用 protobuf 作为序列化数据"></a>6.2.4 使用 protobuf 作为序列化数据</h4><hr><p><code>Protocol buffers</code> 是 <code>Google</code> 设计的，它可以对结构化的数据序列化，与<code>XML</code> 类似，不过比<code>XML</code> 更小，更快，而且更简单。</p><p>如果你决定使用 <code>protobuf</code> 作为序列化数据格式，那在客户端代码中应该使用轻量级的 <code>protobuf</code>。</p><p>因为一般的 <code>protobuf</code> 会生成冗长的代码，这样会导致内存增加、<code>APK</code> 大小增加，执行速度变慢等问题。</p><p>更多关于 <code>protobuf</code> 的信息可以查看 <a href="https://android.googlesource.com/platform/external/protobuf/+/master/java/README.md#installation-lite-version-with-maven" target="_blank" rel="noopener">protobuf readme</a> 中的 “轻量级版本”  。</p><h4 id="6-2-5-Apk-瘦身"><a href="#6-2-5-Apk-瘦身" class="headerlink" title="6.2.5 Apk 瘦身"></a>6.2.5 Apk 瘦身</h4><hr><p>有些资源和第三方库会在我们不知情的情况下大量消耗内存。</p><p><code>Bitmap</code> 大小、资源、动画以及第三方库会影响到 <code>APK</code> 的大小，<code>Android Studio</code> 提供了 <code>R8</code> 和 <code>ProGuard</code> 帮助我们缩小 <code>Apk</code>，去掉不必要的资源。</p><p>如果你使用的 <code>Android Studio</code> 版本是 3.3 以下的，可以使用 <code>ProGuard</code>，3.3 及以上版本的可以使用 <code>R8</code>。</p><h4 id="6-2-6-使用-Dagger2-进行依赖注入"><a href="#6-2-6-使用-Dagger2-进行依赖注入" class="headerlink" title="6.2.6 使用 Dagger2 进行依赖注入"></a>6.2.6 使用 Dagger2 进行依赖注入</h4><hr><p>依赖注入框架不仅可以简化我们的代码，而且能让我们在测试代码的时候更方便。</p><p>如果我们想在应用中使用依赖注入，可以考虑使用 <code>Dagger2</code>。</p><p><code>Dagger2</code> 是在编译期生成代码，而不是用反射实现的，这样就避免了反射带来的内存开销，而是在编译期生成代码，</p><h4 id="6-2-7-谨慎使用第三方库"><a href="#6-2-7-谨慎使用第三方库" class="headerlink" title="6.2.7 谨慎使用第三方库"></a>6.2.7 谨慎使用第三方库</h4><hr><p>当你决定使用一个不是为移动平台设计的第三方库时，你需要对它进行优化，让它能更好地在移动设备上运行。</p><p>这些第三方库包括日志、分析、图片加载、缓存以及其他框架，都有可能带来性能问题。</p><h4 id="6-2-8-使用-IntDef-和-StringDef-替代枚举类型"><a href="#6-2-8-使用-IntDef-和-StringDef-替代枚举类型" class="headerlink" title="6.2.8 使用  IntDef 和 StringDef 替代枚举类型"></a>6.2.8 使用  IntDef 和 StringDef 替代枚举类型</h4><hr><p>使用枚举类型的 <code>dex size</code> 是普通常量定义的 <code>dex size</code> 的 13 倍以上，同时，运行时的内存分配，一个 <code>enum</code> 值的声明会消耗至少 <code>20 bytes</code> 。</p><p>枚举最大的优点是类型安全，但在Android平台上，枚举的内存开销是直接定义常量的三倍以上。所以Android提供了注解的方式检查类型安全。目前提供了int型和String型两种注解方式：<code>IntDef</code> 和 <code>StringDef</code> ，用来提供编译期的类型检查。</p><p>使用 <code>IntDef</code>和 <code>StringDef</code> 需要在 <code>Gradle</code> 配置中引入相应的依赖包：</p><pre><code>compile &#39;com.android.support:support-annotations:22.0.0&#39;</code></pre><h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a><strong>感谢</strong></h2><hr><blockquote><p><a href="https://time.geekbang.org/column/article/74044" target="_blank" rel="noopener">极客时间 Android开发高手课</a>  </p><p><a href="https://coding.imooc.com/learn/list/308.html" target="_blank" rel="noopener">慕课 Top团队大牛带你玩转Android性能分析与优化</a></p><p><a href="https://juejin.im/post/5d3ada056fb9a07eb94fd1bc#heading-3" target="_blank" rel="noopener">探索 Android 内存优化方法</a></p><p><a href="https://square.github.io/leakcanary" target="_blank" rel="noopener">LeakCanary</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>App 内存知识介绍</title>
      <link href="/2020/memory-optimization.html"/>
      <url>/2020/memory-optimization.html</url>
      
        <content type="html"><![CDATA[<p>Android 性能优化第二篇， 内存优化是减少崩溃率工作中非常关键的一部分，由于Android有垃圾自动回收机制不需要手动干预，但也因此，经常出现内存问题如内存泄漏、内存泄漏引发 <code>GC</code> 频繁导致页面卡顿和内存溢出等问题，如果不了解内存是如何管理的以及如何优化，会难以排查问题。</p><p>这篇文章集结了很多文章精华部分(个人认为)，在这里整理分享出更多更完整内存知识，所以这篇文章会很长，目录我会分的很细，方便查找，文末会贴出参考文章。</p><p><strong>注意：如果出现图片不显示问题请移步</strong> <a href="https://calmcenter.club/2019/PicNotShow.html">图片不显示问题</a></p><h1 id="本文主要记载"><a href="#本文主要记载" class="headerlink" title="本文主要记载"></a>本文主要记载</h1><hr><ul><li><strong>1 什么是内存？</strong></li><li><strong>2 JVM 如何分配内存？</strong><ul><li>2.1 所有线程共享的数据区域</li><li>2.2 线程私有的数据区域</li></ul></li><li><strong>3 JVM 如何管理内存？</strong><ul><li>3.1 引用计数算法</li><li>3.2 可达性算法</li><li>3.3 引用介绍</li><li>3.4 垃圾回收器<ul><li>3.4.1 标记-清除算法（Mark-Sweep）</li><li>3.4.2 复制算法（Copying）</li><li>3.4.3 标记-整理算法（Mark-Compact）</li><li>3.4.4 分代收集算法（Generational Collection）</li></ul></li></ul></li><li><strong>4 什么是 Dalvik?</strong><ul><li>4.1 Dalvik 与 JVM 的区别</li><li>4.2 Dalvik 堆大小</li></ul></li><li><strong>5 什么是 ART?</strong><ul><li>5.1 ART 与 Dalvik 的区别</li></ul></li><li><strong>6 内存引发的问题</strong><ul><li>6.1 内存泄漏<ul><li>6.1.1 常见的内存泄漏</li></ul></li><li>6.2 低杀</li><li>6.3 内存抖动</li></ul></li><li><strong>7 Android Bitmap 内存分配的变化</strong></li><li><strong>8 内存优化的两个误区</strong><ul><li>8.1 内存占用越少越好</li><li>8.2 Native 内存不用管</li></ul></li></ul><h2 id="1-什么是内存？"><a href="#1-什么是内存？" class="headerlink" title="1 什么是内存？"></a>1 什么是内存？</h2><hr><p>内存是计算机中重要的部件之一，是与 CPU 进行沟通的桥梁，是 CPU 能直接寻址的存储空间，由半导体器件制成。</p><blockquote><p>如果说数据是商品，那硬盘就是商店的仓库，内存就是商店的货架，仓库里的商品你是不能直接买的，你只能买货架上的商品。</p><p>每一个程序中使用的内存区域相当于是不同的货架，当一个货架上需要摆放的商品超过这个货架所能容纳的最大值，就会出现放不下的情况，也就是内存溢出。</p></blockquote><h2 id="2-JVM-如何分配内存？"><a href="#2-JVM-如何分配内存？" class="headerlink" title="2 JVM 如何分配内存？"></a>2 JVM 如何分配内存？</h2><hr><h3 id="2-1-所有线程共享的数据区域"><a href="#2-1-所有线程共享的数据区域" class="headerlink" title="2.1 所有线程共享的数据区域"></a>2.1 <strong>所有线程共享的数据区域</strong></h3><hr><ul><li><strong>堆</strong>（Java Heap）<ul><li><code>Java</code> 堆是 <code>JVM</code> 管理的内存中最大的一块内存区域。</li><li>几乎所有的对象实例都是在堆中分配内存。</li><li>此区域也是垃圾回收器（<code>Garbage Collection</code>）主要的作用区域，内存泄漏就发生在这个区域。</li></ul></li><li><strong>方法区</strong>（Method Area）<ul><li>方法区存放的是 <strong>类信息、常量、静态变量</strong></li><li>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机会抛出内存溢出异常 <code>OutOfMemoryError</code>。</li></ul></li></ul><h3 id="2-2-线程私有的数据区域"><a href="#2-2-线程私有的数据区域" class="headerlink" title="2.2 线程私有的数据区域"></a>2.2 <strong>线程私有的数据区域</strong></h3><hr><ul><li><p><strong>程序计数器</strong>（Program Counter Register）</p></li><li><p>一块较小的内存空间，可看做是当前线程所执行的字节码的行号指示器。</p></li><li><p>为了线程切换后能恢复到正确的执行位置，每条线程都有一个私有的程序计数器。</p><ul><li>如果线程在执行Java方法，这个计数器记录的是正在执行的虚拟机字节码指令地址；</li><li>如果执行的是Native方法，这个计数器的值为空（Undefined）。</li><li>程序计数器是唯一一个在 Java 虚拟机规范中没有规定任何 <code>OOM</code> 情况的区域。</li></ul></li><li><p><strong>本地方法栈</strong>（Native Method Stack）</p><ul><li>本地方法栈与虚拟机栈的区别是虚拟机栈为 <code>Java</code> 方法服务，而本地方法栈为 <code>Native</code> 方法服务。</li><li>与虚拟机栈一样，本地方法栈也会抛出 <code>StackOverflowError</code> 和 <code>OutOfMemoryError</code> 异常。</li></ul></li><li><p><strong>虚拟机栈</strong>（Virtual Machine Stack ）</p><ul><li>每个方法在执行的同时都会创建一个<strong>栈帧（Stack Frame）</strong>用于存储局部变量表、操作数栈、动态链接、方法出口等信息。</li><li>虚拟机栈生命周期与线程相同。</li><li>当执行 Java 方法时会进行压栈的操作，在栈中会保存局部变量、操作数栈和方法出口等信息。<code>JVM</code> 规定了栈的最大深度，如果线程请求执行方法时栈的深度大于规定的深度，就会抛出栈溢出异常 <code>StackOverflowError</code>。</li><li>如果虚拟机在扩展时无法申请到足够的内存，就会抛出内存溢出异常 <code>OutOfMemoryError</code>。</li></ul></li></ul><blockquote><p><strong>栈帧（Stack Frame）</strong></p><p>当 <code>Java</code> 程序出现异常时，程序会打印出对应的异常堆栈，通过这个堆栈我们可以知道方法的调用链路，而这个调用链路就是由一个个 Java 方法栈帧组成的。</p><ol><li><p><strong>局部变量表</strong>（Local Variable Table）：里面的变量只在当前函数调用中有效，当函数调用结束后，随着函数栈帧的销毁，局部变量表也会随之销毁。</p><p>局部变量表中存放的<strong>编译期</strong>可知的各种数据有：</p><ul><li><p>基本数据类型：如 boolean、char、int 等。</p></li><li><p>对象引用：reference 类型，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置。</p></li><li><p><code>returnAddress</code>类型：指向一条虚拟机指令的操作码。与前面介绍的那些数值类的原生类型不同，<code>returnAddress</code> 类型在 <code>Java</code> 语言之中并不存在相应的类型，也无法在程序运行期间更改 <code>returnAddress</code> 类型的值。</p></li></ul></li><li><p><strong>操作数栈</strong>（Operand Stack）：操作数栈（Operand Stack）也叫操作栈，它主要用于保存计算过程的中间结果，同时作为计算过程中临时变量的存储空间。</p></li><li><p><strong>动态连接</strong>（Dynamic Linking）：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接</p></li><li><p><strong>方法返回地址</strong>：当一个方法开始执行后，只有两种方式可以退出这个方法，一种是正常完成出口，另一种是异常完成出口。</p><ul><li>正常完成出口（Normal Method Invocation Completion）：执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者。是否有返回值和返回值的类型将根据遇到哪种方法返回指令来决定，这种退出方法的方式称为正常完成出口。</li><li>异常完成出口（Abrupt Method Invocation Completion）：在方法执行过程中遇到异常，并且这个异常没有在方法体内得到处理，就会导致方法退出，这种退出方式称为异常完成出口。一个方法使用异常完成出口的方式退出，任何值都不会返回给它的调用者。</li></ul><p>无论采用哪种退出方式，在方法退出后，都需要返回到方法被调用的位置，程序才能继续执行。</p></li></ol></blockquote><h2 id="3-JVM-如何管理内存？"><a href="#3-JVM-如何管理内存？" class="headerlink" title="3 JVM 如何管理内存？"></a>3 JVM 如何管理内存？</h2><hr><p>JVM 的管理主要有 <strong>引用计数算法</strong>、<strong>可达性算法</strong>、<strong>Java 引用</strong> 以及 <strong>垃圾回收器</strong> 知识点。</p><h3 id="3-1-引用计数算法"><a href="#3-1-引用计数算法" class="headerlink" title="3.1 引用计数算法"></a>3.1 引用计数算法</h3><hr><p>给对象中添加一个引用计数器，每当有一个地方引用该对象时，计数器值加1；引用失效时，计数器值减1；任意时刻计数器为0的对象就是不可能再被使用的，表示该对象不存在引用关系。</p><p>优点：实现简单，判定效率也很高；<br>缺点：难以解决对象之间相互循环引用导致计数器值不等于0的问题。</p><h3 id="3-2-可达性算法"><a href="#3-2-可达性算法" class="headerlink" title="3.2 可达性算法"></a>3.2 可达性算法</h3><hr><p>判定对象是否是存活的</p><p>这个算法的基本思路就是通过一系列 <code>GC Roots</code> 对象作为起始点，从这些节点开始向下搜索，搜索走过的路径就叫引用链。<br>当一个对象到 <code>GC Roots</code> 没有任何引用链相连时（<code>GC Roots</code> 到这个对象不可达），则证明此对象是不可用的。</p><p>比如下图中的 <code>object5、object6、object7</code>，虽然它们互有关联，但是它们到 <code>GC Roots</code> 是不可达的，所以它们会被判定为可回收对象。</p><img src="https://raw.githubusercontent.com/CalmCenter/picGo/master/pictures/20200330171812.png" style="zoom:90%"><p>那么那些点可以作为 <code>GC Roots</code> 呢？一般来说，如下情况的对象可以作为 <code>GC Roots</code> ：</p><ol><li><p>虚拟机栈</p><p>虚拟机栈的栈帧中的局部变量表中引用的对象，比如某个方法正在使用的类字段。</p></li><li><p>方法区</p><ul><li><p>类静态属性引用的对象</p></li><li><p>常量引用的对象</p></li></ul></li><li><p>本地方法栈</p><p>本地方法栈中 <code>Native</code> 方法引用的对象。</p></li></ol><h3 id="3-3-引用介绍"><a href="#3-3-引用介绍" class="headerlink" title="3.3 引用介绍"></a>3.3 引用介绍</h3><hr><p>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判定对象是否存活都与引用有关。</p><p>在 <code>JDK 1.2</code> 之后，<code>Java</code> 对引用的概念进行了扩充，将引用分为<strong>强引用</strong>、<strong>软引用</strong>、<strong>弱引用</strong>和<strong>虚引用</strong>四种，这四种引用强度按顺序依次减弱。如果没有指定对象引用类型，默认是<strong>强引用</strong>。</p><ol><li><strong>强引用</strong>：<ul><li>强引用是指代码中普遍存在的，比如 <code>Object obj = new Object()</code> 这类引用。</li><li>强引用可以直接访问目标对象。</li><li>强引用指向的对象在任何时候都不会被系统回收，虚拟机即使抛出 <code>OOM</code> 异常，也不会回收强引用指向的对象。<br>使用 <code>obj = null</code> 不会触发 <code>GC</code>，但是在下次 <code>GC</code> 的时候这个强引用对象就可以被回收了。</li><li>强引用可能导致内存泄漏。</li></ul></li><li><strong>软引用</strong>：<ul><li>软引用用于描述一些还有用但非必需的对象。</li><li>对于软引用关联的对象，在系统即将发生内存溢出前，会把这些对象列入回收范围中进行二次回收。</li><li>如果二次回收后还没有足够的内存，就会抛出内存溢出异常。</li><li>在 <code>JDK 1.2</code> 后，<code>Java</code> 提供了 <code>SoftReference</code> 类来实现软引用。</li></ul></li><li><strong>弱引用</strong>：<ul><li>弱引用的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次 <code>GC</code> 前。</li><li>在 <code>GC</code> 时，只要发现弱引用，不管系统堆空间使用情况如何，都会将对象进行回收。</li><li>软引用、弱引用适合保存可有可无的缓存数据。</li><li><code>JDK 1.2</code> 后，提供了 <code>WeakReference</code> 类来实现弱引用。</li></ul></li><li><strong>虚引用</strong>：<ul><li>一个对象是否有虚引用的存在，都不会对其生存时间构成影响，也无法通过虚引用取得一个对象实例。</li><li>为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</li><li>在 <code>JDK 1.2</code> 后，提供了 <code>PhantomReference</code> 类来实现虚引用。</li></ul></li></ol><h3 id="3-4-垃圾回收器"><a href="#3-4-垃圾回收器" class="headerlink" title="3.4 垃圾回收器"></a>3.4 垃圾回收器</h3><hr><p>垃圾回收器就是我们经常说到的 <code>GC（Garbage Collector）</code>，当我们操作不当导致某块内存泄漏时，<code>GC</code> 就不能对这块内存进行回收。</p><p>拿 <code>Android</code> 来说，进行 <code>GC</code> 时，所有线程都要暂停，包括主线程，<code>16ms</code> 是 <code>Android</code> 要求的每帧绘制时间，而当 <code>GC</code> 的时间超过 <code>16ms</code>，就会造成丢帧的情况，也就是界面卡顿。</p><p>垃圾回收器回收资源的方式就是垃圾回收算法</p><h4 id="3-4-1-标记-清除算法（Mark-Sweep）"><a href="#3-4-1-标记-清除算法（Mark-Sweep）" class="headerlink" title="3.4.1 标记-清除算法（Mark-Sweep）"></a>3.4.1 标记-清除算法（Mark-Sweep）</h4><hr><p>最基础的收集算法：分为 <strong>标记</strong> 和 <strong>清除</strong> 两个阶段，首先，标记出所有需要回收的对象，然后统一回收所有被标记的对象。<br>这种方法有两个不足点：</p><ol><li>标记和清除的效率都不高</li><li>标记清除后会产生大量不连续的内存碎片，内存碎片太多会导致当程序需要分配较大的对象时，无法找到足够的连续内存而不得不提前触发 ·<code>GC</code></li></ol><img src="https://raw.githubusercontent.com/CalmCenter/picGo/master/pictures/20200330181053.png" style="zoom:90%"><h4 id="3-4-2-复制算法（Copying）"><a href="#3-4-2-复制算法（Copying）" class="headerlink" title="3.4.2 复制算法（Copying）"></a>3.4.2 复制算法（Copying）</h4><hr><p>为了解决 <strong>标记-清除算法</strong> 效率问题，<strong>复制收集算法</strong> 出现了。</p><p>将内存按容量划分为大小相等的两块，每次只使用其中的一块，当这一块内存将用完了，就将还存活着的对象复制到另一块内存上面，然后再把已使用过的内存空间一次清理掉。</p><ul><li>优点：实现简单，运行高效；每次都是对整个半区进行内存回收，内存分配时也不需要考虑内存碎片等情况，只要移动堆顶指针，按顺序分配内存即可；</li><li>缺点：粗暴的将内存一分为二，代价有点高。在对象存活率高时，要进行较多的复制操作，这时效率就变低了</li></ul><img src="https://raw.githubusercontent.com/CalmCenter/picGo/master/pictures/20200330181822.png" style="zoom:60%"><h4 id="3-4-3-标记-整理算法（Mark-Compact）"><a href="#3-4-3-标记-整理算法（Mark-Compact）" class="headerlink" title="3.4.3 标记-整理算法（Mark-Compact）"></a>3.4.3 标记-整理算法（Mark-Compact）</h4><hr><p><strong>标记-整理算法</strong> 的标记过程与 <strong>标记-清除算法</strong> 一样，但后续步骤是让所有存活的对象向一端移动，然后直接清理掉边界外的内存。</p><ul><li>避免了 <strong>标记-清除算法</strong> 内存碎片；</li><li>避免了 <strong>复制算法</strong> 50%的空间浪费；</li><li>主要针对对象存活率高的老年代。</li></ul><img src="https://raw.githubusercontent.com/CalmCenter/picGo/master/pictures/20200403112950.png" style="zoom:60%"><h4 id="3-4-4-分代收集算法（Generational-Collection）"><a href="#3-4-4-分代收集算法（Generational-Collection）" class="headerlink" title="3.4.4 分代收集算法（Generational Collection）"></a>3.4.4 分代收集算法（Generational Collection）</h4><hr><p>现代商业虚拟机的垃圾回收都采用 <strong>分代收集算法</strong> ，这种算法会根据对象存活周期的不同将内存划分为几块，这样就可以根据各个区域的特点采用最适当的收集算法。</p><p>堆内存可分为 <strong>新生区</strong> 、<strong>养老区</strong> 和 <strong>永久存</strong> 储区三个区域。</p><ul><li><p><strong>新生区（Young Generation Space）</strong></p><p>由 <strong>一个伊甸区（Eden space）</strong> 和 <strong>两个幸存者区（Survivor space）区</strong> 组成。<br>每次垃圾收集都有大批对象死去，只有少量存活，所以可以用复制算法。</p><ul><li><strong>伊甸区</strong></li></ul><p>大多数情况下，对象都是在伊甸区中分配的，当伊甸区没有足够的空间进行分配时，虚拟机将发起一次 <code>Minor GC</code>。<br><code>Minor GC</code> 是指发生在新生区的垃圾收集动作，<code>Minor GC</code> 非常频繁，回收速度也比较快。<br>当伊甸区的空间用完时，<code>GC</code> 会对伊甸区进行垃圾回收，然后把伊甸区剩下的对象移动到幸存 0 区。</p><ul><li><strong>幸存 0 区</strong></li></ul><p>如果幸存 0 区满了，<code>GC</code> 会对该区域进行垃圾回收，然后再把该区剩下的对象移动到幸存 1 区。</p><ul><li><strong>幸存 1 区</strong></li></ul><p>如果幸存 1 区满了，<code>GC</code> 会对该区域进行垃圾回收，然后把幸存 1 区中的对象移动到养老区。</p></li><li><p><strong>养老区（Tenure Generation Space）</strong></p></li></ul><p>对象存活率高、没有额外空间对它进行担保，就必须使用 <strong>标记-清理</strong> 或 <strong>标记-整理算法</strong> 进行回收。</p><p>用于保存从新生区筛选出来的 <code>Java</code> 对象。<br>当幸存 1 区移动尝试对象到养老区，但是发现空间不足时，虚拟机会发起一次 <code>Major GC</code>。<br><code>Major GC</code> 的速度一般比 <code>Minor GC</code> 慢 10 倍以上。<br>大对象会直接进入养老区，比如很大的数字和很长的字符串。</p><ul><li><strong>永久存储区（Permanent Space）</strong></li></ul><p>一个常驻内存区域，用于存放 <code>JDK</code> 自身携带的 <code>Class Interface</code> 元数据。<br>永久存储区存储的是运行环境必需的类信息，被装载进该区域的数据是不会被垃圾回收器回收掉的，只有 <code>JVM</code> 关闭时才会释放此区域的内存。</p><img src="https://raw.githubusercontent.com/CalmCenter/picGo/master/pictures/20200403114531.png" style="zoom:80%"><h2 id="4-什么是-Dalvik"><a href="#4-什么是-Dalvik" class="headerlink" title="4 什么是 Dalvik?"></a>4 什么是 Dalvik?</h2><hr><p><code>Dalvik</code> 是 <code>Dalvik Virtual Machine</code>（<code>Dalvik</code> 虚拟机）的简称，是 <code>Android</code> 平台的核心组成部分之一。<code>Android 4.4</code> 之前都是使用 <code>Dalvik</code>。</p><p>在 <code>Androd</code> 中，每一个应用都运行在一个 <code>Dalvik VM</code> 实例中，每一个 <code>Dalvik VM</code> 都运行在一个独立的进程空间，这种机制使得 <code>Dalvik</code> 运行在有限的内存中同时运行多个进程。</p><h3 id="4-1-Dalvik-与-JVM-的区别"><a href="#4-1-Dalvik-与-JVM-的区别" class="headerlink" title="4.1 Dalvik 与 JVM 的区别"></a>4.1 Dalvik 与 JVM 的区别</h3><hr><p><code>Dalvik</code> 不是 <code>Java</code> 虚拟机，它并不是按照 Java 虚拟机规范实现的，两者之间并不兼容。</p><ol><li><p>架构</p><ul><li><p><code>JVM</code> 是基于栈的，需要在栈中读取数据，所需的指令会更多，这样会导致速度慢，不适合性能优先的移动设备。</p></li><li><p><code>Dalvik</code> 是基于寄存器的，指令更紧凑和简洁。</p></li></ul><p>由于显式指定了操作数，所以基于寄存器的指令会比基于栈的指令要大，但是由于指令数的减少，总的代码数不会增加多少。</p></li><li><p>执行代码不同</p><ul><li><p>在 <code>Java SE</code> 程序中，<code>Java</code> 类会被编译成一个或多个 <code>.class</code> 文件，然后打包成 <code>jar</code> 文件，<code>JVM</code> 会通过对应的 <code>.class</code> 文件和 <code>jar</code> 文件获取对应的字节码。</p></li><li><p>而 <code>Dalvik</code> 会用 <code>dx</code> 工具将所有的 .class 文件转换为一个 <code>.dex</code> 文件，然后会从该 <code>.dex</code> 文件读取指令和数据。</p></li></ul></li><li><p>共享机制</p><ul><li><p><code>Dalvik</code> 拥有预加载—共享机制，不同应用之间在运行时可以共享相同的类，拥有更高的效率。</p></li><li><p>而 <code>JVM</code> 不存在这种共享机制，不同的程序，打包后的程序都是彼此独立的，即使包中使用了同样的类，运行时也是单独加载和运行的，无法进行共享。</p></li></ul></li></ol><h3 id="4-2-Dalvik-堆大小"><a href="#4-2-Dalvik-堆大小" class="headerlink" title="4.2 Dalvik 堆大小"></a>4.2 Dalvik 堆大小</h3><hr><p>每一个手机厂商都可以设定设备中每一个进程能够使用的堆大小，有关进程堆大小的值有下面三个。</p><p>如果我们想看堆内存大小应该怎么办呢？</p><pre><code>   adb shell getprop dalvik.vm.heapsize</code></pre><ul><li><p>dalvik.vm.heapstartsize</p><p>堆分配的初始值大小，这个值越小，系统内存消耗越慢，但是当应用扩展这个堆，导致 <code>GC</code> 和堆调整时，应用会变慢。</p><p>这个值越大，应用越流畅，但是可运行的应用也会相对减少。</p></li><li><p>dalvik.vm.heapgrowthlimit</p><p>如果在清单文件中声明 <code>largeHeap</code> 为 <code>true</code>，则 <code>App</code> 使用的内存到 <code>heapsize</code> 才会 <code>OOM</code>，否则达到 <code>heapgrowthlimit</code> 就会 <code>OOM</code>。</p></li><li><p>dalvik.vm.heapsize</p><p>进程可用的堆内存最大值，一旦应用申请的内存超过这个值，就会 <code>OOM</code>。</p></li></ul><h2 id="5-什么是-ART"><a href="#5-什么是-ART" class="headerlink" title="5 什么是 ART?"></a>5 什么是 ART?</h2><hr><p><code>ART</code> 的全称是 <code>Android Runtime</code>，是从 <code>Android 4.4</code> 开始新增的 <strong>应用运行时环境</strong>，用于替代 <code>Dalvik</code> 虚拟机。</p><p><code>Dalvik VM</code> 和 <code>ART</code> 都可以支持已转换为 <code>.dex（Dalvik Executable）</code>格式的 <code>Java</code> 应用程序的运行。</p><p><code>Dalvik</code> 是为 32 位 <code>CPU</code> 设计的，而 <code>ART</code> 支持 64 位并兼容 32 位 <code>CPU</code>，这也是 <code>Dalvik</code> 被淘汰的主要原因。</p><h3 id="5-1-ART-与-Dalvik-的区别"><a href="#5-1-ART-与-Dalvik-的区别" class="headerlink" title="5.1 ART 与 Dalvik 的区别"></a>5.1 ART 与 Dalvik 的区别</h3><hr><ol><li><p>预编译</p><ul><li><p><code>Dalvik</code> 中的应用每次运行时，字节码都需要通过即时编译器 JIT 转换为机器码，这会使得应用的运行效率降低。</p></li><li><p>在 <code>ART</code> 中，系统在安装应用时会进行一次预编译，将字节码预先编译成机器码并存储在本地，这样应用就不用在每次运行时执行编译了，运行效率也大大提高。</p></li></ul></li><li><p>GC</p><ul><li><p>在 <code>Dalvik</code> 采用的垃圾回收算法是标记-清除算法，启动垃圾回收机制会造成两次暂停（一次在遍历阶段，另一次在标记阶段）。</p></li><li><p>而在 <code>ART</code> 下，<code>GC</code> 速度比 <code>Dalvik</code> 要快，这是因为应用本身做了垃圾回收的一些工作，启动 <code>GC</code> 后，不再是两次暂停，而是一次暂停。</p><p>而且 <code>ART</code> 使用了一种新技术（<code>packard pre-cleaning</code>），在暂停前做了许多事情，减轻了暂停时的工作量。</p></li></ul></li></ol><h2 id="6-内存引发的问题"><a href="#6-内存引发的问题" class="headerlink" title="6 内存引发的问题"></a>6 内存引发的问题</h2><hr><ol><li>内存造成的第一个问题是<strong>异常</strong>。异常包括 <code>OOM</code>、内存分配失败这些崩溃，也包括因为整体内存不足导致应用被杀死、设备重启等问题。</li><li>内存造成的第二个问题是卡顿。<strong>内存泄漏</strong> 导致 <code>Java</code> 内存不足会频繁 <code>GC</code>，常见现象是 <strong>内存抖动</strong>，这个问题在 <code>Dalvik</code> 虚拟机会更加明显。而 ART 虚拟机在内存管理跟回收策略上都做大量优化</li><li>除了频繁 <code>GC</code> 造成卡顿之外，物理内存不足时系统会触发 <strong>low memory killer</strong> 机制，系统负载过高是造成卡顿的另外一个原因。</li></ol><h3 id="6-1-内存泄漏"><a href="#6-1-内存泄漏" class="headerlink" title="6.1 内存泄漏"></a>6.1 内存泄漏</h3><hr><p>内存泄漏指的是，当一块内存没有被使用，但无法被 GC 时的情况。</p><p>内存泄漏的表现就是可用内存逐渐减少，无法被回收的内存逐渐累积，直到无更多可用内存可申请时，就会导致 <code>OOM</code>。</p><h4 id="6-1-1-常见的内存泄漏"><a href="#6-1-1-常见的内存泄漏" class="headerlink" title="6.1.1 常见的内存泄漏"></a>6.1.1 常见的内存泄漏</h4><hr><ol><li><p><strong>非静态内部类</strong></p><ul><li><p><strong>泄漏场景</strong> </p><p>非静态内部类会持有外部类的实例，比如匿名内部类。</p><p>匿名内部类指的是一个对象名称的类，但是在字节码中，它还是会有构造函数的，而它的构造函数中会包含外部类的实例。</p><p>比如在 <code>Activity</code> 中以匿名内部类的方式声明 <code>Handler</code> 或 <code>AsyncTask</code>，当 <code>Activity</code> 关闭时，由于 <code>Handler</code> 持有 <code>Activity</code> 的强引用，导致 <code>GC</code> 无法对 <code>Activity</code> 进行回收。</p><p>当我们通过 <code>Handler</code> 发送消息时，消息会加入到 <code>MessageQueue</code> 队列中交给 <code>Looper</code> 处理，当有消息还没发送完毕时，<code>Looper</code> 会一直运行，在这个过程中会一直持有 <code>Handler</code>，而 <code>Handler</code> 又持有外部类 <code>Activity</code> 的实例，这就导致了 Activity 无法被释放。</p></li><li><p><strong>解决</strong></p><p>把 <code>Handler</code> 或 <code>AsyncTask</code> 声明为静态内部类，并且使用 <code>WeakReference</code> 包住 <code>Activity</code>，这样 <code>Handler</code> 拿到的就是一个 <code>Activity</code> 的弱引用，<code>GC</code> 就可以回收 <code>Activity</code>。这种方式适用于所有匿名内部类导致的内存泄漏问题。</p><pre><code>public static class MyHandler extends Handler {    Activity activity;    public MyHandler(Activity activity) {        activity = new WeakReference&lt;&gt;(activity).get();    }    @Override    public void handleMessage(Message message) {       // ...    }}</code></pre></li></ul></li><li><p><strong>静态变量</strong></p><ul><li><p><strong>泄漏场景</strong></p><p>静态变量导致内存泄漏的原因是因为 <strong>长生命周期对象</strong> 持有了 <strong>短生命周期对象</strong> 的引用，导致短生命周期对象无法被释放。</p><p>比如一个单例持有了 <code>Activity</code> 的引用，而 <code>Activity</code> 的生命周期可能很短，用户一打开就关闭了，但是单例的生命周期往往是与应用的生命周期相同的。</p></li><li><p><strong>解决</strong></p><p>如果单例需要 <code>Context</code>， 可以考虑使用 <code>ApplicationContext</code>，这样单例持有的 <code>Context</code> 引用就是与应用的生命周期相同的了。</p></li></ul></li><li><p><strong>资源未释放</strong></p><ul><li><p><strong>泄漏场景</strong></p><p>忘了注销 <code>BroadcastReceiver</code></p><p>打开了数据库游标（<code>Cursor</code>）忘了关闭</p><p>打开流忘了关闭</p><p>创建了 <code>Bitmap</code> 但是调用 <code>recycle</code> 方法回收 <code>Bitmap</code> 使用的内存</p><p>使用 <code>RxJava</code> 忘了在 <code>Activity</code> 退出时取消任务</p><p>使用协程忘了在 <code>Activity</code> 退出时取消任务</p></li></ul></li><li><p><strong>Webview</strong></p><ul><li><p><strong>泄漏场景</strong></p><p>不同的 <code>Android</code> 版本的 <code>Webview</code> 会有差异，加上不同厂商定制 <code>ROM</code> 的 <code>Webview</code> 的差异，导致 <code>Webview</code> 存在很大的兼容问题。</p><p>一般情况下，在应用中只要使用一次 <code>Webview</code>，它占用的内存就不会被释放。</p></li><li><p><strong>解决</strong></p><pre><code>@Overrideprotected void onDestroy() {    if( mWebView!=null) {        // 如果先调用destroy()方法，则会命中if (isDestroyed()) return;这一行代码，需要先onDetachedFromWindow()，再        // destory()        ViewParent parent = mWebView.getParent();        if (parent != null) {            ((ViewGroup) parent).removeView(mWebView);        }        mWebView.stopLoading();        // 退出时调用此方法，移除绑定的服务，否则某些特定系统会报错        mWebView.getSettings().setJavaScriptEnabled(false);        mWebView.clearHistory();        mWebView.clearView();        mWebView.removeAllViews();        mWebView.destroy();    }    super.on Destroy();}</code></pre></li></ul></li></ol><h3 id="6-2-低杀"><a href="#6-2-低杀" class="headerlink" title="6.2 低杀"></a>6.2 低杀</h3><hr><p>在内存不足时，这种机制就会针对于所有进程进行回收(优先级由高到低，优先回收低优先级)</p><p>进程优先级：</p><ol><li><strong>前台进程</strong>：优先级最高的进程，是正在于用户交互的进程<ul><li>进程持有一个与用户交互的 Activity（该 Activity 的 onResume 方法被调用）</li><li>进程持有一个 Service，<code>[Service 与用户正在交互的 Activity 绑定]</code>  <code>[Service 调用了 startForeground() 方法(前台服务)]</code>  <code>[Service 正在执行以下生命周期函数（onCreate、onStart、onDestroy ）]</code></li><li>进程持有一个 <code>BroadcastReceiver</code>，这个 <code>BroadcastReceiver</code> 正在执行它的 <code>onReceive()</code> 方法</li></ul></li><li><strong>可见进程</strong>：不含有任何前台组件，但用户还能再屏幕上看见它<ul><li>进程持有一个 <code>Activity</code>，这个 <code>Activity</code> 处于 <code>pause</code> 状态</li><li>进程持有一个 <code>Service</code> 这个 <code>Service</code> 和一个可见的 <code>Activity</code> 绑定。</li><li>可见进程是非常重要的进程，除非前台进程已经把系统的可用内存耗光，否则系统不会终止可见进程。</li></ul></li><li><strong>服务进程</strong>：可能在播放音乐或在后台下载文件，除非系统内存不足，否则系统会尽量维持服务进程的运行。</li></ol><ul><li>如果一个进程中运行着一个 <code>Service</code>，并且这个 <code>service</code> 是通过 <code>startService</code> 开启的，那这个进程就是一个服务进程。</li></ul><ol start="4"><li><p><strong>后台进程</strong></p><p>系统会把后台进程（<code>Background Process</code>）保存在一个 <code>LruCache</code> 列表中，因为终止后台进程对用户体验影响不大，所以系统会酌情清理部分后台进程。</p><p>你可以在 <code>Activity</code> 的 <code>onSaveInstanceState()</code> 方法中保存一些数据，以免在应用在后台被系统清理掉后，用户已输入的信息被清空，导致要重新输入。</p><ul><li>当进程持有一个用户不可见的 <code>Activity</code>（<code>Activity</code> 的 <code>onStop()</code> 方法被调用），但是 <code>onDestroy</code> 方法没有被调用，这个进程就会被系统认定为后台进程。</li></ul></li><li><p><strong>空进程</strong>：当一个进程不包含任何活跃的应用组件，则被系统认定为是空进程。</p><p>系统保留空进程的目的是为了加快下次启动进程的速度。</p></li></ol><h3 id="6-3-内存抖动"><a href="#6-3-内存抖动" class="headerlink" title="6.3 内存抖动"></a>6.3 内存抖动</h3><hr><p>当我们在短时间内频繁创建大量临时对象时，就会引起内存抖动，比如在一个 <code>for</code> 循环中创建临时对象实例。</p><p>内存检测表现如下</p><img src="https://raw.githubusercontent.com/CalmCenter/picGo/master/pictures/20200412160136.png" style="zoom:80%"><p><strong>预防的方法</strong></p><ol><li><p>尽量避免在循环体中创建对象</p></li><li><p>尽量不要在自定义 <code>View</code> 的 <code>onDraw()</code> 方法中创建对象，因为这个方法会被频繁调用</p></li><li><p>对于能够复用的对象，可以考虑使用对象池把它们缓存起来</p></li></ol><h2 id="7-Android-Bitmap-内存分配的变化"><a href="#7-Android-Bitmap-内存分配的变化" class="headerlink" title="7 Android Bitmap 内存分配的变化"></a>7 <strong>Android Bitmap 内存分配的变化</strong></h2><hr><ul><li>在 <code>Android 3.0</code> 之前，<code>Bitmap</code> 对象放在 <code>Java</code> 堆，而像素数据是放在 <code>Native</code> 内存中。如果不手动调用 <code>recycle</code>，<code>Bitmap Native</code> 内存的回收完全依赖 <code>finalize</code> 函数回调，这个时机不太可控。</li><li><code>Android 3.0～Android 7.0</code> 将 <code>Bitmap</code> 对象和像素数据统一放到 <code>Java</code> 堆中，这样就算我们不调用 <code>recycle</code>，<code>Bitmap</code> 内存也会随着对象一起被回收。不过 <code>Bitmap</code> 是内存消耗的大户，把它的内存放到 <code>Java</code> 堆中似乎不是那么美妙。即使是华为 <code>Mate 20</code>，最大的 <code>Java</code> 堆限制也才到 512MB，可能我的物理内存还有 5GB，但是应用还是会因为<code>Java</code> 堆内存不足导致 <code>OOM</code>。<code>Bitmap</code> 放到 <code>Java</code> 堆的另外一个问题会引起大量的 <code>GC</code>，对系统内存也没有完全利用起来。</li><li>有没有一种实现，可以将 <code>Bitmap</code> 内存放到 <code>Nativ</code>e 中，也可以做到和对象一起快速释放，同时 <code>GC</code> 的时候也能考虑这些内存防止被滥用？<code>NativeAllocationRegistry</code> 可以一次满足你这三个要求，<code>Android 8.0</code> 正是使用这个辅助回收 <code>Native</code> 内存的机制，来实现像素数据放到 <code>Native</code> 内存中。<code>Android 8.0</code> 还新增了硬件位图 <code>Hardware Bitmap</code>，它可以减少图片内存并提升绘制效率。</li></ul><h2 id="8-内存优化的两个误区"><a href="#8-内存优化的两个误区" class="headerlink" title="8 内存优化的两个误区"></a>8 内存优化的两个误区</h2><hr><h3 id="8-1-内存占用越少越好。"><a href="#8-1-内存占用越少越好。" class="headerlink" title="8.1 内存占用越少越好。"></a>8.1 内存占用越少越好。</h3><ol><li>有些人认为内存是洪水猛兽，占用越少应用的性能越好，这种认识在具体的优化过程中很容易“用力过猛”。</li><li>应用是否占用了过多的内存，跟设备、系统和当时情况有关，而不是 <code>300MB</code>、<code>400MB</code> 这样一个绝对的数值。当系统内存充足的时候，我们可以多用一些获得更好的性能。当系统内存不足的时候，希望可以做到“用时分配，及时释放”</li></ol><h3 id="8-2-Native-内存不用管"><a href="#8-2-Native-内存不用管" class="headerlink" title="8.2 Native 内存不用管"></a>8.2 <code>Native</code> 内存不用管</h3><ol><li>虽然 <code>Android 8.0</code> 重新将 <code>Bitmap</code> 内存放回到 <code>Native</code> 中，那么我们是不是就可以随心所欲地使用图片呢？</li><li>答案当然是否定的。正如前面所说当系统物理内存不足时，<code>lmk</code> 开始杀进程，从后台、桌面、服务、前台，直到手机重启。</li></ol><h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a><strong>感谢</strong></h2><hr><blockquote><p><a href="https://time.geekbang.org/column/article/74044" target="_blank" rel="noopener">极客时间 Android开发高手课</a>  </p><p><a href="https://coding.imooc.com/learn/list/308.html" target="_blank" rel="noopener">慕课 Top团队大牛带你玩转Android性能分析与优化</a></p><p><a href="https://juejin.im/post/5d3ada056fb9a07eb94fd1bc#heading-3" target="_blank" rel="noopener">探索 Android 内存优化方法</a></p><p><a href="https://juejin.im/post/5d3a870df265da1b855c9d41#heading-15" target="_blank" rel="noopener">探索 Java 内存管理机制</a></p><p><a href="https://juejin.im/post/58b18e442f301e0068028a90" target="_blank" rel="noopener">Android性能优化（三）之内存管理</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生财有术日历</title>
      <link href="/2020/sheng-cai-you-zhu-ri-li.html"/>
      <url>/2020/sheng-cai-you-zhu-ri-li.html</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>日期</th><th align="left">内容</th><th>完整原文链接<br/>(有可能需要付费加入才能观看)</th></tr></thead><tbody><tr><td>1.1</td><td align="left">有钱赚的时候，要集中所有的资源和精力，All in，不要小富即安。<br/>过几年你会拍大腿，那么好的捡钱的机会，为什么错过了。<br/>居安思危才能活得足够长久，富一次的人很多，富一辈子的人很少。</td><td><a href="https://t.zsxq.com/3rrRbMR" target="_blank" rel="noopener">https://t.zsxq.com/3rrRbMR</a></td></tr><tr><td>1.2</td><td align="left">引流也好、裂变也罢，核心仍然是提供价值。<br/>总会有认同价值的，也总会有怀疑价值的，我们不能因为50%的怀疑价值的人，而放弃为剩下的50%的人提供价值的机会。<br/>引流、裂变、发售、势能都是术而已，掌握术容易，术也能带来更快的收益，但不变的是道：核心价值。</td><td><a href="https://t.zsxq.com/2zNrNNr" target="_blank" rel="noopener">https://t.zsxq.com/2zNrNNr</a></td></tr><tr><td>1.3</td><td align="left">我现在创业，期待越轻越好，越产品化越好，最好把内容环节都省掉才觉得好，把增长模块都做到产品中去，只要第一波倒入流量，后面就可以自发增长和变现了。</td><td><a href="https://t.zsxq.com/rVzvzVb" target="_blank" rel="noopener">https://t.zsxq.com/rVzvzVb</a></td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>App 初体验-启动优化</title>
      <link href="/2019/start-optimization.html"/>
      <url>/2019/start-optimization.html</url>
      
        <content type="html"><![CDATA[<p>Android 性能第一篇，随着项目功能的迭（zeng）代（jia），启动速度也会受到影响，性能优化之路的第一步，也就是启动优化，个人认为非常重要，它可以直接影响 <strong>APP</strong> 的留存率，没有人希望自己应用半天打不开。这篇文章就开启 <em>启动优化</em>  之路。</p><p><strong>注意：如果出现图片不显示问题请移步</strong> <a href="https://calmcenter.club/2019/PicNotShow.html">图片不显示问题</a></p><h1 id="本文主要记载"><a href="#本文主要记载" class="headerlink" title="本文主要记载"></a>本文主要记载</h1><ul><li><strong>1 启动</strong></li><li><strong>2 检测启动消耗<code>(敲黑板)</code></strong><ul><li>2.1 启动时间测量方式<ul><li>2.1.1 adb 命令启动时间测量方式</li><li>2.1.2 手动打点</li></ul></li><li>2.2 启动耗时检测方式<ul><li>2.2.1 TraceView</li><li>2.2.2 systrace</li><li>2.2.3 systrace + 函数插桩 AOP</li></ul></li></ul></li><li><strong>3 启动优化<code>(干货)</code></strong><ul><li>3.1 闪屏页展示</li><li>3.2 异步启动实践</li><li>3.3 数据重排</li><li>3.4 类的加载</li><li>3.5 延迟加载方案 IdleHandler</li><li>3.6 其他优化思路</li></ul></li><li><strong>4 启动监控</strong></li></ul><h2 id="1-启动"><a href="#1-启动" class="headerlink" title="1 启动"></a>1 启动</h2><hr><p>Google官方文档 <a href="https://developer.android.com/topic/performance/launch-time.html" target="_blank" rel="noopener">《Launch-Time Performance》</a> 对应用启动优化的概述</p><p>应用的启动分为冷启动、热启动、温启动，而启动最慢、挑战最大的就是冷启动：系统和App本身都有更多的工作要从头开始！我们只要知道我们处理的是冷启动的情况。</p><h2 id="2-检测启动消耗-敲黑板"><a href="#2-检测启动消耗-敲黑板" class="headerlink" title="2 检测启动消耗(敲黑板)"></a>2 检测启动消耗<code>(敲黑板)</code></h2><hr><p>“工欲善其事必先利其器”，我们需要先找到一款适合做启动优化分析的工具。</p><h3 id="2-1-启动时间测量方式"><a href="#2-1-启动时间测量方式" class="headerlink" title="2.1 启动时间测量方式"></a>2.1 启动时间测量方式</h3><hr><h4 id="2-1-1-adb-命令启动时间测量方式"><a href="#2-1-1-adb-命令启动时间测量方式" class="headerlink" title="2.1.1 adb 命令启动时间测量方式"></a>2.1.1 adb 命令启动时间测量方式</h4><hr><pre><code>adb shell am start -W packagename/packagename.Activity</code></pre><p><img src="https://raw.githubusercontent.com/CalmCenter/picGo/master/pictures/20190829115742.png" alt=""></p><p>划掉的红色部分都是包名</p><table><thead><tr><th>字段</th><th>功能</th></tr></thead><tbody><tr><td>ThisTime</td><td>最后一个 Activity 启动耗时</td></tr><tr><td>TotalTIme</td><td>所有 Activity 启动耗时，比如添加启动页</td></tr><tr><td>WaitTime</td><td>AMS 启动 Activity 的总耗时</td></tr><tr><td>ThisTime ≤ TotalToime &lt; WaitTime</td><td></td></tr></tbody></table><p>线下方便使用、可以测量竞品、不能带到线上</p><h4 id="2-1-2-手动打点"><a href="#2-1-2-手动打点" class="headerlink" title="2.1.2 手动打点"></a>2.1.2 手动打点</h4><hr><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LaunchTimer</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">long</span> sTime<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">startRecord</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        sTime <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">endRecord</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">endRecord</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">endRecord</span><span class="token punctuation">(</span>String msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">long</span> cost <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> sTime<span class="token punctuation">;</span>        LogUtils<span class="token punctuation">.</span><span class="token function">e</span><span class="token punctuation">(</span><span class="token string">"LaunchTimer"</span><span class="token punctuation">,</span> msg <span class="token operator">+</span> <span class="token string">" cost "</span> <span class="token operator">+</span> cost<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>在应用启动中，我们所能接收到最早的回调是 <code>Application</code> 中 <code>attachBaseContext(Context context)</code> ，所以只能将 <code>startRecord()</code> 写到这个回调中</p><p>应用启动的结束时间，是用户可操作的时间，先了解两个误区</p><p><code>onAttachedToWindow()</code> 这个方法是在 <code>onResume</code> 之后，只调用一次</p><p><code>onWindowFocusChanged(boolean hasFocus)</code> 这个方法是在获取焦点和失去焦点是调用，在 <code>onAttachedToWindow()</code> 之后调用</p><p>这两个方法，回调时，用户并不可以操作，计算启动耗时的最好的时机应该是某个数据被加载出来后，当然会掺杂一些网络因素，但这里不是为了数据，只是为了用户体验，可以使用一些监听方法</p><pre class=" language-java"><code class="language-java">mView<span class="token punctuation">.</span><span class="token function">getViewTreeObserver</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addOnPreDrawListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ViewTreeObserver<span class="token punctuation">.</span>OnPreDrawListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">onPreDraw</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        mView<span class="token punctuation">.</span><span class="token function">getViewTreeObserver</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">removeOnPreDrawListener</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>mView<span class="token punctuation">.</span><span class="token function">getViewTreeObserver</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addOnDrawListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ViewTreeObserver<span class="token punctuation">.</span>OnDrawListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onDraw</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        mView<span class="token punctuation">.</span><span class="token function">getViewTreeObserver</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">removeOnDrawListener</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>在 View 将要绘制的时候去进行耗时的统计，<code>addOnDrawListener()</code> 需要 <code>API 16</code></p><h3 id="2-2-启动耗时检测方式"><a href="#2-2-启动耗时检测方式" class="headerlink" title="2.2 启动耗时检测方式"></a>2.2 启动耗时检测方式</h3><hr><h4 id="2-2-1-TraceView"><a href="#2-2-1-TraceView" class="headerlink" title="2.2.1 TraceView"></a>2.2.1 TraceView</h4><hr><p>图形化界面的形式展示出执行时间、调用栈，包含所有线程，信息全面</p><p>但是加入 <code>TraceView</code> 的代码后，运行时开销严重，整体都会变慢，可能会带骗优化方向</p><ul><li><h5 id="通过代码跟踪💦"><a href="#通过代码跟踪💦" class="headerlink" title="通过代码跟踪💦"></a>通过代码跟踪💦</h5></li></ul><p>只能用于某一个方法的检测</p><pre><code>Debug.startMethodTracing(&quot;xxx&quot;);...Debug.stopMethodTracing();</code></pre><p>默认生成文件在 <code>mnt/sdcard/Android/data/packagename/fils</code>  </p><pre><code>adb pull /sdcard/Android/data/packagename/fils/my.trace</code></pre><p>这样可以将 <code>trace</code> 文件拷贝到项目根目录</p><p>也可以通过 <code>Device File Explorer</code>(AS 右下角) 找到文件，右键点击 <code>Sava as…</code></p><ul><li><h5 id="通过命令跟踪💦"><a href="#通过命令跟踪💦" class="headerlink" title="通过命令跟踪💦"></a>通过命令跟踪💦</h5></li></ul><p>可用于整个开始结束的过程(内容会比较多~)</p><p>开始跟踪</p><pre><code>adb shell am start -n packagename/packagename.Activity --start-profiler /data/local/tmp/my.trace --sampling 1000</code></pre><p>终止跟踪</p><pre><code>adb shell am profile stop</code></pre><p>拉取文件</p><pre><code>adb pull /data/local/tmp/my.trace</code></pre><p>这种方法可以检测启动到调用终止期间的全部内容，但是有些手机出来的 <code>trace</code> 文件时 <code>0B</code>，这就需要在需要停止的地方写上</p><pre class=" language-java"><code class="language-java">Debug<span class="token punctuation">.</span><span class="token function">stopMethodTracing</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>然后调用开始追踪，会自动停止。文件会放在 <code>data/local/tmp</code> 下。</p><ul><li><h5 id="查看-Trace-文件💦"><a href="#查看-Trace-文件💦" class="headerlink" title="查看 Trace 文件💦"></a>查看 Trace 文件💦</h5></li></ul><img src="https://raw.githubusercontent.com/CalmCenter/picGo/master/pictures/20191126115732.png" style="zoom:50%"><p>这就是用 <code>AndroidStudio</code> 查看生成的 <code>TraceView</code> 文件</p><ol><li>范围选择</li></ol><p>标有 <code>Cpu usage details unavailable</code> 的地方可以选择时间范围；标有 ·THREADS· 的地方可以选择某条线程，括号中的 <code>67</code> 表示检测全称有 <code>67</code> 条线程。选择时间或线程底部的 <code>Call Chart</code> 都会有相应的变化。</p><ol start="2"><li>执行选择</li></ol><p>在线程选择下有一个 <code>Wall Clock Time</code> 这个表示真正执行的时间，可以切换为 <code>Thread Time</code> 表示 <code>CPU</code> 执行的时间，<code>Thread Time</code> 始终小于 <code>Wall Clock Time</code>。</p><ol start="3"><li>CallChart</li></ol><p>从上到下，调用者在上方，被调用者在下方；<code>系统 API</code> 是橙色、<code>应用自身调用</code> 是绿色、<code>第三方 API</code> 是蓝色，看绿色的部分很直观的可以看出我们自己代码在哪里耗时了~</p><ol start="4"><li>TopDown</li></ol><img src="https://raw.githubusercontent.com/CalmCenter/picGo/master/pictures/20191126121637.png" style="zoom:50%"><table><thead><tr><th>标题</th><th>作用</th></tr></thead><tbody><tr><td><strong>Total</strong></td><td>整个函数执行时间</td></tr><tr><td><strong>Self</strong></td><td>函数代码内执行时间</td></tr><tr><td><strong>Children</strong></td><td>子函数耗时</td></tr></tbody></table><p>🌞举个栗子🌞：调用 <code>A</code> 函数整体时间是 <code>Total</code> ，在函数中执行了一行代码耗时 <code>Self</code> ，然后调用 <code>B</code> 函数耗时 <code>Children</code></p><p>这两个方式是比较常用的方式，如果是应用自身方法都可以点击右键进入源码所在位置。</p><ul><li><h5 id="总结💦"><a href="#总结💦" class="headerlink" title="总结💦"></a>总结💦</h5></li></ul><ol><li>运行时开销严重，整体都会变慢(因为 <code>TraceView</code> 要抓取所有线程的所有执行函数以及顺序)</li><li>可能会带偏优化方向(本来不好时间的函数可能加入 <code>TraceView</code> 后，变的非常耗时)</li></ol><h4 id="2-2-2-systrace"><a href="#2-2-2-systrace" class="headerlink" title="2.2.2 systrace"></a>2.2.2 systrace</h4><hr><p>结合 Android 内核的数据，生成 HTML 报告，<code>API 18</code> 以上，推荐 <code>TraceCompat</code></p><ul><li><h5 id="首先清空后台💦"><a href="#首先清空后台💦" class="headerlink" title="首先清空后台💦"></a>首先清空后台💦</h5></li></ul><p>杀掉所有应用，防止出现莫名莫名方法。</p><ul><li><h5 id="在需要检测的地方写入代码-可以不写，但是会少一些-tag-提示-💦"><a href="#在需要检测的地方写入代码-可以不写，但是会少一些-tag-提示-💦" class="headerlink" title="在需要检测的地方写入代码(可以不写，但是会少一些 tag 提示)💦"></a>在需要检测的地方写入代码(可以不写，但是会少一些 tag 提示)💦</h5></li></ul><pre><code>TraceCompat.beginSection(&quot;AppOnCreate&quot;);...TraceCompat.endSection();</code></pre><ul><li><h5 id="执行检测💦"><a href="#执行检测💦" class="headerlink" title="执行检测💦"></a>执行检测💦</h5></li></ul><p>首先进入 <code>SDK</code> 目录，<code>Sdk\platform-tools\systrace\</code> 目录下有一个 <code>systrace.py</code> 文件，打开 <code>cmd</code> 输入</p><pre><code>python systrace.py -b 90960 -t 5 -a packagename -o test.log.html sched gfx view wm am app</code></pre><p>这种方式是 <code>5</code> 秒后自动输出</p><pre><code>python systrace.py gfx view wm am pm ss dalvik app sched -b 90960 -a packagename -o test.log.html</code></pre><p>这种方式可以在自己收集完后，点击 <code>Enter</code> 键停止收集</p><p>两种内容是不太一样的， <code>-t</code> 表示时间，<code>-a</code> 表示包名，<code>-o</code> 输出文件名，最终在当前目录打开文件即可看到，文件只能使用 <code>Chrome</code> 来打开，如果打开 <code>HTML</code> 出现 </p><p><code>Unable to select a master clock domain because no path can be found from &quot;SYSTRACE&quot; to &quot;LINUX_FTRACE_GLOBAL&quot;.</code></p><p>那就是命令出错了，命令我也是收集了好久，最终找到可用的，想了解更多的请查看 <a href="http://gityuan.com/2016/01/17/systrace/" target="_blank" rel="noopener">Gityuan</a> 或 <a href="https://source.android.com/devices/tech/debug/systrace" target="_blank" rel="noopener">官方文档</a> </p><ol start="4"><li>分析文件</li></ol><img src="https://raw.githubusercontent.com/CalmCenter/picGo/master/pictures/20191212120416.png" style="zoom:50%"><p>这里可以看到 <code>CPU</code> 核心数以及运行状态，还有各个线程。</p><p>在 <code>UI Thread</code> 中的 <code>AppOnCreate</code> 正是我们在之前的代码埋 <code>tag</code> 点，点击条目并按 <code>M</code> 键可以查看具体信息。右上角是可以搜索 <code>tag</code> 的。</p><p>具体信息中有 <code>Wall Duration</code> （代码执行时间） <code>CPU Duration</code> （代码消耗 CPU 的时间）两者出现差值的原因是同步锁冲突。 </p><p>这种方式不仅可以帮助监控启动过程中性能问题，卡顿优化的时候也可以用这种方式。因为它会把 <code>UI</code> 的渲染也检测到。</p><ul><li><h5 id="总结💦-1"><a href="#总结💦-1" class="headerlink" title="总结💦"></a>总结💦</h5></li></ul><ol><li>轻量级，开销小</li><li>直观的反应 CPU 利用率</li></ol><h4 id="2-2-3-systrace-函数插桩-AOP-Aspect-Oriented-Programming"><a href="#2-2-3-systrace-函数插桩-AOP-Aspect-Oriented-Programming" class="headerlink" title="2.2.3 systrace + 函数插桩 AOP(Aspect Oriented Programming)"></a>2.2.3 systrace + 函数插桩 AOP(Aspect Oriented Programming)</h4><hr><p> 面向切面编程，针对同一类问题的统一处理，无侵入添加代码。</p><p>在根目录的 <code>build.gradle</code> 下，最新版本请查看 <a href="https://github.com/HujiangTechnology/gradle_plugin_android_aspectjx" target="_blank" rel="noopener">AspectJX 开源地址</a></p><pre class=" language-groovy"><code class="language-groovy">classpath <span class="token string">'com.hujiang.aspectjx:gradle-android-plugin-aspectjx:2.0.8'</span></code></pre><p>在 <code>app</code> 模块下添加如下，通过我的测试这些引用只能添加在 <code>app</code> 模块下，添加在其他子模块下不生效。最新版本请查看 <a href="http://www.eclipse.org/aspectj/downloads.php#stable_release" target="_blank" rel="noopener">AspectJ官网</a></p><p>顶部</p><pre class=" language-groovy"><code class="language-groovy">apply plugin<span class="token punctuation">:</span> <span class="token string">'android-aspectjx'</span></code></pre><p><code>dependencies</code> 内</p><pre class=" language-groovy"><code class="language-groovy">api <span class="token string">'org.aspectj:aspectjrt:1.9.5'</span></code></pre><p>下面是通过注解的方式结合 <code>Systrace</code> 进行埋点。</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">/** * AnnotationRetention.SOURCE：不存储在编译后的 Class 文件。 * AnnotationRetention.BINARY：存储在编译后的 Class 文件，但是反射不可见。 * AnnotationRetention.RUNTIME：存储在编译后的 Class 文件，反射可见。 */</span><span class="token annotation builtin">@Retention</span><span class="token punctuation">(</span>AnnotationRetention<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token comment" spellcheck="true">/** * AnnotationTarget.CLASS：类，接口或对象，注解类也包括在内。 * AnnotationTarget.ANNOTATION_CLASS：只有注解类。 * AnnotationTarget.TYPE_PARAMETER：Generic type parameter (unsupported yet)通用类型参数（还不支持）。 * AnnotationTarget.PROPERTY：属性。 * AnnotationTarget.FIELD：字段，包括属性的支持字段。 * AnnotationTarget.LOCAL_VARIABLE：局部变量。 * AnnotationTarget.VALUE_PARAMETER：函数或构造函数的值参数。 * AnnotationTarget.CONSTRUCTOR：仅构造函数（主函数或者第二函数）。 * AnnotationTarget.FUNCTION：方法（不包括构造函数）。 * AnnotationTarget.PROPERTY_GETTER：只有属性的 getter。 * AnnotationTarget.PROPERTY_SETTER：只有属性的 setter。 * AnnotationTarget.TYPE：类型使用。 * AnnotationTarget.EXPRESSION：任何表达式。 * AnnotationTarget.FILE：文件。 * AnnotationTarget.TYPEALIAS：@SinceKotlin("1.1") 类型别名，Kotlin1.1已可用。 */</span><span class="token annotation builtin">@Target</span><span class="token punctuation">(</span>AnnotationTarget<span class="token punctuation">.</span>FUNCTION<span class="token punctuation">)</span><span class="token keyword">annotation</span> <span class="token keyword">class</span> TraceCompat</code></pre><p>具体的切入代码，需要将 <code>packagename</code> 换成自己的路径名字</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token annotation builtin">@Aspect</span><span class="token keyword">class</span> TraceCompatAspect <span class="token punctuation">{</span>    <span class="token annotation builtin">@Pointcut</span><span class="token punctuation">(</span><span class="token string">"execution(@packagename.TraceCompat * *(..))"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//方法切入点</span>    <span class="token keyword">fun</span> <span class="token function">methodAnnotated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token annotation builtin">@Around</span><span class="token punctuation">(</span><span class="token string">"methodAnnotated()"</span><span class="token punctuation">)</span>    <span class="token keyword">fun</span> <span class="token function">aroundJoinPoint</span><span class="token punctuation">(</span>joinPoint<span class="token operator">:</span> ProceedingJoinPoint<span class="token punctuation">)</span> <span class="token punctuation">{</span>        TraceCompat<span class="token punctuation">.</span><span class="token function">beginSection</span><span class="token punctuation">(</span><span class="token string">"TraceCompat"</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">//执行原方法</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            joinPoint<span class="token punctuation">.</span><span class="token function">proceed</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            TraceCompat<span class="token punctuation">.</span><span class="token function">endSection</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>在需要埋点的加入注解</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@TraceCompat</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><p>这样就完成了 <code>AOP</code> 埋点辅助<code>systrace</code> 监控的方式。<code>AOP</code> 还有很多更强大更方便的用法，这里只是一种注解切入的方式。更多用法请查看其它文章。</p><p>由于我现在使用 <code>AOP</code> 还存在很多问题，还在研究中。。。(上面的例子是可以使用的)</p><h2 id="3-启动优化-干货"><a href="#3-启动优化-干货" class="headerlink" title="3 启动优化(干货)"></a>3 启动优化<code>(干货)</code></h2><hr><h3 id="3-1-闪屏页展示"><a href="#3-1-闪屏页展示" class="headerlink" title="3.1 闪屏页展示"></a>3.1 闪屏页展示</h3><hr><p>闪屏页是优化启动速度的一个小技巧，虽然对实际的启动速度没有任何帮助，但是能让用户感觉应用到应用在第一时间已经被打开。</p><p>合并闪屏和主页面的 Activity，减少一个 Activity 会给线上带来 100 毫秒左右的优化。但是如果这样做的话，管理时会非常复杂。</p><p>闪屏如果存在网络请求，一般都是提前准备好闪屏页的，在下一次生效。</p><p>具体操作文末参考中会有 ~ 这里不再说明。</p><h3 id="3-2-异步启动实践"><a href="#3-2-异步启动实践" class="headerlink" title="3.2 异步启动实践"></a>3.2 异步启动实践</h3><hr><h4 id="3-2-1-启动器"><a href="#3-2-1-启动器" class="headerlink" title="3.2.1 启动器"></a>3.2.1 启动器</h4><hr><p>微信内部使用的 <a href="https://mp.weixin.qq.com/s/6Q818XA5FaHd7jJMFBG60w?" target="_blank" rel="noopener">mmkernel</a></p><p>阿里最近开源的 <a href="https://github.com/alibaba/alpha" target="_blank" rel="noopener">Alpha</a> 启动框架</p><p>慕课网中学习到的 启动器 <code>Task</code> </p><p>它们为各个任务建立依赖关系，最终构成一个有向无环图。对于可以并发的任务，会通过线程池最大程度提升启动速度。</p><h4 id="3-2-1-异步Layout子线程预加载"><a href="#3-2-1-异步Layout子线程预加载" class="headerlink" title="3.2.1 异步Layout子线程预加载"></a>3.2.1 异步Layout子线程预加载</h4><hr><p>参考文章 <a href="https://juejin.im/post/5d63cdf7f265da03ed195f68?utm_source=gold_browser_extension#comment" target="_blank" rel="noopener">Android - 一种新奇的冷启动速度优化思路(Fragment极度懒加载 + Layout子线程预加载)</a> </p><h3 id="3-3-数据重排"><a href="#3-3-数据重排" class="headerlink" title="3.3 数据重排"></a>3.3 数据重排</h3><hr><h4 id="3-3-1-类重排"><a href="#3-3-1-类重排" class="headerlink" title="3.3.1 类重排"></a>3.3.1 类重排</h4><hr><p>Facebook 开源的 Dex 优化工具 <a href="https://github.com/facebook/redex/blob/master/docs/Interdex.md" target="_blank" rel="noopener">ReDex</a></p><p><a href="https://mp.weixin.qq.com/s/Hquq8iJvZuN-gynVFxCCNA" target="_blank" rel="noopener">都9102年了，Android 冷启动优化除了老三样还有哪些新招？</a></p><h4 id="3-3-2-资源文件重排"><a href="#3-3-2-资源文件重排" class="headerlink" title="3.3.2 资源文件重排"></a>3.3.2 资源文件重排</h4><hr><p>支付宝 <a href="https://mp.weixin.qq.com/s/79tAFx6zi3JRG-ewoapIVQ" target="_blank" rel="noopener">《通过安装包重排布优化 Android 端启动性能》</a></p><h3 id="3-4-类的加载"><a href="#3-4-类的加载" class="headerlink" title="3.4 类的加载"></a>3.4 类的加载</h3><hr><p>加载类的过程有一个 verify class 的步骤，它需要校验方法的每一个指令，是一个比较耗时的操作。我们可以通过 Hook 来去掉 verify 这个步骤，这对启动速度有几十毫秒的优化。最大的优化场景在于首次和覆盖安装时。</p><p>这个黑科技可以大大降低首次启动的速度，代价是对后续运行会产生轻微的影响。同时也要考虑兼容性问题，暂时不建议在 ART 平台使用。</p><h3 id="3-5-延迟加载方案-IdleHandler"><a href="#3-5-延迟加载方案-IdleHandler" class="headerlink" title="3.5 延迟加载方案 IdleHandler"></a>3.5 延迟加载方案 IdleHandler</h3><hr><p>利用 <code>IdleHandler</code> 特性，空闲时执行初始化。</p><p><strong><code>IdleHandler</code> 可以用来提升性能，主要用在我们希望能够在当前线程消息队列空闲时做些事情</strong> </p><h3 id="3-6-其他优化思路"><a href="#3-6-其他优化思路" class="headerlink" title="3.6 其他优化思路"></a>3.6 其他优化思路</h3><hr><h4 id="5-0-以下机型-MultiDex-优化"><a href="#5-0-以下机型-MultiDex-优化" class="headerlink" title="5.0 以下机型 MultiDex 优化"></a><code>5.0</code> 以下机型 <code>MultiDex</code> 优化</h4><p><a href="https://juejin.im/post/5d95f4a4f265da5b8f10714b?utm_source=gold_browser_extension#comment" target="_blank" rel="noopener">面试官：今日头条启动很快，你觉得可能是做了哪些优化？</a></p><h4 id="GC-优化"><a href="#GC-优化" class="headerlink" title="GC 优化"></a>GC 优化</h4><hr><p>支付宝提出一种 <a href="https://mp.weixin.qq.com/s/ePjxcyF3N1vLYvD5dPIjUw" target="_blank" rel="noopener">GC 抑制</a> 的方案</p><p>在启动过程，要尽量减少 GC 的次数，避免造成主线程长时间的卡顿。</p><p>特别是对 Dalvik 来说，我们可以通过 systrace 单独查看整个启动过程 GC 的时间。</p><pre><code>python systrace.py dalvik -b 90960 -a com.sample.gc</code></pre><pre><code>// GC使用的总耗时，单位是毫秒Debug.getRuntimeStat(&quot;art.gc.gc-time&quot;);// 阻塞式GC的总耗时Debug.getRuntimeStat(&quot;art.gc.blocking-gc-time&quot;);</code></pre><p>启动过程避免进行大量的字符串操作，特别是序列化跟反序列化过程。一些频繁创建的对象，例如网络库和图片库中的 Byte 数组、Buffer 可以复用。</p><h4 id="系统调用优化"><a href="#系统调用优化" class="headerlink" title="系统调用优化"></a>系统调用优化</h4><hr><p>通过 systrace 的 System Service 类型，我们可以看到启动过程 System Server 的 CPU 工作情况。在启动过程，我们尽量不要做系统调用，例如 PackageManagerService 操作、Binder 调用等待。</p><p>在启动过程也不要过早地拉起应用的其他进程，System Server 和新的进程都会竞争 CPU 资源。</p><h4 id="线程优化"><a href="#线程优化" class="headerlink" title="线程优化"></a>线程优化</h4><hr><p>线程优化就像做填空题和解锁题，我们希望能把所有的时间片都利用上，因此主线程和各个线程都是一直满载的。当然我们也希望每个线程都开足马力向前跑，而不是作为接力棒。所以线程的优化主要在于减少 CPU 调度带来的波动，让应用的启动时间更加稳定。</p><p>从具体的做法来看，线程的优化一方面是控制线程数量，线程数量太多会相互竞争 CPU 资源，因此要有统一的线程池，并且根据机器性能来控制数量。</p><p>3.2.1 启动器 提到，合理分配线程数量。</p><p>另一方面是检查线程间的锁。</p><h4 id="业务优化"><a href="#业务优化" class="headerlink" title="业务优化"></a>业务优化</h4><hr><p>我们首先需要梳理清楚当前启动过程正在运行的每一个模块，哪些是一定需要的、哪些可以砍掉、哪些可以懒加载。</p><p>通过梳理之后，剩下的都是启动过程一定要用的模块。</p><p>这个时候，我们只能硬着头皮去做进一步的优化。优化前期需要“抓大放小”，先看看主线程究竟慢在哪里。</p><p>退而求其次，我们要考虑这些任务是不是可以通过异步线程预加载实现（上面有讲到），但需要注意的是过多的线程预加载会让我们的逻辑变得更加复杂。</p><h4 id="I-O-优化"><a href="#I-O-优化" class="headerlink" title="I/O 优化"></a>I/O 优化</h4><hr><p>启动过程不建议出现网络 I/O</p><p>磁盘 I/O 是启动优化一定要抠的点（敬请期待）</p><p>还有一个是数据结构的选择问题，我们在启动过程只需要读取 Setting.sp 的几项数据，不过 SharedPreference 在初始化的时候还是要全部数据一起解析。如果它的数据量超过 1000 条，启动过程解析时间可能就超过 100 毫秒。如果只解析启动过程用到的数据项则会很大程度减少解析时间，启动过程适合使用随机读写的数据结构。（敬请期待）</p><h4 id="保活"><a href="#保活" class="headerlink" title="保活"></a>保活</h4><hr><p>保活可以减少 Application 创建跟初始化的时间，让冷启动变成温启动。不过在 Target 26 之后，保活的确变得越来越难。</p><p>对于大厂来说，可能需要寻求厂商合作的机会，例如微信的 <a href="https://www.geekpark.net/news/233791" target="_blank" rel="noopener">Hardcoder</a> 方案和 OPPO 推出的Hyper Boost方案。根据 OPPO 的数据，对于手机 QQ、淘宝、微信启动场景会直接有 20% 以上的优化。</p><p>有的时候你问为什么微信可以保活？为什么它可以运行的那么流畅？这里可能不仅仅是技术上的问题，当应用体量足够大，就可以倒逼厂商去专门为它们做优化。</p><h4 id="插件化和热修复"><a href="#插件化和热修复" class="headerlink" title="插件化和热修复"></a>插件化和热修复</h4><hr><p>大部分的框架在设计上都存在大量的 Hook 和私有 API 调用，带来的缺点主要有两个：</p><ul><li>稳定性差。虽然大家都号称兼容 100% 的机型，由于厂商的兼容性、安装失败、dex2oat 失败等原因，还是会有那么一些代码和资源的异常。Android P 推出的 non-sdk-interface 调用限制，以后适配只会越来越难，成本越来越高。</li><li>性能差。Android Runtime 每个版本都有很多的优化，因为插件化和热修复用到的一些黑科技，导致底层 Runtime 的优化我们是享受不到的。Tinker 框架在加载补丁后，应用启动速度会降低 5%～10%。</li></ul><p>应用加固对启动速度来说简直是灾难，有时候我们需要做一些权衡和选择。</p><h2 id="4-启动监控"><a href="#4-启动监控" class="headerlink" title="4 启动监控"></a>4 启动监控</h2><hr><p><a href="https://developer.android.google.cn/topic/performance/vitals/launch-time#av" target="_blank" rel="noopener">Android Vitals</a> </p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ViewPage滑动动画差值器</title>
      <link href="/2019/viewpage-indicator-bezierindicator.html"/>
      <url>/2019/viewpage-indicator-bezierindicator.html</url>
      
        <content type="html"><![CDATA[<p>很久以前看到一个这样的效果，很多文章都是只重点实现选择器，<code>ViewPager</code> 的差值器动画效果没有考虑，这里我努力做到最像，完成这个设计</p><img src="https://user-gold-cdn.xitu.io/2018/2/6/16169f802550c42e?imageslim" style="zoom:40%"><h2 id="本文知识点"><a href="#本文知识点" class="headerlink" title="本文知识点"></a>本文知识点</h2><ul><li></li><li><code>ViewPager</code>  滑动解析</li><li>自定义 <code>Scroller</code> </li><li>反射</li></ul><hr><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> ui </tag>
            
            <tag> viewpage </tag>
            
            <tag> ViewPageIndicator </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dalvik 寄存器</title>
      <link href="/2019/dalvikbase.html"/>
      <url>/2019/dalvikbase.html</url>
      
        <content type="html"><![CDATA[<h1 id="Dalvik-寄存器"><a href="#Dalvik-寄存器" class="headerlink" title="Dalvik 寄存器"></a>Dalvik 寄存器</h1><a id="more"></a><h2 id="寄存器命名法"><a href="#寄存器命名法" class="headerlink" title="寄存器命名法"></a>寄存器命名法</h2><h2 id="Dalvik-字节码"><a href="#Dalvik-字节码" class="headerlink" title="Dalvik 字节码"></a>Dalvik 字节码</h2><h2 id="Dalvik-指令集"><a href="#Dalvik-指令集" class="headerlink" title="Dalvik 指令集"></a>Dalvik 指令集</h2><p>Dalvik 指令在调用格式上模仿了 C 语言的调用约定。Dalvik 指令的语法与助记符有如下特点。</p><ul><li>参数采用从目标 (detination) 到 (source)的方式</li><li>根据字节码大小与类型的不同, 为一些字节码添加了名称后缀以消除歧义<ul><li>32 位常规类型的字节码未添加任何后缀。</li><li>64 位常规类型的字节码添加 -wide 后缀。</li><li>对特殊类型的字节码, 根据具体类型添加后缀, 可以使 -boolean、-byte、-char、-short、-int、-long、-float、-double、-object、-string、-class、-void中的一个</li></ul></li><li>根据字节码布局的选项不同, 为一些字节码添加了字节码后缀以消除歧义。这些后缀通过字节码主名称后添加斜杠来分割。</li><li>在指令集的描述中, 宽度值中的每个字母 都表示 4 位的宽度。</li></ul><h3 id="空操作指令"><a href="#空操作指令" class="headerlink" title="空操作指令"></a>空操作指令</h3><p>空操作指令的助记符为 nop, 它的值为 00。nop 指令通常用于对齐代码, 不进行实际操作。</p><h3 id="数据操作指令"><a href="#数据操作指令" class="headerlink" title="数据操作指令"></a>数据操作指令</h3><p>数据操作指令为 move, 其原型为 move destination, source。根据字节码大小与类型的不同, move 指令有不同的后缀, 如下：</p><table><thead><tr><th align="left"><strong>指令</strong></th><th align="left"><strong>描述</strong></th></tr></thead><tbody><tr><td align="left">move vA, vB</td><td align="left">指令用于将 vB 寄存器的值赋值给 vA 寄存器, <br/>源寄存器和目的寄存器都是 4 位</td></tr><tr><td align="left">move/from16 vAA, vBBBB</td><td align="left">指令用于将 vBBBB 寄存器的值赋值给 vAA 寄存器, <br/>源寄存器为 16 位, 目的寄存器为 8 位</td></tr><tr><td align="left">move/16 vAAAA, vBBBB</td><td align="left">指令用于将 vBBBB 寄存器的值赋值给 vAAAA 寄存器, <br>源寄存器和目的寄存器都是 16 位</td></tr><tr><td align="left">move-wide vA, vB</td><td align="left">指令用于为 4 位的寄存器对赋值, 源寄存器和目的寄存器都是 4 位</td></tr><tr><td align="left">move-wide/from16 vAA, vBBBB</td><td align="left">与 move-wide 相同</td></tr><tr><td align="left">move-wide/16 vAA, vBBBB</td><td align="left">与 move-wide 相同</td></tr><tr><td align="left">move-object vA,vB</td><td align="left">指令用于为对象赋值, 源寄存器和目的寄存器都是 4 位</td></tr><tr><td align="left">move-object/from16 vAA, vBBBB</td><td align="left">指令用于为对象赋值, 源寄存器为 16 位, 目的寄存器为 8 位</td></tr><tr><td align="left">move-object/16 vAAAA, vBBBB</td><td align="left">指令用于为对象赋值, 源寄存器和目的寄存器都是 16 位</td></tr><tr><td align="left">move-result vAA</td><td align="left">指令用于将上一个 invoke 类型指令操作的单字非对象结果赋给 vAA 寄存器</td></tr><tr><td align="left">move-result-wide vAA</td><td align="left">指令用于将上一个 invoke 类型指令操作的双字非对象结果赋给 vAA 寄存器</td></tr><tr><td align="left">move-result-object vAA</td><td align="left">指令用于将上一个 invoke 类型指令操作的对象结果赋给 vAA 寄存器</td></tr><tr><td align="left">move-exception vAA</td><td align="left">指令用于将一个在运行时发生的异常保存到 vAA 寄存器中。<br>这条指令必须在异常发生时由异常处理器使用, 否则指令无效</td></tr></tbody></table><h3 id="返回指令"><a href="#返回指令" class="headerlink" title="返回指令"></a>返回指令</h3><p>返回指令是指函数结束时运行的最后一条指令, 它的基础字节码为 return, 如下：  </p><table><thead><tr><th><strong>指令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>return-void</td><td>指令表示函数从一个 void 方法返回</td></tr><tr><td>return vAA</td><td>指令表示函数返回一个 32 位非对象类型的值, 返回值寄存器为 8 位的寄存器 vAA</td></tr><tr><td>return-wide vAA</td><td>指令表示函数返回一个 64 位非对象类型的值, 返回值寄存器为 8 位的寄存器对 vAA</td></tr><tr><td>return-object vAA</td><td>指令表示函数返回一个对象类型的值, 返回值为 8 位的寄存器 vAA</td></tr></tbody></table><h3 id="数据定义指令"><a href="#数据定义指令" class="headerlink" title="数据定义指令"></a>数据定义指令</h3><p>数据定义指令用来定义程序中用到的常量、字符串、类等数据, 它的基础字节码为 const, 如下：</p><table><thead><tr><th><strong>指令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>const/4 vA,#+B</td><td>指令用于将数值符号扩展为 32 位后赋给寄存器 vA</td></tr><tr><td>const/16 vAA,#+BBBB</td><td>指令用于将数值符号扩展为 32 位后赋给寄存器 vAA</td></tr><tr><td>const vAA,#+BBBBBBBB</td><td>指令用于将数值赋给寄存器 vAA</td></tr><tr><td>const/high16 vAA,#+BBBB0000</td><td>指令用于将数值右边零扩展为 32 位后赋给寄存器 vAA</td></tr><tr><td>const-wide/16 vAA,#+BBBB</td><td>指令用于将数值扩展为 64 位后赋给寄存器对 vAA</td></tr><tr><td>const-wide/32 vAA,#+BBBBBBBB</td><td>指令用于将数值扩展为 64 位后赋给寄存器对 vAA</td></tr><tr><td>const-wide vAA,#+BBBBBBBBBBBBBBBB</td><td>指令用于将数值赋给寄存器对 vAA</td></tr><tr><td>const-wide/hight16 vAA,#+BBBB000000000000</td><td>指令用于将数值右边零扩展为 64 位后赋给寄存器对 vAA</td></tr><tr><td>const-string vAA,string@BBBB</td><td>指令用于通过字符串索引构造一个字符串并赋给寄存器 vAA</td></tr><tr><td>const-string/jumbo vAA,string@BBBBBBBB</td><td>指令用于通过字符串索引(较大)构造一个字符串并赋给寄存器 vAA</td></tr><tr><td>const-class vAA,type@BBBB</td><td>指令用于通过类型索引获取一个类引用并赋给寄存器 vAA</td></tr><tr><td>const-class/jumbo vAAAA,type@BBBBBBBB</td><td>指令用于通过类型索引获取一个类引用并赋给寄存器 vAA<br>(这条指令占用两个字节, 值为 0x00ff)</td></tr></tbody></table><h3 id="锁指令"><a href="#锁指令" class="headerlink" title="锁指令"></a>锁指令</h3><p>锁指令多用在多线程中对同一对象的操作中, Dalvik 指令集中提供了如下两条锁指令：</p><table><thead><tr><th><strong>指令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>monitor-enter vAA</td><td>为指定的对象获取锁</td></tr><tr><td>monitor-exit vAA</td><td>释放指定对象的锁</td></tr></tbody></table><h3 id="实例操作指令"><a href="#实例操作指令" class="headerlink" title="实例操作指令"></a>实例操作指令</h3><p>与实例相关的操作包括实例的类型转换、检查及创建等。如下：</p><table><thead><tr><th><strong>指令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>check-cast vAA,type@BBBB</td><td>指令用于将 vAA 寄存器中的对象引用转换成指定的类型, <br/>如果失败会抛出 ClassCastException 异常, <br/>如果类型 B 指定的是基本类型, <br/>对于非基本类型的 A 来说, 运行时始终会失败。</td></tr><tr><td>instance-of vA,vB,type@CCCC</td><td>指令用于判断 vB 寄存器中的对象是否可以转换成指定的类型, <br/>如果可以 vA 赋给 1, 否则赋给 0。</td></tr><tr><td>new-instance vAA,type@BBBB</td><td>指令用于构造一个指定类型对象的新实例, 并将对象引用赋给 vAA,  <br/>类型符 type 指定的类型不是数组。</td></tr><tr><td>check-cast/jumbo vAAAA,type@BBBBBBBB</td><td>同 check-cast vAA,type@BBBB , <br>只是寄存器值和指令的索引取值返回更大 (android 4.0 新增)</td></tr><tr><td>instance-of/jumbo vAAAA,vBBBB,type@CCCCCCCC</td><td>同 instance-of vA,vB,type@CCCC , <br/>只是寄存器值和指令的索引取值返回更大 (android 4.0 新增)</td></tr><tr><td>new-instance/jumbo vAAAA,type@BBBBBBBB</td><td>同 new-instance vAA,type@BBBB , <br/>只是寄存器值和指令的索引取值返回更大 (android 4.0 新增)</td></tr></tbody></table><h3 id="数组操作指令"><a href="#数组操作指令" class="headerlink" title="数组操作指令"></a>数组操作指令</h3><p>数组操作包括获取数组长度、新建数组、数组赋值、数组元素取值与赋值等操作。如下：</p><table><thead><tr><th><strong>指令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>array-length vA, vB</td><td>获取给定 VB 寄存器中数组的长度并将值赋给 vA 寄存器</td></tr><tr><td>new-array vA, vB, type@CCCC</td><td>构造指定类型 (type@CCCC) 和大小 (vB) 的数组, 并将值赋给 vA</td></tr><tr><td>filled-new-array {vC, vD, vE, vF, vG}, type@BBBB</td><td>构造指定类型 (type@BBBB) 和大小 (vA) 的数组并填充数组内容。<br/>vA 寄存器是隐含使用的, 除了指定数组的大小外还指定了参数的个数, vC ~ vG 是使用到的参数寄存器序列</td></tr><tr><td>filled-new-array/range {vCCCC .. vNNNN}, type@BBBB</td><td>指令功能同 filled-new-array {vC,vD,vE,vF,vG},type@BBBB, <br/>只是参数寄存器使用 range 字节码后缀指定了取值范围, <br/>vC 是第一个参数寄存器,  N = A + C - 1</td></tr><tr><td>fill-array-data vAA, +BBBBBBBB</td><td>用指定的数据来填充数组, vAA 为数组引用, <br/>引用必须为基础类型的数组, 再指令后面会紧跟一个数据表</td></tr><tr><td>new-array/jumbo vAAAA, vBBBB, type@CCCCCCCC</td><td>同 new-array vA,vB,type@CCCC , <br/>只是寄存器值和指令的索引取值返回更大 (android 4.0 新增)</td></tr><tr><td>filled-new-array/jumbo {vCCCC .. vNNNN}, type@BBBBBBBB</td><td>同 filled-new-array/range {vCCCC … vNNNN},type@BBBB , <br/>只是索引取值返回更大 (android 4.0 新增)</td></tr><tr><td>arrayop vAA, vBB, vCC</td><td>对 vBB 寄存器指定的数组元素进行取值和赋值, <br/>vCC 指定数组元素索引, vAA 用来存放读取的或需要设置的数组元素的值, <br/>读取元素使用 aget 类指令, 元素赋值使用 aput 类指令, <br/>根据数组中存储的类型指令后面会紧跟不同的指令后缀, 指令列表有 <br/>( aget , aget-wide , aget-object , <br/>aget-boolean , aget-byte , aget-char , <br/>aget-short , aput , aput-wide , <br/>aput-object , aput-boolean , <br/>aput-byte , aput-char , aput-short )</td></tr></tbody></table><h3 id="异常指令"><a href="#异常指令" class="headerlink" title="异常指令"></a>异常指令</h3>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> delvik </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 网站管理</title>
      <link href="/2019/hexo-website-management.html"/>
      <url>/2019/hexo-website-management.html</url>
      
        <content type="html"><![CDATA[<p>目录请看  <a href="https://calmcenter.club/2019/Complete_works_of_hexo.html">Hexo 搭建博客大全</a></p><p><strong>注意：如果出现图片不显示问题请移步</strong> <a href="https://calmcenter.club/2019/PicNotShow.html">图片不显示问题</a></p><h2 id="本文主要记载"><a href="#本文主要记载" class="headerlink" title="本文主要记载"></a>本文主要记载</h2><ul><li>加入 <code>Coding</code> 服务器</li><li>个人域名</li><li><code>SEO</code>  推广</li></ul><hr><a id="more"></a><p>*<em>重点标注：<code>hexo</code> 根目录配置文件 <code>hexo/_config.yml</code>  下文用 <code>Hexo 配置文件</code> 表示，<code>NexT</code> 样式配置文件 <code>hexo/theme/next/_config.yml</code> 下文用 <code>NexT 配置文件</code> 表示一定要分清，它们都叫 <code>_cpmfig.yml</code> *</em></p><p><strong>本文章写于 <code>2019/5/5</code> 图片内容可能和您现在看的内容不太一样，但是功能大体是不会变的。</strong></p><br><hr><h2 id="加入-Coding-服务器"><a href="#加入-Coding-服务器" class="headerlink" title="加入 Coding 服务器"></a>加入 <code>Coding</code> 服务器</h2><p>这里加入<code>Coding</code> 服务器的作用主要是访问速度，其次就是由于 <code>github</code> 屏蔽百度的爬虫，所以使用 <code>github page</code> 服务的站点的链接无法被抓取，可用  <code>Coding</code>  的 <code>page</code> 服务。</p><ol><li>登录 <a href="https://dev.tencent.com/" target="_blank" rel="noopener">Coding</a></li></ol><p>登录 <a href="https://dev.tencent.com/" target="_blank" rel="noopener">Coding</a> ，并创建项目</p><img src="https://raw.githubusercontent.com/CalmCenter/picGo/master/pictures/20190505114135.png" style="zoom:50%"><ol start="2"><li>个人设置</li></ol><p>首先你需要点击头像，找到个人设置，在个人设置中设置 <strong>密码</strong> 和 <strong>邮箱</strong> 才能设置 <strong>SSH</strong> ，如果你之前设置过 <code>github</code> 的 <code>SSH</code> 你只需要执行以下命令</p><pre><code>clip &lt; ~/.ssh/id_rsa.pub</code></pre><p>然后点击 <code>SSH</code>公钥 设置即可，如果没有设置过 <code>github</code> 请参考 <a href="https://calmcenter.club/2019/Hexo_bash.html#2-3-%E9%85%8D%E7%BD%AE-SSH-%E5%AF%86%E9%92%A5">Hexo 基础搭建 - 配置 SSH 秘钥部分</a></p><ol start="3"><li>验证</li></ol><p>输入以下命令，查看 <code>SSH</code> 配置是否成功</p><pre><code>ssh -T git@git.coding.net</code></pre><ol start="4"><li>添加配置</li></ol><p>在  <code>Hexo 配置文件</code> 中注释掉之前的，添加 <code>repo</code> 中的内容 <code>SSH</code> 路径 <code>,master</code></p><pre><code># Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:  type: git  #repository: git@github.com:CalmCenter/calmcenter.github.io.git  #branch: master  repo:    github: git@github.com:CalmCenter/calmcenter.github.io.git,master    coding: git@git.dev.tencent.com:CalmCenter/calmcenter.coding.me.git,master</code></pre><ol start="5"><li>提交</li></ol><pre><code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code></pre><ol start="6"><li>打开 <code>Coding Pages</code> 服务</li></ol><p><code>头像 -&gt; 我的主页 -&gt; 项目 -&gt; 代码 -&gt; Pages 服务</code> 打钩已阅读服务，点击开启即可</p><p>会告诉你访问地址，打开如果排版不正常，不要慌，可能是子文件目录问题，设置域名后可解决。</p><img src="https://raw.githubusercontent.com/CalmCenter/picGo/master/pictures/20190508105842.png" style="zoom:50%"><br><hr><p>个人域名</p><ol><li>获得域名</li></ol><p>首先你得有你自己的域名，几块钱就好~  <a href="https://cloud.tencent.com/act/domainsales?fromSource=gwzcw.2211770.2211770.2211770&utm_medium=cpc&utm_id=gwzcw.2211770.2211770.2211770" target="_blank" rel="noopener">腾讯云</a> 、<a href="https://wanwang.aliyun.com/domain/yumingheji" target="_blank" rel="noopener">阿里云</a> ，然后需要进行实名认证。完成后就可以添加域名解析地址啦~ </p><ol start="2"><li>添加解析</li></ol><p>这是 <a href="https://cloud.tencent.com/act/domainsales?fromSource=gwzcw.2211770.2211770.2211770&utm_medium=cpc&utm_id=gwzcw.2211770.2211770.2211770" target="_blank" rel="noopener">腾讯云</a> 的域名解析。</p><p><strong>注意：这里域名操作，每次操作完都会有一定缓冲时间，不会立即生效，每次操作完等待 10 分钟左右，再去配置域名</strong> </p><img src="https://raw.githubusercontent.com/CalmCenter/picGo/master/pictures/20190508104813.png" style="zoom:50%"><p>这是添加的解析，因为添加了 <code>coding</code> ，所以有两条，分别将两个访问地址添加到域名解析中，<code>github</code> 用于境外访问，<code>coding</code> 本想着用于境内，但这里必须设置成默认才行。</p><ol start="2"><li><code>github</code> 域名设置</li></ol><p>点击你的博客项目的 <code>Setting</code> -&gt; <code>Options</code> 下滑找到 <code>GitHub Pages</code> </p><img src="https://raw.githubusercontent.com/CalmCenter/picGo/master/pictures/20190508105420.png" style="zoom:50%"><img src="https://raw.githubusercontent.com/CalmCenter/picGo/master/pictures/20190508105344.png" style="zoom:50%"><p>这里会提示你站点发布在什么地方，记得开启 <code>HTTPS</code> 哦。</p><ol start="3"><li><code>Coding</code> 域名设置</li></ol><img src="https://raw.githubusercontent.com/CalmCenter/picGo/master/pictures/20190508105715.png" style="zoom:50%"><p>自定义域名，将申请好的域名添加上去，点击绑定，然后刷新页面，知道 <code>SSL/TLS 安全证书</code> 出现结果，如果错误，请查看解析中 <code>coding</code> 线路类型配置是否是默认，如果是默认还不行，请将境外的 <code>github</code> 先暂停，再去重新绑定。记得开启 <code>HTTPS</code> 哦。</p><p><strong>操作时请留意 个人域名 开头说明的注意事项</strong></p><br><h2 id="SEO-推广"><a href="#SEO-推广" class="headerlink" title="SEO  推广"></a><code>SEO</code>  推广</h2><p>参考自作者 <a href="https://blog.enjoytoshare.club/article/hexo-do-optimization.html#5" target="_blank" rel="noopener">EnjoyToShare</a> </p><h3 id="SEO-是什么"><a href="#SEO-是什么" class="headerlink" title="SEO 是什么"></a><code>SEO</code> 是什么</h3><p>刚搭建完博客，可能你会发现你发表的文章在谷歌或者百度都搜索不到，因为需要进行 <code>SEO</code> 优化的，什么是 <code>SEO</code> ，顾名思义，<code>SEO</code> 即 <code>(Search Engine Optimization)</code> : 汉译为搜索引擎优化，它可以让自己的博文能在谷歌百度上搜索到。</p><h3 id="生成-sitemap"><a href="#生成-sitemap" class="headerlink" title="生成 sitemap"></a>生成 <code>sitemap</code></h3><p><code>sitemap</code> 用于通知搜索引擎网站上有哪些可供抓取的网页，以便搜索引擎可以更加智能地抓取网站。<br>安装 <code>sitemap</code> 站点地图自动生成插件 <code>hexo-generator-sitemap</code> 和 <code>hexo-generator-baidu-sitemap</code> </p><pre><code>npm install hexo-generator-sitemap --save</code></pre><pre><code>npm install hexo-generator-baidu-sitemap --save</code></pre><p>然后修改  <code>Hexo 配置文件</code> ，<strong>添加</strong>如下内容</p><pre><code>sitemap:  path: sitemap.xmlbaidusitemap:  path: baidusitemap.xml</code></pre><p>并<strong>修改</strong> <code>url</code> 为你的域名地址 如 <code>url: https://blog.calmcenter.club/</code> </p><p>然后编译代码</p><pre><code>hexo g</code></pre><p>就会生成在 <code>hexo\public</code> 下生成 <code>sitemap.xml</code> 和 <code>baidusitemap.xml</code> 一个是给谷歌的，一个给是百度的。</p><h3 id="添加协议"><a href="#添加协议" class="headerlink" title="添加协议"></a>添加协议</h3><p>网站通过 <code>Robots协议</code> 告诉搜索引擎哪些页面可以抓取，哪些页面不能抓取。 <code>robots.txt</code> 通常存放于网站根目录 ( <code>public</code> 目录)。由于我们每次 <code>hexo clean</code> 都会清空 <code>public</code> ，着实不方便，我们都知道 <code>source</code> 目录下的文件通过 <code>hexo g</code> 命令会转换成 <code>public</code> 中的文件，所以为了方便起见，我们把 <code>robots.txt</code> 文件放在<code>source</code>目录下，我的 <code>robots.txt</code> 内容为：</p><pre><code>User-agent: *Allow: /Allow: /archives/Allow: /categories/Allow: /tags/Allow: /links/Disallow: /js/Disallow: /css/Disallow: /fonts/Disallow: /vendors/Disallow: /fancybox/Sitemap: https://你的域名/sitemap.xmlSitemap: https://你的域名/baidusitemap.xml</code></pre><p>其中Allow后面的就是你的menu</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 域名 </tag>
            
            <tag> coding </tag>
            
            <tag> seo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 功能样式配置</title>
      <link href="/2019/hexo-functional-style.html"/>
      <url>/2019/hexo-functional-style.html</url>
      
        <content type="html"><![CDATA[<p>目录请看  <a href="https://calmcenter.club/2019/Complete_works_of_hexo.html">Hexo 搭建博客大全</a></p><p><strong>注意：如果出现图片不显示问题请移步</strong> <a href="https://calmcenter.club/2019/PicNotShow.html">图片不显示问题</a></p><h2 id="本文主要记载"><a href="#本文主要记载" class="headerlink" title="本文主要记载"></a>本文主要记载</h2><ul><li><code>NexT</code> 主题设置</li><li>基础样式设置</li><li>图片相关</li><li>打赏、评论、复制功能</li><li><code>DaoVoice</code> 实现在线联系</li><li>文章置顶</li><li>搜索功能</li><li>细节美化</li></ul><pre><code>本文环境是 win10 或 win 7。mac 再执行 npm 时需要在前面添加 sudo本文整理于各大佬文章，文中会给出相应链接，如有侵权，请联系我修改或删除。</code></pre><hr><a id="more"></a><h2 id="功能样式配置"><a href="#功能样式配置" class="headerlink" title="功能样式配置"></a>功能样式配置</h2><h3 id="NexT-主题设置"><a href="#NexT-主题设置" class="headerlink" title="NexT 主题设置"></a><code>NexT</code> 主题设置</h3><p>*<em>重点标注：<code>hexo</code> 根目录配置文件 <code>hexo/_config.yml</code>  下文用 <code>Hexo 配置文件</code> 表示，<code>NexT</code> 样式配置文件 <code>hexo/theme/next/_config.yml</code> 下文用 <code>NexT 配置文件</code> 表示一定要分清，它们都叫 <code>_cpmfig.yml</code> *</em></p><p><a href="https://hexo.io/themes/" target="_blank" rel="noopener">这里有很多主题</a> 这里主要说 <a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener">NexT</a> </p><p>进入 <code>hexo</code> 文件目录 ，执行</p><pre><code>git clone https://github.com/theme-next/hexo-theme-next themes/next</code></pre><p>成功后，在 <code>Hexo 配置文件</code> 找到 <code>theme</code> 字段</p><pre><code>theme: next</code></pre><p>这样 <code>next</code> 样式就设置好了，快打开看看吧  <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a></p><p><strong>注意:如果你是 <code>git</code> 直接 <code>clone</code> 的，会自带 <code>.git</code> 和 <code>.github</code> 文件，需要删掉 <code>.git</code> 和 <code>.github</code> 文件，如果不删在 <a href="https://calmcenter.club/2019/Hexo_code_management.html">Hexo 管理代码</a> 一文中会出现 <code>them/next</code> 里的文件提交不上去的问题</strong></p><h3 id="设置语言、标题等"><a href="#设置语言、标题等" class="headerlink" title="设置语言、标题等"></a>设置语言、标题等</h3><p>在  <code>Hexo 配置文件</code> 找到 <code>Site</code> 字段 </p><table><thead><tr><th align="left">字段</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">title</td><td align="left">网站标题</td></tr><tr><td align="left">subtitle</td><td align="left">副标题</td></tr><tr><td align="left">description</td><td align="left">描述</td></tr><tr><td align="left">author</td><td align="left">作者(您的名字)</td></tr><tr><td align="left">language</td><td align="left">语言 (zh-CN，en等)</td></tr><tr><td align="left">timezone</td><td align="left">网站时区，默认使用您电脑的时区</td></tr></tbody></table><h3 id="NexT-样式"><a href="#NexT-样式" class="headerlink" title="NexT 样式"></a><code>NexT</code> 样式</h3><p>在 <code>Hexo 配置文件</code> 找到 <code>Schemes</code> 字段，这里有四种样式</p><pre><code># Schemes#scheme: Muse#scheme: Mist#scheme: Piscesscheme: Gemini</code></pre><h3 id="图片上传-PicGo-GitHub-图床"><a href="#图片上传-PicGo-GitHub-图床" class="headerlink" title="图片上传 PicGo + GitHub 图床"></a>图片上传 <code>PicGo</code> + <code>GitHub</code> 图床</h3><p>参考自作者 <a href="https://blog.enjoytoshare.club/article/hexo-do-optimization-picture.html" target="_blank" rel="noopener">EnjoyToShare 《PicGo+GitHub图床，让Markdown飞起》</a>  </p><ol><li>首先下载工具</li></ol><p>下载地址 : <a href="https://github.com/Molunerfinn/PicGo/releases" target="_blank" rel="noopener">PicGo</a> </p><img src="https://raw.githubusercontent.com/CalmCenter/picGo/master/picturespicgo_down.png" style="zoom:50%"><ol start="2"><li>登录 <code>GitHub</code> </li></ol><p>创建 <code>Repository</code> 之前都讲过怎么创建，名字可以取成 <code>PicGo</code> 类似的名字，主要用于存放图片。</p><ol start="3"><li>生成 Token  </li></ol><p>点击头像 <code>Settings -&gt; Developer settings -&gt; Personal access tokens</code> 点击  <code>Generate new token</code>  </p><img src="https://raw.githubusercontent.com/CalmCenter/picGo/master/picturesnew_token.png" style="zoom:80%"><img src="https://raw.githubusercontent.com/CalmCenter/picGo/master/picturesaccess_tokens.png" style="zoom:30%"><p>点击最下面的  <code>Generate token</code> ，会出现 <code>token</code> ，这个 <code>token</code> 只出现一次，所以要保存一下</p><img src="https://raw.githubusercontent.com/CalmCenter/picGo/master/picturesaccess_token.png" style="zoom:50%"><ol start="4"><li>配置 <code>PicGo</code> 客户端</li></ol><p>打开 <code>PicGo</code> ，输入相关信息</p><ul><li>仓库名 即你的仓库名</li><li>分支名 默认 master</li><li>Token 就是刚刚复制的那一串字符</li><li>存储路径 这个可以填也可以不填，填了的话图片就上传到这个文件夹，比如 <code>picture/</code> 图中少一个 <code>/</code></li><li>自定义域名 这个要改一下 格式： <code>https://raw.githubusercontent.com/[仓库名]/master</code> </li></ul><img src="https://raw.githubusercontent.com/CalmCenter/picGo/master/picturespic_go_token.png" style="zoom:50%"><p>然后点确定就OK了，不妨试试。</p><p>还有一个方便的操作就是 修改上传快捷键 ，快捷键直接上传，跳过拖入上传区</p><img src="https://raw.githubusercontent.com/CalmCenter/picGo/master/pictures/20190426111300.png" style="zoom:50%"><h3 id="图片全屏查看"><a href="#图片全屏查看" class="headerlink" title="图片全屏查看"></a>图片全屏查看</h3><p>首先进入 <code>hexo/themes/next/source/lib</code> 目录，下载插件</p><pre><code>git clone https://github.com/theme-next/theme-next-fancybox3 fancybox</code></pre><p>然后更改 <code>NexT 配置文件</code> </p><pre><code>fancybox: true</code></pre><p>完成 ~ </p><p><strong>注意:如果你是 <code>git</code> 直接 <code>clone</code> 的，会自带 <code>.git</code> 和 <code>.github</code> 文件，需要删掉 <code>.git</code> 和 <code>.github</code> 文件，如果不删在 <a href="https://calmcenter.club/2019/Hexo_code_management.html">Hexo 管理代码</a> 一文中会出现 <code>them/next/source/lib/fancybox</code> 里的文件提交不上去的问题</strong></p><h3 id="打赏功能"><a href="#打赏功能" class="headerlink" title="打赏功能"></a>打赏功能</h3><p>参考自作者 <a href="https://blog.enjoytoshare.club/article/hexo-do-donate.html" target="_blank" rel="noopener">EnjoyToShare 《Hexo的NexT主题打赏功能》</a>  </p><p>准备好收款二维码，放入 <code>hexo/themes/next/source/images</code> ，打开 <code>NexT 配置文件</code> </p><pre><code>reward_settings:  enable: true  animation: false  comment: 分享不易，可否赏杯咖啡钱reward:  wechatpay: /images/wechatpay.png  alipay: /images/alipay.png  #bitcoin: /images/bitcoin.png</code></pre><h3 id="评论功能"><a href="#评论功能" class="headerlink" title="评论功能"></a>评论功能</h3><p>参考自作者 <a href="https://blog.enjoytoshare.club/article/hexo-do-gitalk.html" target="_blank" rel="noopener">EnjoyToShare 《Hexo NexT 加入评论功能gitalk》</a>  </p><p><code>Gitalk</code> :</p><ul><li>一个基于 <code>Github Issue</code> 和 <code>Preact</code> 开发的评论插件</li><li>详情 <code>Demo</code> 可见:  <a href="https://gitalk.github.io/" target="_blank" rel="noopener">https://gitalk.github.io/</a></li></ul><p>增加评论区</p><ul><li>注册 <code>OAuth Application</code></li><li>在 <code>GitHub</code> 上注册新应用, 链接:  <a href="https://github.com/settings/applications/new" target="_blank" rel="noopener">https://github.com/settings/applications/new</a> </li></ul><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">Application name</td><td align="left">应用名称, 可以任意填入</td></tr><tr><td align="left">Homepage URL</td><td align="left">网站URL, 注意用https://开头</td></tr><tr><td align="left">Application description</td><td align="left">应用描述, 可以任意填入</td></tr><tr><td align="left">Authorization callback URL</td><td align="left">网站URL, 注意用https://开头</td></tr></tbody></table><p>注册后记录 <code>Client ID</code> 和 <code>Client Secret</code> , 后续要使用到。</p><p>打开 <code>NexT 配置文件</code> ， <strong>根据自己信息</strong> 进行一下修改，</p><pre><code>gitalk:  enable: true  github_id: CalmCenter  repo: calmcenter.github.io  client_id: ****  client_secret: ****  admin_user: CalmCenter    distraction_free_mode: true   language:</code></pre><p> 集成过程中出现的错误 <a href="https://liujunzhou.top/2018/8/10/gitalk-error/#%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B" target="_blank" rel="noopener">Junzhou Liu</a> 这里给出了很多，但是在我集成是发现有的 <code>NexT</code> 已经修正，所以这里说几点需要注意的地方。</p><ul><li>你的评论仓库或者 <code>GitHub Page</code> 仓库必须是 <code>public</code> ， <code>NexT 配置文件</code> 的 <code>reop</code> 指定的仓库名称也必须是 <code>public</code> ，否者可能出现 <code>404</code> 的错误</li><li><code>NexT</code> 中的字段配置 和 <code>Gitalk</code> 有两个不一样，需要用 <code>NexT</code> 指定的，否者会出现 <code>Erroe Not Found</code> </li></ul><p>如果错误修改后没反应，试一下</p><pre><code>hexo clean</code></pre><p>重新编译运行。</p><p>成功后会提示你未找到相关 <code>issues</code>  ，需要你登录</p><p><img src="https://raw.githubusercontent.com/CalmCenter/picGo/master/pictures/20190426155441.png" alt=""></p><p><strong>如果有自己的域名记得把 Authorization callback URL 设置成自己的 域名地址</strong> <code>Authorization callback URL</code> 在 <a href="https://github.com/settings/developers" target="_blank" rel="noopener">github setting</a> 点击自己绑定的进去修改</p><p><strong>2019/5/10 踩坑记录，文章的文件名，中文会有问题，导致一直跳转首页并登陆不上，title  可以是中文</strong></p><h3 id="代码块复制功能"><a href="#代码块复制功能" class="headerlink" title="代码块复制功能"></a>代码块复制功能</h3><p>在 <code>NexT 配置文件</code> 中</p><pre><code>codeblock:  border_radius:  copy_button:    enable: true    show_result: true    style:</code></pre><p><code>NexT</code> 随着版本的升级，省去了很多操作，基本都剩开关的设置了</p><h3 id="DaoVoice-实现在线联系"><a href="#DaoVoice-实现在线联系" class="headerlink" title="DaoVoice 实现在线联系"></a><code>DaoVoice</code> 实现在线联系</h3><ol><li>注册登录 <code>DaoVoice</code></li></ol><p><a href="http://www.daovoice.io/" target="_blank" rel="noopener">DaoVoice</a> 点击进行登录注册，邀请码</p><pre><code>c1f73bd5</code></pre><p>登录成功后，你可能是这个目录</p><img src="https://raw.githubusercontent.com/CalmCenter/picGo/master/pictures/20190428141105.png" style="zoom:50%"><p>这样的话你需要关掉这个页面，重新进入 <a href="http://www.daovoice.io/" target="_blank" rel="noopener">DaoVoice</a> 点击登录，如果最后看到是这个目录</p><img src="https://raw.githubusercontent.com/CalmCenter/picGo/master/pictures/20190428141212.png" style="zoom:50%"><p>那就可以继续下面的 ~ </p><ol start="2"><li>集成 </li></ol><p>找到你的 <code>app_id</code></p><img src="https://raw.githubusercontent.com/CalmCenter/picGo/master/pictures/20190428141938.png" style="zoom:30%"><p>并将 <code>1</code> 和 <code>2</code> 的代码 粘贴到 <code>themes/next/layout/_partials/head.swig</code> </p><pre><code>{% if theme.daovoice %}<script>(function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/你的appid.js","daovoice")</script>daovoice('init', {  app_id: "你的appid"});daovoice('update');{% endif %}</code></pre><p><strong>有两处需要填写你的 <code>appid</code> 并且要加 <code>if</code> 开始和结束代码</strong></p><p>然后再  <code>NexT 配置文件</code> 中添加</p><pre><code>daovoice: truedaovoice_app_id: 你的appid</code></pre><p>编译并运行 <code>Hexo</code> </p><pre><code>hexo g &amp;&amp; hexo s</code></pre><p>会发现 <code>DaoVoice</code> 官网会提示</p><img src="https://raw.githubusercontent.com/CalmCenter/picGo/master/pictures/20190428143112.png" style="zoom:30%"><ol start="3"><li>绑定微信</li></ol><p>点击右上角头像，然后点击绑定微信</p><p><img src="https://raw.githubusercontent.com/CalmCenter/picGo/master/pictures/20190428143854.png" alt=""></p><p><img src="https://raw.githubusercontent.com/CalmCenter/picGo/master/pictures/20190428143916.png" alt=""></p><p>这样，可以同时在 <code>DaoVoice</code> 网页的对话页面，和微信小程序 <code>DaoVoice</code> 同时回复~ </p><h3 id="文章置顶"><a href="#文章置顶" class="headerlink" title="文章置顶"></a>文章置顶</h3><ol><li>将 <code>node_modules/hexo-generator-index/lib/generator.js</code> 文件内的内容替换为</li></ol><pre><code>&#39;use strict&#39;;var pagination = require(&#39;hexo-pagination&#39;);module.exports = function(locals){  var config = this.config;  var posts = locals.posts;    posts.data = posts.data.sort(function(a, b) {        if(a.top &amp;&amp; b.top) { // 两篇文章top都有定义            if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排            else return b.top - a.top; // 否则按照top值降序排        }        else if(a.top &amp;&amp; !b.top) { // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233）            return -1;        }        else if(!a.top &amp;&amp; b.top) {            return 1;        }        else return b.date - a.date; // 都没定义按照文章日期降序排    });  var paginationDir = config.pagination_dir || &#39;page&#39;;  return pagination(&#39;&#39;, posts, {    perPage: config.index_generator.per_page,    layout: [&#39;index&#39;, &#39;archive&#39;],    format: paginationDir + &#39;/%d/&#39;,    data: {      __index: true    }  });};</code></pre><ol start="2"><li>在文章头部添加 <code>top</code> 值</li></ol><pre><code>title: Hexo 搭建博客大全date: 2019-04-18 17:32:22categories: Hexotags: [Hexo, NexT, 博客]top: 100</code></pre><h3 id="搜索功能"><a href="#搜索功能" class="headerlink" title="搜索功能"></a>搜索功能</h3><ol><li>安装插件</li></ol><pre><code>npm install hexo-generator-searchdb --save</code></pre><ol start="2"><li>在 <code>Hexo 配置文件</code> 中添加 </li></ol><pre><code># 本地搜索search:  path: search.xml  field: post  format: html  limit: 10000</code></pre><ol start="3"><li>在 <code>NexT 配置文件</code> 启动搜索功能</li></ol><pre><code>local_search:  enable: true  trigger: auto  top_n_per_article: 1  unescape: false</code></pre><ol start="4"><li>完成，清理缓存编译运行</li></ol><pre><code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</code></pre><h3 id="隐藏特定文章"><a href="#隐藏特定文章" class="headerlink" title="隐藏特定文章"></a>隐藏特定文章</h3><p>比如说没写完的 ~ </p><p>首先修改 <code>/themes/next/layout/index.swig</code> 文件，把</p><pre><code>   {% for post in page.posts %}     {{ post_template.render(post, true) }}   {% endfor %}</code></pre><p>替换成</p><pre><code>   {% for post in page.posts %}      {% set hide = false %}      {% if theme.hide.hide_post %}        {% if post.hide %}          {% set hide = true %}        {% endif %}      {% endif %}      {% if !hide %}        {{ post_template.render(post, true) }}      {% endif %}    {% endfor %}</code></pre><p>在 <code>NexT 配置文件</code>  添加代码</p><pre><code># Hide single posthide:  hide_post: true</code></pre><h3 id="细节美化"><a href="#细节美化" class="headerlink" title="细节美化"></a>细节美化</h3><h4 id="●-头像"><a href="#●-头像" class="headerlink" title="● 头像"></a>● 头像</h4><p>在<code>NexT 配置文件</code> 中，找到 <code>avatar</code> 字段</p><table><thead><tr><th>字段</th><th>作用</th></tr></thead><tbody><tr><td>url</td><td>图片相对位置(/image/xxx.png)图片保存在  \hexo\themes\next\source\images 文件下</td></tr><tr><td>rounded</td><td>是否启用圆角</td></tr><tr><td>opacity</td><td>透明度</td></tr><tr><td>rotated</td><td>旋转动画</td></tr></tbody></table><h4 id="●-回到顶部"><a href="#●-回到顶部" class="headerlink" title="● 回到顶部"></a>● 回到顶部</h4><p>打开 <code>NexT 配置文件</code> 搜索 <code>back2top</code>  </p><pre><code>back2top:  enable: true  # 回到侧边栏顶部.  sidebar: true  # 滚动%标签.  scrollpercent: true</code></pre><h4 id="●-页面底部优化"><a href="#●-页面底部优化" class="headerlink" title="● 页面底部优化"></a>● 页面底部优化</h4><ul><li>跳动的心</li></ul><p>参考自作者 <a href="https://11.tt/posts/2018/set-up-hexo-with-coding-and-github/" target="_blank" rel="noopener">十一種情緒的堆棧</a> 在这篇文章 1/2 处左右</p><p>效果就在本页面底部 ~ ，首先先去 <a href="https://fontawesome.com/v4.7.0/icons/" target="_blank" rel="noopener">The Icons</a> 选择一张图片，例如搜索 <code>heartbeat</code> ，点击进去将图片代码 <code>fa-heartbeat</code> 复制下来，打开<code>NexT 配置文件</code> ，搜索 <code>footer</code> 关键字</p><pre><code>footer:  icon:    name: fas fa-heartbeat    animated: true    color: &quot;#ff0000&quot;</code></pre><p>需要将复制的图片代码粘贴到 <code>name</code> 字段，并且前面加上 fas ，如果需要动画的话，将 <code>animated</code> 设置为 <code>true</code> ，并将 <code>color</code> 修改为 <code>#ff0000</code> 。就和我底部效果一样了啦。</p><ul><li>访问统计</li></ul><p>还是在 <code>NexT 配置文件</code> ，搜索 <code>busuanzi_count</code> 字段。</p><pre><code>busuanzi_count:  enable: true  total_visitors: true  total_visitors_icon: user  total_views: true  total_views_icon: eye  post_views: true  post_views_icon: eye</code></pre><p>将 <code>enable</code> 设置为 <code>true</code> 就有和我底部一样的 访问统计 功能了</p><p><img src="https://raw.githubusercontent.com/CalmCenter/picGo/master/picturesvisit.png" alt=""></p><p>统计这块还可以添加一个字数和阅读时长统计，在<code>hexo</code> 根目录配置文件 <code>hexo/_config.yml</code> 搜索 <code>symbols_count_time</code> 如果没有则添加</p><pre><code>symbols_count_time: symbols: true  time: true  total_symbols: true  total_time: true</code></pre><p>在 <code>NexT 配置文件</code> 搜索 <code>symbols_count_time</code> </p><pre><code>symbols_count_time:  separated_meta: true  item_text_post: true  item_text_total: false  awl: 4  wpm: 275</code></pre><p><img src="https://raw.githubusercontent.com/CalmCenter/picGo/master/picturesnumber.png" alt=""></p><p><strong>注: 格式很重要</strong> </p><h4 id="●-圆角布局"><a href="#●-圆角布局" class="headerlink" title="● 圆角布局"></a>● 圆角布局</h4><p>参考自作者 <a href="https://blog.enjoytoshare.club/article/hexo-do-optimization.html" target="_blank" rel="noopener">EnjoyToShare</a> 在这篇文章 3.12，这篇里边还有好多好看的样式 ~</p><p>在 <code>/themes/next/source/css/_variables</code> 中的 <code>Gemini.styl</code> 文件添加</p><pre><code>// 修改主题页面布局为圆角$border-radius-inner            = 15px 15px 15px 15px;$border-radius                  = 15px;</code></pre><h4 id="●-文章标签、分类"><a href="#●-文章标签、分类" class="headerlink" title="● 文章标签、分类"></a>● 文章标签、分类</h4><p>我们在用 <code>hexo new post</code> 创建文件时</p><pre><code>hexo new post &quot;name&quot;</code></pre><p><code>hexo</code> 自动为我们的文章头部生成了如下的内容</p><pre><code>title: 标题date: 2019-04-18 17:32:22</code></pre><ul><li>首先添加分类</li></ul><p>在 <code>data</code> 下方添加 <code>categories</code> </p><pre><code>title: 标题date: 2019-04-18 17:32:22</code></pre><pre><code>categories: Hexo</code></pre><p><strong>注意：英文冒号，还有一个空格</strong></p><p>这样分类就添加上了，还需要给分类一个跳转页，创建一个 <code>categories.md</code> 用于跳转</p><pre><code>hexo new page categories</code></pre><p>会提示我们输入目录 <code>/source/categories/index.md</code>  ，打开这个 <code>index.md</code> ，加入 <code>type</code> 这个页面用于做什么的，<code>comment</code> 是否开启评论，前提是你有评论功能的话。</p><pre><code>title: categoriesdate: 2019-04-25 14:53:31</code></pre><pre><code>type: categoriescomments: false</code></pre><p>这样分类就设置好了，检查一下 <code>Hexo 配置文件</code> ，搜索  <code>category_dir</code> 字段 <code>category_dir: categories</code> 这里已经设置了分类夹的名称，如果之前创建的文件夹完成和这个不一样，需要统一才行。</p><ul><li>添加标签</li></ul><p>同样在 <code>Hexo 配置文件</code> 搜索，<code>tag_dir</code> 可以知道 <code>tag</code> 设置好的文件夹名称，<code>tag_dir: tags</code>  ，我们可以在 <code>categories</code> 下添加 <code>tags</code> 来添加标签。</p><pre><code>tags: [Hexo, NexT, 博客]</code></pre><p>然后添加跳转页面</p><pre><code>hexo new page tags</code></pre><p>创建完成后，为 <code>tags/index.md</code> 添加内容 </p><pre><code>title: categoriesdate: 2019-04-25 15:34:07</code></pre><pre><code>type: tagscomments: false</code></pre><p>标签比分类多一步，我们需要安装一个插件</p><pre><code>npm install hexo-generator-tag --save</code></pre><p>这样 <code>hexo g &amp;&amp; hexo s</code> 编译并运行，本地就可以看到了，标签在文章底部，发现它是 <code># xxx</code> 很难看，修改的 <code>#</code> 需要找到 <code>/themes/next/layout/_macro/post.swig</code> ，搜索 </p><pre><code>rel=&quot;tag&quot;&gt;#</code></pre><p>将 <code>#</code> 换成</p><pre><code>&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;</code></pre><p>这里的 <code>fa-tag</code> 也是在 <a href="https://fontawesome.com/v4.7.0/icons/" target="_blank" rel="noopener">The Icons</a> 中的图片。</p><ul><li>将标签、分类添加至做出菜单栏</li></ul><p>打开 <code>NexT 配置文件</code>   搜索 <code>menu</code> </p><pre><code>menu:  home: / || home  #about: /about/ || user  tags: /tags/ || tags  categories: /categories/ || th  archives: /archives/ || archive  #schedule: /schedule/ || calendar  #sitemap: /sitemap.xml || sitemap  #commonweal: /404/ || heartbeat</code></pre><p>将 <code>tags</code> 和 <code>categories</code> 打开，完成 ~ </p><h4 id="●-强调颜色"><a href="#●-强调颜色" class="headerlink" title="● 强调颜色"></a>● 强调颜色</h4><p>参考自作者 <a href="https://www.jianshu.com/p/f054333ac9e6" target="_blank" rel="noopener">Moorez</a> </p><ul><li>‘’ 内容样式的修改</li></ul><p>打开 <code>/hemes/next/source/css/_custom/custom.styl</code> ，在里面加入</p><pre><code>// Custom styles.code {    color: #ff7600;    background: #fbf7f8;    margin: 2px;}// 大代码块的自定义样式.highlight, pre {    margin: 5px 0;    padding: 5px;    border-radius: 3px;}.highlight, code, pre {    border: 1px solid #d6d6d6;}</code></pre><ul><li>链接样式修改</li></ul><p>修改文件 <code>/themes/next/source/css/_common/components/post/post.styl</code>，在末尾添加如下css样式</p><pre><code>// 文章内链接文本样式.post-body p a{  color: #0593d3;  border-bottom: none;  border-bottom: 1px solid #0593d3;  &amp;:hover {    color: #fc6423;    border-bottom: none;    border-bottom: 1px solid #fc6423;  }}</code></pre><p>设置网站图标</p><h4 id="●-设置网站图标"><a href="#●-设置网站图标" class="headerlink" title="● 设置网站图标"></a>● 设置网站图标</h4><p>参考自作者 <a href="https://www.jianshu.com/p/f054333ac9e6" target="_blank" rel="noopener">Moorez</a> </p><p>首先找一张喜欢的图片，可以在 <a href="http://www.easyicon.net/" target="_blank" rel="noopener">EasyIcon</a> 中或其他任意地方，分别下载 <code>32px</code> 和 <code>16px</code> 两张，然后放到 <code>/themes/next/source/images</code> 里，然后修改 <code>NexT 配置文件</code>  </p><pre><code>favicon:  small: /images/c_16.png  medium: /images/c_32.png  apple_touch_icon: /images/apple-touch-icon-next.png  safari_pinned_tab: /images/logo.svg</code></pre><img src="https://raw.githubusercontent.com/CalmCenter/picGo/master/picturesblog_title.png" style="zoom:100%"><h4 id="●-主页文章添加边框阴影效果"><a href="#●-主页文章添加边框阴影效果" class="headerlink" title="●  主页文章添加边框阴影效果"></a>●  主页文章添加边框阴影效果</h4><p>在 <code>theme/next/source/css/_custom/custom.styl</code>  文件下添加</p><pre><code>// 主页文章添加阴影效果.posts-expand {     .post {        margin-top: 30px;        margin-bottom: 30px;    //border-radius: 15px;        -webkit-box-shadow: 5px 5px 20px rgba(119,118,118,.6);        -moz-box-shadow: 5px 5px 20px rgba(119,118,118,.6);    }}</code></pre><p>很多博客上都没有 <code>posts-expand</code> 这一层，如果没有这一层，你的归档页面将会变得很丑~如果你用了之前的圆角布局，需要把 <code>border-radius: 15px;</code> 的注释删掉。</p><p>应用主要作用实在 <code>-webkit-box-shadow</code> 和 <code>-moz-box-shadow</code> 属性上。</p><p>基于主流浏览器上使用 <code>box-shadow</code> 属性时，我们需要将属性的名称写成 <code>-webkit-box-shadow</code> 的形式。Firefox浏览器则需要写成 <code>-moz-box-shadow</code> 的形式。</p><p>四个值分别为 <code>X轴</code>与 <code>Y轴</code> 移动 、<code>阴影值大小</code> 、<code>阴影颜色rgba</code></p><hr><h2 id="更多样式修改-💦💦"><a href="#更多样式修改-💦💦" class="headerlink" title="更多样式修改 💦💦"></a>更多样式修改 💦💦</h2><p><a href="https://bestzuo.cn/posts/1689445187.html" target="_blank" rel="noopener">Sanarous Hexo博客界面美化2.0</a></p><p><a href="https://leafjame.github.io/posts/2114475547.html" target="_blank" rel="noopener">Leaface Hexo NexT主题美化2.0</a></p><p><a href="https://walesexcitedmei.github.io/2018/08/30/HEXO-NexT-%E4%B8%BB%E9%A2%98%E6%8F%90%E9%AB%98%E5%8D%9A%E5%AE%A2%E9%A2%9C%E5%80%BC/" target="_blank" rel="noopener">[HEXO] NexT 主题提高博客颜值</a></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> git </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Live2D 看板娘</title>
      <link href="/2019/hexo-live2d.html"/>
      <url>/2019/hexo-live2d.html</url>
      
        <content type="html"><![CDATA[<p>目录请看  <a href="https://calmcenter.club/2019/Complete_works_of_hexo.html">Hexo 搭建博客大全</a></p><p><strong>注意：如果出现图片不显示问题请移步</strong> <a href="https://calmcenter.club/2019/PicNotShow.html">图片不显示问题</a></p><h2 id="本文主要记载"><a href="#本文主要记载" class="headerlink" title="本文主要记载"></a>本文主要记载</h2><ul><li>使用 <code>hexo-helper-live2d</code> 完成看板娘</li><li>自定义看板娘(右下角那个~)<ul><li>运行、接入 <code>Demo</code></li><li>更换、修改模型</li></ul></li></ul><hr><a id="more"></a><h2 id="使用-hexo-helper-live2d-完成看板娘"><a href="#使用-hexo-helper-live2d-完成看板娘" class="headerlink" title="使用 hexo-helper-live2d 完成看板娘"></a>使用 <code>hexo-helper-live2d</code> 完成看板娘</h2><p>我的 <code>Live2D</code> 版本是 <code>3.1.1</code></p><p>首先安装配置 hexo-helper-live2d，在 <code>hexo</code> 根目录下执行</p><pre><code>npm install hexo-helper-live2d --save</code></pre><p>插件就安装完成了，你可一下选一个 <a href="https://huaji8.top/post/live2d-plugin-2.0/" target="_blank" rel="noopener">模型</a> 这个给出了展示效果，但是不全， <a href="https://github.com/xiazeyu/live2d-widget-models" target="_blank" rel="noopener">更多模型</a> 这个没有展示效果，比之前的全一点，可以自己试试效果 ~</p><p>在模型中记住自己选择模型的名字 <code>live2d-widget-model-你选中的模型名字</code> ，然后进行安装</p><pre><code>npm install live2d-widget-model-wanko --save</code></pre><p>然后再 <code>Hexo 配置文件</code> 中，添加如下代码，<strong>代码格式很重要！！！</strong> 有时候复制进去没有缩进，效果是出不来的。</p><pre class=" language-yml"><code class="language-yml">live2d:  enable: true  scriptFrom: local  pluginRootPath: live2dw/  pluginJsPath: lib/  pluginModelPath: assets/  tagMode: false  debug: false  model:    use: live2d-widget-model-wanko  display:    position: left    width: 150    height: 300  mobile:    show: true  react:    opacity: 0.7</code></pre><p>这样一只可爱的小白狗就出现了。</p><p>如果要加载自定义模型，需要在根目录新建文件夹 <code>live2d_models</code> 下，再新建一个文件夹 <code>kesshouban （此处自定义）</code> 然后将资源文件放入 <code>kesshouban</code> 内 。然后修改 <code>Hexo 配置文件</code> ，将 <code>model.use</code> 写成 <code>kesshouban</code> 。</p><h2 id="自定义看板娘"><a href="#自定义看板娘" class="headerlink" title="自定义看板娘"></a>自定义看板娘</h2><p>首先感谢 <a href="https://haokan.baidu.com/v?pd=wisenatural&vid=11405187949707723550" target="_blank" rel="noopener">大佬</a> 提供的视屏教程，清晰易懂。</p><p>感谢 <a href="https://github.com/galnetwen" target="_blank" rel="noopener">galnetwen</a> 提供的代码。</p><h3 id="1-运行-Demo"><a href="#1-运行-Demo" class="headerlink" title="1. 运行 Demo"></a>1. 运行 <code>Demo</code></h3><p>首先你需要将 <a href="https://github.com/galnetwen/Live2D" target="_blank" rel="noopener">代码</a> 下载下来</p><p>解压代码并将 <code>Live2D-master</code> 里的内容 <code>live2d</code> 和 <code>demo.html</code> ，解压到 <code>hexo</code> 根目录的 <code>public</code> 的文件夹下。并运行且进入本地访问</p><pre><code>hexo s</code></pre><pre><code>http://localhost:4000/demo.html</code></pre><p>如果出现 <a href="https://play.google.com/store/apps/details?id=com.sinsiroad.potionmaker&hl=zh_CN" target="_blank" rel="noopener">药水制作师</a> 里的模型，就可以啦，如果出不来，证明你路径有问题，请检查路径， <code>live2d</code> 和 <code>demo.html</code> 文件在 <code>public</code> 文件夹下。</p><h3 id="2-接入-Demo"><a href="#2-接入-Demo" class="headerlink" title="2. 接入 Demo"></a>2. 接入 <code>Demo</code></h3><p>将 <code>live2d</code> 文件夹剪切到 <code>hexo/themes/next/source</code> , 文件夹内应该有三个文件夹 <code>css js model</code> 和一个文件 <code>message.json</code> 。</p><p>然后将 <code>demo.html</code> 中的代码整理出来</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/live2d/css/live2d.css<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>landlord<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>message<span class="token punctuation">"</span></span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">opacity</span><span class="token punctuation">:</span><span class="token number">0</span></span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>canvas</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>live2d<span class="token punctuation">"</span></span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>280<span class="token punctuation">"</span></span> <span class="token attr-name">height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>250<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>live2d<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>canvas</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>hide-button<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>隐藏<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://cdn.bootcss.com/jquery/2.2.4/jquery.min.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript">  <span class="token keyword">var</span> message_Path <span class="token operator">=</span> <span class="token string">'/live2d/'</span>  <span class="token keyword">var</span> home_Path <span class="token operator">=</span> <span class="token string">'https://calmcenter.club/'</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/live2d/js/live2d.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/live2d/js/message.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript">  <span class="token function">loadlive2d</span><span class="token punctuation">(</span><span class="token string">"live2d"</span><span class="token punctuation">,</span> <span class="token string">"/live2d/model/tia/model.json"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><p>粘贴到 <code>/theme/next/layout/layout.swig</code> 的 <code>&lt;footer&gt;</code> 标签下</p><img src="https://raw.githubusercontent.com/CalmCenter/picGo/master/pictures/20190509151030.png" style="zoom:50%"><p>执行</p><pre><code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</code></pre><p>看板娘就到我们的博客上来啦~</p><h3 id="3-更换模型"><a href="#3-更换模型" class="headerlink" title="3. 更换模型"></a>3. 更换模型</h3><p>感谢 <a href="https://imjad.cn/" target="_blank" rel="noopener">猫与向日葵</a> 提供血小板模型 <a href="https://cdn.imjad.cn/usr/uploads/kesshouban_v2.7z" target="_blank" rel="noopener">下载地址</a></p><p>在 <code>hexo/next/source/live2d/model</code> 中新建一个文件夹，将压缩包里面的内容，也就是模型放到里面，然后修改 <code>model.json</code> </p><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>        <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"Live2D Model Setting"</span><span class="token punctuation">,</span>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"model"</span><span class="token punctuation">,</span>    <span class="token property">"version"</span><span class="token operator">:</span><span class="token string">"1.0.0"</span><span class="token punctuation">,</span>    <span class="token property">"model"</span><span class="token operator">:</span> <span class="token string">"model.moc"</span><span class="token punctuation">,</span>    <span class="token property">"textures"</span><span class="token operator">:</span> <span class="token punctuation">[</span>      <span class="token string">"model.2048/texture_00.png"</span>    <span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token property">"layout"</span><span class="token operator">:</span><span class="token punctuation">{</span>      <span class="token property">"center_x"</span><span class="token operator">:</span><span class="token number">0.0</span><span class="token punctuation">,</span>      <span class="token property">"center_y"</span><span class="token operator">:</span><span class="token number">0.05</span><span class="token punctuation">,</span>      <span class="token property">"width"</span><span class="token operator">:</span><span class="token number">1.8</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token property">"hit_areas_custom"</span><span class="token operator">:</span><span class="token punctuation">{</span>      <span class="token property">"head_x"</span><span class="token operator">:</span><span class="token punctuation">[</span>-<span class="token number">0.35</span><span class="token punctuation">,</span> <span class="token number">0.6</span><span class="token punctuation">]</span><span class="token punctuation">,</span>      <span class="token property">"head_y"</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token number">0.19</span><span class="token punctuation">,</span> -<span class="token number">0.2</span><span class="token punctuation">]</span><span class="token punctuation">,</span>      <span class="token property">"body_x"</span><span class="token operator">:</span><span class="token punctuation">[</span>-<span class="token number">0.3</span><span class="token punctuation">,</span> -<span class="token number">0.25</span><span class="token punctuation">]</span><span class="token punctuation">,</span>      <span class="token property">"body_y"</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token number">0.3</span><span class="token punctuation">,</span> -<span class="token number">0.9</span><span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token property">"motions"</span><span class="token operator">:</span><span class="token punctuation">{</span>      <span class="token property">"idle"</span><span class="token operator">:</span><span class="token punctuation">[</span>        <span class="token punctuation">{</span><span class="token property">"file"</span><span class="token operator">:</span><span class="token string">"motions/Idle.mtn"</span><span class="token punctuation">}</span>      <span class="token punctuation">]</span><span class="token punctuation">,</span>      <span class="token property">"sleepy"</span><span class="token operator">:</span><span class="token punctuation">[</span>          <span class="token punctuation">{</span><span class="token property">"file"</span><span class="token operator">:</span><span class="token string">"motions/Nemui.mtn"</span><span class="token punctuation">}</span>      <span class="token punctuation">]</span><span class="token punctuation">,</span>      <span class="token property">"flick_head"</span><span class="token operator">:</span><span class="token punctuation">[</span>          <span class="token punctuation">{</span><span class="token property">"file"</span><span class="token operator">:</span><span class="token string">"motions/Anone_Synced.mtn"</span><span class="token punctuation">}</span>      <span class="token punctuation">]</span><span class="token punctuation">,</span>      <span class="token property">"tap_body"</span><span class="token operator">:</span><span class="token punctuation">[</span>          <span class="token punctuation">{</span><span class="token property">"file"</span><span class="token operator">:</span><span class="token string">"motions/Dance.mtn"</span><span class="token punctuation">}</span>      <span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>最终成这样，一个标点都不能错 ！主要是 <code>layout(用于移动模型位置)</code> 和 <code>hit_areas_custom(用于声明点击事件范围)</code> </p><p>值的算法很简单(自己一点一点试的 = =)，以父布局中心为原点，做直角坐标系~ </p><p>这里感谢 <a href="https://www.jbblogs.cn/" target="_blank" rel="noopener">jacob</a> 与我一起讨论相关内容</p><p>然后将  <code>/theme/next/layout/layout.swig</code> 的 <code>&lt;footer&gt;</code> 添加的那句话</p><pre class=" language-css"><code class="language-css">&lt;script type=<span class="token string">"text/javascript"</span>>    loadlive<span class="token number">2</span><span class="token function">d</span><span class="token punctuation">(</span><span class="token string">"live2d"</span>, <span class="token string">"/live2d/model/xxb/model.json"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>&lt;/script></code></pre><p>将 <code>xxb</code> 改成你新建的文件夹名字，编译运行</p><pre><code>hexo g &amp;&amp; hexo s</code></pre><h3 id="4-修改模型"><a href="#4-修改模型" class="headerlink" title="4. 修改模型"></a>4. 修改模型</h3><p><a href="https://imjad.cn/archives/lab/add-dynamic-poster-girl-with-live2d-to-your-blog-01" target="_blank" rel="noopener">大佬链接</a></p>]]></content>
      
      
      <categories>
          
          <category> live2D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> live2D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 管理代码</title>
      <link href="/2019/hexo-code-management.html"/>
      <url>/2019/hexo-code-management.html</url>
      
        <content type="html"><![CDATA[<p>目录请看  <a href="https://calmcenter.club/2019/Complete_works_of_hexo.html">Hexo 搭建博客大全</a></p><p><strong>注意：如果出现图片不显示问题请移步</strong> <a href="https://calmcenter.club/2019/PicNotShow.html">图片不显示问题</a></p><h2 id="本文主要记载"><a href="#本文主要记载" class="headerlink" title="本文主要记载"></a>本文主要记载</h2><ul><li><code>git</code> 拉取代码</li><li><code>git</code> 创建分支</li><li><code>git</code> 提交分支代码</li><li>其他终端如何使用 <code>Hexo</code> 源码</li></ul><hr><a id="more"></a><h2 id="一、管理代码"><a href="#一、管理代码" class="headerlink" title="一、管理代码"></a>一、管理代码</h2><p>当我们需要在不同的终端去写博客的时候，发现 <code>github</code> 库中只有编译后的代码，所以我们需要将我们的 <code>hexo</code> 源码页放入 <code>github</code> 的分支中</p><p>首先我们需要拉取所有代码，选择一个空文件夹例如 <code>D:\blog\github_hexo</code> </p><h3 id="1-1-拉取主分支代码"><a href="#1-1-拉取主分支代码" class="headerlink" title="1.1 拉取主分支代码"></a>1.1 拉取主分支代码</h3><h4 id="1-1-1-初始化-git"><a href="#1-1-1-初始化-git" class="headerlink" title="1.1.1 初始化 git"></a>1.1.1 初始化 <code>git</code></h4><pre><code>git init</code></pre><h4 id="1-1-2-clone-远程代码，复制刚才的-SSH-路径-或者-HTTPS-路径"><a href="#1-1-2-clone-远程代码，复制刚才的-SSH-路径-或者-HTTPS-路径" class="headerlink" title="1.1.2 clone 远程代码，复制刚才的 SSH 路径 或者 HTTPS 路径"></a>1.1.2 clone 远程代码，复制刚才的 <code>SSH</code> 路径 或者 <code>HTTPS</code> 路径</h4><pre><code>git clone &lt;SSH/HTTPS&gt;</code></pre><h4 id="1-1-3-和远程仓库建立关联"><a href="#1-1-3-和远程仓库建立关联" class="headerlink" title="1.1.3 和远程仓库建立关联"></a>1.1.3 和远程仓库建立关联</h4><pre><code>git remote add origin &lt;SSH/HTTPS&gt;</code></pre><p>如果 <code>falal：remote origin already exists.</code> ，执行下面命令</p><pre><code>git remote rm origin</code></pre><p>然后再次建立关联 <code>git remote add origin &lt;SSH/HTTPS&gt;</code> </p><h3 id="1-2-创建分支"><a href="#1-2-创建分支" class="headerlink" title="1.2 创建分支"></a>1.2 创建分支</h3><h4 id="1-2-1-查看分支情况"><a href="#1-2-1-查看分支情况" class="headerlink" title="1.2.1 查看分支情况"></a>1.2.1 查看分支情况</h4><p>进入拉取下来的目录 <code>cd &lt;文件名&gt;</code></p><p>查看分支，查看本地分支包括远程分支</p><pre><code>git branch -a</code></pre><h4 id="1-2-2-创建本地分支"><a href="#1-2-2-创建本地分支" class="headerlink" title="1.2.2 创建本地分支"></a>1.2.2 创建本地分支</h4><p>创建本地分支并切换到新分支</p><pre><code>git checkout -b test</code></pre><p>等价于 <code>git branch test</code> 和 <code>git checkout test</code> </p><img src="https://raw.githubusercontent.com/CalmCenter/picGo/master/picturesgit_branch1.png" style="zoom:100%"><p>这里会告诉你本地当前所处的分支，切换分支可以用，<strong>当你切换分支时，如果本地没有但是远程有这个分支，它会自动给你拉取远程分支，并切换</strong></p><pre><code>git checkout test </code></pre><h4 id="1-2-3-更新远程分支"><a href="#1-2-3-更新远程分支" class="headerlink" title="1.2.3 更新远程分支"></a>1.2.3 更新远程分支</h4><p>上图你可以看到本地分支比远程分支多一个 <code>test</code> 下一步就是将新分支推送至远程GitHub</p><pre><code>git push origin test</code></pre><p>完成后，执行查看分支命令 <code>git branch -a</code> 会发现远程 多了 <code>test</code> 分支。</p><p><strong>如果想删掉分支</strong>，删除本地分支</p><pre><code>git branch -d &lt;分支名称&gt;</code></pre><p>提交删除到远程</p><pre><code>git push origin --delete &lt;分支名称&gt;</code></pre><h3 id="1-3-提交源码到远程分支"><a href="#1-3-提交源码到远程分支" class="headerlink" title="1.3 提交源码到远程分支"></a>1.3 提交源码到远程分支</h3><h4 id="1-3-1-本地操作代码"><a href="#1-3-1-本地操作代码" class="headerlink" title="1.3.1 本地操作代码"></a>1.3.1 本地操作代码</h4><p>在确保是 <code>test</code> 分支下，然后将 <code>.git</code> 以外的所有文件删掉，将 <code>hexo</code> 源码复制到  <code>D:\blog\github_hexo</code> 下，查看文件状态</p><pre><code>git status</code></pre><p><strong>注意:如果你之前是 <code>git</code> 直接 <code>clone</code> 的 <code>NexT</code> ，在拉取目录会自带 <code>.git</code> 和 <code>.github</code> 文件，需要删掉 <code>.git</code> 和 <code>.github</code> 文件，如果不删会出现拉取目录里的文件提交不上去的问题</strong></p><h3 id="设置语言、标题等"><a href="#设置语言、标题等" class="headerlink" title="设置语言、标题等"></a>设置语言、标题等</h3><h4 id="1-3-2-添加到暂存区"><a href="#1-3-2-添加到暂存区" class="headerlink" title="1.3.2 添加到暂存区"></a>1.3.2 添加到暂存区</h4><p><strong>(最后是一个 . 或者 -A 表示所有)</strong></p><pre><code>git add .</code></pre><h4 id="1-3-3-提交本地代码库"><a href="#1-3-3-提交本地代码库" class="headerlink" title="1.3.3 提交本地代码库"></a>1.3.3 提交本地代码库</h4><pre><code>git commit -m &quot;描述&quot;</code></pre><h4 id="1-3-4-提交到远程分支"><a href="#1-3-4-提交到远程分支" class="headerlink" title="1.3.4 提交到远程分支"></a>1.3.4 提交到远程分支</h4><pre><code>git push</code></pre><p>如果提示没有关联，则用下面指令</p><pre><code>git push --set-upstream origin &lt;分支名&gt;</code></pre><h3 id="1-5-其他终端操作"><a href="#1-5-其他终端操作" class="headerlink" title="1.5 其他终端操作"></a>1.5 其他终端操作</h3><h4 id="1-5-1-hexo-环境搭建"><a href="#1-5-1-hexo-环境搭建" class="headerlink" title="1.5.1 hexo 环境搭建"></a>1.5.1 <code>hexo</code> 环境搭建</h4><p>首先创建一个空目录，初始化 <code>git</code></p><pre><code>git init</code></pre><p>安装 <code>hexo-cli</code> 执行下面命令，如果该终端执行过可跳过，再次执行会报错，需要删除掉 <code>C:\Users\&lt;电脑名字&gt;\AppData\Roaming</code> 目录下 <code>npm-cache</code> 和 <code>npm</code> 文件，重新执行这个命令就好。<code>(个人多次实践出来的，不行就删。。。)</code> </p><p>如果 <code>hexo</code> 命令执行过程中报 <code>bash: hexo: command not found</code> 就是没有安装 <code>hexo</code> ，需要执行下面的命令</p><pre><code>npm install hexo-cli -g</code></pre><h4 id="1-5-2-拉取远程分支代码"><a href="#1-5-2-拉取远程分支代码" class="headerlink" title="1.5.2 拉取远程分支代码"></a>1.5.2 拉取远程分支代码</h4><p>然后执行 5.1 的操作 <code>git clone &lt;SSH/HTTPS&gt;</code>、<code>git remote add origin &lt;SSH/HTTPS&gt;</code> ，将远程所有代码拉下来。当前状态你只有主分支代码，你还需要拉取你 <code>test</code> 分支的代码，进入拉取下来的目录 <code>cd &lt;文件名&gt;</code> 。</p><p><code>git branch -a</code> 查看分支情况。然后切换并拉取 <code>test</code> 分支。</p><pre><code>git checkout test</code></pre><h4 id="1-5-3-安装环境"><a href="#1-5-3-安装环境" class="headerlink" title="1.5.3 安装环境"></a>1.5.3 安装环境</h4><p>首先在文件目录下，安装 <code>hexo</code> 和 <code>deployer</code></p><pre><code>npm install hexo --save</code></pre><pre><code>npm install hexo-deployer-git --save</code></pre><p>然后编译并运行</p><pre><code>hexo g &amp;&amp; hexo s</code></pre><p>这样本地就好了，发布 <code>github</code> 需要配置 <code>SSH</code> 和之前 4.3 操作是一样的。</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> git </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 基础搭建</title>
      <link href="/2019/hexo-bash.html"/>
      <url>/2019/hexo-bash.html</url>
      
        <content type="html"><![CDATA[<p>目录请看 <a href="https://calmcenter.club/2019/Complete_works_of_hexo.html">Hexo 搭建博客大全</a></p><p><strong>注意：如果出现图片不显示问题请移步</strong> <a href="https://calmcenter.club/2019/PicNotShow.html">图片不显示问题</a></p><h2 id="本文主要记载"><a href="#本文主要记载" class="headerlink" title="本文主要记载"></a>本文主要记载</h2><ul><li>搭建本地博客</li><li>部署到 <code>Github Pages</code></li></ul><pre><code>本文环境是 win10 或 win 7。mac 再执行 npm 时需要在前面添加 sudo本文整理于各大佬文章，文中会给出相应链接，如有侵权，请联系我修改或删除。</code></pre><hr><a id="more"></a><h2 id="一、-搭建本地博客"><a href="#一、-搭建本地博客" class="headerlink" title="一、 搭建本地博客"></a>一、 搭建本地博客</h2><h3 id="1-1-首先安装-Node-js"><a href="#1-1-首先安装-Node-js" class="headerlink" title="1.1 首先安装 Node.js"></a>1.1 首先安装 <code>Node.js</code></h3><p>首先去 <a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">官方页面</a> 下载安装文件，无脑安装就好 （<del>。</del>）</p><img src="https://raw.githubusercontent.com/CalmCenter/picGo/master/picturesnode.png" style="zoom:20%"><p>图中绿色选择部分，安装完成后输入 <code>npm -v</code> , 会告诉你版本号，就证明你安装成功了</p><p>3.2 安装 <code>Git</code></p><p>去 <a href="https://git-scm.com/download/win" target="_blank" rel="noopener">git官网</a> 下载电脑对应版本，进行安装，安装完成后，输入 <code>git version</code> ，会告诉你版本号，就证明你安装成功了。安装成功后，鼠标右键菜单里会多出 <code>Git GUI Here</code> 和 <code>Git Bash Here</code> 两个按钮。</p><p><strong><a href="https://www.cnblogs.com/wj-1314/p/7993819.html" target="_blank" rel="noopener">Git安装教程</a>  这个是百度的，如果不会查看本链接或重新百度就好~</strong></p><p><strong>我管理代码都是在 <a href="https://www.sourcetreeapp.com/" target="_blank" rel="noopener">Sourcetree</a> 上进行，后续会说，当然也是要 Git 的支持，这个还是很方便的，无脑操作~6</strong></p><h3 id="1-2-安装-Hexo"><a href="#1-2-安装-Hexo" class="headerlink" title="1.2 安装 Hexo"></a>1.2 安装 <code>Hexo</code></h3><p>*<em>注意执行命令期间 <code>WARN</code> 不管 只看 <code>ERR</code> *</em></p><p>在文件夹内如 <code>D:\blog</code> ，鼠标右键点击 <code>Git Bash Here</code> 一气呵成，来到了命令行界面。</p><p>首先安装 <code>hexo</code> </p><pre><code>npm install hexo-cli -g</code></pre><h4 id="1-2-1-镜像相关（如果-npm-可以正常使用这里跳过！）"><a href="#1-2-1-镜像相关（如果-npm-可以正常使用这里跳过！）" class="headerlink" title="1.2.1 镜像相关（如果 npm 可以正常使用这里跳过！）"></a>1.2.1 镜像相关（如果 npm 可以正常使用这里跳过！）</h4><p> 上面正常情况是没有问题的，但是由于国内访问官方 NPM 源速度较慢，为了一劳永逸，此处可以将 NPM 源更换为了淘宝 NPM 镜像源。<br><strong>请注意!!，如果你觉得你的 NPM 源速度够快，更换镜像源这部分可选择性使用</strong></p><p>在 <code>Git Bash Here</code> 中输入指令，将官方 npm 源更换为淘宝 npm 镜像源</p><pre><code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code></pre><p>可以输入 </p><pre><code>cnpm config list</code></pre><p> 查看是否更换成功</p><p><strong>请注意，如需使用上方安装的淘宝源，需要在使用 npm 命令时将其改为 cnpm</strong>，但是如果用了 cnpm 再使用 npm 的话，好像有点问题，npm 一直报 err 。所以这里给出卸载镜像的命令</p><pre><code>npm uninstall cnpm -g</code></pre><p>但是 npm 命令还是报错，还需要删除掉 <code>C:\Users\&lt;电脑名字&gt;\AppData\Roaming</code> 目录下  <code>npm-cache</code> 和 <code>npm</code> 文件，重新执行上面两个安装命令即可</p><h3 id="1-3-Hexo初始化"><a href="#1-3-Hexo初始化" class="headerlink" title="1.3 Hexo初始化"></a>1.3 Hexo初始化</h3><p>安装完成后，输入 <code>hexo -v</code> 会输出 hexo 版本号，证明安装成功。</p><p>然后在当前目录新建一个文件夹，比如 <code>D:\blog\hexos</code> ，在此目录下鼠标右键点击 <code>Git Bash Here</code> 执行，这条命令需要一个空文件夹所以新建一个。</p><pre><code>hexo init</code></pre><p>完成后，文件目录如下</p><img src="https://raw.githubusercontent.com/CalmCenter/picGo/master/pictureshexo_file.png" style="zoom:100%"><p>这样就证明初始化完成了，然后我们继续要生成静态页面，用到的命令是</p><pre><code>hexo g</code></pre><p>其中，<code>g</code> 的全称是 <code>generate</code>，当然也可以用 <code>hexo generate</code> 这条命令。</p><pre><code>npm install hexo-server --save</code></pre><p>然后就是运行了</p><pre><code>hexo s</code></pre><p>其中， <code>s</code> 的全称是 <code>server</code>，当然也可以用 <code>hexo server</code> 这条命令</p><p>然后，打开你的浏览器，输入<code>http://localhost:4000/</code> 即可看到本地静态博客</p><img src="https://raw.githubusercontent.com/CalmCenter/picGo/master/pictureshexo_page.png" style="zoom:20%"><p>本地静态博客完成 ~ </p><p>如果出现 <code>Cannot GET/xxx</code> 等类似错误，意味着有文件未被找到。<code>Cannot GET/xxx</code> 错误本质是 <code>hexo server</code> 返回的一个404错误。</p><p>判断public目录下 <code>xxx</code> 文件是否存在。(我的错误是 <code>Cannot GET/</code> ，因此在public目录下寻找 <code>index.html</code> 是否存在。)</p><p>如果说 <code>index.html</code> 不存在，那么执行 <code>hexo clean</code>，<code>hexo g</code> 重新生成一次，回到步骤1。</p><p>步骤2执行完后 <code>index.html</code> 仍不存在，执行 <code>npm audit fix</code> ，查看是否少了什么组件，通过 <code>npm install hexo-xxx-xxx</code>  安装即可。</p><p>步骤3完成之后，执行 <code>hexo clean</code>，<code>hexo g</code> 重新生成静态文件。</p><p>仍然有问题，请再参考此文：<a href="https://www.cnblogs.com/Sroot/p/6305938.html" target="_blank" rel="noopener">https://www.cnblogs.com/Sroot/p/6305938.html</a></p><p>感谢 <a href="https://www.jianshu.com/p/af83fc73e525" target="_blank" rel="noopener">Cannot GET 错误解决方式 原文地址</a></p><hr><h2 id="二、部署到-Github-Pages"><a href="#二、部署到-Github-Pages" class="headerlink" title="二、部署到 Github Pages"></a>二、部署到 Github Pages</h2><h3 id="2-1-注册Github账户"><a href="#2-1-注册Github账户" class="headerlink" title="2.1 注册Github账户"></a>2.1 注册Github账户</h3><p>进入 <a href="https://github.com/" target="_blank" rel="noopener">github首页</a> ，点击右上角 <a href="https://github.com/join?source=header-home" target="_blank" rel="noopener">sign up</a> 进行注册。</p><h3 id="2-2-创建项目"><a href="#2-2-创建项目" class="headerlink" title="2.2 创建项目"></a>2.2 创建项目</h3><p>登录后，创建一个自己的 <code>GitHub Pages</code>。 点击头像中的 <a href="https://github.com/new" target="_blank" rel="noopener">New repository</a> 。</p><img src="https://raw.githubusercontent.com/CalmCenter/picGo/master/picturesnew_repository.png" style="zoom:50%"><p>*<em>敲黑板！！ 这里重点就是项目名称必须是 <code>自己名称.github.io</code>  *</em></p><h3 id="2-3-配置-SSH-密钥"><a href="#2-3-配置-SSH-密钥" class="headerlink" title="2.3 配置 SSH 密钥"></a>2.3 配置 <code>SSH</code> 密钥</h3><h4 id="2-3-1-查看是否存在-SSH-密钥"><a href="#2-3-1-查看是否存在-SSH-密钥" class="headerlink" title="2.3.1 查看是否存在 SSH 密钥"></a>2.3.1 查看是否存在 <code>SSH</code> 密钥</h4><p>首先通过输入命令</p><pre><code>cd ~/. ssh </code></pre><p>如果存在则会进入此目录,可以略过 4.3.2，否则会提示你不存在，那么继续 4.3.2</p><h4 id="2-3-2-创建新的-SSH-密钥"><a href="#2-3-2-创建新的-SSH-密钥" class="headerlink" title="2.3.2 创建新的 SSH 密钥"></a>2.3.2 创建新的 <code>SSH</code> 密钥</h4><pre><code>ssh-keygen -t rsa -C &quot;your_email@example.com&quot;</code></pre><p>这将按照你提供的邮箱地址，创建一对密钥，然后让你输入 密码</p><pre><code>Enter passphrase (empty for no passphrase): [Type a passphrase]Enter same passphrase again: [Type passphrase again]</code></pre><p>如果你放心，可以不用密码，直接回车，这样每次提交的时候比较方便。</p><h4 id="2-3-3-在-GitHub-添加你的公钥"><a href="#2-3-3-在-GitHub-添加你的公钥" class="headerlink" title="2.3.3 在 GitHub 添加你的公钥"></a>2.3.3 在 <code>GitHub</code> 添加你的公钥</h4><ol><li>首先拷贝公钥内容（ mac 可能用不了，需要手动找到这个文件复制内容）</li></ol><pre><code>clip &lt; ~/.ssh/id_rsa.pub</code></pre><ol start="2"><li>然后登陆 <a href="https://github.com/" target="_blank" rel="noopener">GitHub</a> ，点击头像</li></ol><img src="https://raw.githubusercontent.com/CalmCenter/picGo/master/picturessetting.png" style="zoom:50%"><ol start="3"><li>进入设置页，选择 <code>SSH</code> </li></ol><img src="https://raw.githubusercontent.com/CalmCenter/picGo/master/picturessetting_list.png" style="zoom:50%"><ol start="4"><li>粘贴密钥，添加即可</li></ol><img src="https://raw.githubusercontent.com/CalmCenter/picGo/master/picturesssh_content.png" style="zoom:50%"><ol start="5"><li>测试</li></ol><pre><code>ssh -T git@github.com</code></pre><img src="https://raw.githubusercontent.com/CalmCenter/picGo/master/picturestest_ssh.png" style="zoom:100%"><ol start="6"><li>设置用户信息</li></ol><p><code>Git</code> 会根据用户的名字和邮箱来记录提交。</p><pre><code>git config --global user.name &quot;name&quot;</code></pre><pre><code>git config --global user.email &quot;email&quot;</code></pre><p>这样就配置好了SSH</p><h3 id="2-4-将本地-Hexo-文件编译并上传-GitHub-的库中"><a href="#2-4-将本地-Hexo-文件编译并上传-GitHub-的库中" class="headerlink" title="2.4 将本地 Hexo 文件编译并上传 GitHub 的库中"></a>2.4 将本地 <code>Hexo</code> 文件编译并上传 <code>GitHub</code> 的库中</h3><ol><li>打开 <a href="https://github.com/" target="_blank" rel="noopener">github首页</a> 登录，找到左上角自己的项目</li></ol><img src="https://raw.githubusercontent.com/CalmCenter/picGo/master/picturesgithub_list.png" style="zoom:70%"><ol start="2"><li><p>点击 clone 点击 Use SSH 并复制 <code>SSH</code> 路径</p><img src="https://raw.githubusercontent.com/CalmCenter/picGo/master/picturesgithub_ssh_path.png" style="zoom:70%"></li><li><p>打开 <code>hexo</code> 目录，找到 <code>_config</code> 文件</p><img src="https://raw.githubusercontent.com/CalmCenter/picGo/master/pictureshexo_catalog_config.png" style="zoom:70%"></li><li><p>打开并找到 <code>deploy</code> 关键字</p></li></ol><pre><code>deploy:  type: git  repository: git@github.com:CalmCenter/calmcenter.github.io.git  branch: master</code></pre><p><strong>注意: 引号 后有一个空格，repository 填写 ssh 地址，branch 如果没有特殊要求，写master</strong></p><ol start="5"><li>编译并提交</li></ol><p>部署前需要先装 <code>deployer</code> ，<code>deployer</code> 用于将 <code>hexo</code> 部署到  <code>git page</code> </p><pre><code>npm install hexo-deployer-git --save</code></pre><p>提交前，有时候提交了不生效，需要清理一下缓存</p><pre><code>hexo clean</code></pre><p>编译并提交</p><pre><code>hexo g -d</code></pre><p> 和 <code>hexo g</code> 、 <code>hexo d</code> 一样</p><p><strong>提交后线上会有延迟才会展现最新效果，特别是配置样式之后</strong></p><p>提交过程中会让你输入一次密码，完成后就可以在外网访问博客了。<a href="https://calmcenter.github.io/" target="_blank" rel="noopener">https://calmcenter.github.io/</a> <code>https://用户名.github.io</code></p><p>假如这时候，报错 <code>ERROR Deployer not found: git</code>，那么就是你的 <code>deployer</code> 没有安装成功，你需要执行如下命令再安装一次：</p><pre><code>npm install hexo-deployer-git --save</code></pre><p>这样，你再执行 <code>hexo g -d</code> ，你的博客就部署到 <code>Github</code> 上了。</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> git </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>职场的真相</title>
      <link href="/2019/zhi-chang-de-zhen-xiang.html"/>
      <url>/2019/zhi-chang-de-zhen-xiang.html</url>
      
        <content type="html"><![CDATA[<p>各位同学，大家好，我是曹政，谢谢各位参与我的年终福利课程，职场的真相。<br>关于职场，说实话，我年轻的时候做的并不好，很多教训，很多很愚蠢的事情，所以，我不是说，一个成功职场精英，一个上市公司高管，给你们讲职场，当然，实话说，现在而言，上市高管对我来说不算什么很难的目标，但重要的是，当年我在混职场的时候，其实是很糟糕的。<br>直到自己参与创业，以及自己开公司的时候，站的地位不同了，反过来思考，才知道自己当年职场为什么糟糕。但我知道很多年轻人，可能会重蹈我的覆辙，经历很多教训，做很多自以为聪明的事情。所以这次分享，主要是面对年轻读者，特别是初入职场的读者，希望大家少走弯路，职场顺利。<br>有相当部分内容可能是去年提过的，如果看到了，就当复习吧，两年都提过的肯定是非常非常关键的，特意回看了一下去年的分享课内容，真的是太棒了，感觉今年内容很难超过去年。</p><a id="more"></a><h2 id="1-关于面试"><a href="#1-关于面试" class="headerlink" title="1 关于面试"></a>1 关于面试</h2><h3 id="1-1-做功课很重要"><a href="#1-1-做功课很重要" class="headerlink" title="1.1 做功课很重要"></a>1.1 做功课很重要</h3><p>什么是做功课，你去面试之前，应该先搜索了解这个公司的背景，诸如股权结构，公司负责人的背景，公司主要产品线构成和主要收入构成，公司主要竞品和竞争格局。如果有可能，尽量测试使用以下公司的产品，并搜索一下相关公司的口碑和介绍。</p><p><a href="https://mp.weixin.qq.com/s/9cT-Ng_hvj9V61_XEl-ZVg" target="_blank" rel="noopener">职场自救指南</a><br><a href="https://mp.weixin.qq.com/s/NQuWI2cg_JVJa4SJSpw9rg" target="_blank" rel="noopener">求职是需要诚意的</a></p><p>重复强调一下，有不少公司网上有一些坏的口碑，怎么办？要评估一下，其实大部分知名企业都会存在两极口碑，甚至是很糟糕的口碑，但不代表这个公司没价值，你要知道自己目的是什么。<br>当然也要根据你手里的offer数量和质量综合判断，你一把名企offer，你去甄别口碑，如果你现在要解决当下吃饭问题，只要公司不是那种骗子公司或者法律风险吓人的公司，其实都可以去的。</p><h3 id="1-2-简单而精确的自我介绍"><a href="#1-2-简单而精确的自我介绍" class="headerlink" title="1.2 简单而精确的自我介绍"></a>1.2 简单而精确的自我介绍</h3><p>面试一般都要自我介绍，那么介绍的环节要做到简单精确。</p><p>什么是简单精确</p><p>第一，最能体现你的价值，你的能力的点，要重点表达出来。不要不好意思说，不要以为面试官已经完整的审阅了你的简历或求职信。</p><p>第二，不要啰里啰唆，什么都讲，要分清重点，年轻人找工作有时候生怕少介绍了自己的成绩，什么都要列出来，说实话，有些学校里的证书价值含量极低，你越强调，别人会觉得，你的能力不过如此，还不如不提。</p><p><a href="https://mp.weixin.qq.com/s/v5uFBplY6lkcUqd7vuzETA" target="_blank" rel="noopener">「谈谈自我介绍与第一印象」</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI0MjA1Mjg2Ng==&mid=401539494&idx=1&sn=137441bcf08a53c84f67c5d859c66854&scene=21#wechat_redirect" target="_blank" rel="noopener">「谈谈写作」</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI0MjA1Mjg2Ng==&mid=400367085&idx=1&sn=108ac3dfc843baf5bc56f73edf646ae1&scene=21#wechat_redirect" target="_blank" rel="noopener">「所谓坚持」</a></p><p>大V系列<br><a href="https://mp.weixin.qq.com/s?__biz=MzI0MjA1Mjg2Ng==&mid=401981770&idx=1&sn=127123fb1ca12af53d77e3c567d75fca&scene=21#wechat_redirect" target="_blank" rel="noopener">「关于影响力」</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI0MjA1Mjg2Ng==&mid=401310703&idx=1&sn=979e25d208a6013b8c487726a5a2b020&scene=21#wechat_redirect" target="_blank" rel="noopener">「自我修养」</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI0MjA1Mjg2Ng==&mid=402041293&idx=1&sn=8ba4a204c76eb987f7a7b6130c304e71&chksm=7b0033a04c77bab6b9823c0d3ac21cc03771f5723c06205f0f48b1c50c751b3c4a98f1a14c76&scene=21#wechat_redirect" target="_blank" rel="noopener">「如何正确的勾搭大V」</a></p><h3 id="1-3提出有价值的问题"><a href="#1-3提出有价值的问题" class="headerlink" title="1.3提出有价值的问题"></a>1.3提出有价值的问题</h3><p>大部分公司面试都会有个让面试者提问的环节，很多面试者会问年终奖怎么发，休假怎么休之类的问题。<br>实话说，这类问题不是不能问，别人明确给你offer的时候，你问是没有问题的。<br>人家还在考核你的时候，问题本身是考核的一部分，能理解么？<br>前面为什么说要做功课，这里要问出有价值的问题。</p><p>什么是有价值的问题，关于对方的产品，竞品，业务方向，技术方案，提出自己认真思考后的疑惑。<br>实话说，做到有价值不容易，你可能觉得自己思考深度已经够深了，没准在别人眼里还是一个非常烂的差问题，这咋办，这岂不是弄巧成拙？</p><p>看你怎么理解了，你并不是只有一次面试，职场也并非只有一次选择，被 <code>Diss</code> 了，被别人批驳了，勤反思，为什么很关键的点自己没想到，为什么自己觉得很复杂的问题别人觉得不值一提？只要有收获，就不亏，每个人的职场认知都不是一步到位的，发现自己的不足，是成长的过程，只要成长够快，好的offer迟早是你的，不要在意一城一池的得失。</p><p>最怕的是什么，面试受了点挫折，出了点丑，问的问题被鄙视了，就觉得自己被针对了，被歧视了，加戏很多，对方不尊重自己了，企业文化糟糕了，有时候网上看看各种讨论，这样心态的年轻人还是挺多的。</p><p><a href="https://mp.weixin.qq.com/s/yW4rto4VF1AwFCs62UMZaw" target="_blank" rel="noopener">「别把自己当小受」</a></p><p>浅谈关于领导力<br><a href="https://mp.weixin.qq.com/s?__biz=MzI0MjA1Mjg2Ng==&mid=400713104&idx=1&sn=d38e44a244fb4125808124eb12a17299&scene=21#wechat_redirect" target="_blank" rel="noopener">「识人之能」</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI0MjA1Mjg2Ng==&mid=400819865&idx=1&sn=15fb195cb1cccc71430909a0b267ad2b&scene=21#wechat_redirect" target="_blank" rel="noopener">「授权与放权」</a></p><p>能力成长系列<br><a href="https://mp.weixin.qq.com/s?__biz=MzI0MjA1Mjg2Ng==&mid=209733294&idx=1&sn=111340c5aa21a98dd8b76abc1016dc68&scene=21#wechat_redirect" target="_blank" rel="noopener">「机会来自于担当」</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI0MjA1Mjg2Ng==&mid=209714599&idx=1&sn=1cd7f5ca6045be9da9374477871f1d3d&scene=21#wechat_redirect" target="_blank" rel="noopener">「归纳与总结」</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI0MjA1Mjg2Ng==&mid=209695455&idx=1&sn=4d9a296a87f9525907e1e58c85b0648b&scene=21#wechat_redirect" target="_blank" rel="noopener">「提问的技术」</a> </p><p>年轻人，如何抗造<br><a href="https://mp.weixin.qq.com/s?__biz=MzI0MjA1Mjg2Ng==&mid=2649868155&idx=1&sn=953dec87eb8af0ea29b6b0683f98ba36&chksm=f1075d16c670d4004438ab5a639eacfce8164caaec49d3c56727bc1e97cbceb0075889d3fd06&scene=21#wechat_redirect" target="_blank" rel="noopener">「无意义的忧虑与烦恼」</a><br><a href="https://mp.weixin.qq.com/s/YT85l1W9IqeybiE0fso0Bw" target="_blank" rel="noopener">「 预期管理及心态控制」</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI0MjA1Mjg2Ng==&mid=400665044&idx=1&sn=a8c001c227eb8e4b2559cde4c31db267&scene=21#wechat_redirect" target="_blank" rel="noopener">「从历史中讲创业的韧性」</a></p><h3 id="1-4-保持后续可行性"><a href="#1-4-保持后续可行性" class="headerlink" title="1.4 保持后续可行性"></a>1.4 保持后续可行性</h3><p>技术面试，或者产品运营的面试被难题考倒了，很多人当然会很沮丧，认为失去了一次机会。</p><p>其实这也是一种学习的机会，那么可以考虑这样的一种回答方式，“这道题确实超出了我的知识范畴，我回去想认真思考一下，方便留一下您的联系邮件么，我希望再次解答后还得到您的指点，不不不，我不是奢求再来一次面试，我只是想学会这个算法。”</p><p>或者这类“今天我回答的不好，谢谢您帮我发现了自己的差距和不足，能不能给我一些相关问题的学习资料，书籍和网址，我想回去认真学习一下，如果有可能，不知道以后还能不能得到您的指点，能否留一个您的联系方式。”</p><p>当然，以上并不只是面试的一套说辞，你回去之后还是要认真的完成学习并且认真的把更好的答案发给对方，并诚恳的希望得到对方的批评和指导。</p><p>每个求职者都会说自己热爱学习，愿意接受挑战，怎么证明啊？你看，你没拿到offer，都愿意去学习，这个印象分是什么。</p><p>下次这个公司有新的人力诉求的时候，或者其他岗位有诉求的时候，会不会想到你？我不能说肯定会，但我会说，这样的机会真的会有。</p><h3 id="1-5-关于离职原因的回答"><a href="#1-5-关于离职原因的回答" class="headerlink" title="1.5 关于离职原因的回答"></a>1.5 关于离职原因的回答</h3><p>这是最难回答的面试问题了，那么分三个情况。</p><p>第一，非裸辞的情况，这种相对容易一点，觉得这边机会更好，发展空间更大，能学到更多东西，待遇更有优势，这些都没问题的。尽量不要埋怨老东家，不要说老领导多不好，老东家多苛刻，实话说，人家会很担心，你以后去下一家公司的时候，还会这么说他们。</p><p>第二，裸辞的情况下，那么确实要解释的更多，有些是比较容易解释的，旧公司业务风险较高，所以赶紧撤出。加班太多，个人身体有些吃不消/家里人照顾不到。这种直说也无妨。</p><p>有些可能确实跟旧东家发生了较多矛盾，或者甚至是被裁员，被开除。可能讲出来不是很好听，我觉得把握一个原则，要敢承认自己的不足。比如当时争论的时候确实有些冲动，或者说认真反思了一下，当时确实可以做的更好一些。</p><p>不要一昧的指责旧东家和旧同事，要认真的反思和承认不足，摆事实讲道理，特别是情绪要稳定，一定要让面试官觉得你是讲道理的人，是不记仇的人，这点很重要，说实话，职场上的老江湖，没有谁会轻信一家之言，你真的特别委屈特别冤枉，别人也不会认为这是完全的事实。</p><p>第三，换工作较多的场景，比较碎的工作经验，说实话，尽量尽量不要有这样的职场记录，你说我抹去一些行不行，其实是可以的，但还是尽量不要有这样的职场记录。</p><p>现在一些年轻人，怎么说呢，挺任性的，工作不开心就辞职，换工作比换手机快，一年换好几份，当然，往好处说也是一种人生体验，但确实在后续求职应聘的时候，会有很不好的影响。</p><p>还是那句话，要坦诚自己的问题，面试官问了，别找太多借口，自己当时年轻，社会经验不足，求职的时候考虑不周全，工作的时候也有点任性，坦坦荡荡的说，尽量让人觉得你现在成熟了，认识问题了，不会那么毛躁了。</p><p>当然，有些换工作的经历并不是坏事情，比如前任领导离职创业把我拉出去了，后来创业失败了，投资人拉我进了另一个项目，但很不幸项目也没成功。这种其实不是坏事，说明你的能力被之前的领导，投资人认可，虽然项目换的多，但不会是负面。</p><p>现在不是说找份工作一定要干很多年，但换工作还是要谨慎，尽量找能坚持几年的事情做。</p><h3 id="1-6-关于项目经验的回答"><a href="#1-6-关于项目经验的回答" class="headerlink" title="1.6 关于项目经验的回答"></a>1.6 关于项目经验的回答</h3><p>面试官经常会问，你以前做过的项目，及你在项目中的工作是什么。我其实也强烈建议，日常工作中养成勤奋总结的好习惯。功夫当然还是在日常。</p><p>我以前说过这个案例，项目的方案描述，数据及逻辑清晰不清晰，比如性能优化，优化前的并发指标是什么，优化方案是怎么考虑的，优化后如何测试的，测试指标是怎样的。<br>上线后的数据指标是怎样的，进一步优化的预案有没有，对进一步并发压力的预警系统有没有做，怎么做的。很多人只是简单描述了优化方案，然后说问题解决了，这其实是不行的。</p><p>项目经验，你的总结能力比项目本身更重要，项目很牛逼，你讲出来都是泛泛而谈，我是里面的工程师，写了一个什么结构，你觉得你讲的很清楚，面试官怎么觉得？项目牛逼和你有关系么？项目很一般，你讲的逻辑很清晰，什么问题，如何解决，为什么选择这个方案，效果对比，说明什么，说明你分析问题，处理问题的思路清晰，逻辑严谨，这是人家看重的。</p><p>所以，面试前，把你当年最得意的，认为最能体现自己价值的项目经验，认真复盘一下，尽可能用数据化的方式展现出来，并整理好你的决策和分析逻辑，以及整个项目的分析逻辑。</p><p>为什么很多人觉得我牛逼，很多事情不是我做的，但是我整理后写出来，思路很清晰，逻辑很严谨，数据指标很给力，人家至少知道，这个事情，我是理解透彻了，面试官发现你对项目理解透彻了，能够驾驭了，是不是你完成的，还那么重要么。</p><p> <a href="https://mp.weixin.qq.com/s/A3k8aRbd7o4uuELZAMM_KA" target="_blank" rel="noopener">「面试官是怎么看简历里的项目经验」</a></p><h3 id="1-7-刷题"><a href="#1-7-刷题" class="headerlink" title="1.7 刷题"></a>1.7 刷题</h3><p>刷题有用没？其实是有用的，特别是巨头的面试，还是很看重的。技术面试，<code>leetcode</code> 的题目，如果有足够的刷题经验，还是会很有帮助。</p><p>刷题的几个要点，第一，举一反三，一定要对解题思路理解透彻，能够让算法适应不同的类似场景。第二，一定要增强题目理解力，因为面试官问问题的时候，往往不是题库里那么直接，很多人明明刷题做的很好，但是现场理解上出了偏差，本来是做过的东西，现场换了一个问题，就不知道怎么处理了。</p><p>那么现场如果对面试官的题目理解不到位，可以多问一些问题来理解，不要不好意思问，问清楚再回答。</p><p>刷题的时候自我感觉没问题，面试理解错，这种情况其实非常常见，那么同时，我也说过容错性的话题很多次，也要允许面试官，存在表达歧义的可能性，这就是为什么要追问，要通过追问明确问题的原因。</p><p>增加理解力和沟通能力，在职场永远都是非常重要的。</p><p>我有篇文章，找个小伙伴，日常沟通训练，不知道有多少读者去实践了。</p><p>沟通 <a href="https://mp.weixin.qq.com/s/f_CF8dRObw78k9b9DFAyKA" target="_blank" rel="noopener">「有效提升沟通能力」</a> </p><h3 id="1-8-交流得体"><a href="#1-8-交流得体" class="headerlink" title="1.8 交流得体"></a>1.8 交流得体</h3><p>沟通交流过程中，如何得体，不要太过拘谨，但也不要太过于随便。</p><p>这个度怎么把握？<br>说真的，有些年轻人学校里随便惯了，进入职场的时候，还是那种无所谓，各种玩笑，各种不在乎的样子，这种印象是很不好的。</p><p>第一，穿衣着装，不是说非要正装西服，但还是要相对正式一点，比如短裤背心是不合适的，当然如果你在业内是顶尖大牛，你穿什么都行，职场新人，求职的时候，着装稍微正式一点。</p><p>第二，称谓和交流，客气一些。多用“您”字，多说几句谢谢，多体谅一下面试官，“没关系，我可以等”。“今天学到了很多，感谢您的指导。”“对不起，我能稍微打断一下么，刚才那个问题没听清楚。”，“不好意思，我想多问一句，这个题目中的什么什么，我理解是这样这样，不知道是不是。”</p><p>第三，也不用过于拘谨，适当的主动表达也是很有意义的。“我试了一下咱们的产品，真的很好用，昨天还在跟同学安利呢。”，“咱们公司今年增长太快了，我还特意看了一下财报数据，太惊人了。”</p><p>第四，既要谦虚，也要有自信，不知道能不能理解这个尺度。“我们当年这个项目其实还是有些缺陷的，当时经验不足，时间也比较紧张，有几个地方这里那里的考虑不全，如果现在交给我来做，应该会好很多。” 要承认自己的不足，也要对自己的发展空间有信心。“您提的这个问题，确实我现在可能没办法回答到位，不过如果给我一周时间，我相信会给您一个满意的答案。”</p><p>第五，无论面试成败，都要感谢对方，保留好印象，行业不大，人生何处不相逢。</p><h2 id="2-什么是职场中的态度"><a href="#2-什么是职场中的态度" class="headerlink" title="2 什么是职场中的态度"></a>2 什么是职场中的态度</h2><h3 id="2-1-愿意尝试，愿意学习，积极沟通"><a href="#2-1-愿意尝试，愿意学习，积极沟通" class="headerlink" title="2.1 愿意尝试，愿意学习，积极沟通"></a>2.1 愿意尝试，愿意学习，积极沟通</h3><p>在职场里，态度是非常关键的。<br>遇到困难和障碍，是否愿意学习，是否愿意尝试，这是很重要的，还记得王兴不是贴过一段记录，说他们公司谁谁谁，问什么东西用过没有，人家的回答是，没用过，不过我可以学。</p><p>王兴为什么会贴这句话，“我不会，但我可以学”，在职场是几乎每个老板都看重的素质。</p><p>“我不是这个专业的”，“我来这里不是为了干这个的”，“这个事情不该我来做”，很糟糕，真的，很糟糕。</p><p>另一点就是积极沟通，什么是积极沟通，有问题就问，有观点要表达，当然表达方式可能需要一些技巧，但要敢于表达，有机会要争取，有责任要敢承担。</p><p>此外，项目出现问题，或者出现阻碍的时候，要主动通报，主动寻求协助，主动告知相关同事，这也是积极沟通很重要的一点。</p><p>我们一直说的，印度裔在欧美为什么比华裔吃香，积极沟通这件事上，我们很多人真的没有当回事。中国人干活，印度人表功，为什么会这样，真的是职场不公？其实不是的。</p><p>积极沟通对应的是消极沟通，什么是消极沟通，坐等老板给机会，坐等别人派任务，别人不问就闷头不说，遇到问题不找人帮忙，非要自己抗，影响全局还觉得自己很委屈。</p><p>当你作为老板，面临项目安排规划和人员调配的时候，你就会理解，为什么积极沟通如此重要，为什么闷头做事的中国人不如擅长表功的印度人。我非常希望读者能彻底理解这一点。</p><p><a href="https://mp.weixin.qq.com/s/tlw7hm9No7WNnaDqozyB7w" target="_blank" rel="noopener">「谈谈主动工作」</a><br><a href="https://mp.weixin.qq.com/s/QXEg4oK48G0X-AV3X9c2NQ" target="_blank" rel="noopener">「从校园到职场 - 提问与交流」</a><br><a href="https://mp.weixin.qq.com/s/WI-rFdNOQjRfcwnXNFYx9g" target="_blank" rel="noopener">「再谈职场沟通」</a></p><h3 id="2-2关于加班的话题"><a href="#2-2关于加班的话题" class="headerlink" title="2.2关于加班的话题"></a>2.2关于加班的话题</h3><p>我知道很多人不想加班，但确实很多公司可能存在较多加班场景。</p><p>第一，要理解临时性的加班任务，比如线上出了一个紧急bug，或者有个活动得组织和维护压力非常大，我觉得除非家里有紧急情况需要处理，这种加班还是多体谅一下公司。<br>比如所有国内电商周边公司双11可能都加班，你要想吃这碗饭，你说你坚决不加班，那可能这行真的没你位置了。</p><p>第二，在工作效率和表现上体现优势，你不加班，但你做的事情漂亮，任务完成的很好，那你跟领导沟通的时候，也有足够的底气。</p><p>第三，积极沟通，充分理解诉求和目标，减少无用功。这个去年分享课也提过，很多职场的人闷头做事，把简单的事情做复杂，把很容易处理的问题扩大化，实际上很多都是一厢情愿造成的。多沟通，深入了解诉求，学会把握重点，抓大放小，很多时候，看上去很复杂的工作任务，其实可能没那么复杂，要允许领导描述不清，但自己应该具有进一步核对和澄清的能力。事情多的做不完，最后发现都是无用功，这种情况在职场真的非常常见的！</p><p>第四，部分任务可以考虑在家完成，我在西雅图见一个老朋友，<code>FB</code> 的华人技术经理，美国名校博士，我们觉得美国公司不加班，其实他说很辛苦的，给我看他的日常任务排期，从早到下午都是会议，然后说，白天上班根本没时间写代码，而自己还是有很多代码任务的，怎么办，晚上回家写。</p><p>是的，因为要接孩子，从不在公司加班，但实际上每天都要工作到很晚。 据说在 <code>FB</code> 这种情况并不少见。 其实美国也不止是 <code>FB</code> 如此，西方互联网巨头，很多人工作也是蛮辛苦的。</p><p>这就存在一个跟领导沟通的问题，家里确实有事情，不能在公司加班，但应该完成的工作任务会在家里完成，不会影响进度。实际上家里如果干扰少一些，完成的效率会更高。可能在公司需要几个小时扯皮交流然后慢慢熬的任务，回家后一个小时，甚至半个小时就搞定了。而且你不用去想着如何偷懒摸鱼，早干完时间都是自己的。</p><p>第五，认清现实，我们讲正确呢，说一个好的企业不应该大量无效加班，但另一方面，我们在职场，确实很多事情不是自己认为对就可以的。</p><p>如果你能选择一个不加班，待遇好，成长好，而且还能发挥你优势的岗位，当然，我恭喜你。</p><p>如果你发现很多条件不能兼顾，想清楚自己想要什么，这点很重要。</p><p>选择offer 的时候，很多时候你不可能拿到完全满意的条件，这时候，什么是你当前最看重的，我不能替你做主。</p><p>我去年讲过职场的成长期，成熟期和变现期，不同期间不同诉求，但不同的人有不同选择，不要苛求完美的职场，不要苛求完美的工作，想好自己这一步能获得什么很重要。</p><p> <a href="https://mp.weixin.qq.com/s/Gz5rBTpMdFkNZUZKlV7D4Q" target="_blank" rel="noopener">「关于程序员的996，我们谈谈历史和逻辑」</a></p><h3 id="2-3-面对事故和问题"><a href="#2-3-面对事故和问题" class="headerlink" title="2.3 面对事故和问题"></a>2.3 面对事故和问题</h3><p>职场经常会遇到一些严重的事故，问题，障碍。<br>很多人觉得我必须努力解决掉所有问题，再去给领导汇报，这样可能显得自己比较厉害和负责。</p><p>当然，如果你能尽快的解决掉问题，处理完事故，然后写汇报，这是没问题的，但很多时候，你可能没办法快速解决，快速处理，而且，甚至可能这个问题会影响到很多关联的同事，很多相关工作和计划安排，这时候，你如果还是憋着自己去解决，不汇报，不通知，就非常要命了。</p><p>一定要有全局意识，如果问题会导致其他人的工作延期或者对别人的工作有重要影响，或者超出个人能力范围，一定要主动知会相关人员，并寻求协助。</p><p>就算你工作很努力，一直很拼，很竭尽全力的处理问题，你认为自己的表现已经足够好了，但因为你没有知会关联同事，影响了其他人的进度和主管的项目把控，你这个努力也不能扭转这个损害，你觉得自己委屈，出bug，出故障难道不是很常见的事情么，出问题可以说不是什么太大的责任，但不通报是严重的灾难。当你成为经理，总监，或更高层的管理者，你就明白为什么这么说了。</p><p>我经常对自己公司的员工说这样的话，但我发现很多人依然还是我行我素，自己闷头去处理问题，闷头解决问题，不通报，不知会，总想着解决完再告诉我。讲真，这种情况惹得我火很大，这是管理者不能容忍的。</p><p>面对事故和问题，还有一个责任的承担问题，其实遇到事故，遇到问题，第一重要的是尽快解决问题，责任不要急于撇清，不要急于去分辨，先解决问题。不要说，这不是我的责任，这不是我的错，先说，我现在就去检查，去解决。解决完，处理完，写汇报的时候，再去说明真实原因和逻辑。</p><p>那么该自己承担的责任，要敢于承担，不要总是想着甩锅，总是想着辩白，大部分主管和领导都不傻，年轻人进入职场，千万不要小聪明，很容易被识破，如果发现你不诚实，没担当，这个问题的严重性远远大于你犯了错误。</p><p>但承担责任，敢于担当，也要有具体的行动，比如如何弥补，如何有效的预防类似的问题，如何进一步提升自己的问题解决能力，而不是每次都态度诚恳的道歉，认错。你总是态度很诚恳，但总是犯同样的错误，这也不行对不对。</p><p>我在职场真的见识过那些会甩锅，会推卸责任的年轻人，我说实话，可能一次两次，领导没有真的追究，看上去好像平安无事，但后面遇到升职机会或者更好的项目安排的时候，基本上领导是不会给他们的，我是看在眼里的，这样的案例并不少。</p><p>很多时候这些人觉得自己很聪明，每次都没事，但他们并不知道，人家已经给他们在心里打上一个标签。后续无数好机会都跟他们没关系了。</p><h3 id="2-4-面对合作诉求"><a href="#2-4-面对合作诉求" class="headerlink" title="2.4 面对合作诉求"></a>2.4 面对合作诉求</h3><p>第一，是跟上司和领导通报。很多内部合作，别人来找你，你觉得不麻烦，或者是对方级别比较高，你不敢得罪，就去给人家做事情了，但你的直接上司不知道，你影响本职工作进度，或者有些数据和信息处理是未经授权的，这其实就非常糟糕了。我以前就不是太在意这个，总觉得我为了公司难道不对么？你的上司有权决定这件事该做还是不该做，以及该如何做。你说我私下不影响进度帮同事忙行不行，有些信息数据授权的问题要考虑的，企业内部也有风控，很多你不以为然的事情可能是有严重问题的。遇到严格的内部审计吃不了兜着走的。要通报，要征询上司的授权，不要总觉得无所谓，可能一两次上司没有追究你的问题，但是记着，他心理可能给你打标签了，你没有尊重他的管理职权，他以后怎么会信任你。</p><p><a href="https://mp.weixin.qq.com/s/RLy79oG-ovYr23oOWUPrgA" target="_blank" rel="noopener">「那些用力过猛的员工」</a></p><p>第二，是外部合作中，关于利益诉求和目标的问题，以前旧文也提过，很多职场的人会用力过猛，以为自己为公司特别尽力，各种事情务必在自己公司角度争取最大利益，其实是很糟糕的，因为长远的合作需要双赢，也需要持续的信任。太鸡贼太苛求实际上过犹不及。<br>包括自媒体合作也是，有些企业的公关恨不得自媒体作者所有数据都提供清清楚楚，内容版式改上七八遍各种调整，各种朋友圈微信群都要给他们发一轮，似乎他们这样是为了公司的宣传效果，体现工作价值。坦白说，遇到我和冯老师这种大V，合作一次就烦了，爱做不做，爱信不信，唧唧歪歪，不伺候行不行啊。反而有些简单明了的，他们轻松，我们也轻松，长期合作，我们特么的也不会为了赚他一笔广告费砸自己招牌对不对。确实效果不太好的，不用广告主说，看到数据不理想，我直接补送一个位置就是了。<br>合作的要点，总结一下，一是向上汇报，二是双赢互利互信。别鸡贼，别什么便宜都想赚，多换位思考。</p><h3 id="2-5-面对可能的误解和委屈"><a href="#2-5-面对可能的误解和委屈" class="headerlink" title="2.5 面对可能的误解和委屈"></a>2.5 面对可能的误解和委屈</h3><p>职场中会不会背锅，有没有委屈，会不会被误解。肯定有，而且很常见。</p><p>但我说句潜规则，领导会喜欢那些经得起委屈，扛得起批评的人。很多事情，时间会给出不同的答案。当年王坚博士搞阿里云的时候被批判的还少么，全公司大会上被几乎各个部门吐槽，最后怎样，现在叫王坚院士。</p><p>还有就是，其实有不少领导，只有对亲信才会批头就骂，毫不留情。你看他对你客客气气，从不大声指责，说实话，根本就没拿你当自己人。</p><p>做好手头的工作，用事实来证明自己，事实是最好的辩解。当然，并不是说遭到误解就不解释，有些真的需要时间来证明，有些可能需要深入的沟通，但这里有两点要说明，第一，就事论事，切忌情绪化和人身攻击。否则对的也会变错。第二，只列事实即可，不要臆测，不要假设，不要扣帽子。事实如此，不要说对方是怎样怎样陷害你，这些都是臆测，而且很多都是错误的臆测。</p><p>当然，职场还有一个潜规则，就是尽可能有证据留存，比如沟通邮件，会议记录，确认通知。遇到扯皮的时候，没有证据，就没办法证明责任了，比如某个需求到底是谁提出的，为什么这么提，你明明只是执行者，但是需求方说没提过，你百口莫辩。</p><p>最后，还是要强调，职场不能怕委屈，不能怕误解，时间真的会给出证明。你背了锅，也许你的领导不清楚，但也许别人清楚，公司发展过程中，每个人的角色都会变化，只要你自己不要自暴自弃，总会有新的机会，在某些人眼里，你的委屈甚至是加分项。</p><h3 id="2-6-不吝称赞"><a href="#2-6-不吝称赞" class="headerlink" title="2.6 不吝称赞"></a>2.6 不吝称赞</h3><p><a href="https://mp.weixin.qq.com/s/b0vPDniK3S1KcfWtTQ27lQ" target="_blank" rel="noopener">「再谈职场中的用力过猛」</a></p><p>读书的时候，经常会有一个坏习惯，嘴比较损，特别喜欢揶揄别人，并认为这是关系亲密的象征。说实话，这个问题很常见，我也不例外。</p><p>但职场有时候不自觉就会得罪人。而且自己还以为彼此关系很融洽。</p><p>很多人不喜欢称赞别人，觉得是拍马屁，觉得是奉承。</p><p>我这么说吧，如果人家做的真的好，确实体现了水平，你就应该正面的称赞别人，职场情商里，最重要的就是这条。</p><p>特别是团队合作，项目总结，要感谢所有帮助过你的同事，上司，下属，感谢每个做出贡献的人，并如实的称赞他们的功劳。<br>下属习惯想当然，不知道问一下主管–本来可以避免的。</p><p>赞美他人会让你的职场和社交关系突飞猛进，真的。<br>把那些用于揶揄挖苦的语言天赋转为赞美，你的职场之路会完全不同。<br>实话说，我也不喜欢奉承，拍马屁，很多名气很大的人我也不给面子的，但我认为如实称赞是非常值得的，很多人在某些领域很优秀，首先，你应该看的到，然后，也应该说出来。</p><h2 id="3-信任是如何产生的"><a href="#3-信任是如何产生的" class="headerlink" title="3 信任是如何产生的"></a>3 信任是如何产生的</h2><p>职场信任关系是极为关键的，取得信任才能获得更多的机会，那么信任不是一蹴而就的，需要积累，以下是信任关系的一些要点。</p><h3 id="3-1-正确而及时的汇报"><a href="#3-1-正确而及时的汇报" class="headerlink" title="3.1 正确而及时的汇报"></a>3.1 正确而及时的汇报</h3><p><a href="https://mp.weixin.qq.com/s/tlw7hm9No7WNnaDqozyB7w" target="_blank" rel="noopener">「谈谈主动工作」</a><br><a href="https://mp.weixin.qq.com/s/fWx_JY6tcrYr8DJ6YmPeog" target="_blank" rel="noopener">「职场推进屡屡受阻，别总找借口。」</a></p><p>常见问题，该汇报而不汇报<br>任何可能导致你所承诺的时间计划任务产生变动的因表和事任何可能需要上一级授权的事件和工作。<br>任何可能影响团队其他人或公司其他团队工作安排和计划的因素和事件。<br>里程碑事件，进度变化，任务状态需要其他团队协助，资源协助的事件和工作。</p><p>很多人闷头做事，自己闷头解决问题，不汇报。不知会，总想着自己解决完问题再汇报，我再次强调，这是极为糟糕的！我自己团队有这种情况，我是极为火大的，如果你是创业者，你就能理解为什么这种情况极为糟糕。因为很多项目进度和后续安排，彻底失控。</p><p>我希望读者理解，作为管理者，最怕的不是问题和困难，而是失控，完金无法掌握项目的进度，障碍和影响范畴。<br>很多闷头做事的人犯了严重的错误而自己不知道，觉得自己很辛若，觉得别人天天打小报告的还能升职，你导致了领导失控，你还觉得自己没问题。</p><p>常见误区，不该汇报而频繁汇报自己职权内完全可以处理并解决的问题和事件。<br>无意义的表功表忠心<br>流水账，工作清单记录</p><p>汇报什么呢，我今天做了什么，我完成了什么，我解决了什么问题，我学习体会了领导的讲话，一切都是表达我很努力，很认真，很勤奋的工作。<br>这种普通员工这么写呢，也不是什么大问题，但如果你有一定职务级别，这样写是很糖糕的。因为这些事情，很多是上级完全不关心的。</p><p>我为什么要关心你今天写了什么代码，解决了什么问题，我要关心的是你进度到哪里了，你任务完成的如何了，预计上线时间会不会有影响，对项目团队有没有影响，需要不需要我做什么<br>很多人觉得自己汇报的很详纽，工作量很大，但为什么每次升职都轮不到自己，人家觉得你就是一个闷头干活的，根本抓不住重点讲，连份汇报都写不好，还谈什么升职。</p><p>认真的想想，如果你是领导，底下人的汇报对你来说意味着什么，是让你继续掌控项目的进展和状况，同时让你知道你需要做什么来推动这个项目前进，解决中间的问题。很多人认为汇报就是说自己工作多努力多辛苦多了不起。骨子上就错了。</p><h3 id="3-2-完成任务是第一位的"><a href="#3-2-完成任务是第一位的" class="headerlink" title="3.2 完成任务是第一位的"></a>3.2 完成任务是第一位的</h3><p>很多人觉得怀才不遇，我有很好的想法领导不采纳，我有很棒的建议领导不肯听。或者我的方案比领导的更好。</p><p>是真的么？也许是真的，但问题是，领导凭什么相信你呢？这是需要过程的，而这个过程最核心的就是，你要先把交代的任务做好。</p><p>你可以说你有更好的建议，更多的想法，基本的工作没做好，你谈什么其他呢？</p><p>建立信任的第一步，先把交代的任务做好，不管大事小事，完成到位。你说领导的设计不合理，你完成到位，然后项目没有成功，这不是你的责任，但你已经证明你自己可以做好事情，建立了做事靠谱的印象分，你再提出新的方案，新的计划，被接受的可能性更大一些。</p><p>嫌弃工作不重要，嫌弃事情没有办法体现你的能力和价值，但又不好好做，应付，错漏百出，然后埋怨领导不给你更好的机会，不让你做更有挑战的工作或者完成你更伟大的梦想，信任基础啊。</p><p>很多失败的项目同样可以建立信任基础，你做的好不好，别人看的出来，失败的原因，别人能想明白，你自己没做好，说是别人设计问题，这个你推卸不出去的。你至少要让自己的表现足够好。</p><h3 id="3-3-提出有价值的问题，不断提出有价值的问题"><a href="#3-3-提出有价值的问题，不断提出有价值的问题" class="headerlink" title="3.3 提出有价值的问题，不断提出有价值的问题"></a>3.3 提出有价值的问题，不断提出有价值的问题</h3><p><a href="https://mp.weixin.qq.com/s?__biz=MzI0MjA1Mjg2Ng==&mid=209695455&idx=1&sn=4d9a296a87f9525907e1e58c85b0648b&scene=21#wechat_redirect" target="_blank" rel="noopener">「提问的技术」</a><br><a href="https://mp.weixin.qq.com/s/QXEg4oK48G0X-AV3X9c2NQ" target="_blank" rel="noopener">「从校园到职场 - 提问与交流」</a> </p><p>不要怕提问，不要不敢提问，其实提出有价值的问题，是建立职场信任很关键的步骤。</p><p>上司讲解了产品设计目标，你提出关键的一些要点问题，这证明什么，第一，你认真的去理解上司的讲话了，第二，你有自己的深入思考，第三，你能从中发现一些关键点，关键问题。</p><p>提出有价值问题的人，更容易得到好的项目机会和升迁机会，真的。欧美更是如此，我以前讲过，新加坡英语职场培训，案例里，乖乖记录不提问的是坏案例，而能举一反三提出有价值问题的是好案例。不懂必须问清楚是这边职场很重要的原则。</p><p>当然，尽量不要问蠢问题，什么是蠢问题，你一个设计师去问马云，集团下一步的海外战略是什么，听上去很高大上，其实是个蠢问题。</p><p>与自己工作职能目标密切相关，具有一定的合理选择范围，并且需要一定的洞察力才能回答的问题，那种根本不用选择的问题也是蠢问题，比如，问上司，咱们是要做合法的产品还是违法的？你说呢。</p><p>如果对问题的答案表示质疑，也可以合理指出，请问为什么我们会选择这样一个方案，从而理解方案动机和选择逻辑，这对工作中很多重要选择很有帮助，你才知道什么是你应该关注的，是应该重视的，什么不是。</p><h3 id="3-4-不要试图掩盖自己的弱点，要主动寻求帮助和提升"><a href="#3-4-不要试图掩盖自己的弱点，要主动寻求帮助和提升" class="headerlink" title="3.4 不要试图掩盖自己的弱点，要主动寻求帮助和提升"></a>3.4 不要试图掩盖自己的弱点，要主动寻求帮助和提升</h3><p>很多年轻人知道自己存在缺点和不足，不希望领导知道，尽量去隐瞒，用其他借口和理由规避自己的不足，其实我年轻时候也会这样。<br>主动寻求帮助和提升，其实更容易建立与领导的信任。</p><p>第一，坦诚是有长期复利的。<br>第二，从心理学来说，领导会认为，帮助你成长是他的成本，他有回报预期，而他的回报预期，就是你向上的机会。<br>第三，以前科举，学子们中榜后要去拜老师，递门生贴，我希望你们能理解这个背后的含义是什么，你主动寻求领导的帮助和提升，其实也是递门生贴。</p><h3 id="3-5-扛得住委屈，忍得住寂寞，坚持出成果"><a href="#3-5-扛得住委屈，忍得住寂寞，坚持出成果" class="headerlink" title="3.5 扛得住委屈，忍得住寂寞，坚持出成果"></a>3.5 扛得住委屈，忍得住寂寞，坚持出成果</h3><p>有些委屈，需要时间来证明，那就花点时间去证明。</p><p>有时候，别人风光在前，你觉得不公平，但自己做好自己的事情，很多时候，时间会给你公平，这样的案例我在职场看到太多了，不要说三十年河东，三十年河西，风光一时的可能没有一两年就原形必露，而扎扎实实做事情的不会总是被埋没。当然，这里依然要强调沟通和汇报的能力。但你要做出证明自己的成果，不要总是因为一时委屈和埋怨就半途而废。</p><p>市场需要成熟期，产品需要成熟期，用户也需要成熟期，一些被批评的体无完肤的产品，可能几年后就成为明星爆款，不说别的，当年大话西游不就是么。更早之前，周星驰龙套憋屈了多少年，做出证明自己的成果，是最令人信服的反击质疑和押击的方式。</p><h2 id="4-如何面对不公平"><a href="#4-如何面对不公平" class="headerlink" title="4 如何面对不公平"></a>4 如何面对不公平</h2><h3 id="4-1-世界就没有公平"><a href="#4-1-世界就没有公平" class="headerlink" title="4.1 世界就没有公平"></a>4.1 世界就没有公平</h3><p> <a href="https://mp.weixin.qq.com/s/Si_Hrk6GBP7uGbY3C-gOlA" target="_blank" rel="noopener">「从校园到职场，很抱歉，世界并不按你的计划前进」</a><br><a href="http://mp.weixin.qq.com/s?__biz=MzI0MjA1Mjg2Ng==&mid=2649867486&idx=1&sn=d5a15a242f7c55d5b62195f51b768722&chksm=f1075eb3c670d7a5b837eeefd98051c02b624668e3583afceee15eedb0a6ae3dfb6f0d4eae61&scene=21#wechat_redirect" target="_blank" rel="noopener">「从“自相矛盾”的一些问题来谈谈认知」</a><br><a href="http://mp.weixin.qq.com/s?__biz=MzI0MjA1Mjg2Ng==&mid=2649867005&idx=1&sn=8d2c47cead54264afbfc0bc628f48a0c&chksm=f1075890c670d186792521e0afa1ed2e1e8162d26786ba58fe384002cd566aa9721c76ee17ff&scene=21#wechat_redirect" target="_blank" rel="noopener">「谈谈容错性」</a></p><p>你需要的是机会，和提升自己把握机会的能力，别人机会比你多，别人比你条件优越，没办法的，人从基因就开始不公平，投胎也不公平，你怎么办，就放弃自己重新投胎了？<br>最重要的是有没有自己向上，前进的机会，没有机会，再好的企业氛围，领导重视，公司环境，不要留恋。有很好的机会，那些噪音，可能的不公平，真的不用那么看重。</p><h3 id="4-2-确认自己的投入产出合理性"><a href="#4-2-确认自己的投入产出合理性" class="headerlink" title="4.2 确认自己的投入产出合理性"></a>4.2 确认自己的投入产出合理性</h3><p>你投入的时间，精力，资源，和你所获得的回报，从行业来说，从其他平台对比来说，这份回报是否合理，是否值得，值得，这就是很好的工作，很好的事情。你说某某某不如你比你回报高，这种心态要不得。如果你觉得不值得，你可以找到投入产出回报更高的平台和职位，那就转身离开，你说公司已经特殊照顾你了，这不重要。</p><h3 id="4-3-良好的沟通方式"><a href="#4-3-良好的沟通方式" class="headerlink" title="4.3 良好的沟通方式"></a>4.3 良好的沟通方式</h3><p>确实遭遇到职场不平，涉及维权，涉及解释，涉及赔偿，几个原则。</p><p>其实前面段落提过的，重述一下<br>第一，就事论事，切忌情绪化和人身攻击。否则对的也会变错。<br>第二，只列事实即可，不要魔测，不要假设，不要扣帽子。第三，尽量留存足够的证据，如果真的没有证据，有些事也真的没办法追索。<br>那么这里多加一条，第四，一旦涉及维权相关，务必通过律师和第三方进行，尽量不要自己直接追索，维权尺度一定要听律师的，不要认为自己占理就过度维权。<br>这一条关键时刻是救命的。</p><h3 id="4-4-干净的离开"><a href="#4-4-干净的离开" class="headerlink" title="4.4 干净的离开"></a>4.4 干净的离开</h3><p>如果确实无法继续工作，希望换个环境，那我想说一点，干净的离开。</p><p>不要自作聪明的搞一些报复行为，不要做一些可能违反法律风险的事情，不要以为自己可以要挟东家或者可以通过某种手段逼对方就范。</p><p>中国现在的执法力度非常强大，而且，说实话，很多时候，你意气用事，对的也会变错，本来可以合法争取的权益，也会输得干干净净。</p><p>干净的离开，长期来说，会有很好的口碑，很多企业会做尽调，不干净的事情，就算一时得逞，你也瞒不了太久。江湖并不大，很多人总会在不同场合遇到，尽量不要树敌太多。</p><h2 id="5-晋升的秘密"><a href="#5-晋升的秘密" class="headerlink" title="5 晋升的秘密"></a>5 晋升的秘密</h2><p>领导是如何选择晋升的人选，是不是干活最多的那个，是不是能力最强的那个，很多时候，其实并不是，这一点，我希望读者能够理解，并不是因为谁谁会来事，会做人，而是你没有站在更高的角度看问题。</p><p><a href="https://mp.weixin.qq.com/s/_nx-v_-j_U9V1SRhp4Wltw" target="_blank" rel="noopener">「如何提拔骨干及挑选接班人」</a><br><a href="http://mp.weixin.qq.com/s?__biz=MzI0MjA1Mjg2Ng==&mid=2649867267&idx=1&sn=004bcc8fd248edf7340bdc5f45032b23&chksm=f1075e6ec670d778e98d7b18f85d7328184e22f44347392d6546040888723f36b791b7980b84&scene=21#wechat_redirect" target="_blank" rel="noopener">「当我们追求不可替代。。。」</a></p><h3 id="5-1-团队的信任和支持"><a href="#5-1-团队的信任和支持" class="headerlink" title="5.1 团队的信任和支持"></a>5.1 团队的信任和支持</h3><p>提拔一个新的负责人。很多时候，要看整个团队是否信任和支持，这一条几乎是绝大部分企业晋升都会考虑的关键因素。包括外聘空降，也会考虑内部团队的人接受程度。</p><p>提拔起来的人底下不服气，不支持，是很麻烦的事情。</p><p>所以，平时人缘要好，为什么我说要多称赞别人，团队都信任你，支持你，这一点对晋升机会来说，尤为重要。</p><p>有些人能力很强，但性格不好，处处得罪人，那么怎么提拔？</p><p>别说老板不给你机会，老板希望的是团队的稳定和可控。</p><h3 id="5-2-良好的汇报能力和沟通能力"><a href="#5-2-良好的汇报能力和沟通能力" class="headerlink" title="5.2 良好的汇报能力和沟通能力"></a>5.2 良好的汇报能力和沟通能力</h3><p>前面提到信任关系里，汇报能力很重要，那么沟通能力也很重要。</p><p>光闷头干活，不懂得及时汇报，或者什么破事小事都汇报，你让领导怎么用你，这种提拔起来，项目团队会失控的。</p><p>沟通能力也很重要，你可能团队里大家都很信服你，其他团队，其他部门，沟通少，经常互相不对付，老板也头大对不对，能不能协调资源，沟通不同团队的人员共同完成任务，既然要提拔你作为主管/经理，不能事事都靠上面的大老板，自己要担当这方面的事情对不对。</p><p>沟通还包括什么，如何培养新人，如何提升团队干劲，自己一个人吭哧吭哧加班干活，团队懒洋洋，新人不成长，你觉得做负责人合适么。</p><h3 id="5-3-具有向上管理的能力和思维方式"><a href="#5-3-具有向上管理的能力和思维方式" class="headerlink" title="5.3 具有向上管理的能力和思维方式"></a>5.3 具有向上管理的能力和思维方式</h3><p><a href="https://mp.weixin.qq.com/s/3kzCHGH1E9BXpT1TkS-xZw" target="_blank" rel="noopener">「如何管理和指挥你的上司」</a><br><a href="http://mp.weixin.qq.com/s?__biz=MzI0MjA1Mjg2Ng==&mid=2649867315&idx=1&sn=5e379424b25a683b8be38c3ef0bb83f0&chksm=f1075e5ec670d7488cf5149ac152028e70737963651a287992bf77a0126ab5c663a2b33c043f&scene=21#wechat_redirect" target="_blank" rel="noopener">「从校园到职场 - 技能与职位」</a><br><a href="http://mp.weixin.qq.com/s?__biz=MzI0MjA1Mjg2Ng==&mid=2649867335&idx=1&sn=6d160634a420161b936f53fa54bec4a2&chksm=f1075e2ac670d73c9777004711d959b725c0d8d471a6a7717bbe4b4d78d66904dee8db8606fd&scene=21#wechat_redirect" target="_blank" rel="noopener">「从技术到管理」</a><br><a href="http://mp.weixin.qq.com/s?__biz=MzI0MjA1Mjg2Ng==&mid=2649866907&idx=1&sn=df64810a067a9f1cbbb3c45f8ad8d38c&scene=21#wechat_redirect" target="_blank" rel="noopener">「浅谈领导力之 - 价值决策」</a></p><p>什么叫向上管理，不能什么事情都等着上面分配，上面指挥，上面发现问题告诉你如何解决。要更主动，更积极一点，主动发现问题，主动承揽任务，主动寻求上司的支持和资源调配。我以前也强调过，能把老板利用起来的才是好的项目负责人，老板有时候也是一手好牌，使不上劲懂不懂，老板的人脉资源，老板的社会影响力，如果你的项目足够好，让老板用他的资源配合你，老板开心还来不及。</p><p>当然，强调一下，向上管理是有前提的，信任关系，没有信任关系，老板不可能听你的。信任关系一定是基础，路要一步步走，饭要一口口吃。</p><h3 id="5-4-对产品，业务的理解具有全面性"><a href="#5-4-对产品，业务的理解具有全面性" class="headerlink" title="5.4 对产品，业务的理解具有全面性"></a>5.4 对产品，业务的理解具有全面性</h3><p>到达一定级别的时候，需要的不是你某个领域特定的能力，你需要站在一定高度看问题，所谓全局观，你需要对产品业务的逻辑具有完整的理解，因为你需要对很多关键行为，做出判断，什么是进一步优化的方向，什么是产品的阶段性目标，这时候，你不能只停留在可以把事情做好的地步。</p><p>不要急于上升到战略高度，但工作中做的每件事情，尽可能理解其背后的逻辑，来龙去脉，业务关系，商业途径。</p><p>以前我在百度的时候，做产品经理，我江湖经验多一点，百度很多研发都是那种，怎么说呢，刚毕业进百度，社会经验几乎是0，代码写的不错，但对所谓联盟流量获利的途径，个人草根站长和百度关系什么的，其实都是一知半解，甚至是没有感觉的。</p><p>这时候你会发现，有的人就好奇心很重，写程序看产品设计的时候，会多问一些为什么，会好奇背后的设计思路和逻辑是什么，我也好为人师，你来问，我就讲这些站长是怎么赚钱的，以及怎么赫百度羊毛的，所以我们的产品应该怎么设计，既要共赢，又要防止被对不对。</p><p>那么这些特别喜欢问，特别好奇的程序员，我都记着呢，后来发展的都特别好，跟着很厉害的人去创业，现在好几个这样的程序员身价都好几个亿了，比如多盟的 <code>CTO</code> 王鹏云，还有跟谁学的合伙人张怀亭，都是典型的例子，当年都是这么过来的。也有的就闷头做事，你让我干什么就干什么，懒得问，遇到问题就是你设计没写清楚。从代码能力来说，和前者有差距么？没什么差距的，但从职场发展来说，很容易就看到差距了。</p><h3 id="5-5-能把握关键问题，具有发现问题的能力"><a href="#5-5-能把握关键问题，具有发现问题的能力" class="headerlink" title="5.5 能把握关键问题，具有发现问题的能力"></a>5.5 能把握关键问题，具有发现问题的能力</h3><p>有的的人擅长解决问题，当然很好，但作为管理者，应该擅长发现问题。不要等服务器崩溃了才知道性能负载需要优化。不要等用户规模化流失了才知道产品体验需要改进，不要等无可挽回的时候才知道系统存在问题了。</p><p>要在出现苗头，或者有一些不好的迹象的时候，快速敏锐的发现问题，在还没有出现严重状况的时候，就把风险遏制住。这对管理者来说，非常重要。发现问题，才能有效的分配任务，安排任务，确立目标。</p><p>管理者发现问题不一定完全靠自己，毕竟个人的能力和所获取的信息是有限的，要懂得如何收集信息，如何建立信息分析的网络，以及如何有效的甄别不同渠道的信息反馈。</p><p>所谓发现问题的能力，既包括个人的信息敏锐度，其实也包括一整套信息分析的方法体系。哪怕这套信息架构是前任领导建立的，至少你要能透彻领悟和接手。</p><p>很多时候，一些新上任的管理者，习惯呼啦啦的解决一堆遗留问题彰显自己的才能，却忽视了发现问题和分析问题的手段，对前任留下的信息渠道和网络不重视，甚至从不使用，结果直到出现严重问题的时候无法收场。</p><h3 id="5-6-信任度是关键项"><a href="#5-6-信任度是关键项" class="headerlink" title="5.6 信任度是关键项"></a>5.6 信任度是关键项</h3><p>其实前面一直都强调过了，首先要建立与上司和老板信任关系，才有以上其他，信任是需要证明的，如果没有证明自己值得信任，那就什么都不用提了。</p><p>信任是怎么确立的，件件有着落，事事有回声。还是那句话，有时候你参与一个项目，项目失败了，是不是你失败了？如果在项目中，你的工作表现很好，指派的任务完成得很到位，项目失败不等于你的失败，领导依然会让你肩负其他重任，这一点在很多巨头里你都能看到案例，很多内部失败项目出来的人，有的人会被争抢，有的人还会升职。关键要自己做到位。</p><p>关于建立信任的章节，多仔细再看看。</p><h2 id="6-企业永远不是家"><a href="#6-企业永远不是家" class="headerlink" title="6 企业永远不是家"></a>6 企业永远不是家</h2><p> <a href="https://mp.weixin.qq.com/s/Yxks9eEohmtHCmJFDX37pA" target="_blank" rel="noopener">「谈谈企业福利」</a></p><p>我们讲半天说如何让老板信任，如何获得团队的认可，但这里为什么要说这句呢。再好的老板，再好的团队，不是你的家庭，不是你的亲人。我希望读者务必明确这一点。刘强东说，我们不会亏待和放弃任何一个兄弟。<br>刘强东又说，那些跟不上我们脚步的人，不是我们兄弟。</p><p>很简单，企业文化再吸引人，解释权不归你所有。</p><p>再者，任何企业都有持续维持的风险，哪怕老板特别好，真的人品没得挑，公司如果出现经营困难，老板也不可能变卖家产养你对不对。除非老板是你父母，另当别论。</p><h3 id="6-1-维持职场竞争力"><a href="#6-1-维持职场竞争力" class="headerlink" title="6.1 维持职场竞争力"></a>6.1 维持职场竞争力</h3><p><a href="https://mp.weixin.qq.com/s/qef3o4tygS2LR1AW56jcmA" target="_blank" rel="noopener">「当你面临选择，所谓经验可能一文不值」</a><br><a href="http://mp.weixin.qq.com/s?__biz=MzI0MjA1Mjg2Ng==&mid=2649867713&idx=1&sn=829698f78d0b922fe53f4fee8fa06b79&chksm=f1075facc670d6ba10ccae3d50a6fc068b27ea54e3efb67a598c8af9202cf69cd7dbc23d1122&scene=21#wechat_redirect" target="_blank" rel="noopener">「与时俱进，拥抱变化」</a></p><p>除非你能做到财务自由，或者已经有足够的养活自己的手段。否则，务必要维系自己的职场竞争力，保持自己在职场上有足够的选择权，永远不要认为自己的职场路线会越来越上升，35岁以后，很多工作机会会骤然消失。</p><p>如何维系职场竞争力，第一要不断学习新东西，保持知识面和信息面不要受限。第二要建立业内影响力，能够被一些业内有资源的人所赏识认可。第三要多帮助有潜质的人，现在你帮助过的有潜力年轻人，可能未来成长壮大，遇到一些状况，没准会给你机会收留你。</p><h3 id="6-2-有好的机会要把握"><a href="#6-2-有好的机会要把握" class="headerlink" title="6.2 有好的机会要把握"></a>6.2 有好的机会要把握</h3><p>公司对我很好，老板对我很好，但从职场而言，你尽职尽责的工作，就是对得起他们，如果遇到更好的机会，能够上一个台阶，能够在职场地位，收入上有较大的进步，我的建议是，不要舍不得老板，舍不得同事，真的不要舍不得。</p><p>当然，如果非要抬杠说，有可能留在原公司未来回报更高呢，比如当年阿里不也一穷二白么？我解释一下，这是职场判断问题，如果你判断错了，那就是判断错了，这是另一个话题。但我要说的是，不要为了所谓情感，而失去更好的发展机会。</p><p>我见过有这样的朋友，为了报答老板的知遇之恩，想再干几年，有个好的结果再走，但是，再干几年，不好意思，35岁以上了，以前很好的机会，已经没有了。其实真的不值得，而且，很可能，对老板而言，你没有自己想象的那么重要。</p><h3 id="6-3-止损，止损，一定要止损"><a href="#6-3-止损，止损，一定要止损" class="headerlink" title="6.3 止损，止损，一定要止损"></a>6.3 止损，止损，一定要止损</h3><p>如果公司遇到较大的风险，工资无法发放，经营存在法律风险。</p><p>该走立即要走，不要说，现在走了拿不到什么什么，再过几个月没准如何如何。</p><p>止损务必要果断！</p><p>维权也是，适度维权，不要为了一点点维权利益，把自己的时间和精力都耗进去，你要明白你的前途比那些值钱。</p><h3 id="6-4-注意个人信用，不要被企业滥用"><a href="#6-4-注意个人信用，不要被企业滥用" class="headerlink" title="6.4 注意个人信用，不要被企业滥用"></a>6.4 注意个人信用，不要被企业滥用</h3><p>很多人已经犯了这样的错误，加入一家金融理财公司，为了完成业绩，为了更好地获得晋升机会，不遗余力的发展身边的亲朋好友购买相关产品，最后爆雷，之前的社交网络完全崩渍。个人信用不要那么容易被企业滥用，不要为了几个月的奖金，一点点奖励，把个人信用和口碑都消耗掉，非常愚蠢的做法。</p><p>现在有些公司新员工入职要用身份证办信用卡，办电话卡，给公司业务用，这个那个的，我看着都觉得害怕，个人征信就这么不当回事么？就真的找不到工作了么？把自己当三和大神了么？</p><p>如果一个企业为了发展，不尊重个人信用，滥用员工个人信用，这种公司尽量脱身。</p><p>还有一种，明知公司快出问题，快要沉船，还出来撒谎安慰闹事的人，这种也很蠢，马上走人就对了，最多闭嘴不说话，这算是对得起老板了。这时候还要消耗个人信用，为了站好最后一班岗，还以为这是职场操守，你不想做反骨仔，你退出江湖行不行啊。</p><h3 id="6-5-再好的上司，老板，不要跟着一起沉船"><a href="#6-5-再好的上司，老板，不要跟着一起沉船" class="headerlink" title="6.5 再好的上司，老板，不要跟着一起沉船"></a>6.5 再好的上司，老板，不要跟着一起沉船</h3><p>如果一个企业存在经营风险，或者多年以来业务没有任何起色，不管上司，老板对你多么好，没必要陪着他们沉没。</p><p>我不会鼓励在职摸鱼，或者说那些违反职场道德和法律的事情，但从业者不要给自己加戏太多，真把企业当家一样，同生共死，那实在不值得。<br>不要认为自己是救世主，时间已经证明，你的忠诚拯救不了任何事情。</p><h3 id="6-6-忠诚度的体现是，在其位谋其事，而不是把命和前途都交给他们"><a href="#6-6-忠诚度的体现是，在其位谋其事，而不是把命和前途都交给他们" class="headerlink" title="6.6 忠诚度的体现是，在其位谋其事，而不是把命和前途都交给他们"></a>6.6 忠诚度的体现是，在其位谋其事，而不是把命和前途都交给他们</h3><p>在职的时候认真工作，全力投入，离职的时候遵守契约，这就是忠诚。不是把命和前途交给别人。记住，企业永远不是家，不要被一时的企业文化口号所蒙蔽，记住再好的企业文化，解释权不在你这里。</p><h2 id="7-所谓副业"><a href="#7-所谓副业" class="headerlink" title="7 所谓副业"></a>7 所谓副业</h2><p><a href="https://mp.weixin.qq.com/s/w8qCG-amQe6dm5yoY9jxbA" target="_blank" rel="noopener">「你适合搞副业么？」</a><br><a href="http://mp.weixin.qq.com/s?__biz=MzI0MjA1Mjg2Ng==&mid=2649868955&idx=1&sn=7fcd8e1d034bfce14c954207c05a1b18&chksm=f10750f6c670d9e0edb12ebae725d47780bf0aee01f7c3a7032e270fbc0d5521d0dba7a0c44d&scene=21#wechat_redirect" target="_blank" rel="noopener">「副业赚钱这事，靠谱么？」</a></p><p>很多人都关心副业话题，其实我旧文写过关于副业的文章，我的观点都在里面，今天不会展开太多。</p><h3 id="7-1-副业往往是职场忌讳"><a href="#7-1-副业往往是职场忌讳" class="headerlink" title="7.1 副业往往是职场忌讳"></a>7.1 副业往往是职场忌讳</h3><p>大部分企业和管理者，会忌讳员工搞副业，如果你想在职场精进，我建议你不要投入太多精力和时间在副业上。<br>副业的禁忌其实非常多，竞业，职务侵占，内幕交易等，很容易碰雷，一旦遭遇法务追究，基本上能幸免的极少。</p><p>有的人觉得，我的副业和我的工作没关系，那你分心二用，而且没有办法利用你职场优势，你折腾啥呢？</p><p>昨天新闻里说，<code>google</code> 也不是很允许个人业余研发当作副业。以及最近 <code>nginx</code> 创始人被抓的案例，真的不止是中国的公司不允许。</p><p> <a href="https://mp.weixin.qq.com/s/S3T6V3pevI8cM2PU0DALJA" target="_blank" rel="noopener">「程序员想搞点副业太难了：谷歌已将个人项目归属问题写进雇佣协议」</a></p><p>还有，要强调一句，职场的人会高估你副业的受益，哪怕你亏的一塌糊涂，人家也会认为你赚的很多，更不用说会把你所有工作的过失都归咎于你在副业，这种情况下，别人会心理不平衡，你会失去团队的信任，失去领导的信任，失去同事的支持，也就失去晋升的机会，哪怕你什么都没做错。</p><h3 id="7-2-投资行为相对宽容，但有告知义务"><a href="#7-2-投资行为相对宽容，但有告知义务" class="headerlink" title="7.2 投资行为相对宽容，但有告知义务"></a>7.2 投资行为相对宽容，但有告知义务</h3><p>如果对外有投资项目，相对来说，一些企业会宽松一些，毕竟你没有占用工作的时间和精力，但仍然有告知义务，并且在公司内部也有一些避嫌的考量，比如你投资的项目，恰好是公司的重要供货商和合作伙伴，这其实是非常尴尬的，有的公司是坚决禁止的，有的是你需要避嫌，不参与该供货商选择的任何决策讨论，但很多事是说不清的。</p><p>实际上，很多巨头的高管和中层在外面都有投资项目，也不算是完全的禁忌，只是规避自己职权获利这块注意就行。所以告知是非常重要的，你告知了，而没有规避，责任也容易分担，你没有告知，就很难说了。<br>还有，告知要留证据，不是走过去说一声叫告知，正式写封邮件抄送有关负责人，我在外面有参与某某项目投资，目前该项目与公司有合作洽谈，申请回避。日后追究起来，这封邮件能救命。</p><p>做基金的LP基本上没有任何风险，因为LP不参与决策，所以一般不需要忌讳。但实话说，有些巨头的高管，名义上是外面基金的LP，骨子里做的是GP的事情，这种事，只要大老板不认为有问题，也不会有问题。</p><p>其实很多公司的潜规则是，你投资的项目不去跟竞争对手合作就行。但并不是每个公司都是这么宽容的。</p><h3 id="7-3-企业的敏感度和容忍度"><a href="#7-3-企业的敏感度和容忍度" class="headerlink" title="7.3 企业的敏感度和容忍度"></a>7.3 企业的敏感度和容忍度</h3><p>不同的企业敏感度和容忍度不同，还是前面提到的，有的企业会特别在意你的副业和竞争对手的合作关系.但不在意和自己公司的合作关系。有的敏感度就很高，容忍度很低，这种也不会被允许。</p><p>还有就是职位的容忍度，有些高管可以做的副业，基层是不行的，高管和大老板有信任基础.大老板觉得你不会企业的羊毛.就算第一点，相对于历史贡献，也不会太在意。但基层就不一样了，没有信任基础，那就默认认为你是有问题的。</p><h3 id="7-4-风险性偏好和个人能力资源判断"><a href="#7-4-风险性偏好和个人能力资源判断" class="headerlink" title="7.4 风险性偏好和个人能力资源判断"></a>7.4 风险性偏好和个人能力资源判断</h3><p>网上绝大部分教你副业赚钱的课程和内容都是靠这个话题赚你的钱的，鉴于分辨能力，我建议你一个都不要信。所谓开连锁店.投资什么项目可以坐地收钱，基本没可能。真赚钱的也都是各种精打细算，累的要死，各种踩坑学习总结出来的，没有躺赚的。<br>写文章做自媒体赚钱，我旧文不断强调，可能性不是没有.极低极低。不要总问为什么写了那么久涨不了粉，涨不了是正常的。你写不过半佛仙人的，我都写不过的。</p><p>做影响力，做分享，价值是有的，我一直强调的是，提升业内影响力，一个月写一篇就好，让业内的人看到就好，只要写的够好，几百个人看到也是有价值的，不是靠这个赚钱，是靠这个让你获得更多的业内认可。同时锻炼你表达和总结的能力。坦白说，我看不出有快速复制的适合所有人做副业的项目，你说抖音好不好，快手好不好，公众号好不好，或者这个那个好不好，因人而异，可能极少数人可以成，不具备广泛的复制性。</p><p>先看看你自己能力在哪里，资源在哪里，你对风险的承担力是多少，以及如何正确的评估风险和机会。</p><p> <a href="https:/mp.weixin.qq.com/s/4RB/MifZlaAcYkM76aU8sQ" target="_blank" rel="noopener">「影响力阶级」</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzI0MjA1Mjg2Ng==&mid=2649867195&idx=1&sn=ed55de561442a7a34b162af611ce0c86&chksm=f10759d6c670d0c0ba10e37201199246b5e2c7b916a768afc59505fa2ce45f52e4faf13f6d3e&scene=21#wechat_redirect" target="_blank" rel="noopener">「给我的偷懒找点借口」</a></p><p>任何投资行为，我建议你做好交学费的心理准备。</p><p>其实我也交过不少学费了，我觉得验证一些事情，或者一些人.也不是不可以，关键足，这个学费我交得起才行。</p><h2 id="8-永远不要自作聪明"><a href="#8-永远不要自作聪明" class="headerlink" title="8 永远不要自作聪明"></a>8 永远不要自作聪明</h2><h3 id="8-1-诚实具有持续复利"><a href="#8-1-诚实具有持续复利" class="headerlink" title="8.1 诚实具有持续复利"></a>8.1 诚实具有持续复利</h3><p>很多年轻人会在职场耍小聪明，以为撒点小谎，推卸一下责任，领导不会察觉，其实职场上司很多是老江湖，阅人无数，你的那点伎俩根本逃不过人家眼光，就算一时逃得过，稍微过一段时间，很容易穿帮。</p><p>很多时候，上司和领导真的不会揭穿你，职场上并不是非要绝对正确，有时候看穿不说穿，留点面子给你，但会默默在心理给你打个标签，而你自己还不知道。</p><p>诚实是有复利的，坚持下来你才会知道。</p><h3 id="8-2-不要轻易否定别人"><a href="#8-2-不要轻易否定别人" class="headerlink" title="8.2 不要轻易否定别人"></a>8.2 不要轻易否定别人</h3><p>批评别人很容易，但实际上很多人容易忽视别人的优点，相互尊重是职场生存法则之一，而很多背景还不错的年轻人会有一种天然优越感，学校里惯出来的臭毛病，自以为自己很厉害，自以为职场的人毛病很多。</p><p>比如很多历史遗留问题，自己没有去了解，不知道来龙去脉，批评别人代码不规范，很多逻辑不清晰，其实当时解决的问题场景，所面临的复杂局面，自己根本不知道，人家所用到的技巧和思路，根本没领悟。上去自以为是的调整，很容易闯下大祸。</p><p>还有就是自己加戏的那种，总觉得别人是针对你，是歧视你，是如何的瞧不起你，甚至把别人试图保护你，试图栽培你的苦心当作是恶意，这种情况也挺常见的。</p><p>很多时候，很多年轻人在职场树敌，是自找的，而自己还不知道原委，自己一上来就把别人否定，把别人当敌人，那么人家也不笨，感受到你的恶意，自然会把你当敌人。</p><h3 id="8-3-尽量不要当众指责批评"><a href="#8-3-尽量不要当众指责批评" class="headerlink" title="8.3 尽量不要当众指责批评"></a>8.3 尽量不要当众指责批评</h3><p>有不同意见和不同观点，对对方的安排和决策不满意，可以提么，可以提，但尽可能私下提，一对一提出，如果想留存证据，写一封邮件，不要抄送无关的第三人，然后就事论事，注意态度，不要上纲上线，不要人身攻击。</p><p>除非是非常严重的人品道德问题或者迫不及待要指出的紧急问题，否则尽量留一点空间给别人。</p><h3 id="8-4-不要以己之长评人之短，尊重不同领域的专长"><a href="#8-4-不要以己之长评人之短，尊重不同领域的专长" class="headerlink" title="8.4 不要以己之长评人之短，尊重不同领域的专长"></a>8.4 不要以己之长评人之短，尊重不同领域的专长</h3><p>互相尊重非常重要，如果总是用自己的优点去对比别人，你总是比别人优秀，但别人也有比你强的地方。学会互相尊重，学会互相学习，这一点对个人职场成长和人际关系网络都非常重要。<br>要善于发现和挖掘别人的优点，并给予足够的肯定和鼓励。</p><h3 id="8-5学会对感恩和正向回馈"><a href="#8-5学会对感恩和正向回馈" class="headerlink" title="8.5学会对感恩和正向回馈"></a>8.5学会对感恩和正向回馈</h3><p>得到别人的帮助，一定要表达感谢，不是说一定要给与足够或等额的回馈，但必须有这个表达的过程，并给与正向回馈。不要以为别人帮你是理所当然的，哪怕对方是迫于工作任务，不情愿的帮你，也要表达感谢。<br>我常说的，你微信上请教别人一个问题，也是要给个红包回馈的。也许这个问题超级值钱，远远大于红包的价值，但给一个大红包，毕竟是一种心意。</p><p> <a href="https://mp.weixin.qq.com/s/hsjh6RLTboMYpEetWwb4AQ" target="_blank" rel="noopener">「感恩，不只是一种美德」</a></p><h3 id="8-6-学会站在不同立场的思维方式"><a href="#8-6-学会站在不同立场的思维方式" class="headerlink" title="8.6 学会站在不同立场的思维方式"></a>8.6 学会站在不同立场的思维方式</h3><p>不要总是站在自己的立场评判他人，每个人在不同的立场，会有不同的判断方式，我前面提到了很多，为什么上司，领导在看待一些人的时候，和我们想象的不一样，你站在他的位置的时候，你就会完全明白了。但今天你没机会站在那里，你也能理解，你的格局和视野就真的厉害了。</p><p>站在管理者的立场，你才能理解晋升的关键是什么。站在老板的立场，你才能理解工作的价值是什么。<br>要尽可能站在自己更上一级的立场思考问题，你才能更好的理解你当前工作的意义和价值。</p><h3 id="8-7-不要遮掩问题，要学会认错"><a href="#8-7-不要遮掩问题，要学会认错" class="headerlink" title="8.7 不要遮掩问题，要学会认错"></a>8.7 不要遮掩问题，要学会认错</h3><p><a href="https://mp.weixin.qq.com/s/SQDCbmseIQ-4PQrpzW3SAg" target="_blank" rel="noopener">「年轻人，如何抗造系列之 - 做好自己，留有空间」</a></p><p>遮掩问题，推卸责任往往是很拙劣的一种自作聪明，也是年轻人最容易犯得职场错误。<br>承认错误不丢人，对于大部分企业和领导来说，其实年轻人犯错是被允许的，是培养计划中的一部分。而对错误的反思，复盘，下一步的调整计划，更能体现出你的价值和能力。</p><p>遮掩问题，用更多的谎言去掩盖谎言，很容易穿帮，记住，你不是韦小宝，就算是韦小宝最后也会穿帮。</p><h2 id="9-关于不同领域的职场竞争力"><a href="#9-关于不同领域的职场竞争力" class="headerlink" title="9 关于不同领域的职场竞争力"></a>9 关于不同领域的职场竞争力</h2><p>不同领域，不同行业，可能职场有较大的差距，我不能说我分享的逻辑，一定可以通用所有领域和行业，或者所有企业，我只能说，这代表了我认为较为通用的职场环境，但这里有两个比较大的分支领域，其一，是所谓充分市场竞争领域；其二，是所谓垄断行业；这两个领域的职场，关于升职加薪的重点，有可能是完全不同的。</p><p>怎么思考这个问题呢，在充分市场竞争领域，你的职场竞争力是最重要的，什么是竞争力，就是你的能力和价值，一定会被同行中的某个公司所认可，所需要，这时候你谈领导是否赏识你，老板是否够大方，根本不重要，重要的是你要建立业内影响力，让更多同行老板知道你的能力，这时候就可以待价而沽。</p><p>在垄断领域，所谓职场竞争力就没那么重要了，家庭背景资源更重要，那如果没有怎么办，如何建立信任度就很重要，你必须获得领导和上司的充分信任，才有机会。</p><p>有人问问题，说银行利润这么高，为什么基层工资水平并不高，这个问题很可笑，银行是典型的垄断行业啊！虽然银行间也存在竞争，那是什么竞争，资源的竞争，人脉关系的竞争，你的竞争力在哪里，你说你代码写的好，不重要！那么信任关系如何建立，就是你需要思考的重点了。</p><p>市场竞争才会提升优质人才的身价，这其实是一个很简单的道理，互联网行业的高薪酬来自于残酷的市场竞争，很多人总是想不明白。以为去了利润高的垄断机构可以躺着拿高薪，凭什么啊，先问问你爹是谁？</p><h2 id="10-提升职场容错性"><a href="#10-提升职场容错性" class="headerlink" title="10 提升职场容错性"></a>10 提升职场容错性</h2><p>就是说呢，你要坚持做一些正确的事情，正确的选择，但要允许自己的领导，上司，不那么正确。</p><p>就具体企业，具体职位而言，可能做出了正确的选择，未必得到合理的回报，这是很常见的，世界并不是按照我们的计划前进。</p><p>但职场是个长期的事情，坚持正确的做法，相信时间的裁决。</p><h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><h3 id="1-我领导让我做一件事情，习惯性透出安给我的背景信息（大图、原因、合作方）比较少，曹大您有什么建议吗？"><a href="#1-我领导让我做一件事情，习惯性透出安给我的背景信息（大图、原因、合作方）比较少，曹大您有什么建议吗？" class="headerlink" title="1.我领导让我做一件事情，习惯性透出安给我的背景信息（大图、原因、合作方）比较少，曹大您有什么建议吗？"></a>1.我领导让我做一件事情，习惯性透出安给我的背景信息（大图、原因、合作方）比较少，曹大您有什么建议吗？</h3><p>追问就对了，当然注意态度和方法。</p><h3 id="2-说行政单位的公职人员也类比垄断行业吧？"><a href="#2-说行政单位的公职人员也类比垄断行业吧？" class="headerlink" title="2.说行政单位的公职人员也类比垄断行业吧？"></a>2.说行政单位的公职人员也类比垄断行业吧？</h3><p>是的，肯定是的</p><h3 id="3-问一下曹大，如果我已经在市场竞争行业，和领导起过冲突，后面被穿小鞋，是不是离职换下家才是最优解？"><a href="#3-问一下曹大，如果我已经在市场竞争行业，和领导起过冲突，后面被穿小鞋，是不是离职换下家才是最优解？" class="headerlink" title="3.问一下曹大，如果我已经在市场竞争行业，和领导起过冲突，后面被穿小鞋，是不是离职换下家才是最优解？"></a>3.问一下曹大，如果我已经在市场竞争行业，和领导起过冲突，后面被穿小鞋，是不是离职换下家才是最优解？</h3><p>试试开诚布公的和解，如果无解可以考虑换岗。<br>公司里如果人脉好一点，不要四处树敌，换岗机会应该很多。</p><h3 id="4-如果公司现在问题十分严重，是现在立即找工作吗？还是能等到年后？我在新能源汽车，才工作1年半一边投简历一边上班啊。"><a href="#4-如果公司现在问题十分严重，是现在立即找工作吗？还是能等到年后？我在新能源汽车，才工作1年半一边投简历一边上班啊。" class="headerlink" title="4.如果公司现在问题十分严重，是现在立即找工作吗？还是能等到年后？我在新能源汽车，才工作1年半一边投简历一边上班啊。"></a>4.如果公司现在问题十分严重，是现在立即找工作吗？还是能等到年后？我在新能源汽车，才工作1年半一边投简历一边上班啊。</h3><p>今年情况真不好说</p><h3 id="5-想请问下曹大，如果公司目前项目进度较慢或者有其他进度插入，那手头上自己的事情已经基本完成了，那该如何安排工作呢？"><a href="#5-想请问下曹大，如果公司目前项目进度较慢或者有其他进度插入，那手头上自己的事情已经基本完成了，那该如何安排工作呢？" class="headerlink" title="5.想请问下曹大，如果公司目前项目进度较慢或者有其他进度插入，那手头上自己的事情已经基本完成了，那该如何安排工作呢？"></a>5.想请问下曹大，如果公司目前项目进度较慢或者有其他进度插入，那手头上自己的事情已经基本完成了，那该如何安排工作呢？</h3><p>主动汇报，并申请一些新的事情做</p><h3 id="6-曹大，越级沟通在职场属于核弹式武器，所以职场明规则：不可以越级沟通，不然会死的很快。但是又有一条职场潜规则：不精通越级沟通，那么你这辈子都没法升上去。怎样合理的使用？"><a href="#6-曹大，越级沟通在职场属于核弹式武器，所以职场明规则：不可以越级沟通，不然会死的很快。但是又有一条职场潜规则：不精通越级沟通，那么你这辈子都没法升上去。怎样合理的使用？" class="headerlink" title="6.曹大，越级沟通在职场属于核弹式武器，所以职场明规则：不可以越级沟通，不然会死的很快。但是又有一条职场潜规则：不精通越级沟通，那么你这辈子都没法升上去。怎样合理的使用？"></a>6.曹大，越级沟通在职场属于核弹式武器，所以职场明规则：不可以越级沟通，不然会死的很快。但是又有一条职场潜规则：不精通越级沟通，那么你这辈子都没法升上去。怎样合理的使用？</h3><p>这种事情其实很常见，但是不能靠自己主动地这样的沟通，你可以被动地、因为你做得好，会产生跨级的被动的沟通。但如果大领导给你分配任务，你还是要如实汇报给你当前领导。</p><h3 id="7-能聊一聊转行吗？"><a href="#7-能聊一聊转行吗？" class="headerlink" title="7.能聊一聊转行吗？"></a>7.能聊一聊转行吗？</h3><p>这话题太大了，需要很多背景信息。在转行之前，我建议你先斜杠。</p><h3 id="8-曹大来讲讲2020年的一些机会与风险吧"><a href="#8-曹大来讲讲2020年的一些机会与风险吧" class="headerlink" title="8.曹大来讲讲2020年的一些机会与风险吧"></a>8.曹大来讲讲2020年的一些机会与风险吧</h3><p>出海这些年一直是机会，但是政策和合规性风险都很大。说实话我也不太好判断，要看国际关系的一个走势。</p><h3 id="9-请教曹大：我今年40，职位是研发经理，感觉这么发展下去路越走越窄，这种情况下如何规划未来？需要做些什么功课来提升自己？本来想效仿帅张做些副业，但听您这么一说，又不知道何去何从了"><a href="#9-请教曹大：我今年40，职位是研发经理，感觉这么发展下去路越走越窄，这种情况下如何规划未来？需要做些什么功课来提升自己？本来想效仿帅张做些副业，但听您这么一说，又不知道何去何从了" class="headerlink" title="9.请教曹大：我今年40，职位是研发经理，感觉这么发展下去路越走越窄，这种情况下如何规划未来？需要做些什么功课来提升自己？本来想效仿帅张做些副业，但听您这么一说，又不知道何去何从了"></a>9.请教曹大：我今年40，职位是研发经理，感觉这么发展下去路越走越窄，这种情况下如何规划未来？需要做些什么功课来提升自己？本来想效仿帅张做些副业，但听您这么一说，又不知道何去何从了</h3><p>第一个尽可能要懂业务，对行业业务要精通；第二点可以多扶持一些年轻人。<br>副业不是不能做，是你要平铺一下自己的优势在哪里，不是别人能赚这个钱你自己就能赚这个钱。</p><h3 id="10-曹大，如果投资了与公司业务完全无关的项目，有告知义务吗个人觉得没有这个义务，而且职位只是中层"><a href="#10-曹大，如果投资了与公司业务完全无关的项目，有告知义务吗个人觉得没有这个义务，而且职位只是中层" class="headerlink" title="10.曹大，如果投资了与公司业务完全无关的项目，有告知义务吗个人觉得没有这个义务，而且职位只是中层"></a>10.曹大，如果投资了与公司业务完全无关的项目，有告知义务吗个人觉得没有这个义务，而且职位只是中层</h3><p>是不是与公司的业务无关，不是你说了算而是公司法务说的算。我建议你先私下问一下你上司、或公司的管理人员。</p><h3 id="11-请教曹大，如果觉得不适合做技术，是不是应该提早转行"><a href="#11-请教曹大，如果觉得不适合做技术，是不是应该提早转行" class="headerlink" title="11.请教曹大，如果觉得不适合做技术，是不是应该提早转行"></a>11.请教曹大，如果觉得不适合做技术，是不是应该提早转行</h3><p>先要想好自己究竟适合做什么，以及你所想转过去的这个领域，你的职场竞争力在哪里。</p><h3 id="12-曹大，请教沟通能力应该怎么培养？"><a href="#12-曹大，请教沟通能力应该怎么培养？" class="headerlink" title="12.曹大，请教沟通能力应该怎么培养？"></a>12.曹大，请教沟通能力应该怎么培养？</h3><p>翻翻我的历史文章吧。</p><h3 id="13-请教下曹老师，团队有些高T喜欢带着大家加班导致大家工作效率很低，这种情况一般怎么办比较好？另外曹老师可以多聊聊35岁的问题么？如何及早的规划"><a href="#13-请教下曹老师，团队有些高T喜欢带着大家加班导致大家工作效率很低，这种情况一般怎么办比较好？另外曹老师可以多聊聊35岁的问题么？如何及早的规划" class="headerlink" title="13.请教下曹老师，团队有些高T喜欢带着大家加班导致大家工作效率很低，这种情况一般怎么办比较好？另外曹老师可以多聊聊35岁的问题么？如何及早的规划"></a>13.请教下曹老师，团队有些高T喜欢带着大家加班导致大家工作效率很低，这种情况一般怎么办比较好？另外曹老师可以多聊聊35岁的问题么？如何及早的规划</h3><p>第一如果效率很低的加班你无法改变，换岗呗。尽量换一下岗位。<br>另外说35岁这个问题有点大，在35岁之前让职位尽量高一些，人脉尽量广一点。</p><h3 id="14-曹大，如何建立职场人脉？"><a href="#14-曹大，如何建立职场人脉？" class="headerlink" title="14.曹大，如何建立职场人脉？"></a>14.曹大，如何建立职场人脉？</h3><p>多分享，而且是那种有价值的分享，多参与那种分享场合，通过这种过程让别人认可你。<br>人脉不是你认识多少人，你有多少人的联系方式，有多少人认可你才是人脉，一定要把这个当回事。</p><h3 id="15-请问曹大，领导对于自己的工作不太关注，并且不会分配给自己特别多任务，这种情况应该如何凸显自己的能力？"><a href="#15-请问曹大，领导对于自己的工作不太关注，并且不会分配给自己特别多任务，这种情况应该如何凸显自己的能力？" class="headerlink" title="15.请问曹大，领导对于自己的工作不太关注，并且不会分配给自己特别多任务，这种情况应该如何凸显自己的能力？"></a>15.请问曹大，领导对于自己的工作不太关注，并且不会分配给自己特别多任务，这种情况应该如何凸显自己的能力？</h3><p>无论事情大小要做好做透，多去问问领导对你的工作有什么不满意、有什么可以提升的地方，躲让领导提提批评，这样你态度到了，慢慢他就会重视你。</p><h3 id="16-曹大，请问一下作为基层的开发人员，领导在交任务并不会交代到具体细节，但是开发人员在梳理需求是发现细节可以有不同的做法，但是对应的做法产生的结果不同，这种时候罗列不同做法可能导致的后果，然后再交由领导决断是否可行？如果这种情况出现多次呢？"><a href="#16-曹大，请问一下作为基层的开发人员，领导在交任务并不会交代到具体细节，但是开发人员在梳理需求是发现细节可以有不同的做法，但是对应的做法产生的结果不同，这种时候罗列不同做法可能导致的后果，然后再交由领导决断是否可行？如果这种情况出现多次呢？" class="headerlink" title="16.曹大，请问一下作为基层的开发人员，领导在交任务并不会交代到具体细节，但是开发人员在梳理需求是发现细节可以有不同的做法，但是对应的做法产生的结果不同，这种时候罗列不同做法可能导致的后果，然后再交由领导决断是否可行？如果这种情况出现多次呢？"></a>16.曹大，请问一下作为基层的开发人员，领导在交任务并不会交代到具体细节，但是开发人员在梳理需求是发现细节可以有不同的做法，但是对应的做法产生的结果不同，这种时候罗列不同做法可能导致的后果，然后再交由领导决断是否可行？如果这种情况出现多次呢？</h3><p>这就是为什么要追问，要问上司具体的决策的依据和逻辑，因为你只有知道他的逻辑底层、知道哪些是重要的、哪些是可以忽略的，才可以理解。</p><h3 id="17-请问曹老师：从管理者的角度，如何培养和选拔有潜力成为管理者的员工？最为看重的品质有哪些？谢谢！"><a href="#17-请问曹老师：从管理者的角度，如何培养和选拔有潜力成为管理者的员工？最为看重的品质有哪些？谢谢！" class="headerlink" title="17.请问曹老师：从管理者的角度，如何培养和选拔有潜力成为管理者的员工？最为看重的品质有哪些？谢谢！"></a>17.请问曹老师：从管理者的角度，如何培养和选拔有潜力成为管理者的员工？最为看重的品质有哪些？谢谢！</h3><p>主动性很重要；敢担当、敢承担责任；人脉好，至少团队要服Ta。</p><h3 id="18-曹大，目前刚刚工作3年半，在一家新公司担任二级部门研发leader，目前感觉自己管理能力较弱，并且研发能力到达瓶颈。想问下是花更多经历在突破研发瓶颈呢，还是提升自己的管理能力？（行业为手机行业）"><a href="#18-曹大，目前刚刚工作3年半，在一家新公司担任二级部门研发leader，目前感觉自己管理能力较弱，并且研发能力到达瓶颈。想问下是花更多经历在突破研发瓶颈呢，还是提升自己的管理能力？（行业为手机行业）" class="headerlink" title="18.曹大，目前刚刚工作3年半，在一家新公司担任二级部门研发leader，目前感觉自己管理能力较弱，并且研发能力到达瓶颈。想问下是花更多经历在突破研发瓶颈呢，还是提升自己的管理能力？（行业为手机行业）"></a>18.曹大，目前刚刚工作3年半，在一家新公司担任二级部门研发leader，目前感觉自己管理能力较弱，并且研发能力到达瓶颈。想问下是花更多经历在突破研发瓶颈呢，还是提升自己的管理能力？（行业为手机行业）</h3><p>建议你直接问问自己的上司，哪些地方可以提升和改进。</p><h3 id="19-想请教下曹大，当前感觉技术进步不大，想跳槽，但能力又达不到好公司的要求，这时该怎么办？"><a href="#19-想请教下曹大，当前感觉技术进步不大，想跳槽，但能力又达不到好公司的要求，这时该怎么办？" class="headerlink" title="19.想请教下曹大，当前感觉技术进步不大，想跳槽，但能力又达不到好公司的要求，这时该怎么办？"></a>19.想请教下曹大，当前感觉技术进步不大，想跳槽，但能力又达不到好公司的要求，这时该怎么办？</h3><p>刷题，以及把以前的项目反复整理看怎么能做得更好一点。<br>可以在GitHub上做点好的开源项目，会加分。</p><h3 id="20-请问曹大之所以能成为曹大，最重要的因素是什么？"><a href="#20-请问曹大之所以能成为曹大，最重要的因素是什么？" class="headerlink" title="20.请问曹大之所以能成为曹大，最重要的因素是什么？"></a>20.请问曹大之所以能成为曹大，最重要的因素是什么？</h3><p>第一是我入行比较早，早期互联网人才比较少；<br>第二是我好为人师，攒了很多人脉，口碑比较好。</p><h3 id="21-曹老师，今天要续签合同，两年没有加薪了，我要怎么给领导提？"><a href="#21-曹老师，今天要续签合同，两年没有加薪了，我要怎么给领导提？" class="headerlink" title="21.曹老师，今天要续签合同，两年没有加薪了，我要怎么给领导提？"></a>21.曹老师，今天要续签合同，两年没有加薪了，我要怎么给领导提？</h3><p>两年没加薪你应该是几个月前就在找新的工作了而不是在续签的时候才想起来这个问题。<br>很多人总觉得自己的收入高低是取决于老板对你的赏识及老板够不够大方，很多时候你的价值取决于你在职场、你在你行业里公认的价值中，自己做到了什么程度。</p><h3 id="22-曹大公司有意把我培养成管理层，后续带团队。但目前我下面正在筹备着，还没有人员的补充（光棍司令）那我应该目前做哪些准备来应对接下来的安排呢？或者优先规划哪一块的工作内容呢？（在完成自己工作的前提下）"><a href="#22-曹大公司有意把我培养成管理层，后续带团队。但目前我下面正在筹备着，还没有人员的补充（光棍司令）那我应该目前做哪些准备来应对接下来的安排呢？或者优先规划哪一块的工作内容呢？（在完成自己工作的前提下）" class="headerlink" title="22.曹大公司有意把我培养成管理层，后续带团队。但目前我下面正在筹备着，还没有人员的补充（光棍司令）那我应该目前做哪些准备来应对接下来的安排呢？或者优先规划哪一块的工作内容呢？（在完成自己工作的前提下）"></a>22.曹大公司有意把我培养成管理层，后续带团队。但目前我下面正在筹备着，还没有人员的补充（光棍司令）那我应该目前做哪些准备来应对接下来的安排呢？或者优先规划哪一块的工作内容呢？（在完成自己工作的前提下）</h3><p>还是问上司，直接问Ta你应该学习什么，做什么，准备什么。</p><h3 id="23-请教曹大，职场如何更好处理与同事的关系呢？同级和上下级的"><a href="#23-请教曹大，职场如何更好处理与同事的关系呢？同级和上下级的" class="headerlink" title="23.请教曹大，职场如何更好处理与同事的关系呢？同级和上下级的"></a>23.请教曹大，职场如何更好处理与同事的关系呢？同级和上下级的</h3><p>多感谢别人的帮助多称赞别人的成绩<br>但注意，你不可能让每个人都认同你、称赞你，但你可以坚持正确的方法，这样才有正确的人认同你。<br>发现别人的优点，不是阿谀奉承。</p><h3 id="24-曹大，请问一下，基层开发，然后也算是小组长了。但是公司是扁平化管理，这种如何晋升。做的也是传统化互联网企业。"><a href="#24-曹大，请问一下，基层开发，然后也算是小组长了。但是公司是扁平化管理，这种如何晋升。做的也是传统化互联网企业。" class="headerlink" title="24.曹大，请问一下，基层开发，然后也算是小组长了。但是公司是扁平化管理，这种如何晋升。做的也是传统化互联网企业。"></a>24.曹大，请问一下，基层开发，然后也算是小组长了。但是公司是扁平化管理，这种如何晋升。做的也是传统化互联网企业。</h3><p>尽量做出令人信服的成绩，然后也要尽量建立职场影响力，你的晋升不一定在这家公司。</p><h3 id="25-大公司和创业公司如何选择？"><a href="#25-大公司和创业公司如何选择？" class="headerlink" title="25.大公司和创业公司如何选择？"></a>25.大公司和创业公司如何选择？</h3><p>今年除非特别好的创业公司，我不太建议别人去创业公司。<br>前些年我会建议，这两年我不太敢说这样的话。</p><h3 id="26-开发人员，加班太多，想找个轻松的工作，还适合继续干下去吗"><a href="#26-开发人员，加班太多，想找个轻松的工作，还适合继续干下去吗" class="headerlink" title="26.开发人员，加班太多，想找个轻松的工作，还适合继续干下去吗"></a>26.开发人员，加班太多，想找个轻松的工作，还适合继续干下去吗</h3><p>看你处于职场的什么阶段，以及你个人对自己职场的评估是什么，这种事情不要找别人提建议。</p><h3 id="27-曹大您好，请问职场中应该主动提加薪吗？该怎么提？"><a href="#27-曹大您好，请问职场中应该主动提加薪吗？该怎么提？" class="headerlink" title="27.曹大您好，请问职场中应该主动提加薪吗？该怎么提？"></a>27.曹大您好，请问职场中应该主动提加薪吗？该怎么提？</h3><p>让自己变得值钱。值钱的意思是在行业内很容易找到高工资的职位，如果他不给你加薪你可以直接走。<br>如果你没有变得值钱，提了之后他们也没有给你加薪，是不是很尴尬。</p><h3 id="28-曹大，我现在31了，还没有找到适合自己的职业，自己性格是内向的，现在做销售，一直做不好，想找一些技术向的工作，可是现在这个岁数，面试了不少，都拒绝了，我改怎么办"><a href="#28-曹大，我现在31了，还没有找到适合自己的职业，自己性格是内向的，现在做销售，一直做不好，想找一些技术向的工作，可是现在这个岁数，面试了不少，都拒绝了，我改怎么办" class="headerlink" title="28.曹大，我现在31了，还没有找到适合自己的职业，自己性格是内向的，现在做销售，一直做不好，想找一些技术向的工作，可是现在这个岁数，面试了不少，都拒绝了，我改怎么办"></a>28.曹大，我现在31了，还没有找到适合自己的职业，自己性格是内向的，现在做销售，一直做不好，想找一些技术向的工作，可是现在这个岁数，面试了不少，都拒绝了，我改怎么办</h3><p>面试被拒绝的时候，原因是什么？有没有深入沟通过？有没有保持后续的可能性？有没有在面试后把下一次做得更好？有没有去刷题？类似这样的。</p><h3 id="29-求问曹大，我在事业单位上班但是对做生意感兴趣，而且做了好几年了，想问问怎么结交商业上厉害的朋友并跟着他们学到东西？"><a href="#29-求问曹大，我在事业单位上班但是对做生意感兴趣，而且做了好几年了，想问问怎么结交商业上厉害的朋友并跟着他们学到东西？" class="headerlink" title="29.求问曹大，我在事业单位上班但是对做生意感兴趣，而且做了好几年了，想问问怎么结交商业上厉害的朋友并跟着他们学到东西？"></a>29.求问曹大，我在事业单位上班但是对做生意感兴趣，而且做了好几年了，想问问怎么结交商业上厉害的朋友并跟着他们学到东西？</h3><p>在事业单位上确实可以做副业，如果空余时间比较多的话。而且事业单位对副业这件事的企业敏感度也没有那么高。</p><p>在一些知识星球或者论坛分享你对商业的看法。实话说，你分享的价值越高，找你的人机会也越好，但事实上行业里骗子很多，你要做好鉴别。</p><h3 id="30-曹大，我是非科班培训出来做技术的，随着工龄增长感觉技术路越来越吃力，并且渐渐失去兴趣，但是由于经济压力暂时无法做出取舍的决定，能帮我分析一下我应该怎么做？"><a href="#30-曹大，我是非科班培训出来做技术的，随着工龄增长感觉技术路越来越吃力，并且渐渐失去兴趣，但是由于经济压力暂时无法做出取舍的决定，能帮我分析一下我应该怎么做？" class="headerlink" title="30.曹大，我是非科班培训出来做技术的，随着工龄增长感觉技术路越来越吃力，并且渐渐失去兴趣，但是由于经济压力暂时无法做出取舍的决定，能帮我分析一下我应该怎么做？"></a>30.曹大，我是非科班培训出来做技术的，随着工龄增长感觉技术路越来越吃力，并且渐渐失去兴趣，但是由于经济压力暂时无法做出取舍的决定，能帮我分析一下我应该怎么做？</h3><p>我前面强调过，技术人员如果对业务和商业有比较敏锐的觉察你的职场路会越走越宽的。<br>作为公司的老板和高层，他们有时和技术人员沟通很困难，可能说你的技术能力不是最好的、但他们和你沟通很方便的话，你很理解他们说的话，你能理解他们说的商业目标之类的，就会很有用。<br>所以我前面提到的人，他们现在不会再写代码了，但是他们很理解商业、很理解技术。</p><h3 id="31-请教曹大，关于职场上的人性世故开窍的晚，职场处处上碰壁，吃灰，该阿谀奉承，跟各种人混，还是秉持直白天真，按自己意愿做事，做人？"><a href="#31-请教曹大，关于职场上的人性世故开窍的晚，职场处处上碰壁，吃灰，该阿谀奉承，跟各种人混，还是秉持直白天真，按自己意愿做事，做人？" class="headerlink" title="31.请教曹大，关于职场上的人性世故开窍的晚，职场处处上碰壁，吃灰，该阿谀奉承，跟各种人混，还是秉持直白天真，按自己意愿做事，做人？"></a>31.请教曹大，关于职场上的人性世故开窍的晚，职场处处上碰壁，吃灰，该阿谀奉承，跟各种人混，还是秉持直白天真，按自己意愿做事，做人？</h3><p>沟通不讲方法，不叫直白天真，叫蠢。<br>不能说想怼谁就怼谁，这不对的。</p><h3 id="32-请问曹大，干程序员才4年，就感觉身体不舒服，尤其是颈椎，腰椎等工作一天特别僵硬，怎么平衡工作与身体健康的关系？"><a href="#32-请问曹大，干程序员才4年，就感觉身体不舒服，尤其是颈椎，腰椎等工作一天特别僵硬，怎么平衡工作与身体健康的关系？" class="headerlink" title="32.请问曹大，干程序员才4年，就感觉身体不舒服，尤其是颈椎，腰椎等工作一天特别僵硬，怎么平衡工作与身体健康的关系？"></a>32.请问曹大，干程序员才4年，就感觉身体不舒服，尤其是颈椎，腰椎等工作一天特别僵硬，怎么平衡工作与身体健康的关系？</h3><p>坚持锻炼身体，真的要坚持锻炼身体。</p><h3 id="33-曹老师，遇得那种不懂汇报，你说一句，他做一下，说几次的都没用的员工，是不是要舍得裁掉？"><a href="#33-曹老师，遇得那种不懂汇报，你说一句，他做一下，说几次的都没用的员工，是不是要舍得裁掉？" class="headerlink" title="33.曹老师，遇得那种不懂汇报，你说一句，他做一下，说几次的都没用的员工，是不是要舍得裁掉？"></a>33.曹老师，遇得那种不懂汇报，你说一句，他做一下，说几次的都没用的员工，是不是要舍得裁掉？</h3><p>做事行不行？行就丢在底层，这种人是没办法晋升的。</p><h3 id="34-对于领导强压的不太合理的制度，如何给团队传达？"><a href="#34-对于领导强压的不太合理的制度，如何给团队传达？" class="headerlink" title="34.对于领导强压的不太合理的制度，如何给团队传达？"></a>34.对于领导强压的不太合理的制度，如何给团队传达？</h3><p>跟领导沟通一下，要理解领导作出这种决策的逻辑和原因。</p><h3 id="35-请问曹大，作为职场新人想在公司推进新的业务，该怎么推进呢？除了自己调研业务的可行性以外，在协调同事和领导资源的时候该注意什么呢？"><a href="#35-请问曹大，作为职场新人想在公司推进新的业务，该怎么推进呢？除了自己调研业务的可行性以外，在协调同事和领导资源的时候该注意什么呢？" class="headerlink" title="35.请问曹大，作为职场新人想在公司推进新的业务，该怎么推进呢？除了自己调研业务的可行性以外，在协调同事和领导资源的时候该注意什么呢？"></a>35.请问曹大，作为职场新人想在公司推进新的业务，该怎么推进呢？除了自己调研业务的可行性以外，在协调同事和领导资源的时候该注意什么呢？</h3><p>调研能力是非常考验职场新人的点之一，百度会把这个作为他们考量新产品经理的指标。调研能做好，你在职场会加分很多。</p><h3 id="36-请教曹老师，一个非常普通的计算机本科毕业生需要在哪些方面发力才能进入互联网大厂，还是说建议考研？"><a href="#36-请教曹老师，一个非常普通的计算机本科毕业生需要在哪些方面发力才能进入互联网大厂，还是说建议考研？" class="headerlink" title="36.请教曹老师，一个非常普通的计算机本科毕业生需要在哪些方面发力才能进入互联网大厂，还是说建议考研？"></a>36.请教曹老师，一个非常普通的计算机本科毕业生需要在哪些方面发力才能进入互联网大厂，还是说建议考研？</h3><p>Google Code Jam，拿到前一百，大厂抢着要。</p><h3 id="37-曹大你好。我是程序员，报了挺多类似极客时间的这种技术课程。最大的感受是，学了但很多东西工作用不到，过段时间就忘光了。请问如何进行有效的学习提升？"><a href="#37-曹大你好。我是程序员，报了挺多类似极客时间的这种技术课程。最大的感受是，学了但很多东西工作用不到，过段时间就忘光了。请问如何进行有效的学习提升？" class="headerlink" title="37.曹大你好。我是程序员，报了挺多类似极客时间的这种技术课程。最大的感受是，学了但很多东西工作用不到，过段时间就忘光了。请问如何进行有效的学习提升？"></a>37.曹大你好。我是程序员，报了挺多类似极客时间的这种技术课程。最大的感受是，学了但很多东西工作用不到，过段时间就忘光了。请问如何进行有效的学习提升？</h3><p>你要看你工作中真的哪些东西用得到，带着问题去学习。然后再做做项目。<br>一定要学透，上十个课不如把一堂课学透学扎实。</p><p>「</p><p>」</p><p> <a href="">「」</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 搭建博客篇</title>
      <link href="/2019/complete-works-of-hexo.html"/>
      <url>/2019/complete-works-of-hexo.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、为什么要写这篇文章"><a href="#一、为什么要写这篇文章" class="headerlink" title="一、为什么要写这篇文章"></a>一、为什么要写这篇文章</h1><p>各大网站关于搭建博客的文章已经不是一篇两篇了，但是他们的文章也有坑~<code>(可能是版本问题)</code>也各有各的特点，这里带你踩坑，并带你实现他们的特点，<strong>「stormzhang」</strong> 说过</p><blockquote><p>把无序的信息变的有序，本质上也是信息差，也是可以创造价值的。</p></blockquote><p>所以我准备整理一下各各博客的特点，尽力写成一本大全。</p><h1 id="二、本文主要记载"><a href="#二、本文主要记载" class="headerlink" title="二、本文主要记载"></a>二、本文主要记载</h1><ul><li><strong>Hexo</strong> 基础搭建</li><li>管理代码( <strong>git</strong> 基本操作)</li><li>装饰博客</li><li><strong>live2D</strong> 看板娘</li><li>网站管理<pre><code>本文环境是 win10 或 win 7。mac 再执行 npm 时需要在前面添加 sudo本文整理于各大佬文章，文中会给出相应链接，如有侵权，请联系我修改或删除。</code></pre></li></ul><hr><a id="more"></a><h2 id="Hexo-基础搭建-more"><a href="#Hexo-基础搭建-more" class="headerlink" title="Hexo 基础搭建 more  "></a><a href="https://calmcenter.club/2019/Hexo_bash.html">Hexo 基础搭建 more  </a></h2><ul><li>搭建本地博客</li><li>部署到 <strong>Github Pages</strong></li></ul><h2 id="管理代码-git-基本操作-more"><a href="#管理代码-git-基本操作-more" class="headerlink" title="管理代码( git 基本操作) more"></a><a href="https://calmcenter.club/2019/Hexo_code_management.html">管理代码( git 基本操作) more</a></h2><ul><li><strong>git</strong> 拉取代码</li><li><strong>git</strong> 创建分支</li><li><strong>git</strong> 提交分支代码</li><li>其他终端如何使用 <strong>Hexo</strong> 源码</li></ul><h2 id="功能样式配置-more"><a href="#功能样式配置-more" class="headerlink" title="功能样式配置 more  "></a><a href="https://calmcenter.club/2019/Hexo_functional_style.html">功能样式配置 more  </a></h2><ul><li><strong>NexT</strong> 主题设置</li><li>基础样式设置</li><li>图片相关</li><li>打赏、评论、复制功能</li><li><strong>DaoVoice</strong> 实现在线联系</li><li>文章置顶</li><li>搜索功能</li><li>细节美化</li></ul><h2 id="live2D-看板娘-more"><a href="#live2D-看板娘-more" class="headerlink" title="live2D 看板娘 more  "></a><a href="https://calmcenter.club/2019/Hexo_Live2D.html"><strong>live2D</strong> 看板娘 more  </a></h2><ul><li>使用 <strong>hexo-helper-live2d</strong> 完成看板娘</li><li>自定义看板娘(右下角那个~)<ul><li>运行、接入 <strong>Demo</strong></li><li>更换、修改模型</li></ul></li></ul><h2 id="网站管理-more"><a href="#网站管理-more" class="headerlink" title="网站管理 more  "></a><a href="https://calmcenter.club/2019/Hexo_website_management.html">网站管理 more  </a></h2><ul><li>个人域名</li><li>加入 <strong>Coding</strong> 服务器</li><li><strong>SEO</strong>  推广</li></ul><hr><h1 id="来都来了-在评论留下你的足迹可否-？"><a href="#来都来了-在评论留下你的足迹可否-？" class="headerlink" title="来都来了 ~ 在评论留下你的足迹可否 ？"></a><code>来都来了 ~ 在评论留下你的足迹可否 ？</code></h1><p><strong>注意：如果出现图片不显示问题请移步</strong> <a href="https://calmcenter.club/2019/PicNotShow.html">图片不显示问题</a></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> NexT </tag>
            
            <tag> git </tag>
            
            <tag> github </tag>
            
            <tag> libe2d </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 性能优化篇</title>
      <link href="/2019/complete-works-of-android-performance.html"/>
      <url>/2019/complete-works-of-android-performance.html</url>
      
        <content type="html"><![CDATA[<p>随着项目版本的迭代，<strong>App</strong> 的性能问题会逐渐暴露出来，而好的用户体验与性能表现紧密相关。 最近项目核心功能收尾，准备开启优化之路，打造一个高用户体验的 <strong>APP</strong></p><h2 id="本文主要记载"><a href="#本文主要记载" class="headerlink" title="本文主要记载"></a>本文主要记载</h2><ul><li>App 启动优化💦</li><li>App 内存优化💦</li></ul><p>技术不断更新，我将在边学习边实践的过程中进行分享，并将实践结果与大家分享，希望大家看到文章中有不足的地方及时给我留言，我将与大家积极讨论。</p><h2 id="App-启动优化💦"><a href="#App-启动优化💦" class="headerlink" title="App 启动优化💦"></a>App 启动优化💦</h2><hr><table><thead><tr><th><a href="https://calmcenter.club/2019/start-optimization.html">App 初体验-启动优化 more  </a></th></tr></thead><tbody><tr><td><strong>1 启动</strong> <br /><strong>2 检测启动消耗<code>(敲黑板)</code></strong>  <br />&nbsp;&nbsp;&nbsp;2.1 启动时间测量方式  <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.1.1 adb 命令启动时间测量方式 <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.1.2 手动打点 <br />&nbsp;&nbsp;&nbsp;2.2 启动耗时检测方式  <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.2.1 TraceView <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.2.2 systrace <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.2.3 systrace + 函数插桩 AOP <br /><strong>3 启动优化<code>(干货)</code></strong>  <br />&nbsp;&nbsp;&nbsp;3.1 闪屏页展示 <br />&nbsp;&nbsp;&nbsp;3.2 异步启动实践 <br />&nbsp;&nbsp;&nbsp;3.3 数据重排 <br />&nbsp;&nbsp;&nbsp;3.4 类的加载 <br />&nbsp;&nbsp;&nbsp;3.5 延迟加载方案 IdleHandler <br />&nbsp;&nbsp;&nbsp;3.6 其他优化思路 <br /><strong>4 启动监控</strong></td></tr></tbody></table><h2 id="App-内存优化💦"><a href="#App-内存优化💦" class="headerlink" title="App 内存优化💦"></a>App 内存优化💦</h2><hr><table><thead><tr><th><a href="https://calmcenter.club/2020/memory-optimization.html">App 内存知识介绍 more  </a></th><th><a href="http://localhost:4000/2020/memory-optimization2.html" target="_blank" rel="noopener">App 内存检测优化 more</a></th></tr></thead><tbody><tr><td><strong>1 什么是内存？<br /></strong> <strong>2 JVM 如何分配内存？</strong>  <br />&nbsp;&nbsp;&nbsp;2.1 所有线程共享的数据区域 <br />&nbsp;&nbsp;&nbsp;2.2 线程私有的数据区域 <br /><strong>3 JVM 如何管理内存？</strong>  <br />&nbsp;&nbsp;&nbsp;3.1 引用计数算法 <br />&nbsp;&nbsp;&nbsp;3.2 可达性算法 <br />&nbsp;&nbsp;&nbsp;3.3 引用介绍 <br />&nbsp;&nbsp;&nbsp;3.4 垃圾回收器  <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.4.1 标记-清除算法（Mark-Sweep） <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.4.2 复制算法（Copying） <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.4.3 标记-整理算法（Mark-Compact） <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.4.4 分代收集算法（Generational Collection） <br /><strong>4 什么是 Dalvik?</strong>  <br />&nbsp;&nbsp;&nbsp;4.1 Dalvik 与 JVM 的区别 <br />&nbsp;&nbsp;&nbsp;4.2 Dalvik 堆大小 <br /><strong>5 什么是 ART?</strong>  <br />&nbsp;&nbsp;&nbsp;5.1 ART 与 Dalvik 的区别 <br /><strong>6 内存引发的问题</strong> <br />&nbsp;&nbsp;&nbsp;6.1 内存泄漏  <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.1.1 常见的内存泄漏 <br />&nbsp;&nbsp;&nbsp;6.2 低杀 <br />&nbsp;&nbsp;&nbsp;6.3 内存抖动 <br /><strong>7 Android Bitmap 内存分配的变化</strong> <br /><strong>8 内存优化的两个误区</strong>  <br />&nbsp;&nbsp;&nbsp;8.1 内存占用越少越好 <br />&nbsp;&nbsp;&nbsp;8.2 Native 内存不用管</td><td><strong>1 什么是 Memory Profiler？</strong>  <br />&nbsp;&nbsp;&nbsp;1.1 使用介绍  <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.1.1 启用高级分析 <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.1.2 计算内存(每个内存类别当前使用多少内存) <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.1.3 查看内存分配(分配的对象数) <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.1.4 在分析时提高应用性能 <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.1.5 捕获堆转储 <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.1.6 将堆转储另存为 HPROF 文件 <br /><strong>2 什么是 MAT？</strong>  <br />&nbsp;&nbsp;&nbsp;2.1 使用前提 <br />&nbsp;&nbsp;&nbsp;2.2 使用介绍 <br /><strong>3 什么是 LeakCanary？</strong>  <br />&nbsp;&nbsp;&nbsp;3.1 LeakCanary 原理 <br />&nbsp;&nbsp;&nbsp;3.2 LeakCanary 使用 <br /><strong>4 自定义实现 Demo</strong>  <br />&nbsp;&nbsp;&nbsp;4.1 自动化监测 Demo <br />&nbsp;&nbsp;&nbsp;4.2 重复图片监测 Demo <br /><strong>5 优化思路</strong>  <br />&nbsp;&nbsp;&nbsp;5.1 设备分级 <br />&nbsp;&nbsp;&nbsp;5.2 Bitmap 优化 <br /><strong>6 更多</strong></td></tr></tbody></table><p><a href="https://time.geekbang.org/column/article/74044" target="_blank" rel="noopener">极客时间 Android开发高手课</a>  </p><p><a href="https://coding.imooc.com/learn/list/308.html" target="_blank" rel="noopener">慕课 Top团队大牛带你玩转Android性能分析与优化</a></p><p><strong>注意：如果出现图片不显示问题请移步</strong> <a href="https://calmcenter.club/2019/PicNotShow.html">图片不显示问题</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
