<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Android 11 进程创建流程</title>
      <link href="2021/android-framework-process.html"/>
      <url>2021/android-framework-process.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文来自于 Gityuan <a href="http://gityuan.com/2016/03/26/app-process-create/">理解Android进程创建流程</a> 源码更新于 <a href="https://cs.android.com/">AndroidCodeSearch</a> （现在是 Android 11） ，老版本代码查看于 <a href="http://aosp.opersys.com/">opersys</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;os&#x2F;</span><br><span class="line">- Process.java(PRCS)</span><br><span class="line">- ZygoteProcess.java(ZP)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="一、准备知识"><a href="#一、准备知识" class="headerlink" title="一、准备知识"></a>一、准备知识</h1><p>本文要介绍的是进程的创建，先简单说说进程与线程的区别。</p><p><strong>进程：</strong>每个 <code>App</code> 在启动前必须先创建一个进程，该进程是由 <code>Zygote fork</code> 出来的，进程具有独立的资源空间，用于承载 <code>App</code> 上运行的各种 <code>Activity/Service</code> 等组件。进程对于上层应用来说是完全不可见的，这也是 <code>google</code> 有意为之，让 <code>App</code> 程序都是运行在 <code>Android Runtime</code> 。大多数情况一个 <code>App</code> 就运行在一个进程中，除非在 <code>AndroidManifest.xml</code> 中配置 <code>Android:process</code> 属性，或通过 <code>native</code> 代码 <code>fork</code> 进程。</p><p><strong>线程：</strong>线程对应用开发者来说非常熟悉，比如每次 <code>new Thread().start()</code> 都会创建一个新的线程，该线程并没有自己独立的地址空间，而是与其所在进程之间资源共享。从 <code>Linux</code> 角度来说进程与线程都是一个 <code>task_struct</code> 结构体，除了是否共享资源外，并没有其他本质的区别。</p><p>在接下来的文章，会涉及到 <code>system_server</code> 进程和 <code>Zygote</code> 进程，下面简要这两个进程：</p><ul><li><code>system_server</code> 进程：是用于管理整个 <code>Java framework</code> 层，包含 <code>ActivityManager</code> ，<code>PowerManager</code> 等各种系统服务;</li><li><code>Zygote</code> 进程：是 <code>Android</code> 系统的首个 <code>Java</code> 进程，<code>Zygote</code> 是所有 <code>Java</code> 进程的父进程，包括 <code>system_server</code> 进程以及所有的 <code>App</code> 进程都是 <code>Zygote</code> 的子进程，注意这里说的是子进程，而非子线程。</li></ul><h1 id="二、-system-server-发起请求"><a href="#二、-system-server-发起请求" class="headerlink" title="二、 system_server 发起请求"></a>二、 system_server 发起请求</h1><h2 id="1-PRCS-start"><a href="#1-PRCS-start" class="headerlink" title="1.PRCS.start"></a>1.PRCS.start</h2><p><code>Process.java</code> 在  <a href="https://cs.android.com/">AndroidCodeSearch</a> 中竟然搜索不出来 (2021/1/22) ，请看上面的路径。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ZygoteProcess ZYGOTE_PROCESS = <span class="keyword">new</span> ZygoteProcess();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ProcessStartResult <span class="title">start</span><span class="params">(<span class="meta">@NonNull</span> <span class="keyword">final</span> String processClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="meta">@Nullable</span> <span class="keyword">final</span> String niceName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">int</span> uid, <span class="keyword">int</span> gid, <span class="meta">@Nullable</span> <span class="keyword">int</span>[] gids,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       ...</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">boolean</span> bindMountAppStorageDirs,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="meta">@Nullable</span> String[] zygoteArgs)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 【见 2】</span></span><br><span class="line">    <span class="keyword">return</span> ZYGOTE_PROCESS.start(processClass, niceName, uid, gid, gids,</span><br><span class="line">                runtimeFlags, mountExternal, targetSdkVersion, seInfo,</span><br><span class="line">                abi, instructionSet, appDataDir, invokeWith, packageName,</span><br><span class="line">                zygotePolicyFlags, isTopApp, disabledCompatChanges,</span><br><span class="line">                pkgDataInfoMap, whitelistedDataInfoMap, bindMountAppsData,</span><br><span class="line">                bindMountAppStorageDirs, zygoteArgs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-ZP-start"><a href="#2-ZP-start" class="headerlink" title="2 ZP.start"></a>2 ZP.start</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Process.<span class="function">ProcessStartResult <span class="title">start</span><span class="params">(<span class="meta">@NonNull</span> <span class="keyword">final</span> String processClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              <span class="keyword">final</span> String niceName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              <span class="keyword">int</span> uid, <span class="keyword">int</span> gid, <span class="meta">@Nullable</span> <span class="keyword">int</span>[] gids,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              ...</span></span></span><br><span class="line"><span class="function"><span class="params">                                              <span class="keyword">boolean</span> bindMountAppStorageDirs,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              <span class="meta">@Nullable</span> String[] zygoteArgs)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// TODO (chriswailes): Is there a better place to check this value?</span></span><br><span class="line">    <span class="keyword">if</span> (fetchUsapPoolEnabledPropWithMinInterval()) &#123;</span><br><span class="line">        informZygotesOfUsapPoolStatus();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 调用 startViaZygote() 方法 【见 3】</span></span><br><span class="line">        <span class="keyword">return</span> startViaZygote(processClass, niceName, uid, gid, gids,</span><br><span class="line">                runtimeFlags, mountExternal, targetSdkVersion, seInfo,</span><br><span class="line">                abi, instructionSet, appDataDir, invokeWith, <span class="comment">/*startChildZygote=*/</span> <span class="keyword">false</span>,</span><br><span class="line">                packageName, zygotePolicyFlags, isTopApp, disabledCompatChanges,</span><br><span class="line">                pkgDataInfoMap, whitelistedDataInfoMap, bindMountAppsData,</span><br><span class="line">                bindMountAppStorageDirs, zygoteArgs);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ZygoteStartFailedEx ex) &#123;</span><br><span class="line">        Log.e(LOG_TAG,</span><br><span class="line">                <span class="string">&quot;Starting VM process through Zygote failed&quot;</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">&quot;Starting VM process through Zygote failed&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-ZP-startViaZygote"><a href="#3-ZP-startViaZygote" class="headerlink" title="3.ZP.startViaZygote"></a>3.ZP.startViaZygote</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Process.<span class="function">ProcessStartResult <span class="title">startViaZygote</span><span class="params">(<span class="meta">@NonNull</span> <span class="keyword">final</span> String processClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  <span class="meta">@Nullable</span> <span class="keyword">final</span> String niceName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  <span class="keyword">final</span> <span class="keyword">int</span> uid, <span class="keyword">final</span> <span class="keyword">int</span> gid,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  ...</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  <span class="meta">@Nullable</span> String[] extraArgs)</span></span></span><br><span class="line"><span class="function">                                                  <span class="keyword">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class="line">    ArrayList&lt;String&gt; argsForZygote = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    argsForZygote.add(<span class="string">&quot;--runtime-args&quot;</span>);</span><br><span class="line">    argsForZygote.add(<span class="string">&quot;--setuid=&quot;</span> + uid);</span><br><span class="line">    argsForZygote.add(<span class="string">&quot;--setgid=&quot;</span> + gid);</span><br><span class="line">    argsForZygote.add(<span class="string">&quot;--runtime-flags=&quot;</span> + runtimeFlags);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    argsForZygote.add(<span class="string">&quot;--target-sdk-version=&quot;</span> + targetSdkVersion);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">synchronized</span>(mLock) &#123;</span><br><span class="line">      <span class="comment">// 方法 1：openZygoteSocketIfNeeded() 见 【 3.1】</span></span><br><span class="line">        <span class="comment">// 方法 2：zygoteSendArgsAndGetResult()</span></span><br><span class="line">        <span class="keyword">return</span> zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi),</span><br><span class="line">                                          zygotePolicyFlags,</span><br><span class="line">                                          argsForZygote);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-ZP-openZygoteSocketIfNeeded"><a href="#3-1-ZP-openZygoteSocketIfNeeded" class="headerlink" title="3.1 ZP.openZygoteSocketIfNeeded"></a>3.1 ZP.openZygoteSocketIfNeeded</h3><p><code>openZygoteSocketIfNeeded(abi)</code> 方法是根据当前的 <code>abi</code> 来选择与 <code>zygote</code> 还是 <code>zygote64</code> 来进行通信。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ZygoteState <span class="title">openZygoteSocketIfNeeded</span><span class="params">(String abi)</span> <span class="keyword">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 向主 Zygote 发起连接操作</span></span><br><span class="line">        attemptConnectionToPrimaryZygote();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (primaryZygoteState.matches(abi)) &#123;</span><br><span class="line">            <span class="keyword">return</span> primaryZygoteState;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mZygoteSecondarySocketAddress != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 向第二个 Zygote 发起连接操作</span></span><br><span class="line">            attemptConnectionToSecondaryZygote();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (secondaryZygoteState.matches(abi)) &#123;</span><br><span class="line">                <span class="keyword">return</span> secondaryZygoteState;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(<span class="string">&quot;Error connecting to zygote&quot;</span>, ioe);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(<span class="string">&quot;Unsupported zygote ABI: &quot;</span> + abi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">attemptConnectionToPrimaryZygote</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (primaryZygoteState == <span class="keyword">null</span> || primaryZygoteState.isClosed()) &#123;</span><br><span class="line">      <span class="comment">// 向主 zygote 发起 connect() 操作</span></span><br><span class="line">        primaryZygoteState =</span><br><span class="line">                ZygoteState.connect(mZygoteSocketAddress, mUsapPoolSocketAddress);</span><br><span class="line"></span><br><span class="line">        maybeSetApiDenylistExemptions(primaryZygoteState, <span class="keyword">false</span>);</span><br><span class="line">        maybeSetHiddenApiAccessLogSampleRate(primaryZygoteState);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">attemptConnectionToSecondaryZygote</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (secondaryZygoteState == <span class="keyword">null</span> || secondaryZygoteState.isClosed()) &#123;</span><br><span class="line">      <span class="comment">// 当主 zygote 没能匹配成功，则采用第二个 zygote，发起 connect() 操作</span></span><br><span class="line">        secondaryZygoteState =</span><br><span class="line">                ZygoteState.connect(mZygoteSecondarySocketAddress,</span><br><span class="line">                        mUsapPoolSecondarySocketAddress);</span><br><span class="line"></span><br><span class="line">        maybeSetApiDenylistExemptions(secondaryZygoteState, <span class="keyword">false</span>);</span><br><span class="line">        maybeSetHiddenApiAccessLogSampleRate(secondaryZygoteState);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-ZP-zygoteSendArgsAndGetResult"><a href="#4-ZP-zygoteSendArgsAndGetResult" class="headerlink" title="4.ZP.zygoteSendArgsAndGetResult"></a>4.ZP.zygoteSendArgsAndGetResult</h2><p>这个方法的主要功能是通过 <code>socket</code> 通道向 <code>Zygote</code> 进程发送一个参数列表，然后进入阻塞等待状态，直到远端的 <code>socket</code> 服务端发送回来新创建的进程 <code>pid</code> 才返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Process.<span class="function">ProcessStartResult <span class="title">zygoteSendArgsAndGetResult</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ZygoteState zygoteState, <span class="keyword">int</span> zygotePolicyFlags, <span class="meta">@NonNull</span> ArrayList&lt;String&gt; args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> attemptZygoteSendArgsAndGetResult(zygoteState, msgStr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Process.<span class="function">ProcessStartResult <span class="title">attemptZygoteSendArgsAndGetResult</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ZygoteState zygoteState, String msgStr)</span> <span class="keyword">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> BufferedWriter zygoteWriter = zygoteState.mZygoteOutputWriter;</span><br><span class="line">        <span class="keyword">final</span> DataInputStream zygoteInputStream = zygoteState.mZygoteInputStream;</span><br><span class="line"></span><br><span class="line">        zygoteWriter.write(msgStr);</span><br><span class="line">        zygoteWriter.flush();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//等待 socket 服务端（即 zygote）返回新创建的进程 pid;</span></span><br><span class="line">        Process.ProcessStartResult result = <span class="keyword">new</span> Process.ProcessStartResult();</span><br><span class="line">        result.pid = zygoteInputStream.readInt();</span><br><span class="line">        result.usingWrapper = zygoteInputStream.readBoolean();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result.pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(<span class="string">&quot;fork() failed&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        zygoteState.close();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然 <code>system_server</code> 进程的 <code>zygoteSendArgsAndGetResult()</code> 方法通过 <code>socket</code> 向 <code>Zygote</code> 进程发送消息，这是便会唤醒 <code>Zygote</code> 进程，来响应 <code>socket</code> 客户端的请求（即 <code>system_server</code> 端），接下来的操作便是在 <code>Zygote</code> 来创建进程</p><h1 id="三、Zygote-创建进程"><a href="#三、Zygote-创建进程" class="headerlink" title="三、Zygote 创建进程"></a>三、Zygote 创建进程</h1><p><code>Zygote</code> 进程是由 <code>init</code> 进程创建的，进程启动之后便会调用 <code>ZygoteInit.main()</code> 方法，经过创建 <code>socket 管道</code>，预加载资源后，调用 <code>runSelectLoop()</code>方法。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 11 Service 启动分析</title>
      <link href="2021/android-framework-service.html"/>
      <url>2021/android-framework-service.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文来自于 Gityuan <a href="http://gityuan.com/2016/03/06/start-service/">startService启动过程分析</a> 和 <a href="https://blog.csdn.net/itrenj/article/details/110007831">Service 流程分析</a> 源码更新于 <a href="https://cs.android.com/">AndroidCodeSearch</a> （现在是 Android 11） ，老版本代码查看于 <a href="http://aosp.opersys.com/">opersys</a></p></blockquote><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>经历了之前的 <a href="">无 Binder 不 Android</a> ，相信对 <code>Binder</code> 架构有了较深地理解。<code>Binder</code> 的地位是非常之重要，整个 <code>Java framework</code> 的提供<code>ActivityManagerService</code> 、<code>PackageManagerService</code> 等服务都是基于 <code>Binder</code> 架构来通信的，另外 <a href="">Handle 消息机制</a> 在进程内的通信使用非常多。本文将开启对 <code>ActivityManagerService</code> 的分析。</p><p><code>ActivityManagerService</code> 是 <code>Android</code> 的 <code>Java framework</code> 的服务框架最重要的服务之一。</p><p>对于 <code>Andorid</code> 的 <code>Activity</code>、<code>Service</code>、<code>Broadcast</code>、<code>ContentProvider</code> 四剑客的管理，包含其生命周期都是通过 <code>ActivityManagerService</code> 来完成的。</p><h2 id="1-1-ActivityManagerService-介绍"><a href="#1-1-ActivityManagerService-介绍" class="headerlink" title="1.1 ActivityManagerService 介绍"></a>1.1 ActivityManagerService 介绍</h2><p>缩写</p><ul><li><strong>AMP：</strong>ActivityManagerProxy</li><li><strong>AMN：</strong>ActivityManagerNative</li><li><strong>AMS：</strong>ActivityManagerService</li><li><strong>AT：</strong>ApplicationThread</li><li><strong>ATP：</strong>ApplicationThreadProxy</li><li><strong>ATN：</strong>ApplicationThreadNative</li><li><strong>IAM：</strong>IActivityManager</li><li><strong>IAT：</strong>IApplicationThread</li><li><strong>ACF：</strong>AppComponentFactory</li><li><strong>CW：</strong>ContextWrapper</li><li><strong>CI：</strong>ContextImpl</li><li><strong>LA：</strong>LoadeAPK</li></ul><h3 id="Android-7-0"><a href="#Android-7-0" class="headerlink" title="Android 7.0"></a>Android 7.0</h3><p><code>Android7</code> 之前(包括<code>7.0</code>、<code>7.1</code>)，<code>AMS</code> 是通过自己实现代理类来完成 <code>Binder</code></p><p>与 <code>AMS</code> 通信是基于其代理 <code>AMP</code>（通过 <code>ActivityManagerNative. getDefault</code> 得到其内部类 <code>ActivityManagerProxy</code> 的单例对象，即 <code>AMS</code> 在客户端（用户进程）的代理对象）</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/android/android_service_ams7.png" alt="图片来源于《Gityuan》"></p><p><code>Activity</code> 的直接管理者是 <code>ActivityManager</code>，但最终管理者是 <code>AMS</code>：</p><ul><li><code>Client</code> 端发起启动 <code>Service</code> 请求；</li><li><code>AM</code> 会通过 <code>ActivityManagerNative</code> 的 <code>getDefault</code> 来得到其内部类 <code>ActivityManagerProxy</code> 的单例对象，即 <code>AMS</code> 在客户端（用户进程）的代理对象；</li><li>作为代理类，<code>AMP</code> 中含有 <code>AMS</code> 的引用，<code>AMN</code> 和 <code>AMP</code> 都实现了 <code>IActivityManager</code> ；</li><li><code>IActivityManager</code> 继承了 <code>IInterface</code>（实现 <code>Binder</code> 通信的必备条件），所以 <code>AMP</code> 具备了 <code>Binder</code> 通信能力；</li><li><code>startService</code> 最终会通过 <code>AMP</code> 中的 <code>AMS</code> 引用来调用 <code>AMS</code> 的 <code>transact</code> 方法；</li><li>向 <code>AMS</code> 发送启动 <code>Service</code> 请求，并将序列化数据传递给 <code>AMS</code> ，随后 <code>AMS</code> 的子类 <code>AMN</code> 的 <code>onTransact</code> 会执行，它会将具体的启动工作交给 <code>ActivityStater</code> 来负责；</li></ul><h3 id="Android-8-0"><a href="#Android-8-0" class="headerlink" title="Android 8.0"></a>Android 8.0</h3><p><code>8.0</code> 开始，<code>AMS</code> 通过 <code>AIDL</code> 完成 <code>Binder</code> 通信</p><p><code>AMS</code> 中主要涉及这三个数据结构：<code>ActivityRecord</code>、<code>TaskRecord</code> 和 <code>ActivityStack</code> ；</p><ul><li><strong>ActivityRecord：</strong>存储 <code>Activity</code> 的相关信息，比如 <code>AndroidMainifes</code> 的节点信息，启动 <code>Activity</code> 的包名，所在进程，图标主题标识符，当前 <code>Activity</code> 状态，所属 <code>TaskRecord</code> 等；</li><li><strong>TaskRecord：</strong>描述一个 <code>Activity</code> 任务栈，主要维护了一个按历史顺序排列的 <code>ArrayList&lt;ActivityRecord&gt;</code>，并包含此任务栈所属的 <code>ActivityStack</code> 等；</li><li><strong>ActivityStack：</strong>一个管理系统中所有 <code>Activity</code> 的管理类，真实交由 <code>ActivityStackSupervisor</code> 管理，内部维护了 <code>Activity</code> 的所有状态，并对不同状态的 <code>Activity</code> 进行分类管理，如最近启动的 <code>Activity</code>，正在暂停的 <code>Activity</code> 等。</li></ul><p><a href="https://cs.android.com/android/platform/superproject/+/master:out/soong/.intermediates/frameworks/base/framework-minus-apex/android_common/xref30/srcjars.xref/android/app/IActivityManager.java;drc=master;l=11">IActivityManager.java</a> 就是 <code>ADIL</code> 文件所对应的 <code>java</code> 文件，里面包含了 <code>Proxy</code> 和 <code>Stub</code> 类</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/android/android_service_ams8.webp" alt="图片来源于网络"></p><h2 id="1-2-ApplicationThread"><a href="#1-2-ApplicationThread" class="headerlink" title="1.2 ApplicationThread"></a>1.2 ApplicationThread</h2><h3 id="Android-7-0-1"><a href="#Android-7-0-1" class="headerlink" title="Android 7.0"></a>Android 7.0</h3><p><code>Android 7</code> 之前(包括<code>7.0</code>、<code>7.1</code>)，<code>AT</code> 是通过自己实现代理类来完成 <code>Binder</code></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/android/android_application_thread.png" alt="图片来源于网络"></p><p>与 <code>IActivityManager</code> 的 <code>binder</code> 通信原理一样，<code>ApplicationThreadProxy</code> 作为 <code>binder</code> 通信的客户端，<code>ApplicationThreadNative</code> 作为 <code>Binder</code> 通信的服务端，其中<code>ApplicationThread</code> 继承 <code>ApplicationThreadNative</code> 类，覆写其中的部分方法。</p><h3 id="Android-8-0-1"><a href="#Android-8-0-1" class="headerlink" title="Android 8.0"></a>Android 8.0</h3><p><code>8.0</code> 开始，<code>AT</code> 通过 <code>AIDL</code> 完成 <code>Binder</code> 通信</p><ul><li><code>IApplivation.Thread.Stub</code> 代替 <code>ApplicationThreadNative</code></li><li><code>IApplivation.Thread.Stub.Proxy</code> 代替 <code>ApplicationThreadProxy</code></li></ul><h2 id="1-3-启动服务流程图"><a href="#1-3-启动服务流程图" class="headerlink" title="1.3 启动服务流程图"></a>1.3 启动服务流程图</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;am&#x2F;</span><br><span class="line">  - ActivityManagerService.java</span><br><span class="line">  - ActiveServices.java</span><br><span class="line">  - ServiceRecord.java</span><br><span class="line">  - ProcessRecord.java</span><br><span class="line"></span><br><span class="line">out&#x2F;soong&#x2F;.intermediates&#x2F;frameworks&#x2F;base&#x2F;framework-minus-apex&#x2F;android_common&#x2F;xref30&#x2F;srcjars.xref&#x2F;android&#x2F;app&#x2F;</span><br><span class="line">- IActivityManager.java (AIDL 文件生成的，内含 Proxy 和 Stub)</span><br><span class="line">- IApplicationThread.java (AIDL 文件生成的，内含 Proxy 和 Stub)</span><br><span class="line"></span><br><span class="line">frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;app&#x2F;</span><br><span class="line">  - ActivityManager.java</span><br><span class="line">  </span><br><span class="line">  - IApplicationThread.java</span><br><span class="line">  - ActivityThread.java (内含 ApplicationThread )</span><br><span class="line">  </span><br><span class="line">  - ContextImpl.java</span><br><span class="line">  </span><br><span class="line">  - LoadedApk.java</span><br><span class="line">  </span><br><span class="line">frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;content&#x2F;</span><br><span class="line">- ContextWrapper.java</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/android/android_service_start1.png" alt="图片来源于网络"></p><p>接下来，我们正式从代码角度来分析服务启动的过程。</p><h1 id="二、startService-源码"><a href="#二、startService-源码" class="headerlink" title="二、startService 源码"></a>二、startService 源码</h1><h2 id="2-1-CW-startService"><a href="#2-1-CW-startService" class="headerlink" title="2.1 CW.startService"></a>2.1 CW.startService</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ContextWrapper.java</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ComponentName <span class="title">startService</span><span class="params">(Intent service)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mBase.startService(service); <span class="comment">// 其中 mBase 为 ContextImpl 对象 【 见流程2.2 】</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-CI-startService"><a href="#2-2-CI-startService" class="headerlink" title="2.2 CI.startService"></a>2.2 CI.startService</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">ContextImpl.java</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ComponentName <span class="title">startService</span><span class="params">(Intent service)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当 system 进程调用此方法时输出 warn 信息，system 进程建立调用 startServiceAsUser 方法</span></span><br><span class="line">    warnIfCallingFromSystemProcess();</span><br><span class="line">    <span class="keyword">return</span> startServiceCommon(service, <span class="keyword">false</span>, mUser);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ComponentName <span class="title">startServiceCommon</span><span class="params">(Intent service, <span class="keyword">boolean</span> requireForeground,</span></span></span><br><span class="line"><span class="function"><span class="params">        UserHandle user)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 检验 service，当 service 为空则 throw 异常</span></span><br><span class="line">        validateServiceIntent(service);</span><br><span class="line">        service.prepareToLeaveProcess(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// ActivityManager.getService() 就是获取到的 Proxy 对象 【见 2.3】 【startService 见 2.3.1】</span></span><br><span class="line">        ComponentName cn = ActivityManager.getService().startService(</span><br><span class="line">            mMainThread.getApplicationThread(), service, service.resolveTypeIfNeeded(</span><br><span class="line">                        getContentResolver()), requireForeground,</span><br><span class="line">                        getOpPackageName(), user.getIdentifier());</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">return</span> cn;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-AM-getService"><a href="#2-3-AM-getService" class="headerlink" title="2.3 AM.getService"></a>2.3 AM.getService</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">ActivityManager.java</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IActivityManager <span class="title">getService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> IActivityManagerSingleton.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Singleton.java</span><br><span class="line"></span><br><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//首次调用 create() 来获取AMP对象</span></span><br><span class="line">            mInstance = create();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ActivityManager.java</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton&lt;IActivityManager&gt; IActivityManagerSingleton =</span><br><span class="line">        <span class="keyword">new</span> Singleton&lt;IActivityManager&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> IActivityManager <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//获取名为 &quot;activity&quot; 的服务，服务都注册到 ServiceManager 来统一管理</span></span><br><span class="line">                <span class="keyword">final</span> IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE);</span><br><span class="line">                <span class="comment">// IActivityManager 是 aidl，也就说明 Service 的启动过程是一个IPC的过程</span></span><br><span class="line">                <span class="keyword">final</span> IActivityManager am = IActivityManager.Stub.asInterface(b);</span><br><span class="line">                <span class="keyword">return</span> am;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">IActivityManager.java</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> android.app.<span class="function">IActivityManager <span class="title">asInterface</span><span class="params">(android.os.IBinder obj)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((obj==<span class="keyword">null</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">    <span class="keyword">if</span> (((iin!=<span class="keyword">null</span>)&amp;&amp;(iin <span class="keyword">instanceof</span> android.app.IActivityManager))) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((android.app.IActivityManager)iin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回 Proxy 类</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> android.app.IActivityManager.Stub.Proxy(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>create</code> 方法返回的是 <code>AIDL</code> 生成的代理类，<code>IActivityManager.Stub.Proxy</code>， 那么下一步调用 <code>IActivityManager.Stub.Proxy.startService</code> 方法。</p><p>通过 <code>Binder</code> 通信过程中，</p><ul><li>提供了一个 <code>IActivityManager</code> 服务接口(继承于 <code>android.os.IInterface</code>)</li><li><code>IActivityManager.Stub.Proxy</code> 类实现了 <code>IActivityManager</code> 接口</li><li><code>IActivityManager.Stub</code> 继承 <code>Binder</code> 并且实现 <code>IActivityManager</code> 接口</li><li><code>ActivityManagerService</code> 继承自 <code>IActivityManager.Stub</code> </li></ul><p>这里可以看出 <code>IActivityManager.Stub.Proxy</code> 是 <code>Binder</code> 通信的客户端，<code>ActivityManagerService</code> 是 <code>Binder</code> 通信的服务端，那么<code>IActivityManager.Proxy.startService()</code> 最终调用的是 <code>ActivityManagerService.startService()</code></p><h3 id="2-3-1-IAM-Stub-Proxy-startService"><a href="#2-3-1-IAM-Stub-Proxy-startService" class="headerlink" title="2.3.1 IAM.Stub.Proxy.startService"></a>2.3.1 IAM.Stub.Proxy.startService</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由于是 编译器生成的代码，排版可能比较乱    IActivityManager.java  </span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> <span class="keyword">public</span> android.content.<span class="function">ComponentName <span class="title">startService</span><span class="params">(android.app.IApplicationThread caller, android.content.Intent service, java.lang.String resolvedType, <span class="keyword">boolean</span> requireForeground, java.lang.String callingPackage, java.lang.String callingFeatureId, <span class="keyword">int</span> userId)</span> <span class="keyword">throws</span> android.os.RemoteException</span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">        android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">        android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">        android.content.ComponentName _result;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">          _data.writeStrongBinder((((caller!=<span class="keyword">null</span>))?(caller.asBinder()):(<span class="keyword">null</span>)));</span><br><span class="line">          <span class="keyword">if</span> ((service!=<span class="keyword">null</span>)) &#123;</span><br><span class="line">            _data.writeInt(<span class="number">1</span>);</span><br><span class="line">            service.writeToParcel(_data, <span class="number">0</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">            _data.writeInt(<span class="number">0</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          _data.writeString(resolvedType);</span><br><span class="line">          _data.writeInt(((requireForeground)?(<span class="number">1</span>):(<span class="number">0</span>)));</span><br><span class="line">          _data.writeString(callingPackage);</span><br><span class="line">          _data.writeString(callingFeatureId);</span><br><span class="line">          _data.writeInt(userId);</span><br><span class="line">          <span class="comment">//通过 Binder 传递数据 【见 2.3.2】</span></span><br><span class="line">          <span class="keyword">boolean</span> _status = mRemote.transact(Stub.TRANSACTION_startService, _data, _reply, <span class="number">0</span>);</span><br><span class="line">          <span class="keyword">if</span> (!_status) &#123;</span><br><span class="line">            <span class="keyword">if</span> (getDefaultImpl() != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">return</span> getDefaultImpl().startService(caller, service, resolvedType, requireForeground, callingPackage, callingFeatureId, userId);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          _reply.readException();</span><br><span class="line">          <span class="keyword">if</span> ((<span class="number">0</span>!=_reply.readInt())) &#123;</span><br><span class="line">            _result = android.content.ComponentName.CREATOR.createFromParcel(_reply);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">            _result = <span class="keyword">null</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">          _reply.recycle();</span><br><span class="line">          _data.recycle();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _result;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-2-IAM-Stub-onTransact-Client-gt-Service"><a href="#2-3-2-IAM-Stub-onTransact-Client-gt-Service" class="headerlink" title="2.3.2 IAM.Stub.onTransact(Client -&gt; Service)"></a>2.3.2 IAM.Stub.onTransact(Client -&gt; Service)</h3><p>到这里，借助 <code>IAM</code> 这个 <code>AIDL</code> ，便完成了从 <code>Service</code> 所在的进程（Client 的进程）到了  <code>system_server</code> 进程（服务进程）的调用过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由于是 编译器生成的代码，排版可能比较乱    IActivityManager.java  </span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, android.os.Parcel data, android.os.Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> android.os.RemoteException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="keyword">switch</span> (code)</span><br><span class="line">      ...</span><br><span class="line">        <span class="keyword">case</span> TRANSACTION_startService:</span><br><span class="line">        &#123;</span><br><span class="line">          data.enforceInterface(descriptor);</span><br><span class="line">          <span class="comment">//生成 IApplicationThread 的代理对象，即 IApplicationThread.Stub.Proxy 对象</span></span><br><span class="line">          android.app.IApplicationThread _arg0;</span><br><span class="line">          _arg0 = android.app.IApplicationThread.Stub.asInterface(data.readStrongBinder());</span><br><span class="line">          android.content.Intent _arg1;</span><br><span class="line">          <span class="keyword">if</span> ((<span class="number">0</span>!=data.readInt())) &#123;</span><br><span class="line">            _arg1 = android.content.Intent.CREATOR.createFromParcel(data);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">            _arg1 = <span class="keyword">null</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          java.lang.String _arg2;</span><br><span class="line">          _arg2 = data.readString();</span><br><span class="line">          <span class="keyword">boolean</span> _arg3;</span><br><span class="line">          _arg3 = (<span class="number">0</span>!=data.readInt());</span><br><span class="line">          java.lang.String _arg4;</span><br><span class="line">          _arg4 = data.readString();</span><br><span class="line">          java.lang.String _arg5;</span><br><span class="line">          _arg5 = data.readString();</span><br><span class="line">          <span class="keyword">int</span> _arg6;</span><br><span class="line">          _arg6 = data.readInt();</span><br><span class="line">          <span class="comment">//调用 ActivityManagerService 的 startService() 方法 【见 2.4】</span></span><br><span class="line">          android.content.ComponentName _result = <span class="keyword">this</span>.startService(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6);</span><br><span class="line">          reply.writeNoException();</span><br><span class="line">          <span class="keyword">if</span> ((_result!=<span class="keyword">null</span>)) &#123;</span><br><span class="line">            reply.writeInt(<span class="number">1</span>);</span><br><span class="line">            _result.writeToParcel(reply, android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">            reply.writeInt(<span class="number">0</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在整个调用过程涉及两个进程，令 <code>startService</code> 的发起进程记为进程 <code>A</code> ，<code>ServiceManagerService</code> 记为进程 <code>B</code> ；那么进程 <code>A</code> 通过 <code>Binder</code> 机制（采用 <code>IActivityManager</code> 接口）向进程B发起请求服务，进程 <code>B</code> 则通过 <code>Binder</code> 机制(采用 <code>IApplicationThread</code> 接口)向进程 <code>A</code> 发起请求服务。也就是说进程 <code>A</code> 与进程 <code>B</code> 能相互间主动发起请求，进程通信。</p><h2 id="2-4-AMS-startService"><a href="#2-4-AMS-startService" class="headerlink" title="2.4 AMS.startService"></a>2.4 AMS.startService</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ComponentName <span class="title">startService</span><span class="params">(IApplicationThread caller, Intent service,</span></span></span><br><span class="line"><span class="function"><span class="params">        String resolvedType, <span class="keyword">boolean</span> requireForeground, String callingPackage, <span class="keyword">int</span> userId)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line">    <span class="comment">// 当调用者是孤立进程，则抛出异常。</span></span><br><span class="line">    enforceNotIsolatedCaller(<span class="string">&quot;startService&quot;</span>);</span><br><span class="line">    <span class="comment">// Refuse possible leaked file descriptors</span></span><br><span class="line">    <span class="keyword">if</span> (service != <span class="keyword">null</span> &amp;&amp; service.hasFileDescriptors() == <span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;File descriptors passed in Intent&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (callingPackage == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;callingPackage cannot be null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE,</span><br><span class="line">            <span class="string">&quot;*** startService: &quot;</span> + service + <span class="string">&quot; type=&quot;</span> + resolvedType + <span class="string">&quot; fg=&quot;</span> + requireForeground);</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> callingPid = Binder.getCallingPid();<span class="comment">// 调用者 pid</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> callingUid = Binder.getCallingUid();<span class="comment">// 调用者 uid</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">        ComponentName res;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用 ActiveServices 的 startServiceLocked() 方法 【见 2.5】</span></span><br><span class="line">            res = mServices.startServiceLocked(caller, service,</span><br><span class="line">                    resolvedType, callingPid, callingUid,</span><br><span class="line">                    requireForeground, callingPackage, userId);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Binder.restoreCallingIdentity(origId);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数说明</p><ul><li><strong>caller：</strong> <code>IApplicationThread</code> 类型，复杂处理</li><li><strong>service：</strong> <code>Intent</code> 类型，包含需要运行的 <code>service</code> 信息</li><li>*<em>resolvedType： *</em> <code>String</code> 类型</li><li><strong>callingPackage：</strong> <code>String</code> 类型，调用该方法的 <code>package</code> </li><li><strong>userId：</strong> <code>int</code> 类型，用户的 <code>id</code> </li></ul><h2 id="2-5-AS-startServiceLocked"><a href="#2-5-AS-startServiceLocked" class="headerlink" title="2.5 AS.startServiceLocked"></a>2.5 AS.startServiceLocked</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ComponentName <span class="title">startServiceLocked</span><span class="params">(IApplicationThread caller, Intent service, String resolvedType,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> callingPid, <span class="keyword">int</span> callingUid, <span class="keyword">boolean</span> fgRequired, String callingPackage, <span class="keyword">final</span> <span class="keyword">int</span> userId)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> callerFg;</span><br><span class="line">    <span class="keyword">if</span> (caller != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> ProcessRecord callerApp = mAm.getRecordForAppLocked(caller);</span><br><span class="line">        <span class="keyword">if</span> (callerApp == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">&quot;&quot;</span>);<span class="comment">//抛出异常，此处省略异常字符串</span></span><br><span class="line">        &#125;</span><br><span class="line">        callerFg = callerApp.setSchedGroup != ProcessList.SCHED_GROUP_BACKGROUND;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        callerFg = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检索服务信息</span></span><br><span class="line">    ServiceLookupResult res = retrieveServiceLocked(service, resolvedType, callingPackage,</span><br><span class="line">                callingPid, callingUid, userId, <span class="keyword">true</span>, callerFg, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (res.record == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ComponentName(<span class="string">&quot;!&quot;</span>, res.permission != <span class="keyword">null</span> ? res.permission : <span class="string">&quot;private to package&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取出 ServiceRecord 对象，后面启动过程中都是使用的它</span></span><br><span class="line">    ServiceRecord r = res.record;</span><br><span class="line">    <span class="comment">// 检查是否存在启动服务的 user</span></span><br><span class="line">    <span class="keyword">if</span> (!mAm.mUserController.exists(r.userId)) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">&quot;Trying to start service with non-existent user! &quot;</span> + r.userId);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 省略 判断和处理前台服务</span></span><br><span class="line"></span><br><span class="line">    r.lastActivity = SystemClock.uptimeMillis();</span><br><span class="line">    r.startRequested = <span class="keyword">true</span>;<span class="comment">// 启动服务标识置为 true</span></span><br><span class="line">    r.delayedStop = <span class="keyword">false</span>;</span><br><span class="line">    r.fgRequired = fgRequired;</span><br><span class="line">    r.pendingStarts.add(<span class="keyword">new</span> ServiceRecord.StartItem(r, <span class="keyword">false</span>, r.makeNextStartId(),</span><br><span class="line">            service, neededGrants, callingUid));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 省略 对于非前台进程的调度</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用 startServiceInnerLocked() 方法 【见 2.6】</span></span><br><span class="line">    ComponentName cmp = startServiceInnerLocked(smap, service, r, callerFg, addToStarting);</span><br><span class="line">    <span class="keyword">return</span> cmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一种重要的标记符 <code>callerFg</code> , 用于标记是前台还是后台:</p><ul><li>当发起方进程不等于 <code>ProcessList.SCHED_GROUP_BACKGROUND</code> ，或者发起方为空, 则 <code>callerFg= true</code> ；</li><li>否则，<code>callerFg= false</code>；</li></ul><h2 id="2-6-AS-startServiceInnerLocked"><a href="#2-6-AS-startServiceInnerLocked" class="headerlink" title="2.6 AS.startServiceInnerLocked"></a>2.6 AS.startServiceInnerLocked</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ComponentName <span class="title">startServiceInnerLocked</span><span class="params">(ServiceMap smap, Intent service, ServiceRecord r,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> callerFg, <span class="keyword">boolean</span> addToStarting)</span> <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line">    ServiceState stracker = r.getTracker();</span><br><span class="line">    <span class="keyword">if</span> (stracker != <span class="keyword">null</span>) &#123;</span><br><span class="line">        stracker.setStarted(<span class="keyword">true</span>, mAm.mProcessStats.getMemFactorLocked(), r.lastActivity);</span><br><span class="line">    &#125;</span><br><span class="line">    r.callStart = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">synchronized</span> (r.stats.getBatteryStats()) &#123;</span><br><span class="line">        r.stats.startRunningLocked(); <span class="comment">//用于耗电统计，开启运行的状态</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// bringUpServiceLocked 【见 2.7】</span></span><br><span class="line">    String error = bringUpServiceLocked(r, service.getFlags(), callerFg, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (error != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ComponentName(<span class="string">&quot;!!&quot;</span>, error);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r.startRequested &amp;&amp; addToStarting) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> first = smap.mStartingBackground.size() == <span class="number">0</span>;</span><br><span class="line">        smap.mStartingBackground.add(r);</span><br><span class="line">        r.startingBgTimeout = SystemClock.uptimeMillis() + mAm.mConstants.BG_START_TIMEOUT;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_DELAYED_SERVICE) &#123;</span><br><span class="line">            RuntimeException here = <span class="keyword">new</span> RuntimeException(<span class="string">&quot;here&quot;</span>);</span><br><span class="line">            here.fillInStackTrace();</span><br><span class="line">            Slog.v(TAG_SERVICE, <span class="string">&quot;Starting background (first=&quot;</span> + first + <span class="string">&quot;): &quot;</span> + r, here);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (DEBUG_DELAYED_STARTS) &#123;</span><br><span class="line">            Slog.v(TAG_SERVICE, <span class="string">&quot;Starting background (first=&quot;</span> + first + <span class="string">&quot;): &quot;</span> + r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (first) &#123;</span><br><span class="line">            smap.rescheduleDelayedStartsLocked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (callerFg || r.fgRequired) &#123;</span><br><span class="line">        smap.ensureNotStartingBackgroundLocked(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> r.name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-7-AS-bringUpServiceLocked"><a href="#2-7-AS-bringUpServiceLocked" class="headerlink" title="2.7 AS.bringUpServiceLocked"></a>2.7 AS.bringUpServiceLocked</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">bringUpServiceLocked</span><span class="params">(ServiceRecord r, <span class="keyword">int</span> intentFlags, <span class="keyword">boolean</span> execInFg,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> whileRestarting, <span class="keyword">boolean</span> permissionsReviewRequired)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line">    <span class="comment">// 已经启动，重复启动时，直接发送参数调动 onStartCommand() 方法</span></span><br><span class="line">    <span class="keyword">if</span> (r.app != <span class="keyword">null</span> &amp;&amp; r.app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 调用 service.onStartCommand() 过程</span></span><br><span class="line">        sendServiceArgsLocked(r, execInFg, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!whileRestarting &amp;&amp; mRestartingServices.contains(r)) &#123;</span><br><span class="line">        <span class="comment">//等待延迟重启的过程，则直接返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动 service 前，把 service 从重启服务队列中移除</span></span><br><span class="line">    <span class="keyword">if</span> (mRestartingServices.remove(r)) &#123;</span><br><span class="line">        clearRestartingIfNeededLocked(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// service 正在启动，将 delayed 设置为 false</span></span><br><span class="line">    <span class="keyword">if</span> (r.delayed) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE, <span class="string">&quot;REM FR DELAY LIST (bring up): &quot;</span> + r);</span><br><span class="line">        getServiceMapLocked(r.userId).mDelayedStartList.remove(r);</span><br><span class="line">        r.delayed = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确保拥有该服务的 user 已经启动，否则停止；</span></span><br><span class="line">    <span class="keyword">if</span> (!mAm.mUserController.hasStartedUserState(r.userId)) &#123;</span><br><span class="line">        String msg = <span class="string">&quot;Unable to launch app &quot;</span></span><br><span class="line">                + r.appInfo.packageName + <span class="string">&quot;/&quot;</span></span><br><span class="line">                + r.appInfo.uid + <span class="string">&quot; for service &quot;</span></span><br><span class="line">                + r.intent.getIntent() + <span class="string">&quot;: user &quot;</span> + r.userId + <span class="string">&quot; is stopped&quot;</span>;</span><br><span class="line">        Slog.w(TAG, msg);</span><br><span class="line">        bringDownServiceLocked(r);</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 服务正在启动，设置 package 停止状态为 false</span></span><br><span class="line">        AppGlobals.getPackageManager().setPackageStoppedState(</span><br><span class="line">                r.packageName, <span class="keyword">false</span>, r.userId);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">&quot;Failed trying to unstop package &quot;</span> + r.packageName + <span class="string">&quot;: &quot;</span> + e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isolated = (r.serviceInfo.flags&amp;ServiceInfo.FLAG_ISOLATED_PROCESS) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span> String procName = r.processName;</span><br><span class="line">    String hostingType = <span class="string">&quot;service&quot;</span>;</span><br><span class="line">    ProcessRecord app;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isolated) &#123;</span><br><span class="line">        <span class="comment">// 根据进程名和 uid，查询 ProcessRecord</span></span><br><span class="line">        app = mAm.getProcessRecordLocked(procName, r.appInfo.uid, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_MU) Slog.v(TAG_MU, <span class="string">&quot;bringUpServiceLocked: appInfo.uid=&quot;</span> + r.appInfo.uid + <span class="string">&quot; app=&quot;</span> + app);</span><br><span class="line">        <span class="keyword">if</span> (app != <span class="keyword">null</span> &amp;&amp; app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                app.addPackage(r.appInfo.packageName, r.appInfo.longVersionCode, mAm.mProcessStats);</span><br><span class="line">                <span class="comment">// 调用 realStartServiceLocked() 方法 启动服务 【见 2.8】</span></span><br><span class="line">                realStartServiceLocked(r, app, execInFg);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (TransactionTooLargeException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">&quot;Exception when starting service &quot;</span> + r.shortName, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        app = r.isolatedProc;</span><br><span class="line">        <span class="keyword">if</span> (WebViewZygote.isMultiprocessEnabled()</span><br><span class="line">                &amp;&amp; r.serviceInfo.packageName.equals(WebViewZygote.getPackageName())) &#123;</span><br><span class="line">            hostingType = <span class="string">&quot;webview_service&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对于进程没有启动的情况</span></span><br><span class="line">    <span class="keyword">if</span> (app == <span class="keyword">null</span> &amp;&amp; !permissionsReviewRequired) &#123;</span><br><span class="line">        <span class="comment">// 启动 service 所要运行的进程 【见 2.7.1】</span></span><br><span class="line">        <span class="keyword">if</span> ((app=mAm.startProcessLocked(procName, r.appInfo, <span class="keyword">true</span>, intentFlags,</span><br><span class="line">                hostingType, r.name, <span class="keyword">false</span>, isolated, <span class="keyword">false</span>)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            bringDownServiceLocked(r);<span class="comment">// 进程启动失败</span></span><br><span class="line">            <span class="keyword">return</span> msg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isolated) &#123;</span><br><span class="line">            r.isolatedProc = app;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r.fgRequired) &#123;</span><br><span class="line">        mAm.tempWhitelistUidLocked(r.appInfo.uid,SERVICE_START_FOREGROUND_TIMEOUT, <span class="string">&quot;fg-service-launch&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mPendingServices.contains(r)) &#123;</span><br><span class="line">        mPendingServices.add(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r.delayedStop) &#123;</span><br><span class="line">        r.delayedStop = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (r.startRequested) &#123;</span><br><span class="line">            stopServiceLocked(r); <span class="comment">//停止服务</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当目标进程已存在，则直接执行 <code>realStartServiceLocked()</code>；</li><li>当目标进程不存在，则先执行 <code>startProcessLocked</code>（过程待更新 <a href="http://gityuan.com/2016/10/09/app-process-create-2/">Android四大组件与进程启动的关系</a>） 创建进程， 经过层层调用最后会调用到 <code>AMS.attachApplicationLocked</code>, 然后再执行 <code>realStartServiceLocked()</code> 。</li></ul><p>对于非前台进程调用而需要启动的服务，如果已经有其他的后台服务正在启动中，那么我们可能希望延迟其启动。这是用来避免启动同时启动过多的进程(非必须的)。</p><h3 id="2-7-1-AMS-attachApplicationLocked"><a href="#2-7-1-AMS-attachApplicationLocked" class="headerlink" title="2.7.1 AMS.attachApplicationLocked"></a>2.7.1 AMS.attachApplicationLocked</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">attachApplicationLocked</span><span class="params">(IApplicationThread thread, <span class="keyword">int</span> pid)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    thread.bindApplication(processName, appInfo, providers, app.instrumentationClass,</span><br><span class="line">            profilerInfo, app.instrumentationArguments, app.instrumentationWatcher,</span><br><span class="line">            app.instrumentationUiAutomationConnection, testMode, enableOpenGlTrace,</span><br><span class="line">            isRestrictedBackupMode || !normalMode, app.persistent,</span><br><span class="line">            <span class="keyword">new</span> Configuration(mConfiguration), app.compat,</span><br><span class="line">            getCommonServicesLocked(app.isolated),</span><br><span class="line">            mCoreSettingsObserver.getCoreSettingsLocked());</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (!badApp) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//寻找所有需要在该进程中运行的服务 【见 2.7.2】</span></span><br><span class="line">            didSomething |= mServices.attachApplicationLocked(app, processName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            badApp = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-7-2-AS-attachApplicationLocked"><a href="#2-7-2-AS-attachApplicationLocked" class="headerlink" title="2.7.2 AS.attachApplicationLocked"></a>2.7.2 AS.attachApplicationLocked</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">attachApplicationLocked</span><span class="params">(ProcessRecord proc, String processName)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> didSomething = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//启动 mPendingServices 队列中，等待在该进程启动的服务</span></span><br><span class="line">    <span class="keyword">if</span> (mPendingServices.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ServiceRecord sr = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;mPendingServices.size(); i++) &#123;</span><br><span class="line">                sr = mPendingServices.get(i);</span><br><span class="line">                <span class="keyword">if</span> (proc != sr.isolatedProc &amp;&amp; (proc.uid != sr.appInfo.uid</span><br><span class="line">                        || !processName.equals(sr.processName))) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                mPendingServices.remove(i);</span><br><span class="line">                i--;</span><br><span class="line">                <span class="comment">// 将当前服务的包信息加入到 proc</span></span><br><span class="line">                proc.addPackage(sr.appInfo.packageName, sr.appInfo.longVersionCode,mAm.mProcessStats);</span><br><span class="line">                <span class="comment">// 启动服务，即将进入服务的生命周期 </span></span><br><span class="line">                realStartServiceLocked(sr, proc, sr.createdFromFg);</span><br><span class="line">                didSomething = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (!isServiceNeededLocked(sr, <span class="keyword">false</span>, <span class="keyword">false</span>)) &#123;</span><br><span class="line">                    bringDownServiceLocked(sr);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">&quot;Exception in new application when starting service &quot;</span> + sr.shortName, e);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对于正在等待重启并需要运行在该进程的服务，现在是启动它们的大好时机</span></span><br><span class="line">    <span class="keyword">if</span> (mRestartingServices.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ServiceRecord sr;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;mRestartingServices.size(); i++) &#123;</span><br><span class="line">            sr = mRestartingServices.get(i);</span><br><span class="line">            <span class="keyword">if</span> (proc != sr.isolatedProc &amp;&amp; (proc.uid != sr.appInfo.uid</span><br><span class="line">                    || !processName.equals(sr.processName))) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mAm.mHandler.removeCallbacks(sr.restarter);</span><br><span class="line">            mAm.mHandler.post(sr.restarter);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> didSomething;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当需要创建新进程,则创建后经历过 <code>attachApplicationLocked</code>，则会再调用 <code>realStartServiceLocked()</code>；</li><li>当不需要创建进程，即在上一步中直接就进入了 <code>realStartServiceLocked()</code>；</li></ul><h2 id="2-8-AS-realStartServiceLocked"><a href="#2-8-AS-realStartServiceLocked" class="headerlink" title="2.8 AS.realStartServiceLocked"></a>2.8 AS.realStartServiceLocked</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">realStartServiceLocked</span><span class="params">(ServiceRecord r,</span></span></span><br><span class="line"><span class="function"><span class="params">        ProcessRecord app, <span class="keyword">boolean</span> execInFg)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (app.thread == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RemoteException();</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    r.app = app;</span><br><span class="line">    r.restartTime = r.lastActivity = SystemClock.uptimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> newService = app.services.add(r);</span><br><span class="line">    <span class="comment">// 发送 delay 消息 【见 2.8.1】</span></span><br><span class="line">    bumpServiceExecutingLocked(r, execInFg, <span class="string">&quot;create&quot;</span>);</span><br><span class="line">    mAm.updateLruProcessLocked(app, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">    updateServiceForegroundLocked(r.app, <span class="comment">/* oomAdj= */</span> <span class="keyword">false</span>);</span><br><span class="line">    mAm.updateOomAdjLocked();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> created = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (LOG_SERVICE_START_STOP) &#123;</span><br><span class="line">            String nameTerm;</span><br><span class="line">            <span class="keyword">int</span> lastPeriod = r.shortName.lastIndexOf(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">            nameTerm = lastPeriod &gt;= <span class="number">0</span> ? r.shortName.substring(lastPeriod) : r.shortName;</span><br><span class="line">            EventLogTags.writeAmCreateService(</span><br><span class="line">                    r.userId, System.identityHashCode(r), nameTerm, r.app.uid, r.app.pid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (r.stats.getBatteryStats()) &#123;</span><br><span class="line">            r.stats.startLaunchedLocked();</span><br><span class="line">        &#125;</span><br><span class="line">        mAm.notifyPackageUse(r.serviceInfo.packageName,</span><br><span class="line">                             PackageManager.NOTIFY_PACKAGE_USE_SERVICE);</span><br><span class="line">        app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE);</span><br><span class="line">        <span class="comment">// 服务进入 onCreate()，调用 ActivityThread 的 scheduleCreateService() 方法 【见 2.9】</span></span><br><span class="line">        app.thread.scheduleCreateService(r, r.serviceInfo,</span><br><span class="line">                mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),</span><br><span class="line">                app.repProcState);</span><br><span class="line">        r.postNotification();</span><br><span class="line">        created = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (DeadObjectException e) &#123;</span><br><span class="line">        mAm.appDiedLocked(app); <span class="comment">// 应用死亡处理</span></span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!created) &#123;</span><br><span class="line">            <span class="comment">// Keep the executeNesting count accurate.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> inDestroying = mDestroyingServices.contains(r);</span><br><span class="line">            serviceDoneExecutingLocked(r, inDestroying, inDestroying);</span><br><span class="line">            <span class="keyword">if</span> (newService) &#123;</span><br><span class="line">                app.services.remove(r);</span><br><span class="line">                r.app = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 尝试重新启动服务</span></span><br><span class="line">            <span class="keyword">if</span> (!inDestroying) &#123;</span><br><span class="line">                scheduleServiceRestartLocked(r, <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r.whitelistManager) &#123;</span><br><span class="line">        app.whitelistManager = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    requestServiceBindingsLocked(r, execInFg);</span><br><span class="line">    updateServiceClientActivitiesLocked(app, <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是启动，并且需要调用 onStartCommand() 方法，给 pendingStarts 集合增加数据，</span></span><br><span class="line">    <span class="comment">// 因为 onStartCommand() 方法是否会调动是根据 pendingStarts 集合是否有数据来决定是否调用的。</span></span><br><span class="line">    <span class="comment">// 在后面说参数调用的时候就会知道，如果仅仅是绑定服务，就不会添加，这也就是为什么我们绑定服务时不会回调 onStartCommand() 方法的原因</span></span><br><span class="line">    <span class="keyword">if</span> (r.startRequested &amp;&amp; r.callStart &amp;&amp; r.pendingStarts.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        r.pendingStarts.add(<span class="keyword">new</span> ServiceRecord.StartItem(r, <span class="keyword">false</span>, r.makeNextStartId(),<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 服务 进入 onStartCommand() 【见 2.15】</span></span><br><span class="line">    sendServiceArgsLocked(r, execInFg, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r.delayed) &#123;</span><br><span class="line">        getServiceMapLocked(r.userId).mDelayedStartList.remove(r);</span><br><span class="line">        r.delayed = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r.delayedStop) &#123;</span><br><span class="line">        r.delayedStop = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (r.startRequested) &#123;</span><br><span class="line">            stopServiceLocked(r); <span class="comment">//停止服务</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-8-1-AS-bumpServiceExecutingLocked"><a href="#2-8-1-AS-bumpServiceExecutingLocked" class="headerlink" title="2.8.1 AS.bumpServiceExecutingLocked"></a>2.8.1 AS.bumpServiceExecutingLocked</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">bumpServiceExecutingLocked</span><span class="params">(ServiceRecord r, <span class="keyword">boolean</span> fg, String why)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> timeoutNeeded = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> ((mAm.mBootPhase &lt; SystemService.PHASE_THIRD_PARTY_APPS_CAN_START)</span><br><span class="line">            &amp;&amp; (r.app != <span class="keyword">null</span>) &amp;&amp; (r.app.pid == android.os.Process.myPid())) &#123;</span><br><span class="line">        timeoutNeeded = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (r.executeNesting == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r.app != <span class="keyword">null</span> &amp;&amp; fg &amp;&amp; !r.app.execServicesFg) &#123;</span><br><span class="line">        r.app.execServicesFg = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (timeoutNeeded) &#123;</span><br><span class="line">            scheduleServiceTimeoutLocked(r.app); <span class="comment">// 【见 2.8.2】</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-8-2-AS-scheduleServiceTimeoutLocked"><a href="#2-8-2-AS-scheduleServiceTimeoutLocked" class="headerlink" title="2.8.2 AS.scheduleServiceTimeoutLocked"></a>2.8.2 AS.scheduleServiceTimeoutLocked</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleServiceTimeoutLocked</span><span class="params">(ProcessRecord proc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (proc.executingServices.size() == <span class="number">0</span> || proc.thread == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Message msg = mAm.mHandler.obtainMessage(</span><br><span class="line">            ActivityManagerService.SERVICE_TIMEOUT_MSG);</span><br><span class="line">    msg.obj = proc;</span><br><span class="line">    <span class="comment">// 当超时后仍没有 remove 该 SERVICE_TIMEOUT_MSG 消息，则执行 service Timeout 流程</span></span><br><span class="line">    mAm.mHandler.sendMessageDelayed(msg,</span><br><span class="line">            proc.execServicesFg ? SERVICE_TIMEOUT : SERVICE_BACKGROUND_TIMEOUT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发送延时消息 `SERVICE_TIMEOUT_MSG 延时时长：</p><ul><li>对于前台服务，则超时为 <code>SERVICE_TIMEOUT</code>，即 <code>timeout=20s</code>；</li><li>对于后台服务，则超时为 <code>SERVICE_BACKGROUND_TIMEOUT</code>，即 <code>timeout=200s</code>；</li></ul><h2 id="2-9-IAT-Stub-Proxy-scheduleCreateService"><a href="#2-9-IAT-Stub-Proxy-scheduleCreateService" class="headerlink" title="2.9 IAT.Stub.Proxy.scheduleCreateService"></a>2.9 IAT.Stub.Proxy.scheduleCreateService</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleCreateService</span><span class="params">(android.os.IBinder token, android.content.pm.ServiceInfo info, android.content.res.CompatibilityInfo compatInfo, <span class="keyword">int</span> processState)</span> <span class="keyword">throws</span> android.os.RemoteException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">    _data.writeStrongBinder(token);</span><br><span class="line">    <span class="keyword">if</span> ((info!=<span class="keyword">null</span>)) &#123;</span><br><span class="line">      _data.writeInt(<span class="number">1</span>);</span><br><span class="line">      info.writeToParcel(_data, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      _data.writeInt(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((compatInfo!=<span class="keyword">null</span>)) &#123;</span><br><span class="line">      _data.writeInt(<span class="number">1</span>);</span><br><span class="line">      compatInfo.writeToParcel(_data, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      _data.writeInt(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    _data.writeInt(processState);</span><br><span class="line">    <span class="comment">//【见 2.9.1】</span></span><br><span class="line">    <span class="keyword">boolean</span> _status = mRemote.transact(Stub.TRANSACTION_scheduleCreateService, _data, <span class="keyword">null</span>, android.os.IBinder.FLAG_ONEWAY);</span><br><span class="line">    <span class="keyword">if</span> (!_status) &#123;</span><br><span class="line">      <span class="keyword">if</span> (getDefaultImpl() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        getDefaultImpl().scheduleCreateService(token, info, compatInfo, processState);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">    _data.recycle();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-9-1-IAT-Stub-onTransact-Service-gt-Client"><a href="#2-9-1-IAT-Stub-onTransact-Service-gt-Client" class="headerlink" title="2.9.1 IAT.Stub.onTransact (Service -&gt; Client)"></a>2.9.1 IAT.Stub.onTransact (Service -&gt; Client)</h3><p>到这里，借助 <code>IAT</code> 这个 <code>AIDL</code> ，便完成了从 <code>system_server</code> 进程（服务进程）到了 <code>Service</code> 所在的进程（Client 的进程）的调用过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, android.os.Parcel data, android.os.Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> android.os.RemoteException</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (code)</span><br><span class="line">    ...</span><br><span class="line">      <span class="keyword">case</span> TRANSACTION_scheduleCreateService:</span><br><span class="line">      &#123;</span><br><span class="line">        data.enforceInterface(descriptor);</span><br><span class="line">        android.os.IBinder _arg0;</span><br><span class="line">        _arg0 = data.readStrongBinder();</span><br><span class="line">        android.content.pm.ServiceInfo _arg1;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="number">0</span>!=data.readInt())) &#123;</span><br><span class="line">          _arg1 = android.content.pm.ServiceInfo.CREATOR.createFromParcel(data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          _arg1 = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        android.content.res.CompatibilityInfo _arg2;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="number">0</span>!=data.readInt())) &#123;</span><br><span class="line">          _arg2 = android.content.res.CompatibilityInfo.CREATOR.createFromParcel(data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          _arg2 = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> _arg3;</span><br><span class="line">        _arg3 = data.readInt();</span><br><span class="line">        <span class="comment">//调用 ActivityThread.ApplicationThread 的 scheduleCreateService() 方法 【见 2.9.2】</span></span><br><span class="line">        <span class="keyword">this</span>.scheduleCreateService(_arg0, _arg1, _arg2, _arg3);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="2-9-2-AT-scheduleCreateService"><a href="#2-9-2-AT-scheduleCreateService" class="headerlink" title="2.9.2 AT.scheduleCreateService"></a>2.9.2 AT.scheduleCreateService</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">scheduleCreateService</span><span class="params">(IBinder token,</span></span></span><br><span class="line"><span class="function"><span class="params">        ServiceInfo info, CompatibilityInfo compatInfo, <span class="keyword">int</span> processState)</span> </span>&#123;</span><br><span class="line">    updateProcessState(processState, <span class="keyword">false</span>);</span><br><span class="line">    CreateServiceData s = <span class="keyword">new</span> CreateServiceData();<span class="comment">// 准备服务创建所需的数据</span></span><br><span class="line">    s.token = token;</span><br><span class="line">    s.info = info;</span><br><span class="line">    s.compatInfo = compatInfo;</span><br><span class="line"><span class="comment">// 给 Handler 类 H 发送 CREATE_SERVICE  【见 2.10】 </span></span><br><span class="line">    sendMessage(H.CREATE_SERVICE, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> H mH = <span class="keyword">new</span> H();</span><br></pre></td></tr></table></figure><p><code>H</code> 是 <code>ActivityThread</code> 的内部类，继承 <code>Handler</code></p><h2 id="2-10-AT-H-handleMessage"><a href="#2-10-AT-H-handleMessage" class="headerlink" title="2.10 AT.H.handleMessage"></a>2.10 AT.H.handleMessage</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(<span class="keyword">int</span> what, Object obj)</span> </span>&#123;</span><br><span class="line">    sendMessage(what, obj, <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(<span class="keyword">int</span> what, Object obj, <span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">    Message msg = Message.obtain();</span><br><span class="line">    msg.what = what;</span><br><span class="line">    msg.obj = obj;</span><br><span class="line">    msg.arg1 = arg1;</span><br><span class="line">    msg.arg2 = arg2;</span><br><span class="line">    <span class="keyword">if</span> (async) &#123;</span><br><span class="line">        msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mH.sendMessage(msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">H</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">            <span class="keyword">case</span> CREATE_SERVICE:</span><br><span class="line">                handleCreateService((CreateServiceData)msg.obj);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> BIND_SERVICE:</span><br><span class="line">                handleBindService((BindServiceData)msg.obj);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> UNBIND_SERVICE:</span><br><span class="line">                handleUnbindService((BindServiceData)msg.obj);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SERVICE_ARGS:</span><br><span class="line">                handleServiceArgs((ServiceArgsData)msg.obj);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> STOP_SERVICE:</span><br><span class="line">                handleStopService((IBinder)msg.obj);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-11-AT-handleCreateService"><a href="#2-11-AT-handleCreateService" class="headerlink" title="2.11 AT.handleCreateService"></a>2.11 AT.handleCreateService</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleCreateService</span><span class="params">(CreateServiceData data)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当应用处于后台即将进行 GC，而此时被调回到活动状态，则跳过本次 gc。</span></span><br><span class="line">    unscheduleGcIdler();</span><br><span class="line">    LoadedApk packageInfo = getPackageInfoNoCheck(data.info.applicationInfo, data.compatInfo);</span><br><span class="line">    <span class="comment">// 通过反射创建目标服务对象</span></span><br><span class="line">    Service service = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 使用类加载器通过反射的形势创建 Service 对象</span></span><br><span class="line">        java.lang.ClassLoader cl = packageInfo.getClassLoader();</span><br><span class="line">      <span class="comment">// packageInfo.getAppFactory()【见 2.11.1】</span></span><br><span class="line">      <span class="comment">// instantiateService 【见 2.12】</span></span><br><span class="line">        service = packageInfo.getAppFactory().instantiateService(cl, data.info.name, data.intent);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 ContextImpl 对象</span></span><br><span class="line">        ContextImpl context = ContextImpl.createAppContext(<span class="keyword">this</span>, packageInfo);</span><br><span class="line">        context.setOuterContext(service);</span><br><span class="line">        <span class="comment">// 创建 Application 对象</span></span><br><span class="line">        Application app = packageInfo.makeApplication(<span class="keyword">false</span>, mInstrumentation);</span><br><span class="line">        <span class="comment">// Serivce 的 attach() 回调，并建立 Service 和 ContextImpl 之间的联系 【见 2.13】</span></span><br><span class="line">        service.attach(context, <span class="keyword">this</span>, data.info.name, data.token, app,ActivityManager.getService());</span><br><span class="line">        <span class="comment">// 调用服务 onCreate() 方法 【见 2.13】</span></span><br><span class="line">        service.onCreate();</span><br><span class="line">        <span class="comment">// 将Service保存到集合中   final ArrayMap&lt;IBinder, Service&gt; mServices = new ArrayMap&lt;&gt;();</span></span><br><span class="line">        mServices.put(data.token, service);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用服务创建完成 【见 2.14】</span></span><br><span class="line">            ActivityManager.getService().serviceDoneExecuting(data.token, SERVICE_DONE_EXECUTING_ANON, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-11-1-packageInfo-getAppFactory"><a href="#2-11-1-packageInfo-getAppFactory" class="headerlink" title="2.11.1 packageInfo.getAppFactory()"></a>2.11.1 packageInfo.getAppFactory()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AppComponentFactory <span class="title">getAppFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mAppComponentFactory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给 mAppComponentFactory 赋值</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> AppComponentFactory <span class="title">createAppFactory</span><span class="params">(ApplicationInfo appInfo, ClassLoader cl)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (appInfo.appComponentFactory != <span class="keyword">null</span> &amp;&amp; cl != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (AppComponentFactory) cl.loadClass(appInfo.appComponentFactory)</span><br><span class="line">                    .newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException | ClassNotFoundException e) &#123;</span><br><span class="line">            Slog.e(TAG, <span class="string">&quot;Unable to instantiate appComponentFactory&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> AppComponentFactory.DEFAULT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-12-ACF-instantiateService"><a href="#2-12-ACF-instantiateService" class="headerlink" title="2.12 ACF.instantiateService"></a>2.12 ACF.instantiateService</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@NonNull</span> <span class="function">Service <span class="title">instantiateService</span><span class="params">(<span class="meta">@NonNull</span> ClassLoader cl,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@NonNull</span> String className, <span class="meta">@Nullable</span> Intent intent)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InstantiationException, IllegalAccessException, ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">// 通过反射创建 Service</span></span><br><span class="line">    <span class="keyword">return</span> (Service) cl.loadClass(className).newInstance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-13-Service-attach-onCreate"><a href="#2-13-Service-attach-onCreate" class="headerlink" title="2.13 Service.attach/onCreate"></a>2.13 Service.attach/onCreate</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Service</span> <span class="keyword">extends</span> <span class="title">ContextWrapper</span> <span class="keyword">implements</span> <span class="title">ComponentCallbacks2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            Context context,</span></span></span><br><span class="line"><span class="function"><span class="params">            ActivityThread thread, String className, IBinder token,</span></span></span><br><span class="line"><span class="function"><span class="params">            Application application, Object activityManager)</span> </span>&#123;</span><br><span class="line">        attachBaseContext(context);</span><br><span class="line">        mThread = thread;          </span><br><span class="line">        mClassName = className;</span><br><span class="line">        mToken = token;</span><br><span class="line">        mApplication = application;</span><br><span class="line">        mActivityManager = (IActivityManager)activityManager;</span><br><span class="line">        mStartCompatibility = getApplicationInfo().targetSdkVersion</span><br><span class="line">                &lt; Build.VERSION_CODES.ECLAIR;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span></span>&#123;    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终调用 <code>Service.onCreate()</code> 方法，对于目标服务都是继承于 <code>Service</code> ，并覆写该方式，调用目标服务的 <code>onCreate()</code> 方法。拨云见日，到此总算是进入了 <code>Service</code> 的生命周期。</p><h2 id="2-14-AMS-serviceDoneExecuting"><a href="#2-14-AMS-serviceDoneExecuting" class="headerlink" title="2.14 AMS.serviceDoneExecuting"></a>2.14 AMS.serviceDoneExecuting</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serviceDoneExecuting</span><span class="params">(IBinder token, <span class="keyword">int</span> type, <span class="keyword">int</span> startId, <span class="keyword">int</span> res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        mServices.serviceDoneExecutingLocked((ServiceRecord)token, type, startId, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由 <code>2.8.1</code> 的 <code>bumpServiceExecutingLocked</code> 发送一个延时消息 <code>SERVICE_TIMEOUT_MSG</code></p><h3 id="2-14-1-AS-serviceDoneExecutingLocked"><a href="#2-14-1-AS-serviceDoneExecutingLocked" class="headerlink" title="2.14.1 AS.serviceDoneExecutingLocked"></a>2.14.1 AS.serviceDoneExecutingLocked</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serviceDoneExecutingLocked</span><span class="params">(ServiceRecord r, <span class="keyword">int</span> type, <span class="keyword">int</span> startId, <span class="keyword">int</span> res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> inDestroying = mDestroyingServices.contains(r);</span><br><span class="line">    <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">      <span class="comment">// 【见 2.14.2】</span></span><br><span class="line">        serviceDoneExecutingLocked(r, inDestroying, inDestroying);</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-14-2-AS-serviceDoneExecutingLocked"><a href="#2-14-2-AS-serviceDoneExecutingLocked" class="headerlink" title="2.14.2 AS.serviceDoneExecutingLocked"></a>2.14.2 AS.serviceDoneExecutingLocked</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">serviceDoneExecutingLocked</span><span class="params">(ServiceRecord r, <span class="keyword">boolean</span> inDestroying,<span class="keyword">boolean</span> finishing)</span> </span>&#123;</span><br><span class="line">    r.executeNesting--;</span><br><span class="line">    <span class="keyword">if</span> (r.executeNesting &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (r.app != <span class="keyword">null</span>) &#123;</span><br><span class="line">            r.app.execServicesFg = <span class="keyword">false</span>;</span><br><span class="line">            r.app.executingServices.remove(r);</span><br><span class="line">            <span class="keyword">if</span> (r.app.executingServices.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 移除服务启动超时的消息</span></span><br><span class="line">                mAm.mHandler.removeMessages(ActivityManagerService.SERVICE_TIMEOUT_MSG, r.app);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r.executeFg) &#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (inDestroying) &#123;</span><br><span class="line">                mDestroyingServices.remove(r);</span><br><span class="line">                r.bindings.clear();</span><br><span class="line">            &#125;</span><br><span class="line">            mAm.updateOomAdjLocked(r.app, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        r.executeFg = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r.app != <span class="keyword">null</span> &amp;&amp; !r.app.persistent) &#123;</span><br><span class="line">                r.app.services.remove(r);</span><br><span class="line">                <span class="keyword">if</span> (r.whitelistManager) &#123;</span><br><span class="line">                    updateWhitelistManagerLocked(r.app);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            r.app = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>handleCreateService()</code> 执行后便会移除服务启动超时的消息 <code>SERVICE_TIMEOUT_MSG</code>。<code>Service</code> 启动过程出现 <code>ANR</code> ，<code>”executing service [发送超时serviceRecord信息]”</code>， 这往往是 <code>service</code> 的 <code>onCreate()</code> 回调方法执行时间过长。</p><p>在 <code>2.8 AS.realStartServiceLocked</code> 方法在完成 <code>onCreate</code> 操作,解析来便是进入 <code>onStartCommand</code> 方法.</p><h2 id="2-15-AS-sendServiceArgsLocked"><a href="#2-15-AS-sendServiceArgsLocked" class="headerlink" title="2.15 AS.sendServiceArgsLocked"></a>2.15 AS.sendServiceArgsLocked</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">sendServiceArgsLocked</span><span class="params">(ServiceRecord r, <span class="keyword">boolean</span> execInFg,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> oomAdjusted)</span> <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> N = r.pendingStarts.size();</span><br><span class="line">    <span class="keyword">if</span> (N == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ArrayList&lt;ServiceStartArgs&gt; args = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (r.pendingStarts.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ServiceRecord.StartItem si = r.pendingStarts.remove(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (si.intent == <span class="keyword">null</span> &amp;&amp; N &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        si.deliveredTime = SystemClock.uptimeMillis();</span><br><span class="line">        r.deliveredStarts.add(si);</span><br><span class="line">        si.deliveryCount++;</span><br><span class="line">        <span class="keyword">if</span> (si.neededGrants != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mAm.grantUriPermissionUncheckedFromIntentLocked(si.neededGrants,</span><br><span class="line">                    si.getUriPermissionsLocked());</span><br><span class="line">        &#125;</span><br><span class="line">        mAm.grantEphemeralAccessLocked(r.userId, si.intent,</span><br><span class="line">                r.appInfo.uid, UserHandle.getAppId(si.callingId));</span><br><span class="line">        <span class="comment">// 标记启动开始 【见 2.8.1】</span></span><br><span class="line">        bumpServiceExecutingLocked(r, execInFg, <span class="string">&quot;start&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!oomAdjusted) &#123;</span><br><span class="line">            oomAdjusted = <span class="keyword">true</span>;</span><br><span class="line">            mAm.updateOomAdjLocked(r.app, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r.fgRequired &amp;&amp; !r.fgWaiting) &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> flags = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (si.deliveryCount &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            flags |= Service.START_FLAG_RETRY;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (si.doneExecutingCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            flags |= Service.START_FLAG_REDELIVERY;</span><br><span class="line">        &#125;</span><br><span class="line">        args.add(<span class="keyword">new</span> ServiceStartArgs(si.taskRemoved, si.id, flags, si.intent));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ParceledListSlice&lt;ServiceStartArgs&gt; slice = <span class="keyword">new</span> ParceledListSlice&lt;&gt;(args);</span><br><span class="line">    slice.setInlineCountLimit(<span class="number">4</span>);</span><br><span class="line">    Exception caughtException = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//该过程类似 [流程 2.9 ~ 2.10]，只是服务端调用不同客户端的方法，最终会调用  AT.handleServiceArgs -&gt; onStartCommand</span></span><br><span class="line">        r.app.thread.scheduleServiceArgs(r, slice);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        caughtException = e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (caughtException != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> inDestroying = mDestroyingServices.contains(r);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.size(); i++) &#123;</span><br><span class="line">            serviceDoneExecutingLocked(r, inDestroying, inDestroying);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (caughtException <span class="keyword">instanceof</span> TransactionTooLargeException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (TransactionTooLargeException)caughtException;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、bindService-源码"><a href="#三、bindService-源码" class="headerlink" title="三、bindService 源码"></a>三、bindService 源码</h1><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/android/android_service_bind.png" alt="图片来源于网络"></p><h2 id="3-1-CW-bindService"><a href="#3-1-CW-bindService" class="headerlink" title="3.1 CW.bindService"></a>3.1 CW.bindService</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ContextWrapper.java</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">bindService</span><span class="params">(Intent service, ServiceConnection conn,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mBase.bindService(service, conn, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-CI-bindService"><a href="#3-2-CI-bindService" class="headerlink" title="3.2 CI.bindService"></a>3.2 CI.bindService</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ContextImpl.java</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">bindService</span><span class="params">(Intent service, ServiceConnection conn,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    warnIfCallingFromSystemProcess();</span><br><span class="line">    <span class="keyword">return</span> bindServiceCommon(service, conn, flags, mMainThread.getHandler(), getUser());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-CI-bindServiceCommon"><a href="#3-3-CI-bindServiceCommon" class="headerlink" title="3.3 CI.bindServiceCommon"></a>3.3 CI.bindServiceCommon</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">bindServiceCommon</span><span class="params">(Intent service, ServiceConnection conn, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">        String instanceName, Handler handler, Executor executor, UserHandle user)</span> </span>&#123;</span><br><span class="line">    IServiceConnection sd;</span><br><span class="line">    <span class="keyword">if</span> (conn == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;connection is null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (handler != <span class="keyword">null</span> &amp;&amp; executor != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Handler and Executor both supplied&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// mPackageInfo 为 LoadedApk</span></span><br><span class="line">    <span class="keyword">if</span> (mPackageInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (executor != <span class="keyword">null</span>) &#123;</span><br><span class="line">            sd = mPackageInfo.getServiceDispatcher(conn, getOuterContext(), executor, flags);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// handler 不为 null，将 ServiceConnection 封装成 IServiceConnection</span></span><br><span class="line">    <span class="comment">// IServiceConnection 就是 LoadedApk.ServiceDispatcher.InnerConnection 类</span></span><br><span class="line">    <span class="comment">// 将 conn 保持到InnerConnection中，handler 为主线程 Handler，也就是 ActivityThread 的内部类 H 对象</span></span><br><span class="line">          <span class="comment">// 【见 4.1】</span></span><br><span class="line">            sd = mPackageInfo.getServiceDispatcher(conn, getOuterContext(), handler, flags);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Not supported in system context&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    validateServiceIntent(service);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        IBinder token = getActivityToken();</span><br><span class="line">        <span class="keyword">if</span> (token == <span class="keyword">null</span> &amp;&amp; (flags&amp;BIND_AUTO_CREATE) == <span class="number">0</span> &amp;&amp; mPackageInfo != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; mPackageInfo.getApplicationInfo().targetSdkVersion</span><br><span class="line">                &lt; android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH) &#123;</span><br><span class="line">            flags |= BIND_WAIVE_PRIORITY;</span><br><span class="line">        &#125;</span><br><span class="line">        service.prepareToLeaveProcess(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 调用 AMS 的 bindIsolatedService() 方法 【见 3.4】</span></span><br><span class="line">        <span class="keyword">int</span> res = ActivityManager.getService().bindIsolatedService(</span><br><span class="line">            mMainThread.getApplicationThread(), getActivityToken(), service,</span><br><span class="line">            service.resolveTypeIfNeeded(getContentResolver()),</span><br><span class="line">            sd, flags, instanceName, getOpPackageName(), user.getIdentifier());</span><br><span class="line">        <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">&quot;Not allowed to bind to service &quot;</span> + service);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res != <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>在这里需要注意以上注释的地方，因为绑定 <code>Service</code> 最终客户端要回调 <code>ServiceConnection</code> 对象的 <code>onServiceConnected()</code> 方法，<code>mPackageInfo.getServiceDispatcher()</code> 就是将我们调用 <code>bindService()</code> 方法传递的 <code>ServiceConnection</code> 对象封装成 <code>IServiceConnection(实现类为LoadedApk.ServiceDispatcher.InnerConnection)</code> 。这是一个 <code>aidl</code> 接口，这是因为 <code>Service</code> 启动和绑定时跨进程的，普通的 <code>ServiceConnection</code> 是不能款进程传输的，所以需要进行封装与转换成 <code>aidl</code> 类型。</p><p><code>ActivityManager.getService().bindIsolatedService</code> 这里不做过多讲解，上面已经讲过了，最终调用的是 <code>AMS</code> 的 <code>bindIsolatedService</code> </p><h2 id="3-4-AMS-bindIsolatedService"><a href="#3-4-AMS-bindIsolatedService" class="headerlink" title="3.4 AMS.bindIsolatedService"></a>3.4 AMS.bindIsolatedService</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bindIsolatedService</span><span class="params">(IApplicationThread caller, IBinder token, Intent service,</span></span></span><br><span class="line"><span class="function"><span class="params">        String resolvedType, IServiceConnection connection, <span class="keyword">int</span> flags, String instanceName,</span></span></span><br><span class="line"><span class="function"><span class="params">        String callingPackage, <span class="keyword">int</span> userId)</span> <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="comment">// 调用 ActiveServices 的 bindServiceLocked() 方法 【见 3.5】</span></span><br><span class="line">        <span class="keyword">return</span> mServices.bindServiceLocked(caller, token, service,</span><br><span class="line">                resolvedType, connection, flags, instanceName, callingPackage, userId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-5-AS-bindServiceLocked"><a href="#3-5-AS-bindServiceLocked" class="headerlink" title="3.5 AS.bindServiceLocked"></a>3.5 AS.bindServiceLocked</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bindServiceLocked</span><span class="params">(IApplicationThread caller, IBinder token, Intent service,</span></span></span><br><span class="line"><span class="function"><span class="params">        String resolvedType, <span class="keyword">final</span> IServiceConnection connection, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">        String instanceName, String callingPackage, <span class="keyword">final</span> <span class="keyword">int</span> userId)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line"><span class="comment">// ... 省略 </span></span><br><span class="line">  ServiceLookupResult res =</span><br><span class="line">        retrieveServiceLocked(service, instanceName, resolvedType, callingPackage,</span><br><span class="line">                callingPid, callingUid, userId, <span class="keyword">true</span>,</span><br><span class="line">                callerFg, isBindExternal, allowInstant);</span><br><span class="line">    ServiceRecord s = res.record;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 绑定服务时，调用 ServiceRecord 的 retrieveAppBindingLocked() 方法，</span></span><br><span class="line"><span class="comment">// 在该方法中给 ServiceRecord的 bindings 添加绑定记录</span></span><br><span class="line">        AppBindRecord b = s.retrieveAppBindingLocked(service, callerApp);</span><br><span class="line">        ConnectionRecord c = <span class="keyword">new</span> ConnectionRecord(b, activity,</span><br><span class="line">                connection, flags, clientLabel, clientIntent,</span><br><span class="line">                callerApp.uid, callerApp.processName, callingPackage);</span><br><span class="line"></span><br><span class="line">        IBinder binder = connection.asBinder();</span><br><span class="line">        s.addConnection(binder, c);</span><br><span class="line">        b.connections.add(c);</span><br><span class="line">        <span class="keyword">if</span> (activity != <span class="keyword">null</span>) &#123;</span><br><span class="line">            activity.addConnection(c);</span><br><span class="line">        &#125;</span><br><span class="line">        b.client.connections.add(c);</span><br><span class="line">        c.startAssociationIfNeeded();</span><br><span class="line">        <span class="comment">// ... 省略 </span></span><br><span class="line">        <span class="keyword">if</span> ((flags&amp;Context.BIND_AUTO_CREATE) != <span class="number">0</span>) &#123;</span><br><span class="line">            s.lastActivity = SystemClock.uptimeMillis();</span><br><span class="line">          <span class="comment">// 【见 3.6】</span></span><br><span class="line">            <span class="keyword">if</span> (bringUpServiceLocked(s, service.getFlags(), callerFg, <span class="keyword">false</span>,</span><br><span class="line">                    permissionsReviewRequired) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// ... 省略 </span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意，上面注释部分，绑定服务时，我们将连接对象保存到了 ServiceRecord 中。</strong></p><h2 id="3-6-AS-bringUpServiceLocked"><a href="#3-6-AS-bringUpServiceLocked" class="headerlink" title="3.6 AS.bringUpServiceLocked"></a>3.6 AS.bringUpServiceLocked</h2><p>绑定服务到这里，后面调用 <code>attach()</code> 和 <code>onCreate()</code> 方法就和启动服务时一样的了 <code>见 startService 2.7</code> ，在 <code>bringUpServiceLocked()</code> 中 调用<br><code>realStartServiceLocked()</code> 方法，接着继续往下调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">bringUpServiceLocked</span><span class="params">(ServiceRecord r, <span class="keyword">int</span> intentFlags, <span class="keyword">boolean</span> execInFg,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> whileRestarting, <span class="keyword">boolean</span> permissionsReviewRequired)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 调用 realStartServiceLocked() 方法 启动服务 【见 3.7】</span></span><br><span class="line">    realStartServiceLocked(r, app, execInFg);</span><br><span class="line">                </span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-7-AS-realStartServiceLocked"><a href="#3-7-AS-realStartServiceLocked" class="headerlink" title="3.7 AS.realStartServiceLocked"></a>3.7 AS.realStartServiceLocked</h2><p>这一步，<strong>和启动 Service 不一样的是，在 <code>realStartServiceLocked()</code> 方法中会调用 <code>requestServiceBindingsLocked()</code> 方法，处理绑定服务的过程</strong> <code>(其他过程请看 startService 2.8)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">realStartServiceLocked</span><span class="params">(ServiceRecord r,</span></span></span><br><span class="line"><span class="function"><span class="params">        ProcessRecord app, <span class="keyword">boolean</span> execInFg)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">    <span class="comment">// 【见 3.14】</span></span><br><span class="line">    requestServiceBindingsLocked(r, execInFg);</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">    <span class="comment">// 服务 进入 onStartCommand() 【见 2.15】</span></span><br><span class="line">    sendServiceArgsLocked(r, execInFg, <span class="keyword">true</span>);</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流程图中 [8 -13] 对应 <code>startService</code> 中的 [9 - 14]</p><p><strong>这里省略 3.8 - 3.13</strong></p><h2 id="3-14-AS-requestServiceBindingsLocked"><a href="#3-14-AS-requestServiceBindingsLocked" class="headerlink" title="3.14 AS.requestServiceBindingsLocked"></a>3.14 AS.requestServiceBindingsLocked</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">requestServiceBindingsLocked</span><span class="params">(ServiceRecord r, <span class="keyword">boolean</span> execInFg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line">    <span class="comment">// 根据 ServiceRecord 的 bindings 是否有数据调用 requestServiceBindingLocked() 方法，在上一步给它添加了数据 【见 3.15】</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=r.bindings.size()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">        IntentBindRecord ibr = r.bindings.valueAt(i);</span><br><span class="line">        <span class="keyword">if</span> (!requestServiceBindingLocked(r, ibr, execInFg, <span class="keyword">false</span>)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据是否有连接对象判断是否需要调用 <code>ActiveServices</code> 中的<code>requestServiceBindingLocked()</code> 方法<code>(和当前方法差了个 s,bindings)</code>，绑定 <code>Service</code> 在 <code>ActiveServices</code> 中的 <code>bindServiceLocked()</code> 方法中添加了，所以集合肯定不会为空</p><h2 id="3-15-AS-requestServiceBindingLocked"><a href="#3-15-AS-requestServiceBindingLocked" class="headerlink" title="3.15 AS.requestServiceBindingLocked"></a>3.15 AS.requestServiceBindingLocked</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">requestServiceBindingLocked</span><span class="params">(ServiceRecord r, IntentBindRecord i,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> execInFg, <span class="keyword">boolean</span> rebind)</span> <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((!i.requested || rebind) &amp;&amp; i.apps.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bumpServiceExecutingLocked(r, execInFg, <span class="string">&quot;bind&quot;</span>);</span><br><span class="line">            r.app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE);</span><br><span class="line">            <span class="comment">// 调用 ActivityThread 的 scheduleBindService() 方法 【见 3.18】</span></span><br><span class="line">            r.app.thread.scheduleBindService(r, i.intent.getIntent(), rebind, r.app.getReportedProcState());</span><br><span class="line">            <span class="keyword">if</span> (!rebind) &#123;</span><br><span class="line">                i.requested = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i.hasBound = <span class="keyword">true</span>;</span><br><span class="line">            i.doRebind = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TransactionTooLargeException e) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> inDestroying = mDestroyingServices.contains(r);</span><br><span class="line">            serviceDoneExecutingLocked(r, inDestroying, inDestroying);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> inDestroying = mDestroyingServices.contains(r);</span><br><span class="line">            serviceDoneExecutingLocked(r, inDestroying, inDestroying);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>[15 - 17]</code> 就是 <code>Service</code> 端到 <code>Client</code> 端的调用，类似 <code>startService</code> 的 <code>[2.9 - 2.10]</code> </p><p><strong>这里省略 3.16 - 3.17</strong></p><h2 id="3-18-AT-handleBindService"><a href="#3-18-AT-handleBindService" class="headerlink" title="3.18 AT.handleBindService"></a>3.18 AT.handleBindService</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleBindService</span><span class="params">(BindServiceData data)</span> </span>&#123;</span><br><span class="line">    Service s = mServices.get(data.token);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            data.intent.setExtrasClassLoader(s.getClassLoader());</span><br><span class="line">            data.intent.prepareToEnterProcess();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!data.rebind) &#123;</span><br><span class="line">                  <span class="comment">// 调用 Service 的 onBind() 方法 【见 3.19】</span></span><br><span class="line">                    IBinder binder = s.onBind(data.intent);</span><br><span class="line">                  <span class="comment">// 这里调用 ActivityManagerService 的 publishService() 方法 【见 4.2】</span></span><br><span class="line">                    ActivityManager.getService().publishService(</span><br><span class="line">                            data.token, data.intent, binder);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="comment">// 如果是重新绑定，就调用 Service 的 onRebind() 方法  【见 3.19】</span></span><br><span class="line">                    s.onRebind(data.intent);</span><br><span class="line">                    ActivityManager.getService().serviceDoneExecuting(</span><br><span class="line">                            data.token, SERVICE_DONE_EXECUTING_ANON, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mInstrumentation.onException(s, e)) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-19-onBind-onRebind"><a href="#3-19-onBind-onRebind" class="headerlink" title="3.19 onBind/onRebind"></a>3.19 onBind/onRebind</h2><p>在上面的方法中我们已经看到了 <code>Service</code> 的 <code>onBind()</code> 或者 <code>onRebind()</code> 方法已经被调用了，那么对于Service类来说已经执行完成了。但是我们绑定<code>Service</code>，客户端需要拿到 <code>IBinder</code> 对象，这个对象是在 <code>ServiceConnection</code> 对象的回调 <code>onServiceConnected()</code> 方法取到的，所以我们继续看看这个过程是怎样的。</p><h1 id="四、bindService-回调"><a href="#四、bindService-回调" class="headerlink" title="四、bindService 回调"></a>四、bindService 回调</h1><h2 id="4-1-LA-getServiceDispatcher"><a href="#4-1-LA-getServiceDispatcher" class="headerlink" title="4.1 LA.getServiceDispatcher"></a>4.1 LA.getServiceDispatcher</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> IServiceConnection <span class="title">getServiceDispatcher</span><span class="params">(ServiceConnection c,</span></span></span><br><span class="line"><span class="function"><span class="params">        Context context, Handler handler, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getServiceDispatcherCommon(c, context, handler, <span class="keyword">null</span>, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> IServiceConnection <span class="title">getServiceDispatcherCommon</span><span class="params">(ServiceConnection c,</span></span></span><br><span class="line"><span class="function"><span class="params">        Context context, Handler handler, Executor executor, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mServices) &#123;</span><br><span class="line">        LoadedApk.ServiceDispatcher sd = <span class="keyword">null</span>;</span><br><span class="line">        ArrayMap&lt;ServiceConnection, LoadedApk.ServiceDispatcher&gt; map = mServices.get(context);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG) Slog.d(TAG, <span class="string">&quot;Returning existing dispatcher &quot;</span> + sd + <span class="string">&quot; for conn &quot;</span> + c);</span><br><span class="line">            sd = map.get(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sd == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (executor != <span class="keyword">null</span>) &#123;</span><br><span class="line">                sd = <span class="keyword">new</span> ServiceDispatcher(c, context, executor, flags);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sd = <span class="keyword">new</span> ServiceDispatcher(c, context, handler, flags);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG) Slog.d(TAG, <span class="string">&quot;Creating new dispatcher &quot;</span> + sd + <span class="string">&quot; for conn &quot;</span> + c);</span><br><span class="line">            <span class="keyword">if</span> (map == <span class="keyword">null</span>) &#123;</span><br><span class="line">                map = <span class="keyword">new</span> ArrayMap&lt;&gt;();</span><br><span class="line">                mServices.put(context, map);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(c, sd);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sd.validate(context, handler, executor);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sd.getIServiceConnection();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-2-AMS-publishService"><a href="#4-2-AMS-publishService" class="headerlink" title="4.2 AMS.publishService"></a>4.2 AMS.publishService</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publishService</span><span class="params">(IBinder token, Intent intent, IBinder service)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(token <span class="keyword">instanceof</span> ServiceRecord)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Invalid service token&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">// 调用 ActiveServices 的 publishServiceLocked() 方法</span></span><br><span class="line">        mServices.publishServiceLocked((ServiceRecord)token, intent, service);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4-3-AS-publishServiceLocked"><a href="#4-3-AS-publishServiceLocked" class="headerlink" title="4.3 AS.publishServiceLocked"></a>4.3 AS.publishServiceLocked</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">publishServiceLocked</span><span class="params">(ServiceRecord r, Intent intent, IBinder service)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Intent.FilterComparison filter = <span class="keyword">new</span> Intent.FilterComparison(intent);</span><br><span class="line">            IntentBindRecord b = r.bindings.get(filter);</span><br><span class="line">            <span class="keyword">if</span> (b != <span class="keyword">null</span> &amp;&amp; !b.received) &#123;</span><br><span class="line">                b.binder = service;</span><br><span class="line">                b.requested = <span class="keyword">true</span>;</span><br><span class="line">                b.received = <span class="keyword">true</span>;</span><br><span class="line">              <span class="comment">// 从 ServiceRecord 的 connections 集合中取出数据</span></span><br><span class="line">                ArrayMap&lt;IBinder, ArrayList&lt;ConnectionRecord&gt;&gt; connections = r.getConnections();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> conni = connections.size() - <span class="number">1</span>; conni &gt;= <span class="number">0</span>; conni--) &#123;</span><br><span class="line">                    ArrayList&lt;ConnectionRecord&gt; clist = connections.valueAt(conni);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;clist.size(); i++) &#123;</span><br><span class="line">                        ConnectionRecord c = clist.get(i);</span><br><span class="line">                        <span class="keyword">if</span> (!filter.equals(c.binding.intent.intent)) &#123;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                          <span class="comment">// c.conn 为 IServiceConnection 对象</span></span><br><span class="line">        <span class="comment">// 实际就是 LoadedApk.ServiceDispatcher.InnerConnection 类</span></span><br><span class="line">                            c.conn.connected(r.name, service, <span class="keyword">false</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                            <span class="comment">//...</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            serviceDoneExecutingLocked(r, mDestroyingServices.contains(r), <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-4-LA-ServiceDispatcher-InnerConnection"><a href="#4-4-LA-ServiceDispatcher-InnerConnection" class="headerlink" title="4.4 LA.ServiceDispatcher.InnerConnection"></a>4.4 LA.ServiceDispatcher.InnerConnection</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// LoadedApk 内部类 InnerConnection 的 connected() 方法，也就是上面的 c.conn.connected() 方法  </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerConnection</span> <span class="keyword">extends</span> <span class="title">IServiceConnection</span>.<span class="title">Stub</span> </span>&#123;</span><br><span class="line">         <span class="meta">@UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.R, trackingBug = 170729553)</span></span><br><span class="line">         <span class="keyword">final</span> WeakReference&lt;LoadedApk.ServiceDispatcher&gt; mDispatcher;</span><br><span class="line"></span><br><span class="line">         InnerConnection(LoadedApk.ServiceDispatcher sd) &#123;</span><br><span class="line">             mDispatcher = <span class="keyword">new</span> WeakReference&lt;LoadedApk.ServiceDispatcher&gt;(sd);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connected</span><span class="params">(ComponentName name, IBinder service, <span class="keyword">boolean</span> dead)</span></span></span><br><span class="line"><span class="function">                 <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">             LoadedApk.ServiceDispatcher sd = mDispatcher.get();</span><br><span class="line">             <span class="keyword">if</span> (sd != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">// 调用 LoadedApk.ServiceDispatcher 的 connected() 方法</span></span><br><span class="line">                 sd.connected(name, service, dead);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><h2 id="4-5-LA-ServiceDispatcher-connected"><a href="#4-5-LA-ServiceDispatcher-connected" class="headerlink" title="4.5 LA.ServiceDispatcher.connected"></a>4.5 LA.ServiceDispatcher.connected</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connected</span><span class="params">(ComponentName name, IBinder service, <span class="keyword">boolean</span> dead)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mActivityExecutor != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mActivityExecutor.execute(<span class="keyword">new</span> RunConnection(name, service, <span class="number">0</span>, dead));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mActivityThread != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 由 ContextImpl.bindServiceCommon() 方法中可知，mActivityThread 就是 ActivityThread 的 H 对象（主线程的Handler），不为null</span></span><br><span class="line"><span class="comment">// RunConnection 的 run方法中调用 doConnected() 方法</span></span><br><span class="line"><span class="comment">// 因为是通过主线程的 Handler 调用的方法，所以客户端的 ServiceConnection.onServiceConnected() 运行在主线程</span></span><br><span class="line">        mActivityThread.post(<span class="keyword">new</span> RunConnection(name, service, <span class="number">0</span>, dead));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        doConnected(name, service, dead);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-6LA-ServiceDispatcher-RunConnection"><a href="#4-6LA-ServiceDispatcher-RunConnection" class="headerlink" title="4.6LA.ServiceDispatcher.RunConnection"></a>4.6LA.ServiceDispatcher.RunConnection</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RunConnection</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    RunConnection(ComponentName name, IBinder service, <span class="keyword">int</span> command, <span class="keyword">boolean</span> dead) &#123;</span><br><span class="line">        mName = name;</span><br><span class="line">        mService = service;</span><br><span class="line">        mCommand = command;</span><br><span class="line">        mDead = dead;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mCommand == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// 调用 doConnected() 方法</span></span><br><span class="line">            doConnected(mName, mService, mDead);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mCommand == <span class="number">1</span>) &#123;</span><br><span class="line">            doDeath(mName, mService);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ComponentName mName;</span><br><span class="line">    <span class="keyword">final</span> IBinder mService;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> mCommand;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> mDead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-7-LA-ServiceDispatcher-doConnected"><a href="#4-7-LA-ServiceDispatcher-doConnected" class="headerlink" title="4.7 LA.ServiceDispatcher.doConnected"></a>4.7 LA.ServiceDispatcher.doConnected</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doConnected</span><span class="params">(ComponentName name, IBinder service, <span class="keyword">boolean</span> dead)</span> </span>&#123;</span><br><span class="line">    ServiceDispatcher.ConnectionInfo old;</span><br><span class="line">    ServiceDispatcher.ConnectionInfo info;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">     <span class="comment">// 由 ContextImpl.bindServiceCommon() 方法中可知，mConnection 就是客户端的 ServiceConnection 对象，回调它的 onServiceConnected() 方法，完成绑定过程</span></span><br><span class="line">    <span class="keyword">if</span> (service != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mConnection.onServiceConnected(name, service);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// The binding machinery worked, but the remote returned null from onBind().</span></span><br><span class="line">        mConnection.onNullBinding(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>mConnection</code> 就是客户端的 <code>ServiceConnection</code> 对象，在前面 <code>ContextImpl</code> 的 <code>bindServiceCommon()</code> 方法说明时有注释进行说明了。</p><h1 id="五、解绑-Service"><a href="#五、解绑-Service" class="headerlink" title="五、解绑 Service"></a>五、解绑 Service</h1><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/android/android_service_unbind.png" alt="图片来源于网络"></p><h1 id="六、停止-Service"><a href="#六、停止-Service" class="headerlink" title="六、停止 Service"></a>六、停止 Service</h1><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/android/android_service_stopservice.png" alt="图片来源于网络"></p><p><a href="http://gityuan.com/2016/03/06/start-service/">startService启动过程分析</a></p><p><a href="https://blog.csdn.net/itrenj/article/details/110007831">Android Service 流程分析</a></p><p><a href="https://www.jianshu.com/p/466bcd23f133">ActivityManagerService 通信浅析</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>了断 Handler</title>
      <link href="2020/android-framework-handler.html"/>
      <url>2020/android-framework-handler.html</url>
      
        <content type="html"><![CDATA[<p>在整个 <code>Android</code> 的源码世界里，有两大利剑，其一是 <code>Binder IPC</code> 机制，另一个便是消息机制 (由 <a href="https://developer.android.com/reference/android/os/Handler.html">Handler</a><code>/Looper/MessageQueue</code> 等构成的)。</p><p><code>Android</code> 有大量的消息驱动方式来进行交互，比如 <code>Android</code> 的四剑客<code>Activity</code>, <code>Service</code>, <code>Broadcast</code>, <code>ContentProvider</code>的启动过程的交互，都离不开消息机制，<code>Android</code> 某种意义上也可以说成是一个以消息驱动的系统。消息机制涉及 <code>MessageQueue/Message/Looper/Handler</code> 这 <code>4</code> 个类。</p><blockquote><p>原文来自于 Gityuan <a href="http://gityuan.com/2015/12/26/handler-message-framework/">Handler(framework)</a> <a href="http://gityuan.com/2015/12/27/handler-message-native/">Handler(native)</a> 源码更新于 <a href="https://cs.android.com/">AndroidCodeSearch</a> 2021/1/9</p></blockquote><h1 id="Handler-是干嘛的？"><a href="#Handler-是干嘛的？" class="headerlink" title="Handler 是干嘛的？"></a>Handler 是干嘛的？</h1><ol><li>推送未来某个时间点将要执行的 <code>Message</code> 或者 <code>Runnable</code> 到消息队列。</li><li>在子线程把需要在另一个线程执行的操作加入到消息队列中去。</li></ol><h1 id="Handler-组成"><a href="#Handler-组成" class="headerlink" title="Handler 组成"></a>Handler 组成</h1><ul><li><strong>Message</strong>：消息分为硬件产生的消息(如按钮、触摸)和软件生成的消息；</li><li><strong>MessageQueue</strong>：消息队列的主要功能向消息池投递消息(<code>MessageQueue.enqueueMessage</code>)和取走消息池的消息(<code>MessageQueue.next</code>)；</li><li><strong>Handler</strong>：消息辅助类，主要功能向消息池发送各种消息事件(<code>Handler.sendMessage</code>)和处理相应消息事件(<code>Handler.handleMessage</code>)；</li><li><strong>Looper</strong>：不断循环执行(<code>Looper.loop</code>)，按分发机制将消息分发给目标处理者。</li></ul><h2 id="Handler-架构"><a href="#Handler-架构" class="headerlink" title="Handler 架构"></a>Handler 架构</h2><blockquote><ul><li><strong>Looper</strong>有一个<strong>MessageQueue</strong>消息队列；</li><li><strong>MessageQueue</strong>有一组待处理的<strong>Message</strong>；</li><li><strong>Message</strong>中有一个用于处理消息的<strong>Handle</strong>r；</li><li><strong>Handler</strong>中有<strong>Looper</strong>和<strong>MessageQueue</strong>。</li></ul></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/android/android_handler.jpg" alt="图片来源于《Android消息机制1-Handler(Java层)》"></p><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><h3 id="利用-HandlerThread-创建"><a href="#利用-HandlerThread-创建" class="headerlink" title="利用 HandlerThread 创建"></a>利用 HandlerThread 创建</h3><p>既然涉及多个线程的通信，会有同步的问题，<code>Android</code> 为了简化 <code>Handler</code> 的创建过程，提供了 <code>HandlerThread</code> 类， 很多时候，在 <code>HandlerThread</code> 线程中运行<code>Loop()</code> 方法，在其他线程中通过 <code>Handler</code> 发送消息到 <code>HandlerThread</code> 线程。通过 <code>wait/notifyAll</code> 的方式，有效地解决了多线程的同步问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Step 1: 创建并启动 HandlerThread 线程，内部包含 Looper</span></span><br><span class="line">HandlerThread handlerThread = <span class="keyword">new</span> HandlerThread(<span class="string">&quot;calmCenter&quot;</span>);<span class="comment">// 【见 1.1】</span></span><br><span class="line">handlerThread.start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 2: 创建Handler</span></span><br><span class="line">Handler handler = <span class="keyword">new</span> Handler(handlerThread.getLooper());<span class="comment">// 【见 1.2】</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 3: 发送消息</span></span><br><span class="line">handler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;thread id=&quot;</span>+Thread.currentThread().getId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>或者 <code>handler.postDelayed(Runnable r, long delayMillis)</code> 用于延迟执行。</p><h3 id="直接创建线程"><a href="#直接创建线程" class="headerlink" title="直接创建线程"></a>直接创建线程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LooperThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Handler mHandler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Looper.prepare(); <span class="comment">// 【见 2.1.1】</span></span><br><span class="line">        <span class="comment">// Step 1: 创建Handler</span></span><br><span class="line">        mHandler = <span class="keyword">new</span> Handler() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//处理即将发送过来的消息</span></span><br><span class="line">                System.out.println(<span class="string">&quot;thread id=&quot;</span>+Thread.currentThread().getId());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Looper.loop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 2: 创建并启动LooperThread线程，内部包含Looper</span></span><br><span class="line">LooperThread looperThread = <span class="keyword">new</span> LooperThread(<span class="string">&quot;calmCenter&quot;</span>);</span><br><span class="line">looperThread.start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 3: 发送消息</span></span><br><span class="line">LooperThread.mHandler.sendEmptyMessage(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><h1 id="一、HandlerThread-源码分析"><a href="#一、HandlerThread-源码分析" class="headerlink" title="一、HandlerThread 源码分析"></a>一、HandlerThread 源码分析</h1><h2 id="1-1-创建-HandlerThread-对象"><a href="#1-1-创建-HandlerThread-对象" class="headerlink" title="1.1 创建 HandlerThread 对象"></a>1.1 创建 HandlerThread 对象</h2><p><code>HandlerThread</code> 继承于 <code>Thread</code> 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HandlerThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">    mPriority = Process.THREAD_PRIORITY_DEFAULT; <span class="comment">//默认优先级</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HandlerThread</span><span class="params">(String name, <span class="keyword">int</span> priority)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">    mPriority = priority;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-获取-Looper-对象"><a href="#1-2-获取-Looper-对象" class="headerlink" title="1.2 获取 Looper 对象"></a>1.2 获取 Looper 对象</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Step 2: 创建Handler</span></span><br><span class="line">Handler handler = <span class="keyword">new</span> Handler(handlerThread.getLooper());</span><br></pre></td></tr></table></figure><p>获取 <code>HandlerThread</code> 线程中的 <code>Looper</code> 对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Looper <span class="title">getLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当线程没有启动或者已经结束时，则返回null</span></span><br><span class="line">    <span class="keyword">if</span> (!isAlive()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当线程已经启动，则等待直到looper创建完成</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive() &amp;&amp; mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait(); <span class="comment">//休眠等待</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mLooper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3-执行-handlerThread-的-run"><a href="#1-3-执行-handlerThread-的-run" class="headerlink" title="1.3 执行 handlerThread 的 run()"></a>1.3 执行 handlerThread 的 run()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mTid = Process.myTid();  <span class="comment">//获取线程的tid</span></span><br><span class="line">    Looper.prepare();   <span class="comment">// 创建Looper对象</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        mLooper = Looper.myLooper(); <span class="comment">//获取looper对象</span></span><br><span class="line">        notifyAll(); <span class="comment">//唤醒等待线程</span></span><br><span class="line">    &#125;</span><br><span class="line">    Process.setThreadPriority(mPriority);</span><br><span class="line">    onLooperPrepared();  <span class="comment">// 该方法可通过覆写，实现自己的逻辑</span></span><br><span class="line">    Looper.loop();   <span class="comment">//进入循环模式</span></span><br><span class="line">    mTid = -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-4-Looper-退出"><a href="#1-4-Looper-退出" class="headerlink" title="1.4 Looper 退出"></a>1.4 Looper 退出</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">quit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Looper looper = getLooper();</span><br><span class="line">    <span class="keyword">if</span> (looper != <span class="keyword">null</span>) &#123;</span><br><span class="line">        looper.quit(); <span class="comment">//普通退出</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">quitSafely</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Looper looper = getLooper();</span><br><span class="line">    <span class="keyword">if</span> (looper != <span class="keyword">null</span>) &#123;</span><br><span class="line">        looper.quitSafely(); <span class="comment">//安全退出</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二、Handler-Java-层源码分析"><a href="#二、Handler-Java-层源码分析" class="headerlink" title="二、Handler Java 层源码分析"></a>二、Handler Java 层源码分析</h1><h2 id="2-1-Looper"><a href="#2-1-Looper" class="headerlink" title="2.1 Looper"></a>2.1 Looper</h2><h3 id="2-1-1-prepare"><a href="#2-1-1-prepare" class="headerlink" title="2.1.1 prepare"></a>2.1.1 prepare</h3><p>对于无参的情况，默认调用 <code>prepare(true)</code>，表示的是这个 <code>Looper</code> 允许退出，而对于 <code>false</code> 的情况则表示当前 <code>Looper</code> 不允许退出，只有在 <code>prepareMainLooper</code> 的时候会传入 <code>false</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    prepare(<span class="keyword">true</span>); <span class="comment">// 允许退出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>prepareMainLooper()</strong></p><p>我们平时使用 <code>Handler</code> 的时候，并不需要执行 <code>Looper.prepare();</code>  ，但是在上面的两种方式中，都需要执行这句话，这是为什么呢？</p><p>其实我们在 <code>Activity</code> 等地方直接使用 <code>Handler</code> 的时候，系统已经为我们执行过 <code>prepare</code> 了，就是这里提到的 <code>prepareMainLooper</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityThread</span> </span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">Looper.prepareMainLooper();</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">thread.attach(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">Looper.loop();</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">thread.detach();</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepareMainLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        prepare(<span class="keyword">false</span>); <span class="comment">// 不允许退出</span></span><br><span class="line">        <span class="keyword">synchronized</span> (Looper.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sMainLooper != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;The main Looper has already been prepared.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            sMainLooper = myLooper();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>Looper.prepare(boolean)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//每个线程只允许执行一次该方法，第二次执行时线程的 TLS 已有数据，则会抛出异常。</span></span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Only one Looper may be created per thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建 Looper 对象，并保存到当前线程的 TLS 区域 【见 2.2】</span></span><br><span class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 <code>new</code> 了一个 <code>Looper</code> 并保存进了 <code>sThreadLocal</code>。至于为什么每个线程在使用 <code>Handler</code> 前 <code>Looper</code> 必须先 <code>prepare</code> ？</p><p>因为 <code>Handler</code> 使用到了 <code>Looper</code> 在使用 <code>Handler</code> 之前，当前线程必须先初始化 <code>Looper</code> 具体见 ，每个线程都需要初始化，这就涉及到了 <code>ThreadLocal</code> 具体见 <code>2.2</code>.</p><h3 id="2-1-2-loop"><a href="#2-1-2-loop" class="headerlink" title="2.1.2 loop"></a>2.1.2 loop</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Looper me = myLooper(); <span class="comment">//获取 TLS 存储的 Looper 对象</span></span><br><span class="line">    <span class="comment">// loop 之前同样需要 Looper.prepare()</span></span><br><span class="line">    <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;No Looper; Looper.prepare() wasn&#x27;t called on this thread.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> MessageQueue queue = me.mQueue; <span class="comment">//获取Looper对象中的消息队列</span></span><br><span class="line">    <span class="comment">//确保在权限检查时基于本地进程，而不是调用进程。</span></span><br><span class="line">    Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">boolean</span> slowDeliveryDetected = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//进入loop的主循环方法</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Message msg = queue.next(); <span class="comment">// 可能会阻塞</span></span><br><span class="line">        <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//没有消息，则退出循环</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//默认为null，可通过setMessageLogging()方法来指定输出，用于debug功能</span></span><br><span class="line">        <span class="keyword">final</span> Printer logging = me.mLogging;</span><br><span class="line">        <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">            logging.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot;</span> + msg.target + <span class="string">&quot; &quot;</span> +</span><br><span class="line">                    msg.callback + <span class="string">&quot;: &quot;</span> + msg.what);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//用于分发 Message</span></span><br><span class="line">            msg.target.dispatchMessage(msg); <span class="comment">// 【见 2.3.2】</span></span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">            logging.println(<span class="string">&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot;</span> + msg.target + <span class="string">&quot; &quot;</span> + msg.callback);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//恢复调用者信息</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> newIdent = Binder.clearCallingIdentity();</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="comment">//将Message放入消息池</span></span><br><span class="line">        msg.recycleUnchecked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>loop()</code> 进入循环模式，不断重复下面的操作，直到没有消息时退出循环</p><ul><li>读取 <code>MessageQueue</code> 的下一条 <code>Message</code> ；</li><li>把 <code>Message</code> 分发给相应的 <code>target</code> ；</li><li>再把分发后的 <code>Message</code> 回收到消息池，以便重复利用。</li></ul><p>这是这个消息处理的核心部分。另外，上面代码中可以看到有 <code>logging</code> 方法，这是用于 <code>debug</code> 的，默认情况下 <code>logging == null</code>，通过设置 <code>setMessageLogging()</code> 用来开启 <code>debug</code> 工作。</p><h3 id="2-1-3-quit"><a href="#2-1-3-quit" class="headerlink" title="2.1.3 quit"></a>2.1.3 quit</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mQueue.quit(<span class="keyword">false</span>); <span class="comment">//消息移除</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quitSafely</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mQueue.quit(<span class="keyword">true</span>); <span class="comment">//安全地消息移除</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Looper.quit()</code> 方法的实现最终调用的是 <code>MessageQueue.quit()</code> 方法</p><p><strong>MessageQueue.quit()</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quit</span><span class="params">(<span class="keyword">boolean</span> safe)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当 mQuitAllowed 为 false，表示不运行退出，强行调用 quit() 会抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (!mQuitAllowed) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Main thread not allowed to quit.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mQuitting) &#123;<span class="comment">//防止多次执行退出操作</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mQuitting = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (safe) &#123;</span><br><span class="line">            removeAllFutureMessagesLocked();<span class="comment">//移除尚未触发的所有消息</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            removeAllMessagesLocked();<span class="comment">//移除所有的消息</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//mQuitting=false，那么认定为 mPtr != 0</span></span><br><span class="line">        nativeWake(mPtr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消息退出的方式：</p><ul><li>当 <code>safe = true</code> 时，只移除尚未触发的所有消息，对于正在触发的消息并不移除；</li><li>当 <code>safe = flase</code> 时，移除所有的消息</li></ul><h2 id="2-2-ThreadLocal"><a href="#2-2-ThreadLocal" class="headerlink" title="2.2 ThreadLocal"></a>2.2 ThreadLocal</h2><p>线程本地存储区（<code>Thread Local Storage</code>，简称为 <code>TLS</code> ），每个线程都有自己的私有的本地存储区域，不同线程之间彼此不能访问对方的 <code>TLS</code> 区域。</p><p><strong>ThreadLocal 原理</strong> </p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/android/android_handler_threadlocal.png" alt="图片来源于《ThreadLocal原理》"></p><p>这张图很久之前看过，找了很久！<a href="[https://blog.csdn.net/imaginehero/article/details/102540507?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522160879958316780299038181%252522%25252C%252522scm%252522%25253A%25252220140713.130102334.pc%25255Fall.%252522%25257D&request_id=160879958316780299038181&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-4-102540507.first_rank_v2_pc_rank_v29&utm_term=ThreadLocal](https://blog.csdn.net/imaginehero/article/details/102540507?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160879958316780299038181%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=160879958316780299038181&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-4-102540507.first_rank_v2_pc_rank_v29&utm_term=ThreadLocal)">ThreadLocal原理(简单易懂)</a></p><ul><li>每个 <code>Thread</code> 线程内部都有一个 <code>ThreadLocalMap</code> 。</li><li><code>ThreadLocalMap</code> 里面存储线程本地对象（<code>key</code>）和线程的变量副本（<code>value</code>）。</li><li><code>Thread</code> 内部的 <code>ThreadLocalMap</code> 是由 <code>ThreadLocal</code> 维护的，由 <code>ThreadLocal</code> 负责向 <code>ThreadLocalMap</code> 设置和获取线程的变量值。</li><li>同一个 <code>Thread</code> 中多个 <code>ThreadLocal</code> 对象，共用一个 <code>ThreadLocalMap</code> 。</li><li>不同 <code>Thread</code>，同一个 <code>ThreadLocal</code> 对象，对应不同的值</li></ul><p><code>ThreadLocal.set(T value)</code>：将 <code>value</code> 存储到当前线程的 <code>TLS</code> 区域，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread(); <span class="comment">//获取当前线程</span></span><br><span class="line">    ThreadLocalMap map = getMap(t); <span class="comment">// 查找当前线程的实际存储的数据结构</span></span><br><span class="line">    <span class="comment">//如果存在 map 就直接 set，没有则创建 map 并 set</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// thread 中维护了一个 ThreadLocalMap</span></span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ThreadLocal.get()</code>：获取当前线程 <code>TLS</code> 区域的数据，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();<span class="comment">// 获取当前线程</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);<span class="comment">// 查找当前线程的实际存储的数据结构</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);<span class="comment">//从 map 中获取 ThreadLocal 为 this 的 Entry节点。</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;<span class="comment">// 从 Entry 节点 获取存储的 Value 值返回。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// map = null 则 创建 map 新增一个 Entry, key 为 this ，value 为 null</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ThreadLocal</code> 的 <code>get()</code> 和 <code>set()</code> 方法操作的类型都是泛型，接着回到前面提到的<code>sThreadLocal</code>变量，其定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;Looper&gt;()</span><br></pre></td></tr></table></figure><p>可见<code>sThreadLocal</code>的 <code>get()</code> 和 <code>set()</code> 操作的类型都是 <code>Looper</code> 类型。</p><h2 id="2-3-Handler"><a href="#2-3-Handler" class="headerlink" title="2.3 Handler"></a>2.3 Handler</h2><h3 id="2-3-1-创建-Handler"><a href="#2-3-1-创建-Handler" class="headerlink" title="2.3.1 创建 Handler"></a>2.3.1 创建 Handler</h3><p><strong>无参构造</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 匿名类、内部类或本地类都必须申明为 static，否则会警告可能出现内存泄露</span></span><br><span class="line">    <span class="keyword">if</span> (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class="line">        <span class="keyword">final</span> Class&lt;? extends Handler&gt; klass = getClass();</span><br><span class="line">        <span class="keyword">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</span><br><span class="line">                (klass.getModifiers() &amp; Modifier.STATIC) == <span class="number">0</span>) &#123;</span><br><span class="line">            Log.w(TAG, <span class="string">&quot;The following Handler class should be static or leaks might occur: &quot;</span> +</span><br><span class="line">                klass.getCanonicalName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//必须先执行 Looper.prepare()，才能获取 Looper 对象，否则为 null.</span></span><br><span class="line">    mLooper = Looper.myLooper();<span class="comment">//从当前线程的 TLS 中获取 Looper 对象</span></span><br><span class="line">    <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">            <span class="string">&quot;Can&#x27;t create handler inside thread &quot;</span> + Thread.currentThread()</span><br><span class="line">                    + <span class="string">&quot; that has not called Looper.prepare()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mQueue = mLooper.mQueue; <span class="comment">//消息队列，来自Looper对象</span></span><br><span class="line">    mCallback = callback;  <span class="comment">//回调方法</span></span><br><span class="line">    mAsynchronous = async; <span class="comment">//设置消息是否为异步处理方式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 <code>Handle</code> 的无参构造方法，默认采用当前线程 <code>TLS</code> 中的 <code>Looper</code> 对象，并且 <code>callback</code> 回调方法为 <code>null</code> ，且消息为同步处理方式。只要执行的 <code>Looper.prepare()</code> 方法，那么便可以获取有效的 <code>Looper</code> 对象。</p><p><strong>有参构造</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(looper, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Looper looper, Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">    mLooper = looper;</span><br><span class="line">    mQueue = looper.mQueue;</span><br><span class="line">    mCallback = callback;</span><br><span class="line">    mAsynchronous = async;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Handler</code> 类在构造方法中，可指定 <code>Looper</code> ， <code>Callback</code> 回调方法以及消息的处理方式(同步或异步)，对于无参的 <code>handler</code> ，默认是当前线程的 <code>Looper</code> 。</p><h3 id="2-3-2-dispatchMessage"><a href="#2-3-2-dispatchMessage" class="headerlink" title="2.3.2 dispatchMessage"></a>2.3.2 dispatchMessage</h3><p>消息分发机制，在 <code>Looper.loop()</code> 中，当发现有消息时，调用消息的目标 <code>handler</code> ，执行 <code>dispatchMessage()</code> 方法来分发消息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 当 Message 存在回调方法，回调 msg.callback.run() 方法；</span></span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 当 Handler 存在 Callback 成员变量时，回调方法 handleMessage()；</span></span><br><span class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Handler 自身的回调方法 handleMessage()</span></span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分发消息流程：</strong></p><ol><li>当 <code>Message</code> 的回调方法不为空时，则回调方法 <code>msg.callback.run()</code>，其中 <code>callBack</code> 数据类型为 <code>Runnable</code> ，否则进入步骤 <code>2</code> ；</li><li>当<code>Handler</code>的<code>mCallback</code>成员变量不为空时，则回调方法<code>mCallback.handleMessage(msg)</code>，否则进入步骤 <code>3</code> ；</li><li>调用<code>Handler</code>自身的回调方法 <code>handleMessage()</code>，该方法默认为空，<code>Handler</code> 子类通过覆写该方法来完成具体的逻辑。</li></ol><p>对于很多情况下，消息分发后的处理方法是第 <code>3</code> 种情况，即 <code>Handler.handleMessage()</code> ，一般地往往通过覆写该方法从而实现自己的业务逻辑。</p><h3 id="2-3-3-消息发送"><a href="#2-3-3-消息发送" class="headerlink" title="2.3.3 消息发送"></a>2.3.3 消息发送</h3><p><strong>sendEmptyMessage()</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendEmptyMessage</span><span class="params">(<span class="keyword">int</span> what)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sendEmptyMessageDelayed(what, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendEmptyMessageDelayed</span><span class="params">(<span class="keyword">int</span> what, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">    Message msg = Message.obtain();<span class="comment">// 【见 2.5.3】</span></span><br><span class="line">    msg.what = what;</span><br><span class="line">    <span class="keyword">return</span> sendMessageDelayed(msg, delayMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageDelayed</span><span class="params">(Message msg, <span class="keyword">long</span> delayMillis)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        delayMillis = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前 Handler 所在的消息队列</span></span><br><span class="line">    MessageQueue queue = mQueue;</span><br><span class="line">    <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 消息队列为空，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将消息添加到消息队列中</span></span><br><span class="line">    <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>sendMessageAtFrontOfQueue</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtFrontOfQueue</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    MessageQueue queue = mQueue;</span><br><span class="line">    <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> enqueueMessage(queue, msg, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法通过设置消息的触发时间为 <code>0</code> ，从而使 <code>Message</code> 加入到消息队列的队头。</p><p><strong>post</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span>  sendMessageDelayed(getPostMessage(r), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Message <span class="title">getPostMessage</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">    Message m = Message.obtain();<span class="comment">// 【见 2.5.3】</span></span><br><span class="line">    m.callback = r;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>postAtFrontOfQueue</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">postAtFrontOfQueue</span><span class="params">(Runnable r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sendMessageAtFrontOfQueue(getPostMessage(r));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>enqueueMessage</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">    msg.target = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">        msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis); <span class="comment">// 【见 2.4.3】</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Handler.sendEmptyMessage()</code>等系列方法最终调用<code>MessageQueue.enqueueMessage(msg, uptimeMillis)</code>，将消息添加到消息队列中，其中 <code>uptimeMillis</code> 为系统当前的运行时间，不包括休眠时间。</p><h3 id="2-3-4-obtainMessage"><a href="#2-3-4-obtainMessage" class="headerlink" title="2.3.4 obtainMessage"></a>2.3.4 obtainMessage</h3><p>获取消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Message <span class="title">obtainMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Message.obtain(<span class="keyword">this</span>);<span class="comment">// 【见 2.5.3】</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Handler.obtainMessage()</code>方法，最终调用<code>Message.obtainMessage(this)</code>，其中 <code>this</code> 为当前的 <code>Handler</code> 对象。</p><h3 id="2-3-5-removeMessages"><a href="#2-3-5-removeMessages" class="headerlink" title="2.3.5 removeMessages"></a>2.3.5 removeMessages</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">removeMessages</span><span class="params">(<span class="keyword">int</span> what)</span> </span>&#123;</span><br><span class="line">    mQueue.removeMessages(<span class="keyword">this</span>, what, <span class="keyword">null</span>);<span class="comment">// 【见 2.4.4】</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Handler</code> 是消息机制中非常重要的辅助类，更多的实现都是 <code>MessageQueue</code>, <code>Message</code> 中的方法，<code>Handler</code> 的目的是为了更加方便的使用消息机制。</p><h2 id="2-4-MessageQueue"><a href="#2-4-MessageQueue" class="headerlink" title="2.4 MessageQueue"></a>2.4 MessageQueue</h2><h3 id="2-4-1-创建-MessageQueue"><a href="#2-4-1-创建-MessageQueue" class="headerlink" title="2.4.1 创建 MessageQueue"></a>2.4.1 创建 MessageQueue</h3><p>在 <code>Looper.prepare()</code> 的时候会调用构造函数创建 <code>MessageQueue</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> MessageQueue(<span class="keyword">boolean</span> quitAllowed) &#123;</span><br><span class="line">    mQuitAllowed = quitAllowed;</span><br><span class="line">    mPtr = nativeInit(); <span class="comment">//【见 4.1.1】</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-2-next"><a href="#2-4-2-next" class="headerlink" title="2.4.2 next"></a>2.4.2 next</h3><p>提取下一条 <code>message</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ptr = mPtr;</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;<span class="comment">// 当消息循环已经退出，则直接返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>; <span class="comment">// 循环迭代的首次为 -1</span></span><br><span class="line">    <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">            Binder.flushPendingCommands();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 阻塞操作，当等待 nextPollTimeoutMillis 时长，或者消息队列被唤醒，都会返回</span></span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);<span class="comment">// 【见 4.1.3】</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">            Message prevMsg = <span class="keyword">null</span>;</span><br><span class="line">            Message msg = mMessages;</span><br><span class="line">            <span class="comment">// 当消息的 Handler 为空时，则查询异步消息</span></span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 当查询到异步消息，则立刻退出循环</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    prevMsg = msg;</span><br><span class="line">                    msg = msg.next;</span><br><span class="line">                &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                    <span class="comment">// 当异步消息触发时间大于当前时间，则设置下一次轮询的超时时长</span></span><br><span class="line">                    nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 获取一条消息，并返回</span></span><br><span class="line">                    mBlocked = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        prevMsg.next = msg.next;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        mMessages = msg.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    msg.next = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">&quot;Returning message: &quot;</span> + msg);</span><br><span class="line">                    <span class="comment">//设置消息的使用状态，即flags |= FLAG_IN_USE</span></span><br><span class="line">                    msg.markInUse();</span><br><span class="line">                    <span class="keyword">return</span> msg;   <span class="comment">//成功地获取MessageQueue中的下一条即将要执行的消息</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 没有消息</span></span><br><span class="line">                nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 消息正在退出，返回 null</span></span><br><span class="line">            <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">                dispose(); <span class="comment">// 【见 4.1.2】</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当消息队列为空，或者是消息队列的第一个消息时</span></span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></span><br><span class="line">                    &amp;&amp; (mMessages == <span class="keyword">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class="line">                pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 没有 idle handlers 需要运行，则循环并等待。</span></span><br><span class="line">                mBlocked = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mPendingIdleHandlers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mPendingIdleHandlers = <span class="keyword">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</span><br><span class="line">            &#125;</span><br><span class="line">            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 只有第一次循环时，会运行 idle handlers，执行完成后，重置 pendingIdleHandlerCount 为 0.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> IdleHandler idler = mPendingIdleHandlers[i];</span><br><span class="line">            mPendingIdleHandlers[i] = <span class="keyword">null</span>; <span class="comment">// 去掉 handler 的引用</span></span><br><span class="line">            <span class="keyword">boolean</span> keep = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                keep = idler.queueIdle();<span class="comment">// idle 时执行的方法</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                Log.wtf(TAG, <span class="string">&quot;IdleHandler threw exception&quot;</span>, t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                    mIdleHandlers.remove(idler);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//重置idle handler个数为0，以保证不会再次重复运行</span></span><br><span class="line">        pendingIdleHandlerCount = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//当调用一个空闲handler时，一个新message能够被分发，因此无需等待可以直接查询pending message.</span></span><br><span class="line">        nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>nativePollOnce</code> 是阻塞操作，其中 <code>nextPollTimeoutMillis</code> 代表下一个消息到来前，还需要等待的时长；当 <code>nextPollTimeoutMillis = -1</code> 时，表示消息队列中无消息，会一直等待下去。</p><p>当处于空闲时，往往会执行<code>IdleHandler</code>中的方法。当 <code>nativePollOnce()</code> 返回后，<code>next()</code> 从 <code>mMessages</code> 中提取一个消息。</p><p><code>nativePollOnce()</code> 在 <code>native</code> 做了大量的工作。</p><h3 id="2-4-3-enqueueMessage"><a href="#2-4-3-enqueueMessage" class="headerlink" title="2.4.3 enqueueMessage"></a>2.4.3 enqueueMessage</h3><p>添加一条消息到消息队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 每一个普通 Message 必须有一个 target</span></span><br><span class="line">    <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Message must have a target.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (msg.isInUse()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg + <span class="string">&quot; This message is already in use.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mQuitting) &#123;<span class="comment">// 正在退出时，回收 msg ，加入到消息池</span></span><br><span class="line">            msg.recycle();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        <span class="keyword">boolean</span> needWake;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">            <span class="comment">// p 为 null (代表 MessageQueue 没有消息） 或者 msg 的触发时间是队列中最早的，则进入该该分支</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">            needWake = mBlocked;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 将消息按时间顺序插入到 MessageQueue。一般地，不需要唤醒事件队列，除非</span></span><br><span class="line">            <span class="comment">// 消息队头存在 barrier，并且同时 Message是队列中最早的异步消息。</span></span><br><span class="line">            needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">            Message prev;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                    needWake = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            msg.next = p;</span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//消息没有退出，我们认为此时mPtr != 0</span></span><br><span class="line">        <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">            nativeWake(mPtr);<span class="comment">// 【4.1.4】</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MessageQueue</code>是按照 <code>Message</code> 触发时间的先后顺序排列的，队头的消息是将要最早触发的消息。当有消息需要加入消息队列时，会从队列头开始遍历，直到找到消息应该插入的合适位置，以保证所有消息的时间顺序。</p><p>往消息队列添加 <code>Message</code> 时，需要根据 <code>mBlocked</code> 情况来决定是否需要调用 <code>nativeWake</code> 。</p><h3 id="2-4-4-removeMessages"><a href="#2-4-4-removeMessages" class="headerlink" title="2.4.4 removeMessages"></a>2.4.4 removeMessages</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeMessages</span><span class="params">(Handler h, <span class="keyword">int</span> what, Object object)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        <span class="comment">// 从消息队列的头部开始，移除所有符合条件的消息</span></span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; p.target == h &amp;&amp; p.what == what</span><br><span class="line">               &amp;&amp; (object == <span class="keyword">null</span> || p.obj == object)) &#123;</span><br><span class="line">            Message n = p.next;</span><br><span class="line">            mMessages = n;</span><br><span class="line">            p.recycleUnchecked();</span><br><span class="line">            p = n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 移除剩余的符合要求的消息</span></span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Message n = p.next;</span><br><span class="line">            <span class="keyword">if</span> (n != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (n.target == h &amp;&amp; n.what == what</span><br><span class="line">                    &amp;&amp; (object == <span class="keyword">null</span> || n.obj == object)) &#123;</span><br><span class="line">                    Message nn = n.next;</span><br><span class="line">                    n.recycleUnchecked();</span><br><span class="line">                    p.next = nn;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            p = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个移除消息的方法，采用了两个 <code>while</code> 循环，第一个循环是从队头开始，移除符合条件的消息，第二个循环是从头部移除完连续的满足条件的消息之后，再从队列后面继续查询是否有满足条件的消息需要被移除。</p><h3 id="2-4-5-postSyncBarrier"><a href="#2-4-5-postSyncBarrier" class="headerlink" title="2.4.5 postSyncBarrier"></a>2.4.5 postSyncBarrier</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">postSyncBarrier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> postSyncBarrier(SystemClock.uptimeMillis());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">postSyncBarrier</span><span class="params">(<span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 输入一个新的同步障碍令牌。</span></span><br><span class="line">    <span class="comment">// 我们不需要唤醒队列，因为barrier的目的是让它停止。</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> token = mNextBarrierToken++;</span><br><span class="line">        <span class="keyword">final</span> Message msg = Message.obtain();<span class="comment">// 【见 2.5.3】</span></span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        msg.arg1 = token;</span><br><span class="line"></span><br><span class="line">        Message prev = <span class="keyword">null</span>;</span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        <span class="keyword">if</span> (when != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; p.when &lt;= when) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【2.4.3】说明每一个普通 <code>Message</code> 必须有一个 <code>target</code> ，对于特殊的 <code>message</code> 是没有 <code>target</code> ，即同步 <code>barrier token</code> 。 这个消息的价值就是用于拦截同步消息，所以并不会唤醒 <code>Looper</code> .</p><h2 id="2-5-Message"><a href="#2-5-Message" class="headerlink" title="2.5 Message"></a>2.5 Message</h2><h3 id="2-5-1-消息对象"><a href="#2-5-1-消息对象" class="headerlink" title="2.5.1 消息对象"></a>2.5.1 消息对象</h3><p>每个消息用 <code>Message</code> 表示，<code>Message</code> 主要包含以下内容：</p><table><thead><tr><th align="left">数据类型</th><th align="center">成员变量</th><th align="right">解释</th></tr></thead><tbody><tr><td align="left">int</td><td align="center">what</td><td align="right">消息类别</td></tr><tr><td align="left">long</td><td align="center">when</td><td align="right">消息触发时间</td></tr><tr><td align="left">int</td><td align="center">arg1</td><td align="right">参数1</td></tr><tr><td align="left">int</td><td align="center">arg2</td><td align="right">参数2</td></tr><tr><td align="left">Object</td><td align="center">obj</td><td align="right">消息内容</td></tr><tr><td align="left">Handler</td><td align="center">target</td><td align="right">消息响应方</td></tr><tr><td align="left">Runnable</td><td align="center">callback</td><td align="right">回调方法</td></tr></tbody></table><p>创建消息的过程，就是填充消息的上述内容的一项或多项。</p><h3 id="2-5-2-消息池"><a href="#2-5-2-消息池" class="headerlink" title="2.5.2 消息池"></a>2.5.2 消息池</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Message sPool;</span><br></pre></td></tr></table></figure><p>在代码中，可能经常看到 <code>recycle()</code> 方法，咋一看，可能是在做虚拟机的 <code>gc()</code> 相关的工作，其实不然，这是用于把消息加入到消息池的作用。这样的好处是，当消息池不为空时，可以直接从消息池中获取Message对象，而不是直接创建，提高效率。</p><p>静态变量 <code>sPool</code> 的数据类型为 <code>Message</code> ，通过 <code>next</code> 成员变量，维护一个消息池；静态变量 <code>MAX_POOL_SIZE</code> 代表消息池的可用大小；消息池的默认大小为 <code>50</code> 。</p><p>消息池常用的操作方法是 <code>obtain()</code> 和 <code>recycle()</code> 。</p><h3 id="2-5-3-obtain"><a href="#2-5-3-obtain" class="headerlink" title="2.5.3 obtain"></a>2.5.3 obtain</h3><p>从消息池中获取消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(sPoolSync) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sPool != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Message m = sPool;</span><br><span class="line">            sPool = m.next;</span><br><span class="line">            m.next = <span class="keyword">null</span>;<span class="comment">// 从 sPool 中取出一个 Message 对象，并消息链表断开(单独的一个节点)</span></span><br><span class="line">            m.flags = <span class="number">0</span>; <span class="comment">// 清除 in-use flag</span></span><br><span class="line">            sPoolSize--;<span class="comment">// 消息池的可用大小进行减 1 操作</span></span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Message();<span class="comment">// 当消息池为空时，直接创建Message对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>obtain()</code> ，从消息池取 <code>Message</code> ，都是把消息池表头的 <code>Message</code> 取走，再把表头指向 <code>next</code> ；</p><h3 id="2-5-4-recycle"><a href="#2-5-4-recycle" class="headerlink" title="2.5.4 recycle"></a>2.5.4 recycle</h3><p>把不再使用的消息加入消息池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否该消息还在使用</span></span><br><span class="line">    <span class="keyword">if</span> (isInUse()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (gCheckRecycle) &#123;<span class="comment">// Android 5.0 以后的版本默认为 true ,之前的版本默认为 false.</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;This message cannot be recycled because it &quot;</span></span><br><span class="line">                    + <span class="string">&quot;is still in use.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清空状态，并且将消息添加到消息池中</span></span><br><span class="line">    recycleUnchecked();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对于不再使用的消息，加入到消息池</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recycleUnchecked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将消息标示位置为 IN_USE ，并清空消息所有的参数。</span></span><br><span class="line">    flags = FLAG_IN_USE;</span><br><span class="line">    what = <span class="number">0</span>;</span><br><span class="line">    arg1 = <span class="number">0</span>;</span><br><span class="line">    arg2 = <span class="number">0</span>;</span><br><span class="line">    obj = <span class="keyword">null</span>;</span><br><span class="line">    replyTo = <span class="keyword">null</span>;</span><br><span class="line">    sendingUid = -<span class="number">1</span>;</span><br><span class="line">    when = <span class="number">0</span>;</span><br><span class="line">    target = <span class="keyword">null</span>;</span><br><span class="line">    callback = <span class="keyword">null</span>;</span><br><span class="line">    data = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 当消息池没有满时，将 Message 对象加入消息池</span></span><br><span class="line">    <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sPoolSize &lt; MAX_POOL_SIZE) &#123;</span><br><span class="line">            next = sPool;</span><br><span class="line">            sPool = <span class="keyword">this</span>;</span><br><span class="line">            sPoolSize++;<span class="comment">// 消息池的可用大小进行加 1 操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>recycle()</code>，将 <code>Message</code>加入到消息池的过程，都是把 <code>Message</code> 加到链表的表头；</p><h1 id="三、-Handler-Java-层总结"><a href="#三、-Handler-Java-层总结" class="headerlink" title="三、 Handler Java 层总结"></a>三、 Handler Java 层总结</h1><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/android/android_handler2.jpg" alt="图片来源于《Android消息机制1-Handler(Java层)》"></p><p><strong>图解：</strong></p><ul><li><code>Handler</code> 通过 <code>sendMessage()</code> 发送 <code>Message</code> 到 <code>MessageQueue</code> 队列；</li><li><code>Looper</code> 通过 <code>loop()</code> ，不断提取出达到触发条件的 <code>Message</code> ，并将 <code>Message</code> 交给 <code>target</code> 来处理；</li><li>经过 <code>dispatchMessage()</code> 后，交回给 <code>Handler</code> 的 <code>handleMessage()</code> 来进行相应地处理。</li><li>将 <code>Message</code> 加入 <code>MessageQueue</code> 时，往管道写入字符，可以会唤醒 <code>loop</code> 线程；如果 <code>MessageQueue</code> 中没有 <code>Message</code> ，并处于 <code>Idle</code> 状态，则会执行 <code>IdelHandler</code> 接口中的方法，往往用于做一些清理性地工作。</li></ul><p><strong>消息分发的优先级：</strong></p><ol><li><code>Message</code> 的回调方法：<code>message.callback.run()</code>，优先级最高；</li><li><code>Handler</code> 的回调方法：<code>Handler.mCallback.handleMessage(msg)</code>，优先级仅次于 <code>1</code> ；</li><li><code>Handler</code> 的默认方法：<code>Handler.handleMessage(msg)</code>，优先级最低。</li></ol><p><strong>消息缓存：</strong></p><p>为了提供效率，提供了一个大小为 <code>50</code> 的 <code>Message</code> 缓存队列，减少对象不断创建与销毁的过程。</p><h1 id="四、-Native-分析"><a href="#四、-Native-分析" class="headerlink" title="四、 Native 分析"></a>四、 Native 分析</h1><p><strong>相关源码位置</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">framework/base/core/java/andorid/os/MessageQueue.java</span><br><span class="line">framework/base/core/jni/android_os_MessageQueue.cpp</span><br><span class="line">framework/base/core/java/andorid/os/Looper.java</span><br><span class="line"></span><br><span class="line">system/core/libutils/Looper.cpp</span><br><span class="line">system/core/include/utils/Looper.h</span><br><span class="line">system/core/libutils/RefBase.cpp</span><br><span class="line"></span><br><span class="line">framework/base/<span class="keyword">native</span>/android/looper.cpp</span><br><span class="line">framework/<span class="keyword">native</span>/include/android/looper.h</span><br></pre></td></tr></table></figure><p>讲解了 <code>Java</code> 层的消息处理机制，其中 <code>MessageQueue</code> 类里面涉及到多个 <code>native</code> 方法，除了 <code>MessageQueue</code> 的 <code>native</code> 方法，<code>native</code> 层本身也有一套完整的消息机制，用于处理 <code>native</code> 的消息，如下图 <code>Native</code> 层的消息机制。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/android/android_handler_native.png" alt="图片来源于《Android消息机制1-Handler(Java层)》"></p><h2 id="4-1-MessageQueue"><a href="#4-1-MessageQueue" class="headerlink" title="4.1 MessageQueue"></a>4.1 MessageQueue</h2><p><code>MessageQueue</code> 是消息机制的 <code>Java</code> 层和 <code>C++</code> 层的连接纽带，<code>Java</code> 层可以向 <code>MessageQueue</code> 消息队列中添加消息，<code>Native</code> 层也可以向 <code>MessageQueue</code> 消息队列中添加消息，大部分核心方法都交给 <code>native</code> 层来处理，其中 <code>MessageQueue</code> 类中涉及的 <code>native</code> 方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">nativeInit</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeDestroy</span><span class="params">(<span class="keyword">long</span> ptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">nativePollOnce</span><span class="params">(<span class="keyword">long</span> ptr, <span class="keyword">int</span> timeoutMillis)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeWake</span><span class="params">(<span class="keyword">long</span> ptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">nativeIsPolling</span><span class="params">(<span class="keyword">long</span> ptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeSetFileDescriptorEvents</span><span class="params">(<span class="keyword">long</span> ptr, <span class="keyword">int</span> fd, <span class="keyword">int</span> events)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="4-1-1-nativeInit"><a href="#4-1-1-nativeInit" class="headerlink" title="4.1.1 nativeInit"></a>4.1.1 nativeInit</h3><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/android/android_handler_native_init.png" alt="图片来源于《Android消息机制1-Handler(Java层)》"></p><ul><li><strong>new MessageQueue()</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MessageQueue.java</span><br><span class="line"></span><br><span class="line">MessageQueue(<span class="keyword">boolean</span> quitAllowed) &#123;</span><br><span class="line">    mQuitAllowed = quitAllowed;</span><br><span class="line">    mPtr = nativeInit();  <span class="comment">//mPtr记录native消息队列的信息 【android_os_MessageQueue_nativeInit()】</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">nativeInit</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ul><li><strong>android_os_MessageQueue_nativeInit()</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">android_os_MessageQueue.cpp</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">android_os_MessageQueue_nativeInit</span><span class="params">(JNIEnv* env, jclass clazz)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化 native 消息队列</span></span><br><span class="line">    NativeMessageQueue* nativeMessageQueue = <span class="keyword">new</span> NativeMessageQueue();</span><br><span class="line">    <span class="keyword">if</span> (!nativeMessageQueue) &#123;</span><br><span class="line">        jniThrowRuntimeException(env, <span class="string">&quot;Unable to allocate native queue&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 增加引用计数</span></span><br><span class="line">    nativeMessageQueue-&gt;incStrong(env);</span><br><span class="line">    <span class="comment">// reinterpret_cast 强制类型转换符</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(nativeMessageQueue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>new NativeMessageQueue()</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">android_os_MessageQueue.cpp</span><br><span class="line"></span><br><span class="line">NativeMessageQueue::NativeMessageQueue() :</span><br><span class="line">        mPollEnv(<span class="literal">NULL</span>), mPollObj(<span class="literal">NULL</span>), mExceptionObj(<span class="literal">NULL</span>) &#123;</span><br><span class="line">    mLooper = Looper::getForThread();<span class="comment">//获取 TLS 中的 Looper 对象，功能类比于 Java 层的 Looper.myLooper();</span></span><br><span class="line">    <span class="keyword">if</span> (mLooper == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mLooper = <span class="keyword">new</span> Looper(<span class="literal">false</span>);<span class="comment">//创建 native 层的 Looper 【new Looper()】</span></span><br><span class="line">        Looper::setForThread(mLooper);<span class="comment">//保存 native 层的 Looper 到 TLS，功能类比于 Java 层的 ThreadLocal.set();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处 <code>Native</code> 层的 <code>Looper</code> 与 <code>Java</code> 层的 <code>Looper</code> 没有任何的关系，只是在 <code>Native</code> 层重实现了一套类似功能的逻辑。</p><ul><li><strong>new Looper()</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Looper.cpp</span><br><span class="line"></span><br><span class="line">Looper::Looper(<span class="keyword">bool</span> allowNonCallbacks)</span><br><span class="line">    : mAllowNonCallbacks(allowNonCallbacks),</span><br><span class="line">      mSendingMessage(<span class="literal">false</span>),</span><br><span class="line">      mPolling(<span class="literal">false</span>),</span><br><span class="line">      mEpollRebuildRequired(<span class="literal">false</span>),</span><br><span class="line">      mNextRequestSeq(<span class="number">0</span>),</span><br><span class="line">      mResponseIndex(<span class="number">0</span>),</span><br><span class="line">      mNextMessageUptime(LLONG_MAX) &#123;</span><br><span class="line">    <span class="comment">// 构造唤醒事件的 fd</span></span><br><span class="line">    mWakeEventFd.reset(eventfd(<span class="number">0</span>, EFD_NONBLOCK | EFD_CLOEXEC));</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(mWakeEventFd.get() &lt; <span class="number">0</span>, <span class="string">&quot;Could not make wake event fd: %s&quot;</span>, strerror(errno));</span><br><span class="line"></span><br><span class="line">    AutoMutex _l(mLock);</span><br><span class="line">    rebuildEpollLocked();<span class="comment">// 重建 Epoll 事件 【epoll_create/epoll_ctl】</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>epoll_create/epoll_ctl</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Looper.cpp</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Looper::rebuildEpollLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Close old epoll instance if we have one.</span></span><br><span class="line">    <span class="keyword">if</span> (mEpollFd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        mEpollFd.reset(); <span class="comment">// 闭旧的 poll 例</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建新的 epoll 实例，并注册 wake 管道</span></span><br><span class="line">    mEpollFd.reset(epoll_create1(EPOLL_CLOEXEC)); </span><br><span class="line">    LOG_ALWAYS_FATAL_IF(mEpollFd &lt; <span class="number">0</span>, <span class="string">&quot;Could not create epoll instance: %s&quot;</span>, strerror(errno));</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">eventItem</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp; eventItem, <span class="number">0</span>, <span class="keyword">sizeof</span>(epoll_event)); <span class="comment">// 把未使用的数据区域进行置 0 操作</span></span><br><span class="line">    eventItem.events = EPOLLIN;<span class="comment">//可读事件</span></span><br><span class="line">    eventItem.data.fd = mWakeEventFd.get();</span><br><span class="line">    <span class="comment">//将唤醒事件 (mWakeEventFd) 添加到 epoll 实例 (mEpollFd)</span></span><br><span class="line">    <span class="keyword">int</span> result = epoll_ctl(mEpollFd.get(), EPOLL_CTL_ADD, mWakeEventFd.get(), &amp;eventItem);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(result != <span class="number">0</span>, <span class="string">&quot;Could not add wake event fd to epoll instance: %s&quot;</span>,</span><br><span class="line">                        strerror(errno));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mRequests.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> Request&amp; request = mRequests.valueAt(i);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">eventItem</span>;</span></span><br><span class="line">        request.initEventItem(&amp;eventItem);</span><br><span class="line">        <span class="comment">// 将 request 队列的事件，分别添加到 epoll 实例</span></span><br><span class="line">        <span class="keyword">int</span> epollResult = epoll_ctl(mEpollFd.get(), EPOLL_CTL_ADD, request.fd, &amp;eventItem);</span><br><span class="line">        <span class="keyword">if</span> (epollResult &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            ALOGE(<span class="string">&quot;Error adding epoll events for fd %d while rebuilding epoll set: %s&quot;</span>,</span><br><span class="line">                  request.fd, strerror(errno));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Looper</code> 对象中的 <code>mWakeEventFd</code> 添加到 <code>epoll</code> 监控，以及 <code>mRequests</code> 也添加到 <code>epoll</code> 的监控范围内。</p><h3 id="4-1-2-nativeDestroy"><a href="#4-1-2-nativeDestroy" class="headerlink" title="4.1.2 nativeDestroy"></a>4.1.2 nativeDestroy</h3><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/android/android_handler_native_destroy.png" alt="图片来源于《Android消息机制1-Handler(Java层)》"></p><ul><li><strong>MessageQueue.dispose()</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MessageQueue.java</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mPtr != <span class="number">0</span>) &#123;</span><br><span class="line">            nativeDestroy(mPtr); <span class="comment">//【android_os_MessageQueue_nativeDestroy()】</span></span><br><span class="line">            mPtr = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><strong>android_os_MessageQueue_nativeDestroy()</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">android_os_MessageQueue.cpp</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_os_MessageQueue_nativeDestroy</span><span class="params">(JNIEnv* env, jclass clazz, jlong ptr)</span> </span>&#123;</span><br><span class="line">    NativeMessageQueue* nativeMessageQueue = <span class="keyword">reinterpret_cast</span>&lt;NativeMessageQueue*&gt;(ptr);</span><br><span class="line">    nativeMessageQueue-&gt;decStrong(env); <span class="comment">// 【RefBase::decStrong()】</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>nativeMessageQueue</code> 继承自 <code>RefBase</code> 类，所以 <code>decStrong</code> 最终调用的是 <code>RefBase.decStrong()</code> 。</p><ul><li><strong>RefBase::decStrong()</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">RefBase.cpp</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RefBase::decStrong</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    weakref_impl* <span class="keyword">const</span> refs = mRefs;</span><br><span class="line">    refs-&gt;removeStrongRef(id); <span class="comment">// 移除强引用</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int32_t</span> c = refs-&gt;mStrong.fetch_sub(<span class="number">1</span>, <span class="built_in">std</span>::memory_order_release);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(BAD_STRONG(c), <span class="string">&quot;decStrong() called on %p too many times&quot;</span>,</span><br><span class="line">            refs);</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::atomic_thread_fence(<span class="built_in">std</span>::memory_order_acquire);</span><br><span class="line">        refs-&gt;mBase-&gt;onLastStrongRef(id);</span><br><span class="line">        <span class="keyword">int32_t</span> flags = refs-&gt;mFlags.load(<span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">        <span class="keyword">if</span> ((flags&amp;OBJECT_LIFETIME_MASK) == OBJECT_LIFETIME_STRONG) &#123;</span><br><span class="line">            <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">            <span class="comment">// 在这种情况下，析构函数不删除引用。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 移除弱引用</span></span><br><span class="line">    refs-&gt;decWeak(id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-1-3-nativePollOnce"><a href="#4-1-3-nativePollOnce" class="headerlink" title="4.1.3 nativePollOnce"></a>4.1.3 nativePollOnce</h3><p><code>nativePollOnce</code> 用于提取消息队列中的消息，提取消息的调用链</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/android/android_handler_poll_once.png" alt="图片来源于《Android消息机制1-Handler(Java层)》"></p><ul><li><strong>android_os_MessageQueue_nativePollOnce()</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">android_os_MessageQueue.cpp</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_os_MessageQueue_nativePollOnce</span><span class="params">(JNIEnv* env, jobject obj,</span></span></span><br><span class="line"><span class="function"><span class="params">        jlong ptr, jint timeoutMillis)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将 Java 层传递下来的 mPtr 转换为 nativeMessageQueue</span></span><br><span class="line">    NativeMessageQueue* nativeMessageQueue = <span class="keyword">reinterpret_cast</span>&lt;NativeMessageQueue*&gt;(ptr);</span><br><span class="line">    nativeMessageQueue-&gt;pollOnce(env, obj, timeoutMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>NativeMessageQueue::pollOnce()</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">android_os_MessageQueue.cpp</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NativeMessageQueue::pollOnce</span><span class="params">(JNIEnv* env, jobject pollObj, <span class="keyword">int</span> timeoutMillis)</span> </span>&#123;</span><br><span class="line">    mPollEnv = env;</span><br><span class="line">    mPollObj = pollObj;</span><br><span class="line">    mLooper-&gt;pollOnce(timeoutMillis);<span class="comment">// 【Looper::pollOnce()】</span></span><br><span class="line">    mPollObj = <span class="literal">NULL</span>;</span><br><span class="line">    mPollEnv = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mExceptionObj) &#123;</span><br><span class="line">        env-&gt;Throw(mExceptionObj);</span><br><span class="line">        env-&gt;DeleteLocalRef(mExceptionObj);</span><br><span class="line">        mExceptionObj = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>Looper::pollOnce()</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">Looper.h</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">pollOnce</span><span class="params">(<span class="keyword">int</span> timeoutMillis)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pollOnce(timeoutMillis, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Looper.cpp</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Looper::pollOnce</span><span class="params">(<span class="keyword">int</span> timeoutMillis, <span class="keyword">int</span>* outFd, <span class="keyword">int</span>* outEvents, <span class="keyword">void</span>** outData)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 先处理没有 Callback 方法的 Response 事件</span></span><br><span class="line">        <span class="keyword">while</span> (mResponseIndex &lt; mResponses.size()) &#123;</span><br><span class="line">            <span class="keyword">const</span> Response&amp; response = mResponses.itemAt(mResponseIndex++);</span><br><span class="line">            <span class="keyword">int</span> ident = response.request.ident;</span><br><span class="line">            <span class="keyword">if</span> (ident &gt;= <span class="number">0</span>) &#123; <span class="comment">// ident 大于 0，则表示没有 callback, 因为 POLL_CALLBACK = -2,</span></span><br><span class="line">                <span class="keyword">int</span> fd = response.request.fd;</span><br><span class="line">                <span class="keyword">int</span> events = response.events;</span><br><span class="line">                <span class="keyword">void</span>* data = response.request.data;</span><br><span class="line">                <span class="keyword">if</span> (outFd != <span class="literal">nullptr</span>) *outFd = fd;</span><br><span class="line">                <span class="keyword">if</span> (outEvents != <span class="literal">nullptr</span>) *outEvents = events;</span><br><span class="line">                <span class="keyword">if</span> (outData != <span class="literal">nullptr</span>) *outData = data;</span><br><span class="line">                <span class="keyword">return</span> ident;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (outFd != <span class="literal">nullptr</span>) *outFd = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (outEvents != <span class="literal">nullptr</span>) *outEvents = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (outData != <span class="literal">nullptr</span>) *outData = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 再处理内部轮询</span></span><br><span class="line">        result = pollInner(timeoutMillis); <span class="comment">//【Looper::pollInner()】</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>参数说明：</p><ul><li><strong>timeoutMillis：</strong>超时时长</li><li><strong>outFd：</strong>发生事件的文件描述符</li><li><strong>outEvents：</strong>当前outFd上发生的事件，包含以下4类事件<ul><li><strong>EVENT_INPUT</strong> 可读</li><li><strong>EVENT_OUTPUT</strong> 可写</li><li><strong>EVENT_ERROR</strong> 错误</li><li><strong>EVENT_HANGUP</strong> 中断</li></ul></li><li><strong>outData：</strong>上下文数据</li></ul></blockquote><ul><li><strong>Looper::pollInner()</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">Looper.cpp</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Looper::pollInner</span><span class="params">(<span class="keyword">int</span> timeoutMillis)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">int</span> result = POLL_WAKE;</span><br><span class="line">    mResponses.clear();</span><br><span class="line">    mResponseIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    mPolling = <span class="literal">true</span>; <span class="comment">// 即将处于 idle 状态</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">eventItems</span>[<span class="title">EPOLL_MAX_EVENTS</span>];</span><span class="comment">// fd 最大个数为 16</span></span><br><span class="line">    <span class="comment">// 等待事件发生或者超时，在 nativeWake() 方法，向管道写端写入字符，则该方法会返回；</span></span><br><span class="line">    <span class="keyword">int</span> eventCount = epoll_wait(mEpollFd.get(), eventItems, EPOLL_MAX_EVENTS, timeoutMillis);</span><br><span class="line"></span><br><span class="line">    mPolling = <span class="literal">false</span>;<span class="comment">// 不再处于 idle 状态</span></span><br><span class="line"></span><br><span class="line">    mLock.lock();<span class="comment">//请求锁</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果需要，重建 epoll 集。</span></span><br><span class="line">    <span class="keyword">if</span> (mEpollRebuildRequired) &#123;</span><br><span class="line">        mEpollRebuildRequired = <span class="literal">false</span>;</span><br><span class="line">        rebuildEpollLocked();<span class="comment">// epoll 重建，直接跳转 Done;</span></span><br><span class="line">        <span class="keyword">goto</span> Done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 轮询误差检查.</span></span><br><span class="line">    <span class="keyword">if</span> (eventCount &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno == EINTR) &#123;</span><br><span class="line">            <span class="keyword">goto</span> Done;</span><br><span class="line">        &#125;</span><br><span class="line">        result = POLL_ERROR;<span class="comment">// epoll 事件个数小于 0 ，发生错误，直接跳转 Done;</span></span><br><span class="line">        <span class="keyword">goto</span> Done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查轮询超时时间。</span></span><br><span class="line">    <span class="keyword">if</span> (eventCount == <span class="number">0</span>) &#123;<span class="comment">// epoll 事件个数等于0，发生超时，直接跳转 Done;</span></span><br><span class="line">        result = POLL_TIMEOUT;</span><br><span class="line">        <span class="keyword">goto</span> Done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环遍历，处理所有的事件</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; eventCount; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> fd = eventItems[i].data.fd;</span><br><span class="line">        <span class="keyword">uint32_t</span> epollEvents = eventItems[i].events;</span><br><span class="line">        <span class="keyword">if</span> (fd == mWakeEventFd.get()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (epollEvents &amp; EPOLLIN) &#123;</span><br><span class="line">                awoken();<span class="comment">// 已经唤醒了，则读取并清空管道数据</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ALOGW(<span class="string">&quot;Ignoring unexpected epoll events 0x%x on wake event fd.&quot;</span>, epollEvents);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">ssize_t</span> requestIndex = mRequests.indexOfKey(fd);</span><br><span class="line">            <span class="keyword">if</span> (requestIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> events = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (epollEvents &amp; EPOLLIN) events |= EVENT_INPUT;</span><br><span class="line">                <span class="keyword">if</span> (epollEvents &amp; EPOLLOUT) events |= EVENT_OUTPUT;</span><br><span class="line">                <span class="keyword">if</span> (epollEvents &amp; EPOLLERR) events |= EVENT_ERROR;</span><br><span class="line">                <span class="keyword">if</span> (epollEvents &amp; EPOLLHUP) events |= EVENT_HANGUP;</span><br><span class="line">                <span class="comment">// 处理 request，生成对应的 reponse 对象，push 到响应数组</span></span><br><span class="line">                pushResponse(events, mRequests.valueAt(requestIndex));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ALOGW(<span class="string">&quot;Ignoring unexpected epoll events 0x%x on fd %d that is &quot;</span></span><br><span class="line">                        <span class="string">&quot;no longer registered.&quot;</span>, epollEvents, fd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">Done: ;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 再处理 Native 的 Message，调用相应回调方法</span></span><br><span class="line">    mNextMessageUptime = LLONG_MAX;</span><br><span class="line">    <span class="keyword">while</span> (mMessageEnvelopes.size() != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">nsecs_t</span> now = systemTime(SYSTEM_TIME_MONOTONIC);</span><br><span class="line">        <span class="keyword">const</span> MessageEnvelope&amp; messageEnvelope = mMessageEnvelopes.itemAt(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (messageEnvelope.uptime &lt;= now) &#123;</span><br><span class="line">            &#123; </span><br><span class="line">                sp&lt;MessageHandler&gt; handler = messageEnvelope.handler;</span><br><span class="line">                Message message = messageEnvelope.message;</span><br><span class="line">                mMessageEnvelopes.removeAt(<span class="number">0</span>);</span><br><span class="line">                mSendingMessage = <span class="literal">true</span>;</span><br><span class="line">                mLock.unlock(); <span class="comment">// 释放锁</span></span><br><span class="line">                handler-&gt;handleMessage(message);<span class="comment">// 处理消息事件</span></span><br><span class="line">            &#125;</span><br><span class="line">            mLock.lock(); <span class="comment">// 请求锁</span></span><br><span class="line">            mSendingMessage = <span class="literal">false</span>;</span><br><span class="line">            result = POLL_CALLBACK; <span class="comment">// 发生回调</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// The last message left at the head of the queue determines the next wakeup time.</span></span><br><span class="line">            mNextMessageUptime = messageEnvelope.uptime;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mLock.unlock();<span class="comment">// 释放锁</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理带有 Callback() 方法的 Response 事件，执行 Reponse 相应的回调方法</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mResponses.size(); i++) &#123;</span><br><span class="line">        Response&amp; response = mResponses.editItemAt(i);</span><br><span class="line">        <span class="keyword">if</span> (response.request.ident == POLL_CALLBACK) &#123;</span><br><span class="line">            <span class="keyword">int</span> fd = response.request.fd;</span><br><span class="line">            <span class="keyword">int</span> events = response.events;</span><br><span class="line">            <span class="keyword">void</span>* data = response.request.data;</span><br><span class="line">            <span class="comment">// 处理请求的回调方法</span></span><br><span class="line">            <span class="keyword">int</span> callbackResult = response.request.callback-&gt;handleEvent(fd, events, data);</span><br><span class="line">            <span class="keyword">if</span> (callbackResult == <span class="number">0</span>) &#123;</span><br><span class="line">                removeFd(fd, response.request.seq);<span class="comment">// 移除 fd</span></span><br><span class="line">            &#125;</span><br><span class="line">            response.request.callback.clear();<span class="comment">// 清除 reponse 引用的回调方法</span></span><br><span class="line">            result = POLL_CALLBACK; <span class="comment">// 发生回调</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>pollOnce</code> 返回值说明：</p><ul><li><strong>POLL_WAKE：</strong> 表示由 <code>wake()</code> 触发，即 <code>pipe</code> 写端的 <code>write</code> 事件触发；</li><li><strong>POLL_CALLBACK：</strong> 表示某个被监听 <code>fd</code> 被触发。</li><li><strong>POLL_TIMEOUT：</strong> 表示等待超时；</li><li><strong>POLL_ERROR：</strong>表示等待期间发生错误；</li></ul></blockquote><ul><li><strong>Looper::awoken()</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Looper.cpp</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Looper::awoken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> counter;</span><br><span class="line">    <span class="comment">// 不断读取管道数据，目的就是为了清空管道内容</span></span><br><span class="line">    TEMP_FAILURE_RETRY(read(mWakeEventFd.get(), &amp;counter, <span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>poll小结</strong></p><p><code>pollInner()</code> 方法的处理流程：</p><ol><li>先调用 <code>epoll_wait()</code>，这是阻塞方法，用于等待事件发生或者超时；</li><li>对于 <code>epoll_wait()</code> 返回，当且仅当以下 <code>3</code> 种情况出现：<ul><li><code>POLL_ERROR</code>，发生错误，直接跳转到 <code>Done</code>；</li><li><code>POLL_TIMEOUT</code>，发生超时，直接跳转到 <code>Done</code> ；</li><li>检测到管道有事件发生，则再根据情况做相应处理：<ul><li>如果是管道读端产生事件，则直接读取管道的数据；</li><li>如果是其他事件，则处理 <code>request</code> ，生成对应的 <code>reponse</code> 对象，<code>push</code> 到 <code>reponse</code> 数组；</li></ul></li></ul></li><li>进入 <code>Done</code> 标记位的代码段：<ul><li>先处理 <code>Native</code> 的 <code>Message</code> ，调用 <code>Native</code>  的 <code>Handler</code> 来处理该 <code>Message</code>；</li><li>再处理 <code>Response</code> 数组，<code>POLL_CALLBACK</code> 类型的事件；</li></ul></li></ol><p>从上面的流程，可以发现对于 <code>Request</code> 先收集，一并放入 <code>reponse</code> 数组，而不是马上执行。真正在 <code>Done</code> 开始执行的时候，是先处理 <code>native Message</code>，再处理 <code>Request</code> ，说明 <code>native Message</code> 的优先级高于 <code>Request</code> 请求的优先级。</p><p>另外 <code>pollOnce()</code> 方法中，先处理 <code>Response</code> 数组中不带 <code>Callback</code> 的事件，再调用了 <code>pollInner()</code> 方法。</p></blockquote><h3 id="4-1-4-nativeWake"><a href="#4-1-4-nativeWake" class="headerlink" title="4.1.4 nativeWake"></a>4.1.4 nativeWake</h3><p><code>nativeWake</code> 用于唤醒功能，在添加消息到消息队列 <code>enqueueMessage()</code> , 或者把消息从消息队列中全部移除 <code>quit()</code> ，再有需要时都会调用  <code>nativeWake</code> 方法。包含唤醒过程的添加消息的调用链，如下：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/android/android_handler_native_wake.png" alt="图片来源于《Android消息机制1-Handler(Java层)》"></p><ul><li><strong>android_os_MessageQueue_nativeWake()</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">android_os_MessageQueue.cpp</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_os_MessageQueue_nativeWake</span><span class="params">(JNIEnv* env, jclass clazz, jlong ptr)</span> </span>&#123;</span><br><span class="line">    NativeMessageQueue* nativeMessageQueue = <span class="keyword">reinterpret_cast</span>&lt;NativeMessageQueue*&gt;(ptr);</span><br><span class="line">    nativeMessageQueue-&gt;wake();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>NativeMessageQueue::wake()</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">android_os_MessageQueue.cpp</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NativeMessageQueue::wake</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mLooper-&gt;wake();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Looper.cpp</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Looper::wake</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> inc = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 向管道 mWakeEventFd 写入字符 1</span></span><br><span class="line">    <span class="keyword">ssize_t</span> nWrite = TEMP_FAILURE_RETRY(write(mWakeEventFd.get(), &amp;inc, <span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>)));</span><br><span class="line">    <span class="keyword">if</span> (nWrite != <span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno != EAGAIN) &#123;</span><br><span class="line">            LOG_ALWAYS_FATAL(<span class="string">&quot;Could not write wake signal to fd %d (returned %zd): %s&quot;</span>,</span><br><span class="line">                             mWakeEventFd.get(), nWrite, strerror(errno));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>TEMP_FAILURE_RETRY</code>  是一个宏定义， 当执行 <code>write</code> 失败后，会不断重复执行，直到执行成功为止。</p><h3 id="4-1-5-sendMessage"><a href="#4-1-5-sendMessage" class="headerlink" title="4.1.5 sendMessage"></a>4.1.5 sendMessage</h3><p>这里主要讲 <code>Native</code> 层如何向 <code>MessageQueue</code> 发送消息</p><p><strong>sendMessage</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Looper.cpp</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Looper::sendMessage</span><span class="params">(<span class="keyword">const</span> sp&lt;MessageHandler&gt;&amp; handler, <span class="keyword">const</span> Message&amp; message)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">nsecs_t</span> now = systemTime(SYSTEM_TIME_MONOTONIC);</span><br><span class="line">    sendMessageAtTime(now, handler, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>sendMessageDelayed</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Looper.cpp</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Looper::sendMessageDelayed</span><span class="params">(<span class="keyword">nsecs_t</span> uptimeDelay, <span class="keyword">const</span> sp&lt;MessageHandler&gt;&amp; handler,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> Message&amp; message)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">nsecs_t</span> now = systemTime(SYSTEM_TIME_MONOTONIC);</span><br><span class="line">    sendMessageAtTime(now + uptimeDelay, handler, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>sendMessageAtTime</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Looper::sendMessageAtTime</span><span class="params">(<span class="keyword">nsecs_t</span> uptime, <span class="keyword">const</span> sp&lt;MessageHandler&gt;&amp; handler,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> Message&amp; message)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> i = <span class="number">0</span>;</span><br><span class="line">    &#123; <span class="comment">//请求锁</span></span><br><span class="line">        AutoMutex _l(mLock);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">size_t</span> messageCount = mMessageEnvelopes.size();</span><br><span class="line">        <span class="comment">// 找到 message 应该插入的位置 i</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; messageCount &amp;&amp; uptime &gt;= mMessageEnvelopes.itemAt(i).uptime) &#123;</span><br><span class="line">            i += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">MessageEnvelope <span class="title">messageEnvelope</span><span class="params">(uptime, handler, message)</span></span>;</span><br><span class="line">        mMessageEnvelopes.insertAt(messageEnvelope, i, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前正在发送消息，那么不再调用 wake()，直接返回。</span></span><br><span class="line">        <span class="keyword">if</span> (mSendingMessage) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// 释放锁</span></span><br><span class="line">    <span class="comment">// 当把消息加入到消息队列的头部时，需要唤醒 poll 循环。</span></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">        wake();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="4-1-6-总结"><a href="#4-1-6-总结" class="headerlink" title="4.1.6 总结"></a>4.1.6 总结</h3><ul><li><strong>nativeInit()：</strong><ul><li>创建了 <code>NativeMessageQueue</code> 对象，增加其引用计数，并将 <code>NativeMessageQueue</code> 指针 <code>mPtr</code> 保存在 <code>Java</code> 层的 <code>MessageQueue</code> </li><li>创建了 <code>Native Looper</code> 对象</li><li>调用 <code>epoll</code> 的 <code>epoll_create()/epoll_ctl()</code> 来完成对 <code>mWakeEventFd</code> 和 <code>mRequests</code> 的可读事件监听</li></ul></li><li><strong>nativeDestroy()：</strong><ul><li>调用 <code>RefBase::decStrong()</code> 来减少对象的引用计数</li><li>当引用计数为 <code>0</code> 时，则删除 <code>NativeMessageQueue</code> 对象</li></ul></li><li><strong>nativePollOnce()：</strong><ul><li>调用 <code>Looper::pollOnce()</code> 来完成，空闲时停留在 <code>epoll_wait()</code> 方法，用于等待事件发生或者超时</li></ul></li><li><strong>nativeWake()：</strong><ul><li>调用 <code>Looper::wake()</code> 来完成，向管道 <code>mWakeEventfd</code> 写入字符；</li></ul></li></ul><h2 id="4-2-认识-Native-结构体和类"><a href="#4-2-认识-Native-结构体和类" class="headerlink" title="4.2 认识 Native 结构体和类"></a>4.2 认识 Native 结构体和类</h2><p><code>Looper.h/Looper.cpp</code> 文件中，定义了 <code>Message</code> 结构体，消息处理类，回调类，<code>Looper</code> 类。</p><h3 id="4-2-1-Message-结构体"><a href="#4-2-1-Message-结构体" class="headerlink" title="4.2.1 Message 结构体"></a>4.2.1 Message 结构体</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Looper.h</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Message</span> &#123;</span></span><br><span class="line">    Message() : what(<span class="number">0</span>) &#123; &#125;</span><br><span class="line">    Message(<span class="keyword">int</span> w) : what(w) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The message type. (interpretation is left up to the handler) */</span></span><br><span class="line">    <span class="keyword">int</span> what;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="4-2-2-消息处理类"><a href="#4-2-2-消息处理类" class="headerlink" title="4.2.2 消息处理类"></a>4.2.2 消息处理类</h3><p><strong>MessageHandler</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Looper.h</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageHandler</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> RefBase &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~MessageHandler();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(<span class="keyword">const</span> Message&amp; message)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>WeakMessageHandler</code> 类，继承于 <code>MessageHandler</code>  类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Looper.h</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeakMessageHandler</span> :</span> <span class="keyword">public</span> MessageHandler &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~WeakMessageHandler();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    WeakMessageHandler(<span class="keyword">const</span> wp&lt;MessageHandler&gt;&amp; handler);</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(<span class="keyword">const</span> Message&amp; message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    wp&lt;MessageHandler&gt; mHandler;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Looper.cpp</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WeakMessageHandler::handleMessage</span><span class="params">(<span class="keyword">const</span> Message&amp; message)</span> </span>&#123;</span><br><span class="line">    sp&lt;MessageHandler&gt; handler = mHandler.promote();</span><br><span class="line">    <span class="keyword">if</span> (handler != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        handler-&gt;handleMessage(message);<span class="comment">// 调用 MessageHandler 类的处理方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-3-回调类"><a href="#4-2-3-回调类" class="headerlink" title="4.2.3 回调类"></a>4.2.3 回调类</h3><p><strong>LooperCallback</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Looper.h</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LooperCallback</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> RefBase &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~LooperCallback();</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 用于处理指定的文件描述符的poll事件</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">handleEvent</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> events, <span class="keyword">void</span>* data)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>SimpleLooperCallback</code> 类， 继承于 <code>LooperCallback</code> 类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Looper.h</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleLooperCallback</span> :</span> <span class="keyword">public</span> LooperCallback &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~SimpleLooperCallback();</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SimpleLooperCallback(Looper_callbackFunc callback);</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">handleEvent</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> events, <span class="keyword">void</span>* data)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Looper_callbackFunc mCallback;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Looper.cpp</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SimpleLooperCallback::handleEvent</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> events, <span class="keyword">void</span>* data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mCallback(fd, events, data);<span class="comment">// 调用回调方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-4-Looper"><a href="#4-2-4-Looper" class="headerlink" title="4.2.4 Looper"></a>4.2.4 Looper</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> EPOLL_MAX_EVENTS = <span class="number">16</span>; <span class="comment">//轮询事件的文件描述符的个数上限</span></span><br></pre></td></tr></table></figure><p>其中 <code>Looper</code> 类的内部定义了 <code>Request</code> ，<code>Response</code> ，<code>MessageEnvelope</code> 这 <code>3</code> 个结构体</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/android/android_handler_struct.png" alt="图片来源于《Android消息机制2》"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Request</span> &#123;</span><span class="comment">// 请求结构体</span></span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">int</span> ident;</span><br><span class="line">    <span class="keyword">int</span> events;</span><br><span class="line">    <span class="keyword">int</span> seq;</span><br><span class="line">    sp&lt;LooperCallback&gt; callback;</span><br><span class="line">    <span class="keyword">void</span>* data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initEventItem</span><span class="params">(struct epoll_event* eventItem)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Response</span> &#123;</span><span class="comment">// 响应结构体</span></span><br><span class="line">    <span class="keyword">int</span> events;</span><br><span class="line">    Request request;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MessageEnvelope</span> &#123;</span><span class="comment">// 信封结构体</span></span><br><span class="line">    MessageEnvelope() : uptime(<span class="number">0</span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    MessageEnvelope(<span class="keyword">nsecs_t</span> u, sp&lt;MessageHandler&gt; h, <span class="keyword">const</span> Message&amp; m)</span><br><span class="line">        : uptime(u), handler(<span class="built_in">std</span>::move(h)), message(m) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">nsecs_t</span> uptime;</span><br><span class="line">    sp&lt;MessageHandler&gt; handler;</span><br><span class="line">    Message message;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>MessageEnvelope</code> 正如其名字，信封。<code>MessageEnvelope</code> 里面记录着收信人 <code>(handler)</code> ，发信时间 <code>(uptime)</code> ，信件内容 <code>(message)</code> </p><h3 id="4-2-5-ALooper"><a href="#4-2-5-ALooper" class="headerlink" title="4.2.5 ALooper"></a>4.2.5 ALooper</h3><p><code>ALooper</code> 类定义在通过 <code>looper.cpp/looper.h</code>（注意此文件是小写字母开头，与 <code>Looper.cpp</code> 不同，具体源码路径，可通过查看 上面 Native 分析 相关源码路径分析）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> Looper* <span class="title">ALooper_to_Looper</span><span class="params">(ALooper* alooper)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;Looper*&gt;(alooper);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> ALooper* <span class="title">Looper_to_ALooper</span><span class="params">(Looper* looper)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;ALooper*&gt;(looper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ALooper</code> 类 与前面介绍的 <code>Looper</code> 类，更多的操作是通过 <code>ALooper_to_Looper()</code> ，<code>Looper_to_ALooper()</code> 这两个方法转换完成的，也就是说 <code>ALooper</code> 类中定义的所有方法，都是通过转换为 <code>Looper</code> 类，再执行 <code>Looper</code> 中的方法。</p><h3 id="4-2-6-总结"><a href="#4-2-6-总结" class="headerlink" title="4.2.6 总结"></a>4.2.6 总结</h3><p><code>MessageQueue</code> 通过 <code>mPtr</code> 变量保存 <code>NativeMessageQueue</code> 对象，从而使得 <code>MessageQueue</code> 成为 <code>Java</code> 层和 <code>Native</code> 层的枢纽，既能处理上层消息，也能处理 <code>native</code> 层消息；下面列举 <code>Java</code> 层与 <code>Native</code> 层的对应图</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/android/android_handler_handler_arch.png" alt="图片来源于《Android消息机制2》"></p><p>图解：</p><ul><li>红色虚线关系：<code>Java</code> 层和 <code>Native</code> 层的 <code>MessageQueue</code> 通过 <code>JNI</code> 建立关联，彼此之间能相互调用，搞明白这个互调关系，也就搞明白了 <code>Java</code> 如何调用 <code>C++</code> 代码，<code>C++</code> 代码又是如何调用 <code>Java</code> 代码。</li><li>蓝色虚线关系：<code>Handler/Looper/Message</code> 这三大类 <code>Java</code> 层与 <code>Native</code> 层并没有任何的真正关联，只是分别在 <code>Java</code> 层和 <code>Native</code> 层的 <code>handler</code> 消息模型中具有相似的功能。都是彼此独立的，各自实现相应的逻辑。</li><li><code>WeakMessageHandler</code> 继承于 <code>MessageHandler</code> 类，<code>NativeMessageQueue</code> 继承于 <code>MessageQueue</code> 类</li></ul><p>另外，消息处理流程是先处理 <code>Native Message</code> ，再处理 <code>Native Request</code> ，最后处理 <code>Java Message</code> 。理解了该流程，也就明白有时上层消息很少，但响应时间却较长的真正原因。</p><h1 id="五、其他要点"><a href="#五、其他要点" class="headerlink" title="五、其他要点"></a>五、其他要点</h1><p><strong>问题：</strong></p><p><code>Android</code> 中为什么主线程不会因为 <code>Looper.loop()</code> 里的死循环卡死？</p><p>没看见哪里有相关代码为这个死循环准备了一个新线程去运转？</p><p><code>Activity</code> 的生命周期这些方法这些都是在主线程里执行的吧，那这些生命周期方法是怎么实现在死循环体外能够执行起来的？</p><hr><p>要完全彻底理解这个问题，需要准备以下 <code>4</code> 方面的知识： <code>Process/Thread</code>，<code>Android Binder IPC</code>，<code>Handler/Looper/MessageQueue</code> 消息机制，<code>Linux pipe/epoll</code> 机制。</p><p><strong>(1) Android 中为什么主线程不会因为 Looper.loop() 里的死循环卡死？</strong></p><p>这里涉及线程，先说说 进程 / 线程</p><p><strong>进程：</strong>每个 <code>app</code> 运行时前首先创建一个进程，该进程是由 <code>Zygote fork</code> 出来的，用于承载 <code>App</code> 上运行的各种 <code>Activity/Service</code> 等组件。进程对于上层应用来说是完全透明的，这也是 <code>google</code> 有意为之，让 <code>App</code> 程序都是运行在 <code>Android Runtime</code> 。大多数情况一个 <code>App</code> 就运行在一个进程中，除非在<code>AndroidManifest.xml</code> 中配置 <code>Android:process</code> 属性，或通过 <code>native</code> 代码 <code>fork</code> 进程。</p><p><strong>线程：</strong>线程对应用来说非常常见，比如每次 <code>new Thread().start</code> 都会创建一个新的线程。该线程与 <code>App</code> 所在进程之间资源共享，从 <code>Linux</code> 角度来说进程与线程除了是否共享资源外，并没有本质的区别，都是一个 <code>task_struct</code> 结构体，<strong>在CPU看来进程或线程无非就是一段可执行的代码，CPU 采用 CFS 调度算法，保证每个 task 都尽可能公平的享有 CPU 时间片</strong>。</p><p>对于线程既然是一段可执行的代码，当可执行代码执行完成后，线程生命周期便该终止了，线程退出。</p><p>而对于主线程，我们是绝不希望会被运行一段时间，自己就退出，那么如何保证能一直存活呢？</p><p><strong>简单做法就是可执行代码是能一直执行下去的，死循环便能保证不会被退出</strong>，例如，<code>binder</code> 线程也是采用死循环的方法，通过循环方式不同与 <code>Binder</code> 驱动进行读写操作，当然并非简单地死循环，无消息时会休眠。但这里可能又引发了另一个问题，既然是死循环又如何去处理其他事务呢(比如谁来添加 <code>Message</code> 然后唤醒这个休眠呢)？<strong>通过创建新线程的方式。</strong></p><p>真正会卡死主线程的操作是在回调方法 <code>onCreate/onStart/onResume</code> 等操作时间过长，会导致掉帧，甚至发生 <code>ANR</code> ，<code>looper.loop</code> 本身不会导致应用卡死。</p><p><strong>(2) 没看见哪里有相关代码为这个死循环准备了一个新线程去运转？</strong></p><p>事实上，会在进入死循环之前便创建了新 <code>binder</code> 线程，在代码 <code>ActivityThread.main()</code> 中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ....</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建Looper和MessageQueue对象，用于处理主线程的消息</span></span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建ActivityThread对象</span></span><br><span class="line">    ActivityThread thread = <span class="keyword">new</span> ActivityThread(); </span><br><span class="line"></span><br><span class="line">    <span class="comment">//建立Binder通道 (创建新线程)</span></span><br><span class="line">    thread.attach(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    Looper.loop(); <span class="comment">//消息循环运行</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Main thread loop unexpectedly exited&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>thread.attach(false)；便会创建一个 Binder 线程（具体是指 ApplicationThread，Binder 的服务端，用于接收系统服务 AMS 发送来的事件），该 Binder 线程通过 Handler 将 Message 发送给主线程</strong></p><p><strong><code>ActivityThread</code> 实际上并非线程</strong>，不像 <code>HandlerThread</code> 类，<code>ActivityThread</code> 并没有真正继承 <code>Thread</code> 类，只是往往运行在主线程，该人以线程的感觉，其实承载 <code>ActivityThread</code> 的主线程就是由 <code>Zygote fork</code> 而创建的进程。</p><p><strong>主线程的死循环一直运行是不是特别消耗CPU资源呢？</strong></p><p>其实不然，这里就涉及到 <strong><code>Linux pipe/epoll</code> 机制</strong>，简单说就是在主线程的 <code>MessageQueue</code> 没有消息时，便阻塞在 <code>loop</code> 的 <code>queue.next()</code> 中的 <code>nativePollOnce()</code> 方法里，此时主线程会释放 <code>CPU</code> 资源进入休眠状态，直到下个消息到达或者有事务发生，通过往 <code>pipe</code> 管道写端写入数据来唤醒主线程工作。这里采用的 <code>epoll</code> 机制，是一种 <code>IO</code> 多路复用机制，可以同时监控多个描述符，当某个描述符就绪(读或写就绪)，则立刻通知相应程序进行读或写操作，本质同步 <code>I/O</code> ，即读写是阻塞的。 <strong>所以说，主线程大多数时候都是处于休眠状态，并不会消耗大量 CPU 资源。</strong></p><p><strong>(3) Activity的生命周期是怎么实现在死循环体外能够执行起来的？</strong></p><p><code>ActivityThread</code> 的内部类 <code>H</code> 继承于 <code>Handler</code> ，通过 <code>handler</code> 消息机制，简单说 <code>Handler</code> 机制用于同一个进程的线程间通信。</p><p><strong>Activity 的生命周期都是依靠主线程的 Looper.loop，当收到不同 Message 时则采用相应措施：</strong><br>在 <code>H.handleMessage(msg)</code> 方法中，根据接收到不同的 <code>msg</code> ，执行相应的生命周期。</p><p>比如收到 <code>msg=H.LAUNCH_ACTIVITY</code>，则调用 <code>ActivityThread.handleLaunchActivity()</code> 方法，最终会通过反射机制，创建 <code>Activity</code> 实例，然后再执行 <code>Activity.onCreate()</code> 等方法；再比如收到 <code>msg=H.PAUSE_ACTIVITY</code> ，则调用 <code>ActivityThread.handlePauseActivity()</code> 方法，最终会执行 <code>Activity.onPause()</code> 等方法。 </p><p> <strong>主线程的消息又是哪来的呢？</strong></p><p>当然是 <code>App</code> 进程中的其他线程通过 <code>Handler</code> 发送给主线程</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/android/android_handler_at.jpg" alt="图片来源于《Gityuan》"></p><p><strong>system_server 进程是系统进程</strong>，<code>java framework</code> 框架的核心载体，里面运行了大量的系统服务，比如这里提供 <code>ApplicationThreadProxy</code>（简称 <code>ATP</code> ），<code>ActivityManagerService</code>（简称 <code>AMS</code> ），这个两个服务都运行在 <code>system_server</code> 进程的不同线程中，由于 <code>ATP</code> 和 <code>AMS</code> 都是基于 <code>IBinder</code> 接口，都是 <code>binder</code> 线程，<code>binder</code> 线程的创建与销毁都是由 <code>binder</code> 驱动来决定的。</p><p><strong>App 进程则是我们常说的应用程序</strong>，主线程主要负责 <code>Activity/Service</code> 等组件的生命周期以及UI相关操作都运行在这个线程； 另外，每个 <code>App</code> 进程中至少会有两个 <code>binder</code> 线程 <code>ApplicationThread</code> (简称 <code>AT</code> )和 <code>ActivityManagerProxy</code>（简称 <code>AMP</code> ），除了图中画的线程，其中还有很多线程，比如 <code>signal catcher</code> 线程等，这里就不一一列举。</p><p><code>Binder</code> 用于不同进程之间通信，由一个进程的 <code>Binder</code> 客户端向另一个进程的服务端发送事务，比如图中线程 2 向线程 4 发送事务；而 <code>handler</code> 用于同一个进程中不同线程的通信，比如图中线程 4 向主线程发送消息。</p><p><strong>结合图说说 Activity 生命周期，比如暂停 Activity，流程如下：</strong></p><ol><li>线程 1 的 <code>AMS</code> 中调用线程 2 的 <code>ATP</code> ；（由于同一个进程的线程间资源共享，可以相互直接调用，但需要注意多线程并发问题）</li><li>线程 2 通过 <code>binder</code> 传输到 <code>App</code> 进程的线程 4；</li><li>线程 4 通过 <code>handler</code> 消息机制，将暂停 <code>Activity</code> 的消息发送给主线程；</li><li>主线程在 <code>looper.loop()</code> 中循环遍历消息，当收到暂停 <code>Activity</code> 的消息时，便将消息分发给 <code>ActivityThread.H.handleMessage()</code> 方法，再经过方法的调用，最后便会调用到 <code>Activity.onPause()</code> ，当 <code>onPause()</code> 处理完后，继续循环 <code>loop</code> 下去。</li></ol><p><a href="https://www.zhihu.com/question/34652589">原文</a></p><h1 id="可能问到的问题"><a href="#可能问到的问题" class="headerlink" title="可能问到的问题"></a>可能问到的问题</h1><ul><li><p><code>Handler</code> 机制和底层实现</p><ul><li>上文 二、三、四</li></ul></li><li><p><code>Handler</code>、<code>Thread</code> 和 <code>HandlerThread</code> 的差别</p><ul><li>上文 一、HandlerThread 源码分析</li><li><a href="https://blog.csdn.net/lmj623565791/article/details/47079737/">Android HandlerThread 完全解析</a> </li></ul></li><li><p><code>ThreadLocal</code> 原理，实现及如何保证 <code>Local</code> 属性？</p><ul><li>上文 2.2 ThreadLocal</li></ul></li><li><p>请解释下在单线程模型中 <code>Message</code> 、<code>Handler</code> 、<code>Message Queue</code> 、<code>Looper</code> 之间的关系</p><ul><li>上文 三、 Handler Java 层总结</li></ul></li><li><p>为什么不能在子线程更新 <code>UI</code>？(这个问题应该这样问更合理：为什么不能在非 <code>UI</code> 线程更新 <code>UI</code>)</p><ul><li><a href="https://zhuanlan.zhihu.com/p/142674015">做了三年安卓，我竟然不知道什么是 UI 线程</a> </li><li><a href="https://zhuanlan.zhihu.com/p/87332093">面试官：Android 子线程更新UI了解吗？</a></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无 Binder 不 Android</title>
      <link href="2020/android-framework-binder.html"/>
      <url>2020/android-framework-binder.html</url>
      
        <content type="html"><![CDATA[<h1 id="Binder-是什么？"><a href="#Binder-是什么？" class="headerlink" title="Binder 是什么？"></a>Binder 是什么？</h1><p><code>Binder</code> 是一种进程间通信机制，基于开源的 <a href="http://www.angryredplanet.com/~hackbod/openbinder/docs/html/BinderIPCMechanism.html">OpenBinder</a> 实现；<code>OpenBinder</code> 起初由 <code>Be Inc.</code> 开发，后由 <code>Plam Inc.</code> 接手，现在 <code>OpenBinder</code> 的作者在 <code>Google</code> 工作，这也为后来的 <code>Binder</code> 。从字面上来解释 <code>Binder</code> 有胶水、粘合剂的意思，顾名思义就是粘和不同的进程，使之实现通信。</p><h1 id="Binder-有那么重要吗"><a href="#Binder-有那么重要吗" class="headerlink" title="Binder 有那么重要吗 ?"></a>Binder 有那么重要吗 ?</h1><p>作为一个 <code>Android</code> 攻城狮，会不会有这也的疑惑？</p><ul><li>为什么 <code>Activity</code> 间传递对象需要序列化？</li><li><code>Activity</code> 的启动流程是什么样的？</li><li>四大组件底层的通信机制是怎样的？</li><li><code>AIDL</code> 内部的实现原理是什么？</li><li>插件化编程技术应该从何学起？</li></ul><p>这些都是因为 <code>Binder</code> 才让无数 <code>Android</code> 小伙伴疑惑重重，想要知道 <code>Android</code> 中血液是如何流动的，就必须正确认识 <code>Binder</code> 。</p><h1 id="为什么选中了-Binder-实现-IPC-机制？"><a href="#为什么选中了-Binder-实现-IPC-机制？" class="headerlink" title="为什么选中了 Binder 实现 IPC 机制？"></a>为什么选中了 Binder 实现 IPC 机制？</h1><p><code>Android</code> 内核是基于 <code>Linux</code> 系统, 而 <code>Linux</code> 现存多种进程间 <code>IPC(Inter-Process Communication)</code> 方式</p><ul><li><strong>管道：</strong>在创建时分配一个 page 大小的内存，管道是由内核管理的一个缓冲区，缓存区大小比较有限；</li><li><strong>消息队列：</strong>信息复制两次，额外的 CPU 消耗；不合适频繁或信息量大的通信；</li><li><strong>共享内存：</strong>无须复制，共享缓冲区直接付附加到进程虚拟地址空间，速度快；但进程间的同步问题操作系统无法实现，必须各进程利用同步工具解决；</li><li><strong>套接字：</strong>作为更通用的接口，传输效率低，主要用于不通机器或跨网络的通信；</li><li><strong>信号量：</strong>常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</li><li><strong>信号：</strong>不适用于信息交换，更适用于进程中断控制，比如非法内存访问，杀死某个进程等；</li></ul><p>为何不直接采用 <code>Linux</code> 现有的进程 <code>IPC</code> 方案呢，难道 <code>Linux</code> 社区那么多优秀人员都没有考虑到有 <code>Binder</code> 这样一个更优秀的方案，还是 <code>google</code> 太过于牛 <code>B</code> ？</p><p>这得从各个方面考虑到</p><ol><li><p><strong>性能角度（数据拷次数）：</strong> <code>Binder</code> 数据拷贝只需要一次，而管道、消息队列、<code>Socket</code> 都需要 <code>2</code> 次，但共享内存方式一次内存拷贝都不需要；从性能角度看，<code>Binder</code> 性能仅次于共享内存。</p></li><li><p><strong>稳定性：</strong> <code>Binder</code>是基于 <code>C/S</code> 架构的，<code>C/S</code> 架构，是指客户端 <code>(Client)</code> 和服务端 <code>(Server)</code> 组成的架构，<code>Client</code> 端有什么需求，直接发送给 <code>Server</code> 端去完成，架构清晰明朗，<code>Server</code> 端与 <code>Client</code> 端相对独立，稳定性较好；而共享内存实现方式复杂，没有客户与服务端之别， 需要充分考虑到访问临界资源的并发同步问题，否则可能会出现死锁等问题；从这稳定性角度看，<code>Binder</code> 架构优越于共享内存。</p></li><li><p><strong>安全性：</strong> <code>Android</code> 作为一个开放性的平台，市场上有各类海量的应用供用户选择安装，因此安全性对于 <code>Android</code> 平台而言极其重要。对于我们普通用户，绝不希望从 <code>App</code> 商店下载偷窥隐射数据、后台造成手机耗电等等问题，传统 <code>Linux IPC</code> 无任何保护措施，完全由上层协议来确保。</p><p>传统 <code>Linux IPC</code> 的接收方无法获得对方进程可靠的 <code>UID/PID</code> ，从而无法鉴别对方身份；而 <code>Android</code> 为每个安装好的应用程序分配了自己的 <code>UID</code> ，故进程的 <code>UID</code> 是鉴别进程身份的重要标志；传统 <code>IPC</code> 只能由用户在数据包里填入<code>UID/PID</code>；另外，可靠的身份标记只有由 <code>IPC</code> 机制本身在内核中添加。其次传统 <code>IPC</code> 访问接入点是开放的，无法建立私有通道。从安全角度，<code>Binder</code> 的安全性更高。</p><p>但是 <code>Android</code> 就算用了 <code>Binder</code> 架构，而现如今 <code>Android</code> 手机的各种流氓软件，不就是干着这种偷窥隐射，后台偷偷跑流量的事吗？没错，确实存在，但这不能说 <code>Binder</code> 的安全性不好，因为 <code>Android</code> 系统仍然是掌握主控权，可以控制这类 <code>App</code> 的流氓行为，只是对于该采用何种策略来控制，在这方面 <code>android</code> 的确存在很多有待进步的空间，这也是 <code>google</code> 以及各大手机厂商一直努力改善的地方之一。</p></li></ol><h1 id="Linux-传统-IPC-如何通信的？"><a href="#Linux-传统-IPC-如何通信的？" class="headerlink" title="Linux 传统 IPC 如何通信的？"></a>Linux 传统 IPC 如何通信的？</h1><p>了解 <code>Linux IPC</code> 相关的概念和原理有助于理解 <code>Binder</code> 通信原理。因此，在介绍 <code>Binder</code> 跨进程通信原理之前，先聊聊 <code>Liunx</code> 中的几个概念以及 <code>Linux</code> 系统下传统的进程间通信是如何实现。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/android/android_linux_ipc.jpg" alt="图片来源于《写给 Android 应用工程师的 Binder 原理剖析》"></p><p><strong>进程隔离</strong></p><p>操作系统中进程隔离指的是，进程与进程间内存是不共享的，也就是一个进程不能直接操作或者访问另一个进程，A 进程和 B 进程之间要进行数据交互就得采用特殊的通信机制：进程间通信（<code>IPC</code>）。</p><p><strong>进程空间划分：用户空间(User Space)/内核空间(Kernel Space)</strong></p><p>现在操作系统都是采用的虚拟存储器，对于 <code>32</code> 位系统而言，它的寻址空间（虚拟存储空间）就是 <code>2</code> 的 <code>32</code> 次方，也就是 <code>4GB</code>。</p><p>操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也可以访问底层硬件设备的权限。<code>Liunx</code>为了保护用户进程不能直接操作内核，保证内核的安全，操作系统从逻辑上将虚拟空间划分为用户空间和内核空间。针对 <code>Linux</code> 操作系统而言，将最高的 <code>1GB</code> 字节供内核使用，称为内核空间；较低的 <code>3GB</code> 字节供各进程使用，称为用户空间。</p><blockquote><p>内核空间（Kernel）是系统内核运行的空间，用户空间（User Space）是用户程序运行的空间。为了保证安全性，它们之间是隔离的。每个进程可以通过<strong>系统调用</strong>进入内核，因此，Linux 内核对系统内的所有进程共享。</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/android/android_linux_space.png" alt="图片来源于《用户空间与内核空间，进程上下文与中断上下文总结》"></p><p><strong>系统调用</strong></p><p>系统调用是用户空间访问内核空间的唯一方式，保证了所有的资源访问都是在内核的控制下进行的，避免了用户程序对系统资源的越权访问，提升了系统安全性和稳定性。</p><p>当一个任务（进程）执行系统调用而陷入内核代码中执行时，称进程处于<strong>内核运行态（内核态）</strong>。当进程在执行用户自己的代码的时候，我们称其处于<strong>用户运行态（用户态）</strong>。</p><p>系统调用主要通过如下两个函数来实现：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">copy_from_user() //将数据从用户空间拷贝到内核空间</span><br><span class="line">copy_to_user() //将数据从内核空间拷贝到用户空间</span><br></pre></td></tr></table></figure><h2 id="Linux-的-IPC-通信原理"><a href="#Linux-的-IPC-通信原理" class="headerlink" title="Linux 的 IPC 通信原理"></a>Linux 的 IPC 通信原理</h2><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/android/android_linux_ipc2.jpg" alt="图片来源于《写给 Android 应用工程师的 Binder 原理剖析》"></p><ol><li>消息发送方将要发送的数据存放在内存缓存区中，通过系统调用进入内核态。</li><li>然后内核程序在内核空间分配内存，开辟一块内核缓存区，调用 <code>copy_from_user()</code> 函数将数据从用户空间的内存缓存区拷贝到内核空间的内核缓存区中。</li><li>接收方进程在接收数据时在自己的用户空间开辟一块内存缓存区，然后内核程序调用 <code>copy_to_user()</code> 函数将数据从内核缓存区拷贝到接收进程的内存缓存区。这样数据发送方进程和数据接收方进程就完成了一次数据传输，我们称完成了一次进程间通信。</li></ol><p><code>Linux</code> 的 <code>IPC</code> 通信原理有两个问题：</p><ul><li>一次数据传递需要经历：用户空间 –&gt; 内核缓存区 –&gt; 用户空间，需要 2 次数据拷贝，这样效率不高。</li><li>接收数据的缓存区由数据接收进程提供，但是接收进程并不知道需要多大的空间来存放将要传递过来的数据，因此只能开辟尽可能大的内存空间或者先调用API接收消息头来获取消息体的大小，浪费了空间或者时间。</li></ul><h1 id="Binder-IPC-如何通信的？"><a href="#Binder-IPC-如何通信的？" class="headerlink" title="Binder IPC 如何通信的？"></a>Binder IPC 如何通信的？</h1><p>跨进程通信是需要<strong>内核空间</strong>做支持的。传统的 <code>IPC</code> 机制如管道、<code>Socket</code> 都是内核的一部分，因此通过内核支持来实现进程间通信自然是没问题的。但是 <code>Binder</code> 并不是 <code>Linux</code> 系统内核的一部分，那怎么办呢？</p><p>这就得益于 <code>Linux</code> 的<strong>动态内核可加载模块</strong>（<code>Loadable Kernel Module，LKM</code>）的机制；</p><ul><li>模块是具有独立功能的程序，它可以被单独编译，但是不能独立运行。</li><li>它在运行时被链接到内核作为内核的一部分运行。</li></ul><p>这样，<code>Android</code> 系统就可以通过动态添加一个内核模块运行在内核空间，用户进程之间通过这个内核模块作为桥梁来实现通信。（在 <code>Android</code> 系统中，这个运行在内核空间，负责各个用户进程通过 <code>Binder</code> 实现通信的内核模块就叫 <strong>Binder 驱动</strong>（<code>Binder Dirver</code>）。）</p><p><strong>那 <code>Binder</code> 是如何做到减少数据拷贝的呢？</strong></p><p>这就得说一下 <code>Linux</code> 下的另一个概念：<strong>内存映射</strong>。</p><p><code>Binder IPC</code> 机制中涉及到的内存映射通过 <code>mmap()</code> 来实现，<code>mmap()</code> 是操作系统中一种内存映射的方法，通常是用在有物理介质的文件系统上的。</p><p>比如进程中的用户区域是不能直接和物理设备打交道的，如果想要把磁盘上的数据读取到进程的用户区域，需要两次拷贝（<code>磁盘--&gt;内核空间--&gt;用户空间</code>）；</p><p>通常在这种场景下 <code>mmap()</code> 就能发挥作用，通过在物理介质和用户空间之间建立映射，用户对这块内存区域的修改可以直接反应到内核空间；反之内核空间对这段区域的修改也能直接反应到用户空间。这样就可以减少数据拷贝次数，用内存读写取代 <code>I/O</code> 读写，提高文件读取效率，实现用户空间和内核空间的高效互动。</p><p>两个空间各自的修改能直接反映在映射的内存区域，从而被对方空间及时感知。也正因为如此，内存映射能够提供对进程间通信的支持。</p><p><strong>但是 <code>Binder</code> 并不存在物理介质！</strong></p><p>因此 <code>Binder</code> 驱动使用 <code>mmap()</code> 并不是为了在物理介质和用户空间之间建立映射，而是用来在内核空间创建<strong>数据接收的缓存空间</strong>。</p><ol><li>这样 <code>Binder</code> 驱动在内核空间创建一个数据接收缓存区；</li><li>接着在内核空间开辟一块内核缓存区，建立<strong>内核缓存区</strong>和<strong>内核中数据接收缓存区</strong>之间的映射关系，以及<strong>内核中数据接收缓存区</strong>和<strong>接收进程用户空间地址</strong>的映射关系；</li><li>发送方进程通过系统方法将数据 <code>copy</code> 到内核中的<strong>内核缓存区</strong>，由于内核缓存区和接收进程的用户空间存在内存映射，因此也就相当于把数据发送到了接收进程的用户空间，这样便完成了一次进程间的通信。</li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/android/android_binder_mmap.jpg" alt="图片来源于《写给 Android 应用工程师的 Binder 原理剖析》"></p><blockquote><p><strong>深入了解</strong></p><ul><li><strong>Binder 设备的初始化过程</strong></li></ul><p><code>Binder</code> 设备的初始化过程是在<code>Binder</code> 驱动程序的初始化函数 <code>binder_init</code> 中进行的。</p><p>它首先在目标设备上创建了一个 <code>/proc/binder/proc</code> 目录，每一个使用了 <code>Binder</code> 进程间通信机制的进程在该目录下都对应有一个文件，这些文件是以进程 <code>ID</code> 来命名的，通过它们就可以读取到各个进程的 <code>Binder</code> 线程池、<code>Binder</code> 实体对象、<code>Binder</code> 引用对象以及内核缓冲区等信息。然后调用函数 <code>misc_register</code> 来创建一个 <code>Binder</code> 设备，最后 <code>Binder</code> 驱动程序在目标设备上创建了一个 <code>Binder</code> 设备文件 <code>/dev/binder</code>，这个设备文件的操作方法列表是由全局变量 <code>binder_fops</code> 指定的。</p><p>全局变量 <code>binder_fops</code> 为 <code>Binder</code> 设备文件 <code>/dev/binder</code> 指定文件打开 (<code>binder_open</code>)，映射(<code>binder_mmap</code>)，数据操作(<code>binder_ioctl</code>)</p><ul><li><strong>binder_open 打开过程</strong></li></ul><p>一个进程在使用 <code>Binder</code> 进程间通信机制之前，首先要调用函数 <code>open</code> 打开设备文件 <code>/dev/binder</code> 来获得一个文件描述符，然后才能通过这个文件描述符来和 <code>Binder</code> 驱动程序交互，继而和其他进程执行 <code>Binder</code> 进程间通信。</p><p>当进程调用函数 <code>open</code> 打开设备文件 <code>/dev/binder</code> 时，<code>Binder</code> 驱动程序中的函数 <code>binder_open</code> 就会被调用，它会为进程创建一个 <code>binder_proc</code> 结构体 <code>proc</code>，并把它加入到一个全局 <code>hash</code> 队列 <code>binder_procs</code> 中。<code>Binder</code> 驱动程序将所有打开了设备文件 <code>dev/binder</code> 的进程都加入到全局 <code>hash</code> 队列 <code>binder_procs</code> 中。最后会在目标设备上的 <code>/proc/binder/proc</code> 目录下创建一个以进程 <code>ID</code> 为名称的只读文件，通过读取这个文件就可以获得进程 <code>PID</code> 的 <code>Binder</code> 线程池、<code>Binder</code> 实体对象、<code>Binder</code> 引用对象以及内核缓冲区等信息。</p><ul><li><strong>内存映射过程</strong></li></ul><p>进程打开了设备文件 <code>/dev/binder</code> 之后，还必须要调用函数 <code>mmap</code> 把这个设备文件映射到进程的地址空间，然后才可以使用 <code>Binder</code> 进程间通信机制。设备文件 <code>/dev/binder</code> 对应的是一个虚拟设备，将它映射到进程的地址空间的目的并不是对它的内容感兴趣，而是为了为进程分配内核缓冲区，以便它可以用来传输进程间通信数据。</p><p>当进程调用函数 <code>mmap</code> 将设备文件 <code>/dev/binder</code> 映射到自己的地址空间时，<code>Binder</code> 驱动程序中的函数 <code>binder_mmap</code> 就会被调用。</p><p><code>Binder</code> 驱动程序最多可以为进程分配 <code>4M</code> 内核缓冲区来传输进程间通信数据。<code>Binder</code> 驱动程序为进程分配的内核缓冲区在用户空间只可以读，而不可以写。</p><p><code>Binder</code> 驱动程序为进程分配的内核缓冲区有两个地址，其中一个是用户空间地址，另一个是内核空间地址。进程通过用户空间地址来访问这块内核缓冲区的内容，而 <code>Binder</code> 驱动程序通过内核空间地址来访问这块内核缓冲区的内容。由于它们是连续的，并且起始地址相差一个固定值，因此，只要知道其中的一个地址，就可以方便的计算出另外一个地址。</p><p><code>Binder</code> 驱动程序为进程分配的内核缓冲区即为一系列物理页面，它们分别被映射到进程的用户地址空间和内核地址空间。当 <code>Binder</code> 驱动程序需要将一块数据传输给一个进程时，它就可以先把这块数据保存在为该进程所分配的一块内核缓冲区中，然后再把这块内核缓冲区的用户空间地址告诉进程，最后进程就可以访问到里面的数据了。这样做的好处便是不需要将数据从内核空间复制到用户空间，从而提高了数据的传输效率。</p></blockquote><p>了解了 <code>Binder IPC</code> 的底层通信原理，再看看实现层面 <code>Binder</code> 架构是如何设计的。</p><h2 id="Binder-通信模型"><a href="#Binder-通信模型" class="headerlink" title="Binder 通信模型"></a>Binder 通信模型</h2><p>一次完整的进程间通信必然至少包含两个进程，通常我们称通信的双方分别为客户端进程 <code>（Client）</code> 和服务端进程 <code>（Server）</code> ，由于进程隔离机制的存在，通信双方必然需要借助 <code>Binder</code> 来实现。</p><p>从组件视角来说，<code>Binder</code> 包含 <code>Client</code> 、<code>Server</code>、<code>ServiceManager</code> 以及 <code>binder驱动</code> ，其中<code>ServiceManager</code> 用于管理系统中的各种服务</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/android/android_binder_ipc.jpg" alt="图片来源于《彻底理解 Android Binder 通信架构》"></p><p>其中 <code>Client(AMP)</code>、<code>Server(AMS)</code>、<code>Service Manager</code> 运行在用户空间，它们之间交互都是虚线表示，是由于它们彼此之间不是直接交互的，而是都通过与<code>Binder Driver</code> 进行交互的，<code>Binder</code> 驱动运行在内核空间。其中 <code>Service Manager</code> 和 <code>Binder</code> 驱动由系统提供是 <code>Android</code> 平台的基础架构，而 <code>Client</code>、<code>Server</code> 由应用程序来实现。<code>Client</code>、<code>Server</code> 和 <code>ServiceManager</code> 均是通过系统调用 <code>open</code>、<code>mmap</code> 和 <code>ioctl</code> 来访问设备文件 <code>/dev/binder</code>，从而实现与 <code>Binder</code> 驱动的交互来间接的实现跨进程通信。<code>( 此处的 Service Manager 是指 Native 层的 ServiceManager(C++)，并非指 framework 层的 ServiceManager(Java) )</code></p><p><code>Client</code>、<code>Server</code>、<code>ServiceManager</code>、<code>Binder</code> 驱动这几个组件在通信过程中扮演的角色就如同 互联网中服务器 <code>(Server)</code>、客户端 <code>(Client)</code> 、<code>DNS</code> 域名服务器 <code>(ServiceManager)</code> 以及路由器 (<code>Binder</code> 驱动) 之前的关系。</p><p>通常我们访问一个网页的步骤是这样的：首先在浏览器输入一个地址，如 <a href="https://link.zhihu.com/?target=http%3A//www.google.com">google.com</a> 然后按下回车键。但是并没有办法通过域名地址直接找到我们要访问的服务器，因此需要首先访问 <code>DNS</code> 域名服务器，域名服务器中保存了 <a href="https://link.zhihu.com/?target=http%3A//www.google.com">google.com</a> 对应的 <code>ip</code> 地址 <code>10.249.23.13</code>，然后通过这个 <code>ip</code> 地址才能访问到 <a href="https://link.zhihu.com/?target=http%3A//www.google.com">google.com</a> 对应的服务器。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/android/android_binder_ipc2.png" alt="图片来源于《写给 Android 应用工程师的 Binder 原理剖析》"></p><ul><li><p><strong>Binder 驱动</strong></p><p><code>Binder</code> 驱动就如同路由器一样，是整个通信的核心；驱动负责进程之间 <code>Binder</code> 通信的建立，<code>Binder</code> 在进程之间的传递，<code>Binder</code> 引用计数管理，数据包在进程之间的传递和交互等一系列底层支持。</p></li><li><p><strong>ServiceManager</strong></p><p><code>ServiceManager</code> 和 <code>DNS</code> 类似，作用是将字符形式的 <code>Binder</code> 名字转化成 <code>Client</code> 中对该 <code>Binder</code> 的引用，使得 <code>Client</code> 能够通过 <code>Binder</code> 的名字获得对 <code>Binder</code> 实体的引用。</p><ul><li><p><strong>实名 Binder</strong></p><p>注册了名字的 <code>Binder</code> 叫实名 <code>Binder</code>，就像网站一样除了除了有 <code>IP</code> 地址以外还有自己的网址。</p></li></ul></li></ul><p><strong>如何注册服务？</strong></p><p><code>Server</code> 创建了 <code>Binder</code>，并为它起一个字符形式，可读易记的名字，将这个 <code>Binder</code> 实体连同名字一起，以数据包的形式通过 <code>Binder</code> 驱动发送给 <code>ServiceManager</code> ，通知 <code>ServiceManager</code> 注册一个名为 <code>“xx”</code> 的 <code>Binder</code>，它位于某个 <code>Server</code> 中。驱动为这个穿越进程边界的 <code>Binder</code> ，创建位于内核中的实体节点，以及 <code>ServiceManager</code> 对实体的引用，将名字以及新建的引用打包传给 <code>ServiceManager</code>。</p><p><strong>但是！这里有个问题！</strong> <code>ServierManager</code> 是一个进程，<code>Server</code> 是另一个进程，<code>Server</code> 向 <code>ServiceManager</code> 中注册 <code>Binder</code> 必然涉及到进程间通信。<strong>我们在实现进程间通信的时候需要先用到进程间通信</strong>，这… 这就好像蛋可以孵出鸡的前提却是要先找只鸡下蛋！</p><p><strong>解决方法</strong>，<code>Binder</code> 的实现比较巧妙，就是<strong>预先创造一只鸡来下蛋</strong>。<code>ServiceManager</code> 和其他进程同样采用 <code>Bidner</code> 通信，<code>ServiceManager</code> 是 <code>Server</code> 端，有自己的 <code>Binder</code> 实体，其他进程都是 <code>Client</code>，需要通过这个 <code>Binder</code> 的引用来实现 <code>Binder</code> 的注册，查询和获取。</p><p><code>ServiceManger</code> 收到数据后从中 取出名字和引用 填入查找表。</p><p><code>ServiceManager</code> 提供的 <code>Binder</code> 比较特殊，它没有名字也不需要注册。当一个进程使用 <code>BINDER_SET_CONTEXT_MGR</code> 命令将自己注册成 <code>ServiceManager</code> 时，<code>Binder</code> 驱动会自动为它创建 <code>Binder</code> 实体（<strong>这就是那只预先造好的那只鸡</strong>）。这个 <code>Binder</code> 实体的引用在所有 <code>Client</code> 中都固定为 <code>0</code>， 无需通过其它手段获得。</p><p>也就是说，一个 <code>Server</code> 想要向 <code>ServiceManager</code> 注册自己的 <code>Binder</code> 就必须通过这个 <code>0</code> 号引用和 <code>ServiceManager</code> 的 <code>Binder</code> 通信。类比互联网，<code>0</code> 号引用就好比是域名服务器的地址，你必须预先动态或者手工配置好。还有需要注意的是，这里说的 <code>Client</code> 是相对于 <code>ServiceManager</code> 而言的，一个进程或者应用程序可能是提供服务的 <code>Server</code>，但对于 <code>ServiceManager</code> 来说它仍然是个 <code>Client</code>。</p><p><strong>怎么获取服务？</strong></p><p><code>Server</code> 向 <code>ServiceManager</code> 中注册了 <code>Binder</code> 以后，<code>Client</code> 就能通过名字获得 <code>Binder</code> 的引用了。<code>Client</code> 也利用保留的 <code>0</code> 号引用向 <code>ServiceManager</code> 请求访问某个 <code>Binder</code> 我申请访问名字叫 <code>“xx”</code> 的 <code>Binder</code> 引用。</p><p><code>ServiceManager</code> 收到这个请求后从请求数据包中取出 <code>Binder</code> 名称，在查找表里找到对应的条目，取出对应的 Binder 引用作为回复发送给发起请求的 <code>Client</code>。</p><p>从面向对象的角度看，<code>Server</code> 中的 <code>Binder</code> 实体现在有两个引用：一个位于 <code>ServiceManager</code> 中，一个位于发起请求的 <code>Client</code> 中。如果接下来有更多的 <code>Client</code> 请求该 <code>Binder</code>，系统中就会有更多的引用指向该 <code>Binder</code> ，就像 <code>Java</code> 中一个对象有多个引用一样。</p><h2 id="Binder-通信过程"><a href="#Binder-通信过程" class="headerlink" title="Binder 通信过程"></a>Binder 通信过程</h2><ol><li>首先，一个进程使用 <code>BINDER_SET_CONTEXT_MGR</code> 命令通过 <code>Binder</code> 驱动将自己注册成为 <code>ServiceManager</code>；</li><li><code>Server</code> 通过驱动向 <code>ServiceManager</code> 中注册 <code>Binder</code>（<code>Server</code> 中的 <code>Binder</code> 实体），表明可以对外提供服务。驱动为这个 <code>Binder</code> 创建位于内核中的实体节点，以及 <code>ServiceManager</code> 对实体的引用，将名字以及新建的引用打包传给 <code>ServiceManager</code>，<code>ServiceManger</code> 将其填入查找表。</li><li><code>Client</code> 通过名字，在 <code>Binder</code> 驱动的帮助下从 <code>ServiceManager</code> 中获取到对 <code>Binder</code> 实体的引用，通过这个引用就能实现和 <code>Server</code> 进程的通信。</li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/android/android_binder_ipc3.jpg" alt="图片来源于《写给 Android 应用工程师的 Binder 原理剖析》"></p><h2 id="Binder-通信中的代理模式"><a href="#Binder-通信中的代理模式" class="headerlink" title="Binder 通信中的代理模式"></a>Binder 通信中的代理模式</h2><p>我们已经解释清楚 <code>Client</code>、<code>Server</code> 借助 <code>Binder</code> 驱动完成跨进程通信的实现机制了，但是还有个问题会让我们困惑。</p><p><code>A</code> 进程想要 <code>B</code> 进程中某个对象（<code>object</code>）是如何实现的呢？毕竟它们分属不同的进程，<code>A</code> 进程 没法直接使用 <code>B</code> 进程中的 <code>object</code>。</p><p><strong>一次通信过程简述</strong></p><p>跨进程通信的过程都有 <code>Binder</code> 驱动的参与，因此在数据流经 <code>Binder</code> 驱动的时候驱动会对数据做一层转换。</p><p>当 <code>A</code> 进程想要获取 <code>B</code> 进程中的 <code>object</code> 时，驱动并不会真的把 <code>object</code> 返回给 <code>A</code>，而是返回了一个跟 <code>object</code> 看起来一模一样的代理对象 <code>objectProxy</code>，这个 <code>objectProxy</code> 具有和 <code>object</code> 一摸一样的方法，但是这些方法并没有 <code>B</code> 进程中 <code>object</code> 对象那些方法的能力，这些方法只需要把请求参数交给驱动即可。对于 <code>A</code> 进程来说和直接调用 <code>object</code> 中的方法是一样的。</p><p>当 <code>Binder</code> 驱动接收到 <code>A</code> 进程的消息后，发现这是个 <code>objectProxy</code> 就去查询自己维护的表单，一查发现这是 <code>B</code> 进程 <code>object</code> 的代理对象。于是就会去通知 <code>B</code> 进程调用 <code>object</code> 的方法，并要求 <code>B</code> 进程把返回结果发给自己。当驱动拿到 <code>B</code> 进程的返回结果后就会转发给 <code>A</code> 进程，一次通信就完成了。</p><p><strong><code>Binder</code> 中的具体调用如下：</strong></p><p>在 <code>Client</code> 进程和 <code>Server</code> 进程的一次通信过程中，涉及了四种类型的对象，它们分别是</p><ul><li>位于 <code>Binder</code> 驱动程序中的 <code>Binder</code> 实体对象 <code>（binder_node）</code> 和 <code>Binder</code> 引用对象 <code>（binder_ref）</code> </li><li>位于 <code>Binder</code> 库中的 <code>Binder</code> 本地对象 <code>（BBinder）</code> 和 <code>Binder</code> 代理对象 <code>（BpBinder）</code> </li></ul><p>它们的交互过程如下：</p><ol><li>运行在 <code>Client</code> 进程中的 <code>Binder</code> <strong>代理对象</strong>通过 <code>Binder</code> 驱动程序向运行在 <code>Server</code> 进程中的 <code>Binder</code> <strong>本地对象</strong>发出一个进程间通信请求，<code>Binder</code> 驱动程序接着就根据 <code>Client</code> 进程传递过来的 <code>Binder</code> <strong>代理对象</strong>的句柄值来找到对应的 <code>Binder</code> <strong>引用对象</strong>。</li><li><code>Binder</code> 驱动程序根据前面找到的 <code>Binder</code> <strong>引用对象</strong>找到对应的 <code>Binder</code> <strong>实体对象</strong>，并且创建一个事务 <code>（binder_transaction）</code> 来描述该次进程间通信过程。</li><li><code>Binder</code> 驱动程序根据前面找到的 <code>Binder</code> <strong>实体对象</strong>来找到运行在 <code>Server</code> 进程中的 <code>Binder</code> <strong>本地对象</strong>，并且将 <code>Client</code> 进程传递过来的通信数据发送给它处理。</li><li><code>Binder</code> <strong>本地对象</strong>处理完成 <code>Client</code> 进程的通信请求之后，就将通信结果返回给 <code>Binder</code> 驱动程序，<code>Binder</code> 驱动程序接着就找到前面所创建的一个事务。</li><li><code>Binder</code> 驱动程序根据前面找到的事务的相关属性来找到发出通信请求的 <code>Client</code> 进程，并且通知 <code>Client</code> 进程将通信结果返回给对应的 <code>Binder</code> <strong>代理对象</strong>处理。</li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/android/android_binder_ipc4.jpg" alt="图片来源于《写给 Android 应用工程师的 Binder 原理剖析》"></p><p>从这个过程就可以看出，<code>Binder</code> 代理对象依赖于 <code>Binder</code> 引用对象，而 <code>Binder</code> 引用对象又依赖于 <code>Binder</code> 实体对象，最后，<code>Binder</code> 实体对象又依赖于 <code>Binder</code> 本地对象。这样，<code>Binder</code> 进程间通信机制就必须采用一种技术措施来保证，不能销毁一个还被其他对象依赖着的对象。为了维护这些 <code>Binder</code> 对象的依赖关系，<code>Binder</code> 进程间通信机制采用了<strong>引用计数</strong>来维护每一个 <code>Binder</code> 对象的生命周期。</p><blockquote><p><strong>深入了解</strong></p><ul><li><strong>Binder 本地对象的生命周期</strong></li></ul><p><code>Binder</code> 本地对象是一个类型为 <code>BBinder</code> 的对象，它是在用户空间中创建的，并且运行在 <code>Server</code> 进程中。</p><p><code>Binder</code> 本地对象一方面会被运行在 <code>Server</code> 进程中的其他对象引用，另一方面也会被 <code>Binder</code> 驱动程序中的 <code>Binder</code> 实体对象引用。</p><p>由于 <code>BBinder</code> 类继承了 <code>RefBase</code> 类，因此，<code>Server</code> 进程中的其他对象可以简单的通过智能指针来引用这些 <code>Binder</code> 本地对象，以便可以控制它们的生命周期。</p><p>由于 <code>Binder</code> 驱动程序中的 <code>Binder</code> 实体对象是运行在内核空间的，它不能够通过智能指针来引用运行在用户空间的 <code>Binder</code> 本地对象，因此，<code>Binder</code> 驱动程序就需要和 <code>Server</code> 进程约定一套规则来维护它们的引用计数，避免它们在还被 <code>Binder</code> 实体对象引用的情况下销毁。</p><p><strong>如何保证本地对象在 <code>Binder</code> 实体对象引用的情况下不被销毁？</strong></p><p><code>Server</code> 进程将一个 <code>Binder</code> 本地对象注册到 <code>ServerManager</code> 时，<code>Binder</code> 驱动程序就会为它创建一个 <code>Binder</code> 实体对象。接下来，当 <code>Client</code> 进程通过 <code>ServerManager</code> 来查询一个 <code>Binder</code> 本地对象的代理对象接口时，<code>Binder</code> 驱动程序就会为它所对应的 <code>Binder</code> 实体对象创建一个 <code>Binder</code> 引用对象，接着在使用 <code>BR_INCREFS</code> 和 <code>BR_ACQUIRE</code> 协议来通知对应的 <code>Server</code> 进程增加对应的 <code>Binder</code> 本地对象的弱引用技术和强引用技术。这样就能保证 <code>Client</code> 进程中的 <code>Binder</code> 代理对象在引用一个 <code>Binder</code> 本地对象期间，该 <code>Binder</code> 本地对象不会被销毁。当没有任何 <code>Binder</code> 代理对象引用一个 <code>Binder</code> 本地对象时，<code>Binder</code> 驱动程序就会使用 <code>BR_DECREFS</code> 和 <code>BR_RELEASE</code> 协议来通知对应的 <code>Server</code> 进程减少对应的 <code>Binder</code> 本地对象的弱引用技术和强引用技术。</p><p>总结来说，<code>Binder</code> 驱动程序就是通过 <code>BR_INCREFS</code>、<code>BR_ACQUIRE</code>、<code>BR_DECREFS</code> 和 <code>BR_RELEASE</code> 协议来引用运行在 <code>Server</code> 进程中的 <code>Binder</code> 本地对象的，相关的代码实现在函数 <code>binder_thread_read</code> 中。</p><ul><li><strong>Binder 实体对象的生命周期</strong></li></ul><p><code>Binder</code> 实体对象是一个类型为 <code>binder_node</code> 的对象，它是在 <code>Binder</code> 驱动程序中创建的，并且被 <code>Binder</code> 驱动程序中的 <code>Binder</code> 引用对象所引用。</p><p>当 <code>Client</code> 进程第一次引用一个 <code>Binder</code> 实体对象时，<code>Binder</code> 驱动程序就会在内部为它创建一个 <code>Binder</code> 引用对象。例如，当 <code>Client</code> 进程通过 <code>ServerManager</code> 来获得一个 <code>Service</code> 组件的代理对象接口时，<code>Binder</code> 驱动程序就会找到与该 <code>Service</code> 组件对应的 <code>Binder</code> 实体对象，接着再创建一个 <code>Binder</code> 引用对象来引用它。这时候就需要增加被引用的 <code>Binder</code> 实体对象的引用计数。相应地，当 <code>Client</code> 进程不再引用一个 <code>Service</code> 组件时，它也会请求 <code>Binder</code> 驱动程序释放之前为它所创建的 <code>Binder</code> 引用对象。这时候就需要减少该 <code>Binder</code> 引用对象所引用的 <code>Binder</code>实体对象的引用计数。</p><ul><li><strong>Binder 引用对象的生命周期</strong></li></ul><p><code>Binder</code> 引用对象是一个类型为 <code>binder_ref</code> 的对象，它是在 <code>Binder</code> 驱动程序中创建的，并且被用户空间中的 <code>Binder</code> 代理对象所引用。</p><p>当 <code>Client</code> 进程引用了 <code>Server</code> 进程中的一个 <code>Binder</code> 本地对象时，<code>Binder</code> 驱动程序就会在内部为它创建一个 <code>Binder</code> 引用对象。由于 <code>Binder</code> 引用对象是运行在内核空间的，而引用了它的 <code>Binder</code> 代理对象是运行在用户空间的，因此，<code>Client</code> 进程和 <code>Binder</code> 驱动程序就需要约定一套规则来维护 <code>Binder</code> 引用对象的引用计数，避免它们在还被 <code>Binder</code> 代理对象引用的情况下被销毁。</p><p>这套规则可以划分为 <code>BC_ACQUIRE</code>、<code>BC_INCREFS</code>、<code>BC_RELEASE</code> 和 <code>BC_DECREFS</code> 四个协议，分别用来增加和减少一个 <code>Binder</code> 引用对象的强引用技术和弱引用技术。相关的代码实现在 <code>Binder</code> 驱动程序的函数<code>binder_thread_write</code> 中。</p><ul><li><strong>Binder 代理对象的生命周期</strong></li></ul><p><code>Binder</code> 代理对象是一个类型为 <code>BpBinder</code> 的对象，它是在用户空间中创建的，并且运行在 <code>Client</code> 进程中。</p><p>与 <code>Binder</code> 本地对象类似，<code>Binder</code> 代理对象一方面会被运行在 <code>Client</code> 进程中的其他对象引用，另一方面它也会引用 <code>Binder</code> 驱动程序中的 <code>Binder</code> 引用对象。</p><p>由于 <code>BpBinder</code> 类继承了 <code>RefBase</code> 类，因此，<code>Client</code> 进程中的其他对象可以简单地通过智能指针来引用这些 <code>Binder</code> 代理对象，以便可以控制它们的生命周期。</p><p>由于 <code>Binder</code> 驱动程序中的 <code>Binder</code> 引用对象是运行在内核空间的，<code>Binder</code> 代理对象就不能通过智能指针来引用它们，因此，<code>Client</code> 进程就需要通过 <code>BC_ACQUIRE</code>、<code>BC_INCREFS</code>、<code>BC_RELEASE</code> 和 <code>BC_DECREFS</code> 四个协议来引用 <code>Binder</code> 驱动程序中的 <code>Binder</code> 引用对象。</p><p>前面提到，每一个 <code>Binder</code> 代理对象都是通过一个句柄值来和一个 <code>Binder</code> 引用对象关联的，而 <code>Client</code> 进程就是通过这个句柄值来维护运行在它里面的 <code>Binder</code> 代理对象的。具体来说，就是 <code>Client</code> 进程会在内部创建一个 <code>handle_entry</code> 类型的 <code>Binder</code> 代理对象列表，它以句柄值作为关键字来维护它内部所有的 <code>Binder</code> 代理对象。</p><ul><li><strong>智能指针</strong></li></ul><p>智能指针是一种能够自动维护对象引用计数的技术，它是一个对象而不是一个指针，但是它引用了一个实际使用的对象。正是因为它是一个对象，因此它能够自动地维护实际对象的引用计数。简单来说，就是在智能指针构造时，增加它所引用的对象的引用计数；而在智能指针析构时，就减少它所引用的对象的引用计数。由于智能指针的构造和析构都是自动的，因此，它就很自然的实现了自动的对象引用计数技术。</p><p>但是这样并不能解决对象的相互引用问题，于是就需要采取一种稍微复杂的引用计数技术来维护对象的生周期了，这种引用计数技术将对象的引用计数分为强引用计数和弱引用计数两种，其中，对象的生命周期只受强引用计数控制。</p><p><code>Android</code> 系统提供了三种类型的 <code>C++</code> 智能指针，分别为轻量级指针（<code>Light Pointer</code>）、强指针（<code>Strong Pointer</code>）和弱指针（<code>Weak Pointer</code>）。</p></blockquote><h2 id="Binder-的完整定义"><a href="#Binder-的完整定义" class="headerlink" title="Binder 的完整定义"></a>Binder 的完整定义</h2><ul><li>从进程间通信的角度看，<code>Binder</code> 是一种进程间通信的机制；</li><li>从 <code>Server</code> 进程的角度看，<code>Binder</code> 指的是 <code>Server</code> 中的 <code>Binder</code> 实体对象；</li><li>从 <code>Client</code> 进程的角度看，<code>Binder</code> 指的是对 <code>Binder</code> 代理对象，是 <code>Binder</code> 实体对象的一个远程代理</li><li>从传输过程的角度看，<code>Binder</code> 是一个可以跨进程传输的对象；<code>Binder</code> 驱动会对这个跨越进程边界的对象对一点点特殊处理，自动完成代理对象和本地对象之间的转换。</li></ul><p><strong>简单 Demo</strong></p><p><a href="https://github.com/CalmCenter/HelloBinder">HelloBinder</a></p><h1 id="感谢：本文收集整理自如下文章"><a href="#感谢：本文收集整理自如下文章" class="headerlink" title="感谢：本文收集整理自如下文章"></a><strong>感谢：本文收集整理自如下文章</strong></h1><p><a href="https://zhuanlan.zhihu.com/p/35519585">写给 Android 应用工程师的 Binder 原理剖析</a></p><p><a href="https://www.zhihu.com/question/39440766/answer/89210950">为什么 Android 要采用 Binder 作为 IPC 机制？</a></p><p><a href="https://github.com/Omooo/Android-Notes/blob/master/blogs/Android/Framework/源代码情景分析">Binder 对象引用计数技术</a></p><p><a href="https://github.com/Omooo/Android-Notes/blob/master/blogs/Android/Framework/源代码情景分析">Binder 设备文件的初始化、打开和内存映射过程</a></p><p><a href="https://juejin.cn/post/6844903976819752968#comment">Android Binder原理（一）学习Binder前必须要了解的知识点</a></p><p><a href="http://gityuan.com/2016/09/04/binder-start-service/">彻底理解Android Binder通信架构</a></p><p><a href="http://gityuan.com/2015/10/31/binder-prepare/">Binder系列</a></p><h1 id="可能问到的问题"><a href="#可能问到的问题" class="headerlink" title="可能问到的问题"></a>可能问到的问题</h1><ul><li>进程间通信的方式？<ul><li>多进程间的通信 <code>IPC(InterProcess Communication)</code><ul><li>AIDL<code>（Android Interface Definition Language，Android接口定义语言）</code>：适合于多进程多线程，需要开发者自己实现线程安全.</li><li>Messenger ：基于消息的进程间通信的方式，适合于多进程单线程</li></ul></li><li><a href="https://www.jianshu.com/p/ce1e35c84134">Android开发高级进阶——多进程间通信</a></li><li><a href="https://blog.csdn.net/hello_json/article/details/79815320"> Messenger 和 AIDL 的区别</a></li></ul></li><li>Binder机制的作用和原理？<ul><li>上文 Binder IPC 如何通信？</li></ul></li><li>简述IPC？</li><li>什么是AIDL？如何使用？<ul><li><code>AIDL(Android Interface Define Language)</code> 是 <code>IPC</code> 进程间通信方式的一种，用于生成可以在 <code>Android</code> 设备上两个进程之间进行进程间通信<code>(interprocess communication, IPC)</code> 的代码.</li><li><a href="https://www.jianshu.com/p/a5c73da2e9be">AIDL使用解析</a></li><li><a href="https://www.jianshu.com/p/d1fac6ccee98">Android中AIDL的使用详解</a></li></ul></li><li>AIDL解决了什么问题？<ul><li><code>官方文档：Note: Using AIDL is necessary only if you allow clients from different applications to access your service for IPC and want to handle multithreading in your service. If you do not need to perform concurrent IPC across different applications, you should create your interface by implementing a Binder or, if you want to perform IPC, but do not need to handle multithreading, implement your interface using a Messenger. Regardless, be sure that you understand Bound Services before implementing an AIDL.“只有当你允许来自不同的客户端访问你的服务并且需要处理多线程问题时你才必须使用AIDL”</code></li></ul></li><li>Android 进程分类？<ul><li><a href="https://blog.csdn.net/zhongshujunqia/article/details/72458271">Android-四种进程类型</a></li></ul></li><li>谈谈对进程共享和线程安全的认识?<ul><li><a href="https://blog.csdn.net/oweixiao123/article/details/9057445">android的线程安全</a></li><li><a href="https://www.cnblogs.com/android-blogs/p/5816922.html">Android开发中多进程共享数据</a></li><li><a href="https://blog.csdn.net/coding_glacier/article/details/8230159">Android中UID机制和共享进程</a></li><li>问你线程安全的时候，不止要回答主线程跟子线程之间的切换，还有数据结构处理的线程安全问题，多线程操作同一个数据的一致性问题，等等。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 11 Activity 启动分析</title>
      <link href="2020/android-framework-activity.html"/>
      <url>2020/android-framework-activity.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文由文末多篇文章引导综合而成  源码更新于 <a href="https://cs.android.com/">AndroidCodeSearch</a> （现在是 Android 11）</p></blockquote><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p><code>AMS</code> 和 <code>AT</code> 相关部分，在 <a href="https://calmcenter.club/2021/android-framework-service.html">Service 启动分析</a> 已经讲过了，<code>startActivity</code>的整体流程与 <code>startService</code> 非常相近，但比 <code>Service</code> 启动更为复杂，多了<code>stack/task</code> 以及 <code>UI</code> 的相关内容以及Activity的生命周期更为丰富。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;am&#x2F;</span><br><span class="line">  - ActivityManagerService.java (AMS)</span><br><span class="line"> - ProcessList.java (PL)</span><br><span class="line"></span><br><span class="line">frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;</span><br><span class="line">- ActivityTaskManagerService.java(ATMS)</span><br><span class="line">- ActivityStarter.java (AS)</span><br><span class="line">- RootWindowContainer.java (RWC)</span><br><span class="line">- ActivityStack.java(AStk)</span><br><span class="line">- ActivityRecord.java(AR)</span><br><span class="line">- ActivityStackSupervisor.java(ASS)</span><br><span class="line"></span><br><span class="line">frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;app&#x2F;</span><br><span class="line">- Activity.java (Aty)</span><br><span class="line">- Instrumentation.java (Ins)</span><br><span class="line">- ActivityTaskManager.java(ATM)</span><br><span class="line">- ClientTransactionHandler.java (CTH ActivityThread 父类)</span><br><span class="line">- ActivityManagerInternal.java(AMI)</span><br><span class="line"></span><br><span class="line">  - ActivityThread.java (AT 内含 ApplicationThread )</span><br><span class="line"></span><br><span class="line">frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;app&#x2F;servertransaction&#x2F;</span><br><span class="line">- ClientTransaction.java(CT)</span><br><span class="line">- TransactionExecutor.java (TE)</span><br><span class="line">- PauseActivityItem.java(PAI)</span><br><span class="line">- LaunchActivityItem.java(LAI)</span><br><span class="line">- TransactionExecutorHelper.java(TEH)</span><br></pre></td></tr></table></figure><p><strong>生成的文件和目录(Generated Files and Directories)</strong></p><p>与上面重复的，发现从这里的文件时可以点击跳转目标方法，上面有的文件反而不行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">out&#x2F;soong&#x2F;.intermediates&#x2F;frameworks&#x2F;base&#x2F;framework-minus-apex&#x2F;android_common&#x2F;xref30&#x2F;srcjars.xref&#x2F;android&#x2F;app&#x2F;</span><br><span class="line">- IApplicationThread.java (AIDL 文件生成的，内含 Proxy 和 Stub)</span><br><span class="line">- IActivityTaskManager.java (AIDL 文件生成的，内含 Proxy 和 Stub)</span><br><span class="line">- IActivityManager.java (AIDL 文件生成的，内含 Proxy 和 Stub)</span><br><span class="line"></span><br><span class="line">out&#x2F;soong&#x2F;.intermediates&#x2F;frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;services.core.unboosted&#x2F;android_common&#x2F;xref&#x2F;srcjars.xref&#x2F;frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;</span><br><span class="line">- ActivityStartController.java(ASC)</span><br><span class="line">- ActivityStarter.java(AS)</span><br><span class="line">- RootWindowContainer.java(RWC)</span><br><span class="line">- ClientLifecycleManager.java (CLM)</span><br><span class="line"></span><br><span class="line">out&#x2F;soong&#x2F;.intermediates&#x2F;frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;services.core.unboosted&#x2F;android_common&#x2F;xref&#x2F;srcjars.xref&#x2F;frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;am&#x2F;</span><br><span class="line">- ProcessList.java (PL)</span><br></pre></td></tr></table></figure><p>话不多说，直接上源码</p><h1 id="二、startActivity-源码"><a href="#二、startActivity-源码" class="headerlink" title="二、startActivity 源码"></a>二、startActivity 源码</h1><h2 id="2-1-Aty-startActivity"><a href="#2-1-Aty-startActivity" class="headerlink" title="2.1 Aty.startActivity"></a>2.1 Aty.startActivity</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivity</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.startActivity(intent, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivity</span><span class="params">(Intent intent, <span class="meta">@Nullable</span> Bundle options)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> (options != <span class="keyword">null</span>) &#123;</span><br><span class="line">        startActivityForResult(intent, -<span class="number">1</span>, options);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        startActivityForResult(intent, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivityForResult</span><span class="params">(<span class="meta">@RequiresPermission</span> Intent intent, <span class="keyword">int</span> requestCode,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@Nullable</span> Bundle options)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        options = transferSpringboardActivityOptions(options);</span><br><span class="line">      <span class="comment">// 【见 2.2】</span></span><br><span class="line">        Instrumentation.ActivityResult ar =</span><br><span class="line">            mInstrumentation.execStartActivity(</span><br><span class="line">                <span class="keyword">this</span>, mMainThread.getApplicationThread(), mToken, <span class="keyword">this</span>,</span><br><span class="line">                intent, requestCode, options);</span><br><span class="line">        <span class="keyword">if</span> (ar != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mMainThread.sendActivityResult(</span><br><span class="line">                mToken, mEmbeddedID, requestCode, ar.getResultCode(),</span><br><span class="line">                ar.getResultData());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此时 requestCode = -1</span></span><br><span class="line">        <span class="keyword">if</span> (requestCode &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            mStartedActivity = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cancelInputsAndStartExitTransition(options);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>execStartActivity()</code> 方法的参数:</p><ul><li><code>mMainThread</code>: 数据类型为 <code>ApplicationThread</code> ，通过 <code>mMainThread.getApplicationThread()</code> 方法获取。</li><li><code>mToken</code>: 数据类型为IBinder.</li></ul><h2 id="2-2-Ins-execStartActivity"><a href="#2-2-Ins-execStartActivity" class="headerlink" title="2.2 Ins.execStartActivity"></a>2.2 Ins.execStartActivity</h2><p>这里可以发现实际操作的类是 <code>Instrumentation</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ActivityResult <span class="title">execStartActivity</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Context who, IBinder contextThread, IBinder token, Activity target,</span></span></span><br><span class="line"><span class="function"><span class="params">        Intent intent, <span class="keyword">int</span> requestCode, Bundle options)</span> </span>&#123;</span><br><span class="line">    IApplicationThread whoThread = (IApplicationThread) contextThread;</span><br><span class="line">    Uri referrer = target != <span class="keyword">null</span> ? target.onProvideReferrer() : <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (referrer != <span class="keyword">null</span>) &#123;</span><br><span class="line">        intent.putExtra(Intent.EXTRA_REFERRER, referrer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mActivityMonitors != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mSync) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> N = mActivityMonitors.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> ActivityMonitor am = mActivityMonitors.get(i);</span><br><span class="line">                ActivityResult result = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (am.ignoreMatchingSpecificIntents()) &#123;</span><br><span class="line">                    result = am.onStartActivity(intent);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    am.mHits++;</span><br><span class="line">                    <span class="keyword">return</span> result;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (am.match(who, <span class="keyword">null</span>, intent)) &#123;</span><br><span class="line">                    am.mHits++;</span><br><span class="line">                    <span class="keyword">if</span> (am.isBlocking()) &#123;</span><br><span class="line">                        <span class="comment">// 当该 monitor 阻塞 activity 启动,则直接返回</span></span><br><span class="line">                        <span class="keyword">return</span> requestCode &gt;= <span class="number">0</span> ? am.getResult() : <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        intent.migrateExtraStreamToClipData(who);</span><br><span class="line">        intent.prepareToLeaveProcess(who);</span><br><span class="line">      <span class="comment">// 【见 2.3】</span></span><br><span class="line">        <span class="keyword">int</span> result = ActivityTaskManager.getService().startActivity(whoThread,</span><br><span class="line">                who.getBasePackageName(), who.getAttributionTag(), intent,</span><br><span class="line">                intent.resolveTypeIfNeeded(who.getContentResolver()), token,</span><br><span class="line">                target != <span class="keyword">null</span> ? target.mEmbeddedID : <span class="keyword">null</span>, requestCode, <span class="number">0</span>, <span class="keyword">null</span>, options);</span><br><span class="line">      <span class="comment">// 检查 activity 是否启动成功</span></span><br><span class="line">        checkStartActivityResult(result, intent);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Failure from system&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-1-ATM-getService-Client-gt-Service"><a href="#2-2-1-ATM-getService-Client-gt-Service" class="headerlink" title="2.2.1 ATM.getService (Client -&gt; Service)"></a>2.2.1 ATM.getService (Client -&gt; Service)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IActivityTaskManager <span class="title">getService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> IActivityTaskManagerSingleton.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@UnsupportedAppUsage(trackingBug = 129726065)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton&lt;IActivityTaskManager&gt; IActivityTaskManagerSingleton =</span><br><span class="line">        <span class="keyword">new</span> Singleton&lt;IActivityTaskManager&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> IActivityTaskManager <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">final</span> IBinder b = ServiceManager.getService(Context.ACTIVITY_TASK_SERVICE);</span><br><span class="line">                <span class="keyword">return</span> IActivityTaskManager.Stub.asInterface(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure><p>熟悉的代码，如果之前看过 <a href="https://calmcenter.club/2021/android-framework-service.html">Service 启动分析</a> 对这段代码结构肯定不陌生，特别是 <code>Singleton</code> ，详细请看 <code>Service 启动分析 2.3</code></p><p>这里用 <code>AIDL</code> 文件的特性，我们只需要找到谁继承了 <code>IActivityTaskManager.Stub</code> 。会发现是 <code>ActivityTaskManagerService</code></p><h2 id="2-3-ATMS-startActivity"><a href="#2-3-ATMS-startActivity" class="headerlink" title="2.3 ATMS.startActivity"></a>2.3 ATMS.startActivity</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">startActivity</span><span class="params">(IApplicationThread caller, String callingPackage,</span></span></span><br><span class="line"><span class="function"><span class="params">        String callingFeatureId, Intent intent, String resolvedType, IBinder resultTo,</span></span></span><br><span class="line"><span class="function"><span class="params">        String resultWho, <span class="keyword">int</span> requestCode, <span class="keyword">int</span> startFlags, ProfilerInfo profilerInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">        Bundle bOptions)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> startActivityAsUser(caller, callingPackage, callingFeatureId, intent, resolvedType,</span><br><span class="line">            resultTo, resultWho, requestCode, startFlags, profilerInfo, bOptions,</span><br><span class="line">            UserHandle.getCallingUserId());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">startActivityAsUser</span><span class="params">(IApplicationThread caller, String callingPackage,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@Nullable</span> String callingFeatureId, Intent intent, String resolvedType,</span></span></span><br><span class="line"><span class="function"><span class="params">        IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode, <span class="keyword">int</span> startFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">        ProfilerInfo profilerInfo, Bundle bOptions, <span class="keyword">int</span> userId, <span class="keyword">boolean</span> validateIncomingUser)</span> </span>&#123;</span><br><span class="line">    assertPackageMatchesCallingUid(callingPackage);</span><br><span class="line">    enforceNotIsolatedCaller(<span class="string">&quot;startActivityAsUser&quot;</span>);</span><br><span class="line"></span><br><span class="line">    userId = getActivityStartController().checkTargetUser(userId, validateIncomingUser,</span><br><span class="line">            Binder.getCallingPid(), Binder.getCallingUid(), <span class="string">&quot;startActivityAsUser&quot;</span>);</span><br><span class="line">    <span class="comment">// 【见 2.3.1】</span></span><br><span class="line">    <span class="keyword">return</span> getActivityStartController().obtainStarter(intent, <span class="string">&quot;startActivityAsUser&quot;</span>)</span><br><span class="line">            .setCaller(caller)</span><br><span class="line">            .setCallingPackage(callingPackage)</span><br><span class="line">            .setCallingFeatureId(callingFeatureId)</span><br><span class="line">            .setResolvedType(resolvedType)</span><br><span class="line">            .setResultTo(resultTo)</span><br><span class="line">            .setResultWho(resultWho)</span><br><span class="line">            .setRequestCode(requestCode)</span><br><span class="line">            .setStartFlags(startFlags)</span><br><span class="line">            .setProfilerInfo(profilerInfo)</span><br><span class="line">            .setActivityOptions(bOptions)</span><br><span class="line">            .setUserId(userId)</span><br><span class="line">            .execute();  <span class="comment">// 【见 2.4】</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-1-getActivityStartController-obtainStarter"><a href="#2-3-1-getActivityStartController-obtainStarter" class="headerlink" title="2.3.1 getActivityStartController().obtainStarter"></a>2.3.1 getActivityStartController().obtainStarter</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ActivityStarter <span class="title">obtainStarter</span><span class="params">(Intent intent, String reason)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mFactory.obtain().setIntent(intent).setReason(reason);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现这里返回 <code>ActivityStarter</code> </p><h2 id="2-4-AS-execute"><a href="#2-4-AS-execute" class="headerlink" title="2.4 AS.execute"></a>2.4 AS.execute</h2><p>这里不同版本代码会有很大的出入，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      <span class="comment">// 执行启动 【见 2.5】</span></span><br><span class="line">        res = executeRequest(mRequest);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">      <span class="comment">// activity 开始启动日志</span></span><br><span class="line">      mSupervisor.getActivityMetricsLogger().notifyActivityLaunched(launchingState, res,mLastStartActivityRecord);</span><br><span class="line"><span class="keyword">return</span> getExternalResult(mRequest.waitResult == <span class="keyword">null</span> ? res : waitForResult(res, mLastStartActivityRecord));</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-5-AS-executeRequest"><a href="#2-5-AS-executeRequest" class="headerlink" title="2.5 AS.executeRequest"></a>2.5 AS.executeRequest</h2><p>这段有点长，但是中间只是用来做记录防止忘记，所以只写了注释省略了很多代码，重点在这个方法的最后。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">executeRequest</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  <span class="comment">//收集 intent 所指向的 activity 信息</span></span><br><span class="line">    ActivityInfo aInfo = request.activityInfo;</span><br><span class="line">  <span class="comment">//处理 intent 信息，当存在多个 activity 时，弹出 resolverAcitvity</span></span><br><span class="line">    ResolveInfo rInfo = request.resolveInfo;</span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line"><span class="comment">// 获取调用者的进程记录对象</span></span><br><span class="line">    WindowProcessController callerApp = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (caller != <span class="keyword">null</span>) &#123;</span><br><span class="line">        callerApp = mService.getProcessController(caller);</span><br><span class="line">        <span class="keyword">if</span> (callerApp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            callingPid = callerApp.getPid();</span><br><span class="line">            callingUid = callerApp.mInfo.uid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            err = ActivityManager.START_PERMISSION_DENIED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 获取调用者所在的 activity</span></span><br><span class="line">    ActivityRecord sourceRecord = <span class="keyword">null</span>;</span><br><span class="line">    ActivityRecord resultRecord = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (resultTo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        sourceRecord = mRootWindowContainer.isInAnyStack(resultTo);</span><br><span class="line">        <span class="keyword">if</span> (sourceRecord != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (requestCode &gt;= <span class="number">0</span> &amp;&amp; !sourceRecord.finishing) &#123;</span><br><span class="line">                resultRecord = sourceRecord;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> launchFlags = intent.getFlags();</span><br><span class="line">    <span class="keyword">if</span> ((launchFlags &amp; Intent.FLAG_ACTIVITY_FORWARD_RESULT) != <span class="number">0</span> &amp;&amp; sourceRecord != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// activity 执行结果的返回由源 activity 切换到新 activity，不需要返回结果则不会进该分支  </span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err == ActivityManager.START_SUCCESS &amp;&amp; intent.getComponent() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 从 intent 中无法找到相应的 component</span></span><br><span class="line">        err = ActivityManager.START_INTENT_NOT_RESOLVED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err == ActivityManager.START_SUCCESS &amp;&amp; aInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 从 intent 中无法找到相应的 ActivityInfo</span></span><br><span class="line">        err = ActivityManager.START_CLASS_NOT_FOUND;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err == ActivityManager.START_SUCCESS &amp;&amp; sourceRecord != <span class="keyword">null</span></span><br><span class="line">            &amp;&amp; sourceRecord.getTask().voiceSession != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 启动的 activity 是 voice session 一部分</span></span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err == ActivityManager.START_SUCCESS &amp;&amp; voiceSession != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 启动的是 voice session</span></span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ActivityStack resultStack = resultRecord == <span class="keyword">null</span></span><br><span class="line">            ? <span class="keyword">null</span> : resultRecord.getRootTask();</span><br><span class="line">  </span><br><span class="line"><span class="comment">//错误则返回</span></span><br><span class="line">    <span class="keyword">if</span> (err != START_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 检查权限</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ActivityController 不为空的情况，比如 monkey 测试过程</span></span><br><span class="line">    <span class="keyword">if</span> (mService.mController != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mInterceptor.setStates(userId, realCallingPid, realCallingUid, startFlags, callingPackage,</span><br><span class="line">            callingFeatureId);</span><br><span class="line">    <span class="keyword">if</span> (mInterceptor.intercept(intent, rInfo, aInfo, resolvedType, inTask, callingPid,</span><br><span class="line">            callingUid, checkedOptions)) &#123;</span><br><span class="line">        <span class="comment">// activity 被拦截</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 终止则返回</span></span><br><span class="line">    <span class="keyword">if</span> (abort) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">return</span> START_ABORTED;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 activity 记录对象</span></span><br><span class="line">    <span class="keyword">final</span> ActivityRecord r = <span class="keyword">new</span> ActivityRecord(mService, callerApp, callingPid, callingUid,</span><br><span class="line">            callingPackage, callingFeatureId, intent, resolvedType, aInfo,</span><br><span class="line">            mService.getGlobalConfiguration(), resultRecord, resultWho, requestCode,</span><br><span class="line">            request.componentSpecified, voiceSession != <span class="keyword">null</span>, mSupervisor, checkedOptions,</span><br><span class="line">            sourceRecord);</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ActivityStack stack = mRootWindowContainer.getTopDisplayFocusedStack();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (voiceSession == <span class="keyword">null</span> &amp;&amp; stack != <span class="keyword">null</span> &amp;&amp; (stack.getResumedActivity() == <span class="keyword">null</span></span><br><span class="line">            || stack.getResumedActivity().info.applicationInfo.uid != realCallingUid)) &#123;</span><br><span class="line">      <span class="comment">// 如果前台 stack 还没有 resume 状态的 activity，则检查 app 是否允许切换</span></span><br><span class="line">        <span class="keyword">if</span> (!mService.checkAppSwitchAllowedLocked(callingPid, callingUid,</span><br><span class="line">                realCallingPid, realCallingUid, <span class="string">&quot;Activity start&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(restrictedBgActivity &amp;&amp; handleBackgroundActivityAbort(r))) &#123;</span><br><span class="line">              <span class="comment">// 如果不允许切换，则把要启动的 activity 添加到 PendingActivity，并且返回</span></span><br><span class="line">                mController.addPendingActivityLaunch(<span class="keyword">new</span> PendingActivityLaunch(r,</span><br><span class="line">                        sourceRecord, startFlags, stack, callerApp, intentGrants));</span><br><span class="line">            &#125;</span><br><span class="line">            ActivityOptions.abort(checkedOptions);</span><br><span class="line">            <span class="keyword">return</span> ActivityManager.START_SWITCHES_CANCELED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mService.onStartActivitySetDidAppSwitch();</span><br><span class="line">    mController.doPendingActivityLaunches(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">// 【见 2.6】</span></span><br><span class="line">    mLastStartActivityResult = startActivityUnchecked(r, sourceRecord, voiceSession,</span><br><span class="line">            request.voiceInteractor, startFlags, <span class="keyword">true</span> <span class="comment">/* doResume */</span>, checkedOptions, inTask,</span><br><span class="line">            restrictedBgActivity, intentGrants);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (request.outActivity != <span class="keyword">null</span>) &#123;</span><br><span class="line">        request.outActivity[<span class="number">0</span>] = mLastStartActivityRecord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mLastStartActivityResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-6-AS-startActivityUnchecked"><a href="#2-6-AS-startActivityUnchecked" class="headerlink" title="2.6 AS.startActivityUnchecked"></a>2.6 AS.startActivityUnchecked</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">startActivityUnchecked</span><span class="params">(<span class="keyword">final</span> ActivityRecord r, ActivityRecord sourceRecord,</span></span></span><br><span class="line"><span class="function"><span class="params">            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> startFlags, <span class="keyword">boolean</span> doResume, ActivityOptions options, Task inTask,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> restrictedBgActivity, NeededUriGrants intentGrants)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = START_CANCELED;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  <span class="comment">//【见 2.7]】</span></span><br><span class="line">        result = startActivityInner(r, sourceRecord, voiceSession, voiceInteractor,</span><br><span class="line">                startFlags, doResume, options, inTask, restrictedBgActivity, intentGrants);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-7-AS-startActivityInner"><a href="#2-7-AS-startActivityInner" class="headerlink" title="2.7 AS.startActivityInner"></a>2.7 AS.startActivityInner</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">startActivityInner</span><span class="params">(<span class="keyword">final</span> ActivityRecord r, ActivityRecord sourceRecord,</span></span></span><br><span class="line"><span class="function"><span class="params">        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> startFlags, <span class="keyword">boolean</span> doResume, ActivityOptions options, Task inTask,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> restrictedBgActivity, NeededUriGrants intentGrants)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    mTargetStack.startActivityLocked(mStartActivity,</span><br><span class="line">            topStack != <span class="keyword">null</span> ? topStack.getTopNonFinishingActivity() : <span class="keyword">null</span>, newTask,</span><br><span class="line">            mKeepCurTransition, mOptions);</span><br><span class="line">    <span class="keyword">if</span> (mDoResume) &#123;</span><br><span class="line">      <span class="comment">//获取前台栈顶第一个非finishing的Activity</span></span><br><span class="line">        <span class="keyword">final</span> ActivityRecord topTaskActivity =</span><br><span class="line">                mStartActivity.getTask().topRunningActivityLocked();</span><br><span class="line">        <span class="keyword">if</span> (!mTargetStack.isTopActivityFocusable()</span><br><span class="line">                || (topTaskActivity != <span class="keyword">null</span> &amp;&amp; topTaskActivity.isTaskOverlay()</span><br><span class="line">                &amp;&amp; mStartActivity != topTaskActivity)) &#123;</span><br><span class="line">          <span class="comment">// 如果该活动是不可调焦的，我们不能恢复它，但仍然希望确保它在开始时可见(这也将触发进入动画)。</span></span><br><span class="line">          <span class="comment">// 这方面的一个例子是PIP活动。</span></span><br><span class="line">          <span class="comment">// 同样，我们不希望在一个任务中恢复当前有覆盖的活动，因为开始的活动只是需要在可见的暂停状态，直到覆盖被删除。</span></span><br><span class="line">          <span class="comment">// 传递&#123;@code null&#125;作为start参数可以确保所有活动都是可见的。</span></span><br><span class="line">            mTargetStack.ensureActivitiesVisible(<span class="keyword">null</span> <span class="comment">/* starting */</span>,<span class="number">0</span> <span class="comment">/* configChanges */</span>, !PRESERVE_WINDOWS);</span><br><span class="line">            <span class="comment">// 继续并告诉窗口管理器为这个活动执行应用程序过渡，因为应用程序过渡不会通过 resume 通道触发。</span></span><br><span class="line">            mTargetStack.getDisplay().mDisplayContent.executeAppTransition();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果目标堆栈之前不是可调焦的 (该堆栈上之前的 top 运行活动不可见)，</span></span><br><span class="line">          <span class="comment">// 那么之前任何将该堆栈移动到该堆栈的调用都不会更新被调焦的堆栈。</span></span><br><span class="line">          <span class="comment">// 如果现在启动新的活动允许任务堆栈可调焦，那么请确保我们现在相应地更新已调焦的堆栈。</span></span><br><span class="line">            <span class="keyword">if</span> (mTargetStack.isTopActivityFocusable()</span><br><span class="line">                    &amp;&amp; !mRootWindowContainer.isTopDisplayFocusedStack(mTargetStack)) &#123;</span><br><span class="line">                mTargetStack.moveToFront(<span class="string">&quot;startActivityInner&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">// 【见 2.8】</span></span><br><span class="line">            mRootWindowContainer.resumeFocusedStacksTopActivities(</span><br><span class="line">                    mTargetStack, mStartActivity, mOptions);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> START_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-8-RWC-resumeFocusedStacksTopActivities"><a href="#2-8-RWC-resumeFocusedStacksTopActivities" class="headerlink" title="2.8 RWC.resumeFocusedStacksTopActivities"></a>2.8 RWC.resumeFocusedStacksTopActivities</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">resumeFocusedStacksTopActivities</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mStackSupervisor.readyToResume()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (targetStack != <span class="keyword">null</span> &amp;&amp; (targetStack.isTopStackInDisplayArea()</span><br><span class="line">            || getTopDisplayFocusedStack() == targetStack)) &#123;</span><br><span class="line">      <span class="comment">// 【见 2.9】 ActivityStack.resumeTopActivityUncheckedLocked</span></span><br><span class="line">        result = targetStack.resumeTopActivityUncheckedLocked(target, targetOptions);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> displayNdx = getChildCount() - <span class="number">1</span>; displayNdx &gt;= <span class="number">0</span>; --displayNdx) &#123;</span><br><span class="line">        <span class="keyword">final</span> DisplayContent display = getChildAt(displayNdx);</span><br><span class="line">        <span class="keyword">boolean</span> resumedOnDisplay = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> tdaNdx = display.getTaskDisplayAreaCount() - <span class="number">1</span>; tdaNdx &gt;= <span class="number">0</span>; --tdaNdx) &#123;</span><br><span class="line">            <span class="keyword">final</span> TaskDisplayArea taskDisplayArea = display.getTaskDisplayAreaAt(tdaNdx);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> sNdx = taskDisplayArea.getStackCount() - <span class="number">1</span>; sNdx &gt;= <span class="number">0</span>; --sNdx) &#123;</span><br><span class="line">                <span class="keyword">final</span> ActivityStack stack = taskDisplayArea.getStackAt(sNdx);</span><br><span class="line">                <span class="keyword">final</span> ActivityRecord topRunningActivity = stack.topRunningActivity();</span><br><span class="line">                <span class="keyword">if</span> (!stack.isFocusableAndVisible() || topRunningActivity == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (stack == targetStack) &#123;</span><br><span class="line">                    <span class="comment">// 只需更新 targetStack 的结果，因为 targetStack 已经在上面恢复了。</span></span><br><span class="line">                  <span class="comment">// 我们不想再次恢复它，特别是在某些情况下，它会导致第二次启动失败，如果应用程序进程死亡。</span></span><br><span class="line">                    resumedOnDisplay |= result;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (taskDisplayArea.isTopStack(stack) &amp;&amp; topRunningActivity.isState(RESUMED)) &#123;</span><br><span class="line">                    <span class="comment">// 从 MoveTaskToFront 操作开始任何延迟的应用程序过渡，但只考虑显示的顶部任务和堆栈。</span></span><br><span class="line">                    stack.executeAppTransition(targetOptions);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    resumedOnDisplay |= topRunningActivity.makeActiveIfNeeded(target);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!resumedOnDisplay) &#123;</span><br><span class="line">            <span class="comment">// 在没有有效 activities 的情况下(例如，设备刚刚启动或启动程序崩溃)，可能什么都没有恢复显示。</span></span><br><span class="line">          <span class="comment">// 显式地请求集中堆栈中的top活动的resume将确保至少home活动被启动和恢复，并且不会发生递归。</span></span><br><span class="line">            <span class="keyword">final</span> ActivityStack focusedStack = display.getFocusedStack();</span><br><span class="line">            <span class="keyword">if</span> (focusedStack != <span class="keyword">null</span>) &#123;</span><br><span class="line">                result |= focusedStack.resumeTopActivityUncheckedLocked(target, targetOptions);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (targetStack == <span class="keyword">null</span>) &#123;</span><br><span class="line">                result |= resumeHomeActivity(<span class="keyword">null</span> <span class="comment">/* prev */</span>, <span class="string">&quot;no-focusable-task&quot;</span>,</span><br><span class="line">                        display.getDefaultTaskDisplayArea());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>mStackSupervisor</code> 是一个 <code>ActivityStackSupervisor</code> 对象的实例。</p><ul><li><strong>ActivityStackSupervisor</strong>：负责所有 <code>Activity</code> 栈的管理。内部管理了 <code>mRunningTasks</code> 和 <code>mRecentTasks</code> 两个 <code>Activity</code> 栈。其中， <code>mRunningTasks</code> 是 <code>Helper</code> 类抽象出用于获取当前运行的任务集的逻辑； <code>mRecentTasks</code> 管理的是最近任务的历史列表，包括非活动任务。</li></ul><h2 id="2-9-AStk-resumeTopActivityUncheckedLocked"><a href="#2-9-AStk-resumeTopActivityUncheckedLocked" class="headerlink" title="2.9 AStk.resumeTopActivityUncheckedLocked"></a>2.9 AStk.resumeTopActivityUncheckedLocked</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">resumeTopActivityUncheckedLocked</span><span class="params">(ActivityRecord prev, ActivityOptions options)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mInResumeTopActivity) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 防止递归</span></span><br><span class="line">        mInResumeTopActivity = <span class="keyword">true</span>;</span><br><span class="line">      <span class="comment">// 【见 2.10】</span></span><br><span class="line">        result = resumeTopActivityInnerLocked(prev, options);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 当恢复 top 活动时，可能需要暂停 top 活动(例如，返回锁屏。</span></span><br><span class="line">      <span class="comment">// 我们在 &#123;@link #resumeTopActivityUncheckedLocked&#125; 中取消了正常的暂停逻辑，因为顶部活动在结束时恢复。</span></span><br><span class="line">      <span class="comment">// 我们在这里再次调用&#123;@link ActivityStackSupervisor# checkreadyforsleepplocked&#125;来确保任何必要的暂停逻辑发生。</span></span><br><span class="line">      <span class="comment">// 在不考虑锁屏的情况下，活动将被显示，对&#123;@link ActivityStackSupervisor# checkreadyforsleepplocked&#125;的调用被跳过。</span></span><br><span class="line">        <span class="keyword">final</span> ActivityRecord next = topRunningActivity(<span class="keyword">true</span> <span class="comment">/* focusableOnly */</span>);</span><br><span class="line">        <span class="keyword">if</span> (next == <span class="keyword">null</span> || !next.canTurnScreenOn()) &#123;</span><br><span class="line">            checkReadyForSleep();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mInResumeTopActivity = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-10-AStk-resumeTopActivityInnerLocked"><a href="#2-10-AStk-resumeTopActivityInnerLocked" class="headerlink" title="2.10 AStk.resumeTopActivityInnerLocked"></a>2.10 AStk.resumeTopActivityInnerLocked</h2><p>这个方法比较长，主要负责上一个 <code>activity</code> 的 <code>pause</code> 和下一个 <code>activity</code> 的 <code>resume</code> 相关的一系列操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">resumeTopActivityInnerLocked</span><span class="params">(ActivityRecord prev, ActivityOptions options)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 系统没有进入 booting 或 booted 状态，则不允许启动 Activity</span></span><br><span class="line">    <span class="keyword">if</span> (!mAtmService.isBooting() &amp;&amp; !mAtmService.isBooted()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 找到第一个没有 finishing 的栈顶 activity</span></span><br><span class="line">    ActivityRecord next = topRunningActivity(<span class="keyword">true</span> <span class="comment">/* focusableOnly */</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> hasRunningActivity = next != <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Maybe this entire condition can get removed?</span></span><br><span class="line">    <span class="keyword">if</span> (hasRunningActivity &amp;&amp; !isAttached()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// top running 之后的任意处于初始化状态且有显示 StartingWindow , 则移除 StartingWindow</span></span><br><span class="line">    mRootWindowContainer.cancelInitializingActivities();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  暂停/恢复 处理情况，确保无论结束继续，状态都被重置。</span></span><br><span class="line">    <span class="keyword">boolean</span> userLeaving = mStackSupervisor.mUserLeaving;</span><br><span class="line">    mStackSupervisor.mUserLeaving = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!hasRunningActivity) &#123;</span><br><span class="line">        <span class="comment">// 栈里没有 Activity 了，去别的地方看看。</span></span><br><span class="line">        <span class="keyword">return</span> resumeNextFocusableActivityWhenStackIsEmpty(prev, options);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">boolean</span> pausing = taskDisplayArea.pauseBackStacks(userLeaving, next);</span><br><span class="line">    <span class="keyword">if</span> (mResumedActivity != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// onPause 【见 3.1】</span></span><br><span class="line">        pausing |= startPausingLocked(userLeaving, <span class="keyword">false</span> <span class="comment">/* uiSleeping */</span>, next);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// ... </span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          <span class="comment">// ... </span></span><br><span class="line">    <span class="comment">// 【见 4.1】</span></span><br><span class="line">            mStackSupervisor.startSpecificActivity(next, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ... </span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ... </span></span><br><span class="line">  <span class="comment">// 【见 4.1】</span></span><br><span class="line">        mStackSupervisor.startSpecificActivity(next, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>resumeTopActivityInnerLocked()</code> 方法中会去判断是否有 Activity 处于 <code>Resume</code> 状态。</p><p>如果有的话会先让这个 <code>Activity</code> 执行 <code>Pausing</code> 过程（其实也就是中 <code>Launcher</code> 的 <code>onPause</code> 流程），然后再执行 <code>startSpecificActivity</code> 方法来启动需要启动的 <code>Activity</code>。</p><h1 id="三、onPause"><a href="#三、onPause" class="headerlink" title="三、onPause"></a>三、onPause</h1><h2 id="3-1-AStk-startPausingLocked"><a href="#3-1-AStk-startPausingLocked" class="headerlink" title="3.1 AStk.startPausingLocked"></a>3.1 AStk.startPausingLocked</h2><p>栈顶 <code>Activity</code> 执行 <code>onPause()</code> 方法退出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">startPausingLocked</span><span class="params">(<span class="keyword">boolean</span> userLeaving, <span class="keyword">boolean</span> uiSleeping,</span></span></span><br><span class="line"><span class="function"><span class="params">        ActivityRecord resuming)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    ActivityRecord prev = mResumedActivity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把 prev 赋值给 mPausingActivity，这个值在 Activity 启动过程中会用到，</span></span><br><span class="line">    <span class="comment">// 这边其实就是将 mResumedActivity 赋值给 mPausingActivity，就是我们的 Launcher(也可以叫未添加新 Activity 时的栈顶 Activity)。</span></span><br><span class="line">    mPausingActivity = prev;</span><br><span class="line">    mLastPausedActivity = prev;</span><br><span class="line">    mLastNoHistoryActivity = prev.isNoHistory() ? prev : <span class="keyword">null</span>;</span><br><span class="line">    prev.setState(PAUSING, <span class="string">&quot;startPausingLocked&quot;</span>);</span><br><span class="line">    prev.getTask().touchActiveTime();</span><br><span class="line">    clearLaunchTime(prev);</span><br><span class="line"></span><br><span class="line">    mAtmService.updateCpuStats();</span><br><span class="line"></span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prev.attachedToProcess()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            EventLogTags.writeWmPauseActivity(prev.mUserId, System.identityHashCode(prev),</span><br><span class="line">                    prev.shortComponentName, <span class="string">&quot;userLeaving=&quot;</span> + userLeaving);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 从 Android P 开始，引入了 ClientLifecycleManager 和 ClientTransactionHandler 来辅助</span></span><br><span class="line"><span class="comment">             * 管理 Activity 生命周期，它会发送 EXECUTE_TRANSACTION 消息到 ActivityThread.H 里面继续处理。</span></span><br><span class="line"><span class="comment">             * 通过 ClientLifecycleManager 的 scheduleTransaction() 方法把 PauseActivityItem</span></span><br><span class="line"><span class="comment">             * 事件加入到执行计划中，开始栈顶的 pausing 过程。</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             *    ClientLifecycleManager getLifecycleManager() &#123;</span></span><br><span class="line"><span class="comment">             *        return mLifecycleManager;</span></span><br><span class="line"><span class="comment">             *    &#125;</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">          <span class="comment">// 【见 3.2】 这里注意是 传递的是PauseActivityItem</span></span><br><span class="line">            mAtmService.getLifecycleManager().scheduleTransaction(prev.app.getThread(),</span><br><span class="line">                    prev.appToken, PauseActivityItem.obtain(prev.finishing, userLeaving,</span><br><span class="line">                            prev.configChangeFlags, pauseImmediately));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            mPausingActivity = <span class="keyword">null</span>;</span><br><span class="line">            mLastPausedActivity = <span class="keyword">null</span>;</span><br><span class="line">            mLastNoHistoryActivity = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mPausingActivity = <span class="keyword">null</span>;</span><br><span class="line">        mLastPausedActivity = <span class="keyword">null</span>;</span><br><span class="line">        mLastNoHistoryActivity = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-CLM-scheduleTransaction"><a href="#3-2-CLM-scheduleTransaction" class="headerlink" title="3.2 CLM.scheduleTransaction"></a>3.2 CLM.scheduleTransaction</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleTransaction</span><span class="params">(<span class="meta">@NonNull</span> IApplicationThread client, <span class="meta">@NonNull</span> IBinder activityToken,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@NonNull</span> ActivityLifecycleItem stateRequest)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ClientTransaction clientTransaction = transactionWithState(client, activityToken,</span><br><span class="line">            stateRequest);</span><br><span class="line">    scheduleTransaction(clientTransaction);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleTransaction</span><span class="params">(ClientTransaction transaction)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> IApplicationThread client = transaction.getClient();</span><br><span class="line">  <span class="comment">// 【见 3.3】</span></span><br><span class="line">    transaction.schedule();</span><br><span class="line">    <span class="keyword">if</span> (!(client <span class="keyword">instanceof</span> Binder)) &#123;</span><br><span class="line">        transaction.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-CT-schedule-Service-gt-Client"><a href="#3-3-CT-schedule-Service-gt-Client" class="headerlink" title="3.3 CT.schedule (Service -&gt; Client)"></a>3.3 CT.schedule (Service -&gt; Client)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> IApplicationThread mClient;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> IApplicationThread <span class="title">getClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mClient;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">schedule</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">  <span class="comment">// 【见 3.4】</span></span><br><span class="line">    mClient.scheduleTransaction(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ClientTransaction.schedule()</code> 方法的 <code>mClient</code> 是一个 <code>IApplicationThread(这是一个 AIDL 文件生成的类)</code> 类型，<code>ActivityThread</code> 的内部类 <code>ApplicationThread</code> 派生这个接口类并实现了对应的方法<code>(这里不懂的看 2.2.1)</code>。所以直接跳转到 <code>ApplicationThread</code> 中的 <code>scheduleTransaction()</code> 方法。</p><h2 id="3-4-AT-scheduleTransaction"><a href="#3-4-AT-scheduleTransaction" class="headerlink" title="3.4 AT.scheduleTransaction"></a>3.4 AT.scheduleTransaction</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleTransaction</span><span class="params">(ClientTransaction transaction)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">  <span class="comment">// 【见 3.5】</span></span><br><span class="line">    ActivityThread.<span class="keyword">this</span>.scheduleTransaction(transaction);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-5-CTH-scheduleTransaction"><a href="#3-5-CTH-scheduleTransaction" class="headerlink" title="3.5 CTH.scheduleTransaction"></a>3.5 CTH.scheduleTransaction</h2><p><code>ActivityThread</code> 类中并没有定义 <code>scheduleTransaction()</code> 方法，所以调用的是他父类 <code>ClientTransactionHandler</code> 的 <code>scheduleTransaction()</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleTransaction</span><span class="params">(ClientTransaction transaction)</span> </span>&#123;</span><br><span class="line">    transaction.preExecute(<span class="keyword">this</span>);</span><br><span class="line">  <span class="comment">// 【见 3.6】</span></span><br><span class="line">    sendMessage(ActivityThread.H.EXECUTE_TRANSACTION, transaction);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-6-AT-H-handleMessage"><a href="#3-6-AT-H-handleMessage" class="headerlink" title="3.6 AT.H.handleMessage"></a>3.6 AT.H.handleMessage</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">H</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">            <span class="keyword">case</span> EXECUTE_TRANSACTION:</span><br><span class="line">                <span class="keyword">final</span> ClientTransaction transaction = (ClientTransaction) msg.obj;</span><br><span class="line">                <span class="comment">// Handler H 的实例接收到 EXECUTE_TRANSACTION 消息后调用 </span></span><br><span class="line">                <span class="comment">// TransactionExecutor.execute() 方法切换 Activity 状态。</span></span><br><span class="line"><span class="comment">// 【见 3.7】</span></span><br><span class="line">                mTransactionExecutor.execute(transaction);</span><br><span class="line">                <span class="keyword">if</span> (isSystem()) &#123;</span><br><span class="line">                    transaction.recycle();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-7-TE-execute"><a href="#3-7-TE-execute" class="headerlink" title="3.7 TE.execute"></a>3.7 TE.execute</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(ClientTransaction transaction)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> IBinder token = transaction.getActivityToken();</span><br><span class="line">    <span class="comment">// ... 这里需要记住有两个方法 executeCallbacks() executeLifecycleState() 6.1 会用到</span></span><br><span class="line">  <span class="comment">// 处理添加的 callback 【见 3.8】 </span></span><br><span class="line">    executeCallbacks(transaction);</span><br><span class="line"><span class="comment">// 处理 当前状态 设置的 LifecycleStateRequest 状态 之间的生命周期【见 6.1】</span></span><br><span class="line">    executeLifecycleState(transaction);</span><br><span class="line">    mPendingActions.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-8-TE-executeCallbacks"><a href="#3-8-TE-executeCallbacks" class="headerlink" title="3.8 TE.executeCallbacks"></a>3.8 TE.executeCallbacks</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ActivityThread.java</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> TransactionExecutor mTransactionExecutor = <span class="keyword">new</span> TransactionExecutor(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">TransactionExecutor.java</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TransactionExecutor</span><span class="params">(ClientTransactionHandler clientTransactionHandler)</span> </span>&#123;</span><br><span class="line">      mTransactionHandler = clientTransactionHandler;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeCallbacks</span><span class="params">(ClientTransaction transaction)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> List&lt;ClientTransactionItem&gt; callbacks = transaction.getCallbacks();</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> size = callbacks.size();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">          <span class="keyword">final</span> ClientTransactionItem item = callbacks.get(i);</span><br><span class="line">          <span class="comment">//...</span></span><br><span class="line">        <span class="comment">// 【见 3.9】  【见 5.2 和 7.6，由于步骤重复，省略了之前步骤】</span></span><br><span class="line">          item.execute(mTransactionHandler, token, mPendingActions);</span><br><span class="line">          item.postExecute(mTransactionHandler, token, mPendingActions);</span><br><span class="line">          <span class="comment">//...</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>item</code> 在 <code>2.11</code> 重点强调了，调用 <code>scheduleTransaction</code> 时传递的是 <code>PauseActivityItem</code> ，所以这里调用的是 <code>PauseActivityItem.execute</code> </p><p>这里的 <code>mTransactionHandler</code> 是 <code>ActivityThread</code> ，也就是下面的 <code>client</code> 。</p><h2 id="3-9-PAI-execute"><a href="#3-9-PAI-execute" class="headerlink" title="3.9 PAI.execute"></a>3.9 PAI.execute</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(ClientTransactionHandler client, IBinder token,</span></span></span><br><span class="line"><span class="function"><span class="params">          PendingTransactionActions pendingActions)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 跳转到 ActivityThread.handlePauseActivity 方法 【见 3.10】</span></span><br><span class="line">      client.handlePauseActivity(token, mFinished, mUserLeaving, mConfigChanges, pendingActions,</span><br><span class="line">              <span class="string">&quot;PAUSE_ACTIVITY_ITEM&quot;</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="3-10-AT-handlePauseActivity"><a href="#3-10-AT-handlePauseActivity" class="headerlink" title="3.10 AT.handlePauseActivity"></a>3.10 AT.handlePauseActivity</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlePauseActivity</span><span class="params">(IBinder token, <span class="keyword">boolean</span> finished, <span class="keyword">boolean</span> userLeaving,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> configChanges, PendingTransactionActions pendingActions, String reason)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">      <span class="comment">// 调用 performPauseActivity() 方法</span></span><br><span class="line">        performPauseActivity(r, finished, reason, pendingActions);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Bundle <span class="title">performPauseActivity</span><span class="params">(ActivityClientRecord r, <span class="keyword">boolean</span> finished, String reason,</span></span></span><br><span class="line"><span class="function"><span class="params">        PendingTransactionActions pendingActions)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//... </span></span><br><span class="line">    performPauseActivityIfNeeded(r, reason);</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> shouldSaveState ? r.state : <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performPauseActivityIfNeeded</span><span class="params">(ActivityClientRecord r, String reason)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        r.activity.mCalled = <span class="keyword">false</span>;</span><br><span class="line">      <span class="comment">// 【见 3.11】</span></span><br><span class="line">        mInstrumentation.callActivityOnPause(r.activity);</span><br><span class="line">        <span class="keyword">if</span> (!r.activity.mCalled) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SuperNotCalledException(<span class="string">&quot;Activity &quot;</span> + safeToComponentShortString(r.intent)</span><br><span class="line">                    + <span class="string">&quot; did not call through to super.onPause()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SuperNotCalledException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mInstrumentation.onException(r.activity, e)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Unable to pause activity &quot;</span></span><br><span class="line">                    + safeToComponentShortString(r.intent) + <span class="string">&quot;: &quot;</span> + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    r.setState(ON_PAUSE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-11-Ins-callActivityOnPause"><a href="#3-11-Ins-callActivityOnPause" class="headerlink" title="3.11 Ins.callActivityOnPause"></a>3.11 Ins.callActivityOnPause</h2><p>这里可以发现实际操作 <code>Activity</code> 的类 还是 <code>Instrumentation</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callActivityOnPause</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 直接调用 Activity.performPause 方法 【见 3.12】</span></span><br><span class="line">    activity.performPause();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-12-Aty-performPause"><a href="#3-12-Aty-performPause" class="headerlink" title="3.12 Aty.performPause"></a>3.12 Aty.performPause</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">performPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    dispatchActivityPrePaused();</span><br><span class="line">    mDoReportFullyDrawn = <span class="keyword">false</span>;</span><br><span class="line">    mFragments.dispatchPause();</span><br><span class="line">    mCalled = <span class="keyword">false</span>;</span><br><span class="line">  <span class="comment">// 执行暂停方法</span></span><br><span class="line">    onPause();</span><br><span class="line">    EventLogTags.writeWmOnPausedCalled(mIdent, getComponentName().getClassName(),</span><br><span class="line">            <span class="string">&quot;performPause&quot;</span>);</span><br><span class="line">    mResumed = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (!mCalled &amp;&amp; getApplicationInfo().targetSdkVersion</span><br><span class="line">            &gt;= android.os.Build.VERSION_CODES.GINGERBREAD) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SuperNotCalledException(</span><br><span class="line">                <span class="string">&quot;Activity &quot;</span> + mComponent.toShortString() +</span><br><span class="line">                <span class="string">&quot; did not call through to super.onPause()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    dispatchActivityPostPaused();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>至此，Launcher 的 onPause() 流程分析结束！同时，我们需要明白一点：在启动一个 Activity 的时候最先被执行的是栈顶的 Activity 的 onPause() 方法。</strong></p><h1 id="四、新-Activity-的创建"><a href="#四、新-Activity-的创建" class="headerlink" title="四、新 Activity 的创建"></a>四、新 Activity 的创建</h1><h2 id="4-1-ASS-startSpecificActivity"><a href="#4-1-ASS-startSpecificActivity" class="headerlink" title="4.1 ASS.startSpecificActivity"></a>4.1 ASS.startSpecificActivity</h2><p>在 <code>2.10 ActivityStack.resumeTopActivityInnerLocked</code> 末尾，有一句 <code>mStackSupervisor.startSpecificActivity();</code> </p><p><code>mStackSupervisor</code> 在 <code>ActivityStack</code> 父类 <code>Task</code> 中找到 <code>final ActivityStackSupervisor mStackSupervisor;</code> ，所以这里的 <code>mStackSupervisor.startSpecificActivity</code> 就是调用的 <code>ActivityStackSupervisor</code> 类的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ActivityStackSupervisor</span><span class="params">(ActivityTaskManagerService service, Looper looper)</span> </span>&#123;</span><br><span class="line">    mService = service;</span><br><span class="line">    mLooper = looper;</span><br><span class="line">    mHandler = <span class="keyword">new</span> ActivityStackSupervisorHandler(looper);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">startSpecificActivity</span><span class="params">(ActivityRecord r, <span class="keyword">boolean</span> andResume, <span class="keyword">boolean</span> checkConfig)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> WindowProcessController wpc = mService.getProcessController(r.processName, r.info.applicationInfo.uid);</span><br><span class="line">    <span class="keyword">boolean</span> knownToBeDead = <span class="keyword">false</span>;</span><br><span class="line">  <span class="comment">// 如果 app 存在，并且已经启动</span></span><br><span class="line">    <span class="keyword">if</span> (wpc != <span class="keyword">null</span> &amp;&amp; wpc.hasThread()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// app 存在并且已经启动，调用 realStartActivityLocked() 方法 【见 5.1】</span></span><br><span class="line">            <span class="comment">// andResume 在 2.10 中均是传递的 true</span></span><br><span class="line">            realStartActivityLocked(r, wpc, andResume, checkConfig);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;&#125;</span><br><span class="line">        knownToBeDead = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    r.notifyUnknownVisibilityLaunchedForKeyguardTransition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isTop = andResume &amp;&amp; r.isTopRunningActivity();</span><br><span class="line">  <span class="comment">// 比如 Launcher 启动 app 的时候</span></span><br><span class="line">  <span class="comment">// 调用 startProcessAsync() 方法启动新的进程 【见 4.2】</span></span><br><span class="line">    mService.startProcessAsync(r, knownToBeDead, isTop, isTop ? <span class="string">&quot;top-activity&quot;</span> : <span class="string">&quot;activity&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>mService</code> 是 <code>ActivityTaskManagerService</code> </p><p>如果已经启动，就会调用 <code>realStartActivityLocked()</code> 方法继续处理，注意 <code>andResume</code> 的值。</p><p>如果没有启动，则会调用 <code>ActivityTaskManagerService.startProcessAsync()</code> 方法创建新的进程，我们重点看下新应用进程的创建流程。</p><h2 id="4-2-ATMS-startProcessAsync-新进程"><a href="#4-2-ATMS-startProcessAsync-新进程" class="headerlink" title="4.2 ATMS.startProcessAsync(新进程)"></a>4.2 ATMS.startProcessAsync(新进程)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">startProcessAsync</span><span class="params">(ActivityRecord activity, <span class="keyword">boolean</span> knownToBeDead, <span class="keyword">boolean</span> isTop,</span></span></span><br><span class="line"><span class="function"><span class="params">        String hostingType)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (Trace.isTagEnabled(TRACE_TAG_WINDOW_MANAGER)) &#123;</span><br><span class="line">            Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, <span class="string">&quot;dispatchingStartProcess:&quot;</span></span><br><span class="line">                    + activity.processName);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// Message 包含一个 ActivityManagerInternal::startProcess 方法 【见 4.2.1】</span></span><br><span class="line">        <span class="keyword">final</span> Message m = PooledLambda.obtainMessage(ActivityManagerInternal::startProcess,</span><br><span class="line">                mAmInternal, activity.processName, activity.info.applicationInfo, knownToBeDead,</span><br><span class="line">                isTop, hostingType, activity.intent.getComponent());</span><br><span class="line">        mH.sendMessage(m);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-1-AMI-startProcess"><a href="#4-2-1-AMI-startProcess" class="headerlink" title="4.2.1 AMI.startProcess"></a>4.2.1 AMI.startProcess</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">startProcess</span><span class="params">(String processName, ApplicationInfo info,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> knownToBeDead, <span class="keyword">boolean</span> isTop, String hostingType, ComponentName hostingName)</span></span>;</span><br></pre></td></tr></table></figure><p>一个抽象方法，由 <code>ActivityManagerService</code> 内部类 <code>LocalService</code> 实现</p><h3 id="4-2-2-AMS-LocalService-startProcess"><a href="#4-2-2-AMS-LocalService-startProcess" class="headerlink" title="4.2.2 AMS.LocalService.startProcess"></a>4.2.2 AMS.LocalService.startProcess</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalService</span> <span class="keyword">extends</span> <span class="title">ActivityManagerInternal</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startProcess</span><span class="params">(String processName, ApplicationInfo info, <span class="keyword">boolean</span> knownToBeDead,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">boolean</span> isTop, String hostingType, ComponentName hostingName)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (Trace.isTagEnabled(Trace.TRACE_TAG_ACTIVITY_MANAGER)) &#123;</span><br><span class="line">                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">&quot;startProcess:&quot;</span></span><br><span class="line">                            + processName);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (ActivityManagerService.<span class="keyword">this</span>) &#123;</span><br><span class="line">                    <span class="comment">// 调用 startProcessLocked() 方法 【见 4.2.3】</span></span><br><span class="line">                    startProcessLocked(processName, info, knownToBeDead, <span class="number">0</span> <span class="comment">/* intentFlags */</span>,</span><br><span class="line">                            <span class="keyword">new</span> HostingRecord(hostingType, hostingName, isTop),</span><br><span class="line">                            ZYGOTE_POLICY_FLAG_LATENCY_SENSITIVE, <span class="keyword">false</span> <span class="comment">/* allowWhileBooting */</span>,</span><br><span class="line">                            <span class="keyword">false</span> <span class="comment">/* isolated */</span>, <span class="keyword">true</span> <span class="comment">/* keepIfLarge */</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-3-AMS-startProcessLocked"><a href="#4-2-3-AMS-startProcessLocked" class="headerlink" title="4.2.3 AMS.startProcessLocked"></a>4.2.3 AMS.startProcessLocked</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ProcessList mProcessList = <span class="keyword">new</span> ProcessList();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> ProcessRecord <span class="title">startProcessLocked</span><span class="params">(String processName,</span></span></span><br><span class="line"><span class="function"><span class="params">        ApplicationInfo info, <span class="keyword">boolean</span> knownToBeDead, <span class="keyword">int</span> intentFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">        HostingRecord hostingRecord, <span class="keyword">int</span> zygotePolicyFlags, <span class="keyword">boolean</span> allowWhileBooting,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> isolated, <span class="keyword">boolean</span> keepIfLarge)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 【见 4.2.4】</span></span><br><span class="line">    <span class="keyword">return</span> mProcessList.startProcessLocked(processName, info, knownToBeDead, intentFlags,</span><br><span class="line">            hostingRecord, zygotePolicyFlags, allowWhileBooting, isolated, <span class="number">0</span> <span class="comment">/* isolatedUid */</span>,</span><br><span class="line">            keepIfLarge, <span class="keyword">null</span> <span class="comment">/* ABI override */</span>, <span class="keyword">null</span> <span class="comment">/* entryPoint */</span>,</span><br><span class="line">            <span class="keyword">null</span> <span class="comment">/* entryPointArgs */</span>, <span class="keyword">null</span> <span class="comment">/* crashHandler */</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-4-PL-startProcessLocked"><a href="#4-2-4-PL-startProcessLocked" class="headerlink" title="4.2.4 PL.startProcessLocked"></a>4.2.4 PL.startProcessLocked</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> ProcessRecord <span class="title">startProcessLocked</span><span class="params">(String processName, ApplicationInfo info,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> knownToBeDead, <span class="keyword">int</span> intentFlags, HostingRecord hostingRecord,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> zygotePolicyFlags, <span class="keyword">boolean</span> allowWhileBooting, <span class="keyword">boolean</span> isolated, <span class="keyword">int</span> isolatedUid,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> keepIfLarge, String abiOverride, String entryPoint, String[] entryPointArgs,</span></span></span><br><span class="line"><span class="function"><span class="params">        Runnable crashHandler)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">    <span class="comment">// 调用 startProcessLocked() 方法</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> success =</span><br><span class="line">            startProcessLocked(app, hostingRecord, zygotePolicyFlags, abiOverride);</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">startProcessLocked</span><span class="params">(ProcessRecord app, HostingRecord hostingRecord,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> zygotePolicyFlags, String abiOverride)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 调用 startProcessLocked() 方法</span></span><br><span class="line">    <span class="keyword">return</span> startProcessLocked(app, hostingRecord, zygotePolicyFlags,</span><br><span class="line">            <span class="keyword">false</span> <span class="comment">/* disableHiddenApiChecks */</span>, <span class="keyword">false</span> <span class="comment">/* disableTestApiChecks */</span>,</span><br><span class="line">            <span class="keyword">false</span> <span class="comment">/* mountExtStorageFull */</span>, abiOverride);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">startProcessLocked</span><span class="params">(ProcessRecord app, HostingRecord hostingRecord,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> zygotePolicyFlags, <span class="keyword">boolean</span> disableHiddenApiChecks, <span class="keyword">boolean</span> disableTestApiChecks,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> mountExtStorageFull, String abiOverride)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line"><span class="comment">// 调用 startProcessLocked() 方法</span></span><br><span class="line">        <span class="keyword">return</span> startProcessLocked(hostingRecord, entryPoint, app, uid, gids,</span><br><span class="line">                runtimeFlags, zygotePolicyFlags, mountExternal, seInfo, requiredAbi,</span><br><span class="line">                instructionSet, invokeWith, startTime);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">        mService.forceStopPackageLocked(app.info.packageName, UserHandle.getAppId(app.uid),</span><br><span class="line">                <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, app.userId, <span class="string">&quot;start failure&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">startProcessLocked</span><span class="params">(HostingRecord hostingRecord, String entryPoint, ProcessRecord app,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> uid, <span class="keyword">int</span>[] gids, <span class="keyword">int</span> runtimeFlags, <span class="keyword">int</span> zygotePolicyFlags, <span class="keyword">int</span> mountExternal,</span></span></span><br><span class="line"><span class="function"><span class="params">        String seInfo, String requiredAbi, String instructionSet, String invokeWith,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">long</span> startTime)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mService.mConstants.FLAG_PROCESS_START_ASYNC) &#123;</span><br><span class="line">        mService.mProcStartHandler.post(() -&gt; handleProcessStart(</span><br><span class="line">                app, entryPoint, gids, runtimeFlags, zygotePolicyFlags, mountExternal,</span><br><span class="line">                requiredAbi, instructionSet, invokeWith, startSeq));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 调用 startProcess() 方法 【见 4.2.5】</span></span><br><span class="line">            <span class="keyword">final</span> Process.ProcessStartResult startResult = startProcess(hostingRecord,</span><br><span class="line">                    entryPoint, app,</span><br><span class="line">                    uid, gids, runtimeFlags, zygotePolicyFlags, mountExternal, seInfo,</span><br><span class="line">                    requiredAbi, instructionSet, invokeWith, startTime);</span><br><span class="line">            handleProcessStartedLocked(app, startResult.pid, startResult.usingWrapper,</span><br><span class="line">                    startSeq, <span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            app.pendingStart = <span class="keyword">false</span>;</span><br><span class="line">            mService.forceStopPackageLocked(app.info.packageName, UserHandle.getAppId(app.uid),</span><br><span class="line">                    <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, app.userId, <span class="string">&quot;start failure&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> app.pid &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-5-PL-startProcess"><a href="#4-2-5-PL-startProcess" class="headerlink" title="4.2.5 PL.startProcess"></a>4.2.5 PL.startProcess</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Process.<span class="function">ProcessStartResult <span class="title">startProcess</span><span class="params">(HostingRecord hostingRecord, String entryPoint,</span></span></span><br><span class="line"><span class="function"><span class="params">        ProcessRecord app, <span class="keyword">int</span> uid, <span class="keyword">int</span>[] gids, <span class="keyword">int</span> runtimeFlags, <span class="keyword">int</span> zygotePolicyFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> mountExternal, String seInfo, String requiredAbi, String instructionSet,</span></span></span><br><span class="line"><span class="function"><span class="params">        String invokeWith, <span class="keyword">long</span> startTime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">final</span> Process.ProcessStartResult startResult;</span><br><span class="line">        <span class="keyword">if</span> (hostingRecord.usesWebviewZygote()) &#123;</span><br><span class="line">            startResult = startWebView(entryPoint,</span><br><span class="line">                    app.processName, uid, uid, gids, runtimeFlags, mountExternal,</span><br><span class="line">                    app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,</span><br><span class="line">                    app.info.dataDir, <span class="keyword">null</span>, app.info.packageName, app.mDisabledCompatChanges,</span><br><span class="line">                    <span class="keyword">new</span> String[]&#123;PROC_START_SEQ_IDENT + app.startSeq&#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hostingRecord.usesAppZygote()) &#123;</span><br><span class="line">            <span class="keyword">final</span> AppZygote appZygote = createAppZygoteForProcessIfNeeded(app);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// We can&#x27;t isolate app data and storage data as parent zygote already did that.</span></span><br><span class="line">            startResult = appZygote.getProcess().start(entryPoint,</span><br><span class="line">                    app.processName, uid, uid, gids, runtimeFlags, mountExternal,</span><br><span class="line">                    app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,</span><br><span class="line">                    app.info.dataDir, <span class="keyword">null</span>, app.info.packageName,</span><br><span class="line">                    <span class="comment">/*zygotePolicyFlags=*/</span> ZYGOTE_POLICY_FLAG_EMPTY, isTopApp,</span><br><span class="line">                    app.mDisabledCompatChanges, pkgDataInfoMap, whitelistedAppDataInfoMap,</span><br><span class="line">                    <span class="keyword">false</span>, <span class="keyword">false</span>,</span><br><span class="line">                    <span class="keyword">new</span> String[]&#123;PROC_START_SEQ_IDENT + app.startSeq&#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 执行 Process.start() 方法</span></span><br><span class="line">            startResult = Process.start(entryPoint,</span><br><span class="line">                    app.processName, uid, uid, gids, runtimeFlags, mountExternal,</span><br><span class="line">                    app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,</span><br><span class="line">                    app.info.dataDir, invokeWith, app.info.packageName, zygotePolicyFlags,</span><br><span class="line">                    isTopApp, app.mDisabledCompatChanges, pkgDataInfoMap,</span><br><span class="line">                    whitelistedAppDataInfoMap, bindMountAppsData, bindMountAppStorageDirs,</span><br><span class="line">                    <span class="keyword">new</span> String[]&#123;PROC_START_SEQ_IDENT + app.startSeq&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> startResult;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，我们就明白了：<code>ATMS.startProcessLocked()</code> 方法经过多次跳转最终会通过 <code>Process.start()</code> 方法来为应用创建进程。</p><p>进程创建流程，请看 <a href="https://calmcenter.club/2021/android-framework-process.html">Android 进程创建流程</a></p><p>源码最后会执行到 <code>ActivityThread.main()</code> 方法，执行主线程的初始化工作。</p><h3 id="4-2-6-AT-main"><a href="#4-2-6-AT-main" class="headerlink" title="4.2.6 AT.main"></a>4.2.6 AT.main</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 创建主线程 looper</span></span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 初始化 ActivityThread</span></span><br><span class="line">    ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">  <span class="comment">// attach 到系统进程 【见 4.2.7】</span></span><br><span class="line">    thread.attach(<span class="keyword">false</span>, startSeq);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        sMainThreadHandler = thread.getHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 主线程启动，进入循环状态</span></span><br><span class="line">    Looper.loop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Main thread loop unexpectedly exited&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-2-7-AT-attach"><a href="#4-2-7-AT-attach" class="headerlink" title="4.2.7 AT.attach"></a>4.2.7 AT.attach</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(<span class="keyword">boolean</span> system, <span class="keyword">long</span> startSeq)</span> </span>&#123;</span><br><span class="line">    sCurrentActivityThread = <span class="keyword">this</span>;</span><br><span class="line">    mSystemThread = system;</span><br><span class="line">    <span class="keyword">if</span> (!system) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">final</span> IActivityManager mgr = ActivityManager.getService();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 通过 ActivityManagerService 为这个应用绑定一个 Application 【见 4.2.8】</span></span><br><span class="line">            mgr.attachApplication(mAppThread, startSeq);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加一个垃圾回收观察者，每当系统触发垃圾回收的时候就会在 run 方法里面</span></span><br><span class="line">        <span class="comment">// 去计算应用使用了多少内存，如果超过总量的四分之三就会尝试释放内存</span></span><br><span class="line">        BinderInternal.addGcWatcher(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (!mSomeActivitiesChanged) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                Runtime runtime = Runtime.getRuntime();</span><br><span class="line">                <span class="keyword">long</span> dalvikMax = runtime.maxMemory();</span><br><span class="line">                <span class="keyword">long</span> dalvikUsed = runtime.totalMemory() - runtime.freeMemory();</span><br><span class="line">                <span class="keyword">if</span> (dalvikUsed &gt; ((<span class="number">3</span>*dalvikMax)/<span class="number">4</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG_MEMORY_TRIM) Slog.d(TAG, <span class="string">&quot;Dalvik max=&quot;</span> + (dalvikMax/<span class="number">1024</span>)</span><br><span class="line">                            + <span class="string">&quot; total=&quot;</span> + (runtime.totalMemory()/<span class="number">1024</span>)</span><br><span class="line">                            + <span class="string">&quot; used=&quot;</span> + (dalvikUsed/<span class="number">1024</span>));</span><br><span class="line">                    mSomeActivitiesChanged = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        ActivityTaskManager.getService().releaseSomeActivities(mAppThread);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 为根 View 添加 config 回调接收 config 变化相关的信息</span></span><br><span class="line">    ViewRootImpl.addConfigCallback(configChangedCallback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>IActivityManager</code> 的实现类是 <code>ActivityManagerService</code> ，可以查看谁继承了 <code>IActivityManager.Stub</code> 。</p><h3 id="4-2-8-AMS-attachApplication"><a href="#4-2-8-AMS-attachApplication" class="headerlink" title="4.2.8 AMS.attachApplication"></a>4.2.8 AMS.attachApplication</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attachApplication</span><span class="params">(IApplicationThread thread, <span class="keyword">long</span> startSeq)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (thread == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">&quot;Invalid application interface&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">          <span class="keyword">int</span> callingPid = Binder.getCallingPid();</span><br><span class="line">          <span class="keyword">final</span> <span class="keyword">int</span> callingUid = Binder.getCallingUid();</span><br><span class="line">          <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">        <span class="comment">// 调用 attachApplicationLocked() 方法</span></span><br><span class="line">          attachApplicationLocked(thread, callingPid, callingUid, startSeq);</span><br><span class="line">          Binder.restoreCallingIdentity(origId);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ActivityTaskManagerInternal mAtmInternal;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">attachApplicationLocked</span><span class="params">(<span class="meta">@NonNull</span> IApplicationThread thread,</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">int</span> pid, <span class="keyword">int</span> callingUid, <span class="keyword">long</span> startSeq)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">      <span class="keyword">if</span> (normalMode) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用 attachApplication() 方法 【见 4.2.9】</span></span><br><span class="line">              didSomething = mAtmInternal.attachApplication(app.getWindowProcessController());</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">              Slog.wtf(TAG, <span class="string">&quot;Exception thrown launching activities in &quot;</span> + app, e);</span><br><span class="line">              badApp = <span class="keyword">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><code>ActivityTaskManagerInternal</code> 的实现类是 <code>ActivityTaskManagerService</code></p><h3 id="4-2-9-ATMS-attachApplication"><a href="#4-2-9-ATMS-attachApplication" class="headerlink" title="4.2.9 ATMS.attachApplication"></a>4.2.9 ATMS.attachApplication</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">attachApplication</span><span class="params">(WindowProcessController wpc)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mGlobalLockWithoutBoost) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 调用 RootWindowContainer.attachApplication() 方法 【见 4.2.10】</span></span><br><span class="line">            <span class="keyword">return</span> mRootWindowContainer.attachApplication(wpc);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-10-RWC-attachApplication"><a href="#4-2-10-RWC-attachApplication" class="headerlink" title="4.2.10 RWC.attachApplication"></a>4.2.10 RWC.attachApplication</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">attachApplication</span><span class="params">(WindowProcessController app)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> didSomething = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> displayNdx = getChildCount() - <span class="number">1</span>; displayNdx &gt;= <span class="number">0</span>; --displayNdx) &#123;</span><br><span class="line">        mTmpRemoteException = <span class="keyword">null</span>;</span><br><span class="line">        mTmpBoolean = <span class="keyword">false</span>; <span class="comment">// Set to true if an activity was started.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> DisplayContent display = getChildAt(displayNdx);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> areaNdx = display.getTaskDisplayAreaCount() - <span class="number">1</span>; areaNdx &gt;= <span class="number">0</span>; --areaNdx) &#123;</span><br><span class="line">            <span class="keyword">final</span> TaskDisplayArea taskDisplayArea = display.getTaskDisplayAreaAt(areaNdx);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> taskNdx = taskDisplayArea.getStackCount() - <span class="number">1</span>; taskNdx &gt;= <span class="number">0</span>; --taskNdx) &#123;</span><br><span class="line">                <span class="keyword">final</span> ActivityStack rootTask = taskDisplayArea.getStackAt(taskNdx);</span><br><span class="line">                <span class="keyword">if</span> (rootTask.getVisibility(<span class="keyword">null</span> <span class="comment">/*starting*/</span>) == STACK_VISIBILITY_INVISIBLE) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="comment">//  RootWindowContainer::startActivityForAttachedApplicationIfNeeded 【见 4.2.11】</span></span><br><span class="line">                <span class="keyword">final</span> PooledFunction c = PooledLambda.obtainFunction(</span><br><span class="line">                        RootWindowContainer::startActivityForAttachedApplicationIfNeeded, <span class="keyword">this</span>,</span><br><span class="line">                        PooledLambda.__(ActivityRecord.class), app,</span><br><span class="line">                        rootTask.topRunningActivity());</span><br><span class="line">                rootTask.forAllActivities(c);</span><br><span class="line">                c.recycle();</span><br><span class="line">                <span class="keyword">if</span> (mTmpRemoteException != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> mTmpRemoteException;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        didSomething |= mTmpBoolean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!didSomething) &#123;</span><br><span class="line">        ensureActivitiesVisible(<span class="keyword">null</span>, <span class="number">0</span>, <span class="keyword">false</span> <span class="comment">/* preserve_windows */</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> didSomething;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-11-RWC-startActivityForAttachedApplicationIfNeeded"><a href="#4-2-11-RWC-startActivityForAttachedApplicationIfNeeded" class="headerlink" title="4.2.11 RWC.startActivityForAttachedApplicationIfNeeded"></a>4.2.11 RWC.startActivityForAttachedApplicationIfNeeded</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">startActivityForAttachedApplicationIfNeeded</span><span class="params">(ActivityRecord r,</span></span></span><br><span class="line"><span class="function"><span class="params">        WindowProcessController app, ActivityRecord top)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r.finishing || !r.okToShowLocked() || !r.visibleIgnoringKeyguard || r.app != <span class="keyword">null</span></span><br><span class="line">            || app.mUid != r.info.applicationInfo.uid || !app.mName.equals(r.processName)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// ActivityStackSupervisor.realStartActivityLocked 【见 5.1】</span></span><br><span class="line">        <span class="keyword">if</span> (mStackSupervisor.realStartActivityLocked(r, app,</span><br><span class="line">                top == r &amp;&amp; r.isFocusable() <span class="comment">/*andResume*/</span>, <span class="keyword">true</span> <span class="comment">/*checkConfig*/</span>)) &#123;</span><br><span class="line">            mTmpBoolean = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">&quot;Exception in new application when starting activity &quot;</span></span><br><span class="line">                + top.intent.getComponent().flattenToShortString(), e);</span><br><span class="line">        mTmpRemoteException = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="五、onCreate"><a href="#五、onCreate" class="headerlink" title="五、onCreate"></a>五、onCreate</h1><h2 id="5-1-ASS-realStartActivityLocked"><a href="#5-1-ASS-realStartActivityLocked" class="headerlink" title="5.1 ASS.realStartActivityLocked"></a>5.1 ASS.realStartActivityLocked</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">realStartActivityLocked</span><span class="params">(ActivityRecord r, WindowProcessController proc,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> andResume, <span class="keyword">boolean</span> checkConfig)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    <span class="keyword">final</span> Task task = r.getTask();</span><br><span class="line">    <span class="keyword">final</span> ActivityStack stack = task.getStack();</span><br><span class="line">    beginDeferResume();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            <span class="keyword">final</span> ClientTransaction clientTransaction = ClientTransaction.obtain(</span><br><span class="line">                    proc.getThread(), r.appToken);</span><br><span class="line">            <span class="keyword">final</span> DisplayContent dc = r.getDisplay().mDisplayContent;</span><br><span class="line">          <span class="comment">// 为 ClientTransaction 对象添加 LaunchActivityItem 的 callback</span></span><br><span class="line">            clientTransaction.addCallback(LaunchActivityItem.obtain(<span class="keyword">new</span> Intent(r.intent),</span><br><span class="line">                    System.identityHashCode(r), r.info,</span><br><span class="line">                    mergedConfiguration.getGlobalConfiguration(),</span><br><span class="line">                    mergedConfiguration.getOverrideConfiguration(), r.compat,</span><br><span class="line">                    r.launchedFromPackage, task.voiceInteractor, proc.getReportedProcState(),</span><br><span class="line">                    r.getSavedState(), r.getPersistentSavedState(), results, newIntents,</span><br><span class="line">                    dc.isNextTransitionForward(), proc.createProfilerInfoIfNeeded(),</span><br><span class="line">                    r.assistToken, r.createFixedRotationAdjustmentsIfNeeded()));</span><br><span class="line">           </span><br><span class="line">            <span class="keyword">final</span> ActivityLifecycleItem lifecycleItem;</span><br><span class="line">          <span class="comment">// 设置当前的生命周期状态</span></span><br><span class="line">          <span class="comment">// andResume 在 4.1 中传递为 true </span></span><br><span class="line">            <span class="keyword">if</span> (andResume) &#123;</span><br><span class="line">                lifecycleItem = ResumeActivityItem.obtain(dc.isNextTransitionForward());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                lifecycleItem = PauseActivityItem.obtain();</span><br><span class="line">            &#125;</span><br><span class="line">            clientTransaction.setLifecycleStateRequest(lifecycleItem);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调用 ClientLifecycleManager.scheduleTransaction 方法 </span></span><br><span class="line">            mService.getLifecycleManager().scheduleTransaction(clientTransaction);</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 <code>ClientLifecycleManager.scheduleTransaction()</code> 方法之后具体是如何执行 请看 <code>[3.1 - 3.8](这里需要记住 3.7 有两个方法 executeCallbacks() executeLifecycleState() 6.1 会用到</code>。之前传入的是 <code>PauseActivityItem</code> ，现在传入的是 <code>LaunchActivityItem</code> ，所以 <code>item.execute</code> 调用的是 <code>LaunchActivityItem.execute()</code> 方法。</p><h2 id="5-2-LAI-execute"><a href="#5-2-LAI-execute" class="headerlink" title="5.2 LAI.execute"></a>5.2 LAI.execute</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(ClientTransactionHandler client, IBinder token,</span></span></span><br><span class="line"><span class="function"><span class="params">        PendingTransactionActions pendingActions)</span> </span>&#123;</span><br><span class="line">    ActivityClientRecord r = <span class="keyword">new</span> ActivityClientRecord(token, mIntent, mIdent, mInfo,</span><br><span class="line">            mOverrideConfig, mCompatInfo, mReferrer, mVoiceInteractor, mState, mPersistentState,</span><br><span class="line">            mPendingResults, mPendingNewIntents, mIsForward,</span><br><span class="line">            mProfilerInfo, client, mAssistToken, mFixedRotationAdjustments);</span><br><span class="line">   <span class="comment">// 调用 ActivityThread.handleLaunchActivity() 方法 【见 5.3】</span></span><br><span class="line">    client.handleLaunchActivity(r, pendingActions, <span class="keyword">null</span> <span class="comment">/* customIntent */</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>3.1.8</code> 分析到这里的 <code>client</code> 是 <code>ActivityThread</code> 所以这里调用的是 <code>ActivityThread.handleLaunchActivity()</code></p><h2 id="5-3-AT-handleLaunchActivity"><a href="#5-3-AT-handleLaunchActivity" class="headerlink" title="5.3 AT.handleLaunchActivity"></a>5.3 AT.handleLaunchActivity</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Activity <span class="title">handleLaunchActivity</span><span class="params">(ActivityClientRecord r,</span></span></span><br><span class="line"><span class="function"><span class="params">        PendingTransactionActions pendingActions, Intent customIntent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  <span class="comment">// 【见 5.4】</span></span><br><span class="line">    <span class="keyword">final</span> Activity a = performLaunchActivity(r, customIntent);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-4-AT-performLaunchActivity"><a href="#5-4-AT-performLaunchActivity" class="headerlink" title="5.4 AT.performLaunchActivity"></a>5.4 AT.performLaunchActivity</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Activity <span class="title">performLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class="line">    ActivityInfo aInfo = r.activityInfo;</span><br><span class="line">    <span class="keyword">if</span> (r.packageInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">        r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo,</span><br><span class="line">                Context.CONTEXT_INCLUDE_CODE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化 ComponentName</span></span><br><span class="line">    ComponentName component = r.intent.getComponent();</span><br><span class="line">    <span class="keyword">if</span> (component == <span class="keyword">null</span>) &#123;</span><br><span class="line">        component = r.intent.resolveActivity(</span><br><span class="line">            mInitialApplication.getPackageManager());</span><br><span class="line">        r.intent.setComponent(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r.activityInfo.targetActivity != <span class="keyword">null</span>) &#123;</span><br><span class="line">        component = <span class="keyword">new</span> ComponentName(r.activityInfo.packageName,</span><br><span class="line">                r.activityInfo.targetActivity);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 初始化 ContextImpl 和 Activity  </span></span><br><span class="line">    ContextImpl appContext = createBaseContextForActivity(r);</span><br><span class="line">    Activity activity = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 初始化 Application</span></span><br><span class="line">        Application app = r.packageInfo.makeApplication(<span class="keyword">false</span>, mInstrumentation);</span><br><span class="line">        <span class="keyword">if</span> (activity != <span class="keyword">null</span>) &#123;</span><br><span class="line">            CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager());</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            r.lastNonConfigurationInstances = <span class="keyword">null</span>;</span><br><span class="line">            checkAndBlockForNetworkAccess();</span><br><span class="line">            activity.mStartedActivity = <span class="keyword">false</span>;</span><br><span class="line">          <span class="comment">// 设置 Activity 的 Theme</span></span><br><span class="line">            <span class="keyword">int</span> theme = r.activityInfo.getThemeResource();</span><br><span class="line">            <span class="keyword">if</span> (theme != <span class="number">0</span>) &#123;</span><br><span class="line">                activity.setTheme(theme);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            activity.mCalled = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (r.isPersistable()) &#123;</span><br><span class="line"><span class="comment">// 调用 Instrumentation.callActivityOnCreate() 方法 【见 5.5】</span></span><br><span class="line">                mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!activity.mCalled) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SuperNotCalledException(</span><br><span class="line">                    <span class="string">&quot;Activity &quot;</span> + r.intent.getComponent().toShortString() +</span><br><span class="line">                    <span class="string">&quot; did not call through to super.onCreate()&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            r.activity = activity;</span><br><span class="line">            mLastReportedWindowingMode.put(activity.getActivityToken(),</span><br><span class="line">                    config.windowConfiguration.getWindowingMode());</span><br><span class="line">        &#125;</span><br><span class="line">        r.setState(ON_CREATE);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (mResourcesManager) &#123;</span><br><span class="line">            mActivities.put(r.token, r);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (SuperNotCalledException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> activity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-5-Ins-callActivityOnCreate"><a href="#5-5-Ins-callActivityOnCreate" class="headerlink" title="5.5 Ins.callActivityOnCreate"></a>5.5 Ins.callActivityOnCreate</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callActivityOnCreate</span><span class="params">(Activity activity, Bundle icicle,</span></span></span><br><span class="line"><span class="function"><span class="params">        PersistableBundle persistentState)</span> </span>&#123;</span><br><span class="line">    prePerformCreate(activity);</span><br><span class="line">    <span class="comment">// 调用 performCreate() 方法 【见 5.6】</span></span><br><span class="line">    activity.performCreate(icicle, persistentState);</span><br><span class="line">    postPerformCreate(activity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-6-Aty-performCreate"><a href="#5-6-Aty-performCreate" class="headerlink" title="5.6 Aty.performCreate"></a>5.6 Aty.performCreate</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">performCreate</span><span class="params">(Bundle icicle, PersistableBundle persistentState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (persistentState != <span class="keyword">null</span>) &#123;</span><br><span class="line">        onCreate(icicle, persistentState);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        onCreate(icicle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此 <code>executeCallbacks()</code> 执行完毕，开始执行 <code>executeLifecycleState()</code> 方法，会先执行 <code>cycleToPath()</code> 方法</p><h1 id="六、onStart、onResume"><a href="#六、onStart、onResume" class="headerlink" title="六、onStart、onResume"></a>六、onStart、onResume</h1><h2 id="6-1-TE-executeLifecycleState"><a href="#6-1-TE-executeLifecycleState" class="headerlink" title="6.1 TE.executeLifecycleState"></a>6.1 TE.executeLifecycleState</h2><p><code>3.7 executeCallbacks</code> 执行完后开始执行 <code>executeLifecycleState</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">executeLifecycleState</span><span class="params">(ClientTransaction transaction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ActivityLifecycleItem lifecycleItem = transaction.getLifecycleStateRequest();</span><br><span class="line">    <span class="comment">// 这里 r 表示 LaunchActivityItem ， lifecycleItem 在 5.1 中所示为 ResumeActivityItem</span></span><br><span class="line">    cycleToPath(r, lifecycleItem.getTargetState(), <span class="keyword">true</span> <span class="comment">/* excludeLastState */</span>, transaction);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cycleToPath</span><span class="params">(ActivityClientRecord r, <span class="keyword">int</span> finish, ClientTransaction transaction)</span> </span>&#123;</span><br><span class="line">    cycleToPath(r, finish, <span class="keyword">false</span> <span class="comment">/* excludeLastState */</span>, transaction);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cycleToPath</span><span class="params">(ActivityClientRecord r, <span class="keyword">int</span> finish, <span class="keyword">boolean</span> excludeLastState,</span></span></span><br><span class="line"><span class="function"><span class="params">        ClientTransaction transaction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> start = r.getLifecycleState();</span><br><span class="line">  <span class="comment">// 计算需要执行那些生命周期 【见 6.2】</span></span><br><span class="line">    <span class="keyword">final</span> IntArray path = mHelper.getLifecyclePath(start, finish, excludeLastState);</span><br><span class="line">  <span class="comment">// 根据 【6.2】 返回执行生命周期 【见 6.3】</span></span><br><span class="line">    performLifecycleSequence(r, path, transaction);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-2-TEH-getLifecyclePath"><a href="#6-2-TEH-getLifecyclePath" class="headerlink" title="6.2 TEH.getLifecyclePath"></a>6.2 TEH.getLifecyclePath</h2><p><code>start</code> 为 <code>ON_CREATE = 1</code> ，<code>finish</code> 为 <code>ON_RESUME = 3</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IntArray <span class="title">getLifecyclePath</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> finish, <span class="keyword">boolean</span> excludeLastState)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    mLifecycleSequence.clear();</span><br><span class="line">    <span class="keyword">if</span> (finish &gt;= start) &#123;<span class="comment">// 3 &gt; 1</span></span><br><span class="line">        <span class="keyword">if</span> (start == ON_START &amp;&amp; finish == ON_STOP) &#123;</span><br><span class="line">            mLifecycleSequence.add(ON_STOP);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 当前情况是走这里，mLifecycleSequence 添加了 2 和 3 也就是 ON_START 和 ON_RESUME</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start + <span class="number">1</span>; i &lt;= finish; i++) &#123;</span><br><span class="line">                mLifecycleSequence.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> mLifecycleSequence;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-3-TE-performLifecycleSequence"><a href="#6-3-TE-performLifecycleSequence" class="headerlink" title="6.3 TE.performLifecycleSequence"></a>6.3 TE.performLifecycleSequence</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">ActivityThread.java</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> TransactionExecutor mTransactionExecutor = <span class="keyword">new</span> TransactionExecutor(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">TransactionExecutor.java</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TransactionExecutor</span><span class="params">(ClientTransactionHandler clientTransactionHandler)</span> </span>&#123;</span><br><span class="line">      mTransactionHandler = clientTransactionHandler;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performLifecycleSequence</span><span class="params">(ActivityClientRecord r, IntArray path,</span></span></span><br><span class="line"><span class="function"><span class="params">          ClientTransaction transaction)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> size = path.size();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, state; i &lt; size; i++) &#123;</span><br><span class="line">          state = path.get(i);</span><br><span class="line">          <span class="keyword">if</span> (DEBUG_RESOLVER) &#123;</span><br><span class="line">              Slog.d(TAG, tId(transaction) + <span class="string">&quot;Transitioning activity: &quot;</span></span><br><span class="line">                      + getShortActivityName(r.token, mTransactionHandler)</span><br><span class="line">                      + <span class="string">&quot; to state: &quot;</span> + getStateName(state));</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="comment">// 有 6.2 所知，这里状态 由 ON_START 到 ON_RESUME</span></span><br><span class="line">        <span class="comment">// 所以会分别执行  mTransactionHandler.handleStartActivity 和 handleResumeActivity</span></span><br><span class="line">          <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">              <span class="keyword">case</span> ON_CREATE:</span><br><span class="line">                  mTransactionHandler.handleLaunchActivity(r, mPendingActions,</span><br><span class="line">                          <span class="keyword">null</span> <span class="comment">/* customIntent */</span>);</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              <span class="keyword">case</span> ON_START:</span><br><span class="line">                  mTransactionHandler.handleStartActivity(r.token, mPendingActions);</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              <span class="keyword">case</span> ON_RESUME:</span><br><span class="line">                  mTransactionHandler.handleResumeActivity(r.token, <span class="keyword">false</span> <span class="comment">/* finalStateRequest */</span>,</span><br><span class="line">                          r.isForward, <span class="string">&quot;LIFECYCLER_RESUME_ACTIVITY&quot;</span>);</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              <span class="keyword">case</span> ON_PAUSE:</span><br><span class="line">                  mTransactionHandler.handlePauseActivity(r.token, <span class="keyword">false</span> <span class="comment">/* finished */</span>,</span><br><span class="line">                          <span class="keyword">false</span> <span class="comment">/* userLeaving */</span>, <span class="number">0</span> <span class="comment">/* configChanges */</span>, mPendingActions,</span><br><span class="line">                          <span class="string">&quot;LIFECYCLER_PAUSE_ACTIVITY&quot;</span>);</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              <span class="keyword">case</span> ON_STOP:</span><br><span class="line">                  mTransactionHandler.handleStopActivity(r.token, <span class="number">0</span> <span class="comment">/* configChanges */</span>,</span><br><span class="line">                          mPendingActions, <span class="keyword">false</span> <span class="comment">/* finalStateRequest */</span>,</span><br><span class="line">                          <span class="string">&quot;LIFECYCLER_STOP_ACTIVITY&quot;</span>);</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              <span class="keyword">case</span> ON_DESTROY:</span><br><span class="line">                  mTransactionHandler.handleDestroyActivity(r.token, <span class="keyword">false</span> <span class="comment">/* finishing */</span>,</span><br><span class="line">                          <span class="number">0</span> <span class="comment">/* configChanges */</span>, <span class="keyword">false</span> <span class="comment">/* getNonConfigInstance */</span>,</span><br><span class="line">                          <span class="string">&quot;performLifecycleSequence. cycling to:&quot;</span> + path.get(size - <span class="number">1</span>));</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              <span class="keyword">case</span> ON_RESTART:</span><br><span class="line">                  mTransactionHandler.performRestartActivity(r.token, <span class="keyword">false</span> <span class="comment">/* start */</span>);</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              <span class="keyword">default</span>:</span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Unexpected lifecycle state: &quot;</span> + state);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><code>mTransactionHandler</code> 如上是 <code>ActivityThread</code> ，所以最终能调用 <code>ActivityThread.handleStartActivity</code></p><p><code>mTransactionHandler.handleStartActivity</code> 和 <code>handleResumeActivity</code> 分别也是对应的 <code>Activity</code> 声明周期的 <code>onStart</code> 和 <code>onResume</code> 。</p><h1 id="七、onStop"><a href="#七、onStop" class="headerlink" title="七、onStop"></a>七、onStop</h1><h2 id="7-1-AT-handleResumeActivity"><a href="#7-1-AT-handleResumeActivity" class="headerlink" title="7.1 AT.handleResumeActivity"></a>7.1 AT.handleResumeActivity</h2><p>为什么分析 <code>onStop</code> 要看 <code>ActivityThread.handleResumeActivity</code> 看代码就知道了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleResumeActivity</span><span class="params">(IBinder token, <span class="keyword">boolean</span> finalStateRequest, <span class="keyword">boolean</span> isForward,</span></span></span><br><span class="line"><span class="function"><span class="params">        String reason)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  <span class="comment">// onResume</span></span><br><span class="line">    <span class="keyword">final</span> ActivityClientRecord r = performResumeActivity(token, finalStateRequest, reason);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  <span class="comment">// 当 MessageQueue 空闲的时候就会执行这个 Handler，即执行完当前 Activity 的 onResume() 方法后执行</span></span><br><span class="line">    Looper.myQueue().addIdleHandler(<span class="keyword">new</span> Idler());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-2-Idler-queueIdle"><a href="#7-2-Idler-queueIdle" class="headerlink" title="7.2 Idler.queueIdle"></a>7.2 Idler.queueIdle</h2><p><code>IdleHandler</code> 是一个回调接口，可以通过 <code>MessageQueue</code> 的 <code>addIdleHandler</code> 添加实现类。当 <code>MessageQueue</code> 中的任务暂时处理完了（没有新任务或者下一个任务延时在之后），这个时候会回调这个接口，返回 <code>false</code> ，那么就会移除它，返回 <code>true</code> 就会在下次 <code>message</code> 处理完了的时候继续回调。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Idler</span> <span class="keyword">implements</span> <span class="title">MessageQueue</span>.<span class="title">IdleHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">queueIdle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ActivityClientRecord a = mNewActivities;</span><br><span class="line">        <span class="keyword">boolean</span> stopProfiling = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (mBoundApplication != <span class="keyword">null</span> &amp;&amp; mProfiler.profileFd != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; mProfiler.autoStopProfiler) &#123;</span><br><span class="line">            stopProfiling = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mNewActivities = <span class="keyword">null</span>;</span><br><span class="line">          <span class="comment">// am 为 ActivityTaskManagerService</span></span><br><span class="line">            IActivityTaskManager am = ActivityTaskManager.getService();</span><br><span class="line">            ActivityClientRecord prev;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (a.activity != <span class="keyword">null</span> &amp;&amp; !a.activity.mFinished) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                      <span class="comment">// 调用 ActivityTaskManagerService.activityIdle() 方法 【见 7.3】</span></span><br><span class="line">                        am.activityIdle(a.token, a.createdConfig, stopProfiling);</span><br><span class="line">                        a.createdConfig = <span class="keyword">null</span>;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                prev = a;</span><br><span class="line">                a = a.nextIdle;</span><br><span class="line">                prev.nextIdle = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">while</span> (a != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stopProfiling) &#123;</span><br><span class="line">            mProfiler.stopProfiling();</span><br><span class="line">        &#125;</span><br><span class="line">        applyPendingProcessState();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-3-ATMS-activityIdle"><a href="#7-3-ATMS-activityIdle" class="headerlink" title="7.3 ATMS.activityIdle"></a>7.3 ATMS.activityIdle</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">activityIdle</span><span class="params">(IBinder token, Configuration config, <span class="keyword">boolean</span> stopProfiling)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mGlobalLock) &#123;</span><br><span class="line">            Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, <span class="string">&quot;activityIdle&quot;</span>);</span><br><span class="line">            <span class="keyword">final</span> ActivityRecord r = ActivityRecord.forTokenLocked(token);</span><br><span class="line">            <span class="keyword">if</span> (r == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">// 调用 ActivityStackSupervisor.activityIdleInternal 方法</span></span><br><span class="line">            mStackSupervisor.activityIdleInternal(r, <span class="keyword">false</span> <span class="comment">/* fromTimeout */</span>,</span><br><span class="line">                    <span class="keyword">false</span> <span class="comment">/* processPausingActivities */</span>, config);</span><br><span class="line">            <span class="keyword">if</span> (stopProfiling &amp;&amp; r.hasProcess()) &#123;</span><br><span class="line">                r.app.clearProfilerIfNeeded();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-4-ASS-activityIdleInternal"><a href="#7-4-ASS-activityIdleInternal" class="headerlink" title="7.4 ASS.activityIdleInternal"></a>7.4 ASS.activityIdleInternal</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">activityIdleInternal</span><span class="params">(ActivityRecord r, <span class="keyword">boolean</span> fromTimeout,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> processPausingActivities, Configuration config)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 暂停 和 结束 Activity 【见 7.5】</span></span><br><span class="line">    processStoppingAndFinishingActivities(r, processPausingActivities, <span class="string">&quot;idle&quot;</span>);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-5-ASS-processStoppingAndFinishingActivities"><a href="#7-5-ASS-processStoppingAndFinishingActivities" class="headerlink" title="7.5 ASS.processStoppingAndFinishingActivities"></a>7.5 ASS.processStoppingAndFinishingActivities</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processStoppingAndFinishingActivities</span><span class="params">(ActivityRecord launchedActivity,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> processPausingActivities, String reason)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;ActivityRecord&gt; readyToStopActivities = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mStoppingActivities.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">final</span> ActivityRecord s = mStoppingActivities.get(i);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> animating = s.isAnimating(TRANSITION | PARENTS,</span><br><span class="line">                ANIMATION_TYPE_APP_TRANSITION | ANIMATION_TYPE_RECENTS);</span><br><span class="line">     </span><br><span class="line">        <span class="keyword">if</span> (!animating || mService.mShuttingDown) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!processPausingActivities &amp;&amp; s.isState(PAUSING)) &#123;</span><br><span class="line">                removeIdleTimeoutForActivity(launchedActivity);</span><br><span class="line">                scheduleIdleTimeout(launchedActivity);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (readyToStopActivities == <span class="keyword">null</span>) &#123;</span><br><span class="line">                readyToStopActivities = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 添加需要 stop 的 activity</span></span><br><span class="line">            readyToStopActivities.add(s);</span><br><span class="line"></span><br><span class="line">            mStoppingActivities.remove(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> numReadyStops = readyToStopActivities == <span class="keyword">null</span> ? <span class="number">0</span> : readyToStopActivities.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numReadyStops; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> ActivityRecord r = readyToStopActivities.get(i);</span><br><span class="line">        <span class="keyword">if</span> (r.isInHistory()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r.finishing) &#123;</span><br><span class="line">                r.destroyIfPossible(reason);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r.stopIfPossible();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-6-AR-stopIfPossible"><a href="#7-6-AR-stopIfPossible" class="headerlink" title="7.6 AR.stopIfPossible"></a>7.6 AR.stopIfPossible</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stopIfPossible</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        EventLogTags.writeWmStopActivity(</span><br><span class="line">                mUserId, System.identityHashCode(<span class="keyword">this</span>), shortComponentName);</span><br><span class="line">        <span class="comment">// 熟悉的代码 之前 3.1 和 5.1 都调用过，这里传递的是 StopActivityItem</span></span><br><span class="line">        mAtmService.getLifecycleManager().scheduleTransaction(app.getThread(), appToken,</span><br><span class="line">                StopActivityItem.obtain(configChangeFlags));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (stack.shouldSleepOrShutDownActivities()) &#123;</span><br><span class="line">            setSleeping(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mAtmService.mH.postDelayed(mStopTimeoutRunnable, STOP_TIMEOUT);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 <code>ClientLifecycleManager.scheduleTransaction()</code> 方法之后具体是如何执行 请看 <code>[3.1 - 3.8]</code> ，所以在 <code>executeCallbacks()</code> 方法中 <code>item.execute</code> 调用的是 <code>StopActivityItem.execute()</code> 方法。和 <code>5.2</code> 类似，具体代码就不贴了。</p><p>至此，启动一个 <code>Activity</code> 所需要的生命周期全部走完。</p><h1 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h1><p>这个图画的煞费苦心 <a href="https://gitee.com/CalmCenter/Pic/raw/master/android/android_activity.png">大图</a></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/android/android_activity.png" alt="AndroidActivity"></p><h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h1><p>因为 11 的资料太少，现在只能根据 10 的代码分析来分析 11 的逻辑。</p><p>两个版本只有部分不同，大部分代码逻辑都是相同的。</p><p><a href="http://gityuan.com/2016/03/12/start-activity/">startActivity启动过程分析</a> 仿照源码书写格式</p><p><a href="https://segmentfault.com/a/1190000022672032">【 Android 10 四大组件 】系列 – Activity 的 “启动流程”</a></p><p><a href="https://juejin.cn/post/6844904145191698439">深入理解Android 之 Activity启动流程（Android 10）</a></p><p><a href="https://blog.csdn.net/yu749942362/article/details/107978083">Android11中Activity的启动流程—从startActivity到onCreate</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>熟悉的陌生人 Context</title>
      <link href="2020/android-framework-context.html"/>
      <url>2020/android-framework-context.html</url>
      
        <content type="html"><![CDATA[<p>遇事不决看注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Interface to global information about an application environment.  This is</span></span><br><span class="line"><span class="comment"> * an abstract class whose implementation is provided by</span></span><br><span class="line"><span class="comment"> * the Android system.  It</span></span><br><span class="line"><span class="comment"> * allows access to application-specific resources and classes, as well as</span></span><br><span class="line"><span class="comment"> * up-calls for application-level operations such as launching activities,</span></span><br><span class="line"><span class="comment"> * broadcasting and receiving intents, etc.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br></pre></td></tr></table></figure><p><code>Context</code> 提供了关于应用环境全局信息的接口。（它描述一个应用程序环境的信息（即上下文））</p><p>它是一个抽象类，它的执行被 <code>Android</code> 系统所提供。（是一个抽象类，Android提供了该抽象类的具体实现类；）</p><p>它允许获取以应用为特征的资源和类型，是一个统领一些资源（应用程序环境变量等）的上下文。（通过它我们可以获取应用程序的资源和类（包括应用级别操作，如启动Activity，发广播，接受Intent等））。</p><p>通过查看，可以发现 <code>Context</code> 整体结构如下：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/android/android_context.jpg" alt=""></p><ol><li><strong>ContextImpl：</strong><ul><li><code>Application/Activity/Service</code> 通过 <code>attach()</code> 调用父类 <code>ContextWrapper</code> 的 <code>attachBaseContext()</code> ，从而设置父类成员变量 <code>mBase</code> 为<code>ContextImpl</code> 对象；</li><li><code>ContextWrapper</code> 的核心工作都是交给 <code>mBase</code> (即 <code>ContextImpl</code> ) 来完成；</li></ul></li><li><strong>Application：</strong> 四大组件属于某一 <code>Application</code>，获取所在 <code>Application</code> ：<ul><li><strong>Activity/Service ：</strong> 是通过调用其方法 <code>getApplication()</code> ，可主动获取当前所在 <code>mApplication</code>；<ul><li><code>mApplication</code> 是由 <code>LoadedApk.makeApplication()</code> 过程所初始化的；</li></ul></li><li><strong>Receiver：</strong> 是通过其方法 <code>onReceive()</code> 的第一个参数指向通当前所在 <code>Application</code> ，也就是只有接收到广播的时候才能拿到当前的 <code>Application</code> 对象；</li><li><strong>provider：</strong> 目前没有提供直接获取当前所在 <code>Application</code> 的方法， 但可通过 <code>getContext()</code> 可以获取当前的 <code>ContextImpl</code> ；</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 编译基础</title>
      <link href="2020/android-compilation-basis.html"/>
      <url>2020/android-compilation-basis.html</url>
      
        <content type="html"><![CDATA[<h1 id="Apk-组成"><a href="#Apk-组成" class="headerlink" title="Apk 组成"></a>Apk 组成</h1><p><code>apk</code> 其实就是一个压缩文件，把文件的后缀改成 <code>.zip</code> 就可以用 <code>windows</code> 解压软件解压了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/android/android_compilation.png" alt=""></p><ul><li><p><strong>AndroidManifest.xml：</strong><code>App</code> 的目录，它记录了 <code>App</code> 的名称、权限、组件等的配置信息。</p></li><li><p><strong>classes.dex：</strong><code>Android</code> 平台上的可执行文件，它由 <code>.java</code> 源文件生成 <code>.class</code> 文件，<code>.class</code> 进一步生成 <code>.dex</code> 文件，如果做了分包处理，可能会有 <code>classes1、classes2 …</code> 。</p></li><li><p><strong>resources.arsc：</strong>资源索引表，包含编译后的二进制文件，每当在 <code>res</code> 文件夹下放一个文件时，<code>aapt</code> 就会自动生成对应的 <code>id</code> 并保存在 <code>.R</code> 文件中，但 <code>.R</code> 文件仅仅只是保证编译程序不会报错，实际上在应用运行时，系统会根据 <code>ID</code> 寻找对应的资源路径，而 <code>resources.arsc</code> 文件就是用来记录这些 <code>ID</code> 和 资源文件位置对应关系 的文件。</p><blockquote><p>Android 资源管理框架又是如何快速定位到最匹配资源的？</p><ol><li><strong>资源 ID 文件 R.java：</strong>赋予每一个非 <code>assets</code> 资源一个 <code>ID</code> 值，这些 <code>ID</code> 值以常量的形式定义在 <code>R.java</code> 文件中。</li><li><strong>资源索引表 resources.arsc：</strong>用来描述那些具有 <code>ID</code> 值的资源的配置信息。</li></ol></blockquote></li><li><p><strong>res：</strong>资源文件夹，<code>res/animator</code>、<code>res/anim</code>、<code>res/color</code>、<code>res/drawable（非Bitmap文件，即非.png、.9.png、.jpg、.gif文件）</code>、<code>res/layout</code>、<code>res/menu</code>、<code>res/values</code> 和 <code>res/xml</code> 的资源文件均会从文本格式的 <code>XML</code> 文件编译成二进制格式的<code>XML</code> 文件，<code>resources.arsc</code>  包含的二进制文件就是这些。</p><blockquote><p>为什么 XML 资源文件要从文本格式编译成二进制格式？</p><ol><li><strong>空间占用更小：</strong>这是由于所有 <code>XML</code> 元素的标签、属性名称、属性值和内容所涉及到的字符串都会被统一收集到一个字符串资源池中去，并且会去重。有了这个字符串资源池，原来使用字符串的地方就会被替换成一个索引到字符串资源池的整数值，从而可以减少文件的大小。</li><li><strong>解析速度更快：</strong>这是由于二进制格式的 <code>XML</code> 元素里面不再包含有字符串值，因此就避免了进行字符串解析，从而提高速度。</li></ol></blockquote></li></ul><ul><li><p><strong>assets：</strong>额外建立的资源文件夹。<code>res</code> 和 <code>assets</code> 的不同在于 <code>res</code> 目录下的文件会在 <code>.R</code> 文件中生成对应的资源 <code>ID</code>，而 <code>assets</code> 不会自动生成对应的 <code>ID</code>，而是通过 <code>AssetManager</code> 类的接口来获取。(没有则不会生成)</p></li><li><p><strong>lib：</strong> 存放的是 <code>ndk</code> 编出来的 <code>so</code> 库。(没有则不会生成)</p></li><li><p><strong>META-INF：</strong>签名文件夹，用于保存 <code>App</code> 的签名和校验信息（当生成 <code>APK</code> 包时，系统会对包中的所有内容做一次校验，然后将结果保存在这里。而手机在安装这一 <code>App</code> 时还会对内容再做一次校验，并和 <code>META-INF</code> 中的值进行比较，以避免 <code>APK</code> 被恶意篡改。），里面存放三个主要文件，有两个是对资源文件做的 <code>SHA1 hash</code> 处理，一个是签名和公钥证书，把这三个文件删了就是一个未签名的 <code>APK</code> 。</p><ul><li><p><strong>MANIFEST.MF：</strong>每一个资源文件都有一个对应的 <code>SHA1-Digest</code> 签名。<code>(SHA1 或者 SHA256)</code></p></li><li><p><strong>CERT.SF：</strong> 开头的 <code>SHA1-Digest-Manifest</code> 为 <code>MANIFEST.MF</code> 文件的 <code>SHA1</code> 经过 <code>base64</code> 编码的结果，之后的内容为 <code>MANIFEST.MF</code> 文件中的每项再次 <code>SHA1</code> 经过 <code>base64</code> 编码后的值。<code>(SHA1 或者 SHA256)</code></p></li><li><p><strong>CERT.RSA：</strong>其中包含了公钥、加密算法等信息。首先，对前一步生成的 <code>CERT.SF</code> 使用了 <code>SHA1</code>生成了数字摘要并使用了 <code>RSA</code> 加密，接着，利用了开发者私钥进行签名。然后，在安装时使用公钥解密。最后，将其与未加密的摘要信息（<code>MANIFEST.MF</code>文件）进行对比，如果相符，则表明内容没有被修改。<code>(SHA1 或者 SHA256)</code></p><blockquote><p>公钥加密，私钥解密的过程，称为 <strong>加密</strong>  </p><p>私钥加密，公钥解密的过程，称为 <strong>签名</strong></p></blockquote></li></ul></li></ul><h1 id="编译打包过程"><a href="#编译打包过程" class="headerlink" title="编译打包过程"></a>编译打包过程</h1><p>首先查看一下官方的编译打包流程图</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/android/android_com_1.jpg" alt=""></p><p>详细打包图</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/android/android_com_3.png" alt=""></p><p>通过上图可将打包分为 7 个步骤</p><ol><li><strong>AAPT(Asset Packaging Tool)：</strong>资源文件（包括 <code>AndroidManifest.xml</code>、布局文件、各种 <code>xml</code> 资源等等）将被 <code>AAPT</code>（<code>Android Gradle Plugin 3.0.0</code> 及之后使用 <code>AAPT2</code> 替代了 <code>AAPT</code>）处理为最终的 <code>resources.arsc</code>，并生成 <code>R.java</code> 文件以保证源码编写时可以方便地访问到这些资源。</li><li><strong>AIDL(Android Interface Description Language)：</strong><code>.aidl</code> 文件通过 <code>AIDL</code> 工具转换成编译器能够处理的 <code>Java</code> 接口文件</li><li><strong>Java Compiler：</strong>编译 <code>R.java</code>、<code>Java</code> 接口文件、<code>Java</code> 源文件，最终它们会统一被编译成 <code>.class</code> 文件。</li><li><strong>dex：</strong>将 <code>.class</code> 文件通过 <code>dex</code> 工具将它们转化为 <code>Dalvik</code> 所能识别的 <code>.dex</code> 文件。</li><li><strong>ApkBuilder：</strong>将生成的 <code>.dex</code> 文件、<code>lib</code> 文件、资源文件等，通过 <code>apkbuilder</code> 生成未签名的 <code>.apk</code> 文件</li><li><strong>Jarsigner：</strong>通过签名工具 <code>Jarsigner</code> 或者其它签名工具对 APK 进行签名得到签名后的 <code>APK</code></li><li><strong>zipalign：</strong>用 <code>ZipAlign</code> 工具进行对齐处理，以提高程序的加载和运行速度。（不进行对齐处理是不能发布到 <code>Google Market</code> 的）</li></ol><p>具体命令请看 <a href="https://www.cnblogs.com/sjm19910902/p/6416022.html">Android应用程序（APK）的编译打包过程</a></p><p>更加详细的旧版打包图</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/android/android_com_2.webp" alt=""></p><h1 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h1><p><strong>什么是签名？</strong></p><p>如果把这个问题放在生活中，签名的意思就很好理解了，就是在某处写下自己名字，作为自己特殊的标识，当别人开到这个签名时，就知道这是和你有关，而不是其他人。</p><p>在 <code>Android</code> 开发中也是一样的道理，通过数字签名来标识作者和应用程序之间的信任关系，保证 <code>APK</code> 不被他人篡改，用私钥根据 <code>APK</code> 内容在 <code>APK</code> 中写入一个 <code>指纹</code> ，如果 <code>APK</code> 中有任何修改，都会导致这个指纹无效，<code>Android</code> 系统在安装是进行签名校验就会不通过。</p><p> <code>Android</code> 系统要求每一个 <code>Android</code> 应用程序必须要经过数字签名才能够安装到系统中，也就是说如果一个 <code>Android</code> 应用程序没有经过数字签名，是没有办法安装到系统中的，在日常开发中 <code>Android Studio</code> 会给一个默认的 <code>debug.keystore</code> 文件，专门用于日常开发使用，具体目录是 <code>C:\User\&lt;用户名&gt;\.android\debug.keystore</code> ，所以 <code>Android Studio</code> 在编译时就会用这个默认的 <code>debug.keystore</code> 进行签名打包，就可以安装啦。</p><h1 id="如何有效地做签名校验？"><a href="#如何有效地做签名校验？" class="headerlink" title="如何有效地做签名校验？"></a>如何有效地做签名校验？</h1><p>常见的签名校验方法如下，使用了 <a href="https://github.com/Blankj/AndroidUtilCode">AndroidUtilCode</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doNormalSignCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String trueSignMD5 = <span class="string">&quot;95:21:D9:10:2B:C6:56:1F:4D:93:25:17:71:65:14:8A&quot;</span>;</span><br><span class="line">    String appSignatureMD5 = AppUtils.getAppSignatureMD5();</span><br><span class="line">    <span class="keyword">return</span> trueSignMD5.equals(appSignatureMD5);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Signature[] getAppSignature(<span class="keyword">final</span> String packageName) &#123;</span><br><span class="line">    <span class="keyword">if</span> (UtilsBridge.isSpace(packageName)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        PackageManager pm = Utils.getApp().getPackageManager();</span><br><span class="line">        <span class="meta">@SuppressLint(&quot;PackageManagerGetSignatures&quot;)</span></span><br><span class="line">        PackageInfo pi = pm.getPackageInfo(packageName, PackageManager.GET_SIGNATURES);</span><br><span class="line">        <span class="keyword">return</span> pi == <span class="keyword">null</span> ? <span class="keyword">null</span> : pi.signatures;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>系统将应用的签名信息封装在 <code>PackageInfo</code> 中，调用 <code>PackageManager</code> 的 <code>getPackageInfo(String packageName, int flags)</code> 即可获取指定包名的签名信息。</p><p>然后我们使用「M* 管理器」，破解验证！（由于这个功能是收费的！让很多小伙伴望而却步，包括我，但是我不服输，于是下面的图来自于 <a href="https://www.jianshu.com/p/7c62fb84e0bc">Android APK：为何你的应用老是被破解，该如何有效地做签名校验？</a> ）</p><p><img src= "/img/loading.gif" data-lazy-src="https://upload-images.jianshu.io/upload_images/1095900-03cafc10d11fecd7?imageMogr2/auto-orient/strip%7CimageView2/2/w/512/format/webp" alt=""></p><p>明明已经提示签名不一致了，但是签名校验还是通过了，我是自己将反编译后的代码写入了自己的程序中，看看有啥不一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> android.app.Application;</span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.content.pm.PackageInfo;</span><br><span class="line"><span class="keyword">import</span> android.content.pm.PackageManager;</span><br><span class="line"><span class="keyword">import</span> android.content.pm.Signature;</span><br><span class="line"><span class="keyword">import</span> android.util.Base64;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.DataInputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HookApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> GET_SIGNATURES = <span class="number">64</span>;</span><br><span class="line">    <span class="keyword">private</span> String appPkgName = BuildConfig.FLAVOR;</span><br><span class="line">    <span class="keyword">private</span> Object base;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[][] sign;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">hook</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            DataInputStream dataInputStream = <span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> ByteArrayInputStream(Base64.decode(<span class="string">&quot;AQAAAskwggLFMIIBraADAgECAgQncO4WMA0GCSqGSIb3DQEBCwUAMBMxETAPBgNVBAMTCGRlbW9k\nZW1vMB4XDTIwMDExOTEwNTA1MloXDTQ1MDExMjEwNTA1MlowEzERMA8GA1UEAxMIZGVtb2RlbW8w\nggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCJUC42nO6yvO0hG5SVceKgRPjHm34VMBEi\nN/8WAYA2sdXJ8JvpT2VV0aBVat+KqKwXSgxLxMs9+HtBCEohjQbrRa5HqUTrVmgFLGTLMBCBSsAo\nflol3wVHhdxYZRjlq9mki5bjTPawBCFMgPPH0rTC7c93m6u0PoveN+Nac0SKv3i3LsHxu6YJvbqp\nK1EH5gxoN9aDTz3WGqg+Kmti7VYUlgyA573ZjULWfjblN1r1megtKcPUPxkXqR4zkWAtZt4ddMKE\nAwDcc6QAE3JfvsJtcTnMpMoqmlpy/z08XyP01WMnOqREvsyMuWVVlGXDgaWBXSxIGs3QgOU0xbWM\n9SGpAgMBAAGjITAfMB0GA1UdDgQWBBR38YijC32IoCPUrwSx1LtpKpqXNjANBgkqhkiG9w0BAQsF\nAAOCAQEARlRfoZsS7ckIefGK4jbF+sJD5ltX4SU8iLIqR4+qAWqlWNSAj0/JGEWw7lwyN3iYfHCr\nWBXksPTyJ0KrOza5OYpdLqxSUrzHOzoiS/zz7h9+PgwXABFj6Xa9SJeAV+svdKEmaQw/juYB9ofS\njAXHgJtoL5eBZdqVA2s5mVTWazcHC5Sqh60xn3e3d9VNhAmWpIZEbPWHuVJRO1vigJe6mKxpQ5Y+\nmfYJaC99NAFqZU/Ngb7MecisJ8wuTGhA59ztZuE7c4d1uLPGoZBISfvih+ZedFvbzf6jGOC7CpqI\nb79SoBuKi/Yebs+557NdedQWtiHkMgFE5QKo1ut997J4qQ==\n&quot;</span>, <span class="number">0</span>)));</span><br><span class="line">            <span class="keyword">byte</span>[][] bArr = <span class="keyword">new</span> <span class="keyword">byte</span>[(dataInputStream.read() &amp; <span class="number">255</span>)][];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bArr.length; i++) &#123;</span><br><span class="line">                bArr[i] = <span class="keyword">new</span> <span class="keyword">byte</span>[dataInputStream.readInt()];</span><br><span class="line">                dataInputStream.readFully(bArr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            Class&lt;?&gt; cls = Class.forName(<span class="string">&quot;android.app.ActivityThread&quot;</span>);</span><br><span class="line">            Object invoke = cls.getDeclaredMethod(<span class="string">&quot;currentActivityThread&quot;</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]).invoke((Object) <span class="keyword">null</span>, <span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">            Field declaredField = cls.getDeclaredField(<span class="string">&quot;sPackageManager&quot;</span>);</span><br><span class="line">            declaredField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            Object obj = declaredField.get(invoke);</span><br><span class="line">            Class&lt;?&gt; cls2 = Class.forName(<span class="string">&quot;android.content.pm.IPackageManager&quot;</span>);</span><br><span class="line">            <span class="keyword">this</span>.base = obj;</span><br><span class="line">            <span class="keyword">this</span>.sign = bArr;</span><br><span class="line">            <span class="keyword">this</span>.appPkgName = context.getPackageName();</span><br><span class="line">            Object newProxyInstance = Proxy.newProxyInstance(cls2.getClassLoader(), <span class="keyword">new</span> Class[]&#123;cls2&#125;, <span class="keyword">this</span>);</span><br><span class="line">            declaredField.set(invoke, newProxyInstance);</span><br><span class="line">            PackageManager packageManager = context.getPackageManager();</span><br><span class="line">            Field declaredField2 = packageManager.getClass().getDeclaredField(<span class="string">&quot;mPM&quot;</span>);</span><br><span class="line">            declaredField2.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            declaredField2.set(packageManager, newProxyInstance);</span><br><span class="line">            System.out.println(<span class="string">&quot;PmsHook success.&quot;</span>);</span><br><span class="line">            Log.e(<span class="string">&quot;Sign&quot;</span>,<span class="string">&quot;PmsHook success.&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;PmsHook failed.&quot;</span>);</span><br><span class="line">            Log.e(<span class="string">&quot;Sign&quot;</span>,<span class="string">&quot;PmsHook failed.&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* access modifiers changed from: protected */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attachBaseContext</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        hook(context);</span><br><span class="line">        <span class="keyword">super</span>.attachBaseContext(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Method method, Object[] objArr)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;getPackageInfo&quot;</span>.equals(method.getName())) &#123;</span><br><span class="line">            String str = (String) objArr[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> (((Integer) objArr[<span class="number">1</span>] &amp; <span class="number">64</span>) != <span class="number">0</span> &amp;&amp; <span class="keyword">this</span>.appPkgName.equals(str)) &#123;</span><br><span class="line">                PackageInfo packageInfo = (PackageInfo) method.invoke(<span class="keyword">this</span>.base, objArr);</span><br><span class="line">                packageInfo.signatures = <span class="keyword">new</span> Signature[<span class="keyword">this</span>.sign.length];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; packageInfo.signatures.length; i++) &#123;</span><br><span class="line">                    packageInfo.signatures[i] = <span class="keyword">new</span> Signature(<span class="keyword">this</span>.sign[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> packageInfo;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>.base, objArr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>继承自 <code>Application</code>，重写了 <code>attachBaseContext</code> 来调用 <code>hook(context)</code> ，在里面做了 <code>IPackageManager</code> 的动态代理，实现在调用 <code>getPackageInfo</code> 方法的时候，修改 <code>signatures[]</code> 为在破解之前计算好的数值( <code>DataInputStream</code> 里的值为破解时动态生成的，最终输入 <code>signatures</code> 的就是 <code>95:21:D9:10:2B:C6:56:1F:4D:93:25:17:71:65:14:8A</code>)。</p><p><a href="https://www.jianshu.com/p/7c62fb84e0bc">Android APK：为何你的应用老是被破解，该如何有效地做签名校验？</a></p><p><a href="https://blog.csdn.net/u011195398/article/details/84567580">Android中如何进行签名校验和完整性校验</a></p><p><a href="https://blog.csdn.net/hp910315/article/details/77684725">Android签名验证原理解析</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin 笔记</title>
      <link href="2020/awesome-kotlin-node.html"/>
      <url>2020/awesome-kotlin-node.html</url>
      
        <content type="html"><![CDATA[<p>自 <code>2017</code> 年 <code>kotlin</code> 成为 <code>Android</code> 开发一级语言，也没有认真总结，一直对 <code>kotlin</code> 的骚操作没有足够的认知，这篇文从就是提升对 <code>kotlin</code> 骚操作的认知 ~ 。</p><h1 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h1><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age: <span class="built_in">Int</span> = <span class="number">18</span></span><br><span class="line"><span class="keyword">val</span> name = <span class="string">&quot;台风眼&quot;</span> <span class="comment">// 如果赋值 可以不用声明类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> name2:String = <span class="literal">null</span> <span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">var</span> name2: String? = <span class="literal">null</span> <span class="comment">// 编译通过   ? 表示可以为 null </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    name = name2 <span class="comment">// 编译报错 因为 name2 可以为 null ，name 不可以为 null 所以不能赋值</span></span><br><span class="line">    </span><br><span class="line">    name = name2!! <span class="comment">// 编译通过 !! 表示 name2 确定不可能为 null</span></span><br><span class="line">    </span><br><span class="line">    name2 = name <span class="comment">// 编译通过 name2 包含的范围比 name 大</span></span><br><span class="line">    </span><br><span class="line">    println(<span class="string">&quot;年龄:<span class="variable">$age</span>&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;名字:<span class="variable">$name</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java-与-Kotlin-交互"><a href="#Java-与-Kotlin-交互" class="headerlink" title="Java 与 Kotlin 交互"></a>Java 与 Kotlin 交互</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Utils.kt</span></span><br><span class="line"><span class="function">fun <span class="title">echo</span><span class="params">(name:String)</span></span>&#123;</span><br><span class="line">    print(name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Main.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    UtilsKt.echo(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Kotlin</code> 函数直接可以写在文件里，不需要写在类里（但是编译后依旧是在类里），<code>Java</code> 在调用 <code>Kotlin</code> 文件时，只需要在 文件名 后加上 <code>kt</code> 如上 <code>UtilsKt</code> 。<code>Utils</code> 文件中的所有函数和类型变量，最终编译后都会被 <code>public static</code> 修饰。</p><p>匿名内部类的调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Utils.kt 匿名内部类</span></span><br><span class="line">object StaticTest &#123;</span><br><span class="line">    <span class="function">fun <span class="title">sayMessage</span><span class="params">(msg: String)</span> </span>&#123;</span><br><span class="line">        println(msg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Kotlin</span></span><br><span class="line">StaticTest.sayMessage(<span class="string">&quot;1&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Java</span></span><br><span class="line">StaticTest.INSTANCE.sayMessage(<span class="string">&quot;1&quot;</span>);</span><br></pre></td></tr></table></figure><p><code>Class</code> 的调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Utils.kt</span></span><br><span class="line"><span class="function">fun <span class="title">testClass</span><span class="params">(clazz: Class&lt;JavaMain&gt;)</span></span>&#123;</span><br><span class="line">    println(clazz.simpleName)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Kotlin</span></span><br><span class="line">testClass(JavaMain::class.java)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Java</span></span><br><span class="line">UtilsKt.testClass(JavaMain.class);</span><br></pre></td></tr></table></figure><p>这是为什么呢？这是因为 <code>Kotlin</code> 与 <code>Java</code> 的 <code>Class</code> 格式是不一致的。<code>Kotlin Class</code> 类型是 <code>KClass</code> 。</p><p> 当 <code>Java</code> 的变量使用到了 <code>Kotlin</code> 的关键字时， <code>Kotlin</code> 调用这个变量需要加上 ``` ` </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JavaMain.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> in = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Kotlin</span></span><br><span class="line">JavaMain.`in`</span><br></pre></td></tr></table></figure><h2 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h2><h3 id="Kotlin-没有封装类"><a href="#Kotlin-没有封装类" class="headerlink" title="Kotlin 没有封装类"></a>Kotlin 没有封装类</h3><p>封装类是什么？就是 <code>Java</code> 中的 <code>Integer、String</code> 等。</p><p><code>Java</code> 中的封装类在 <code>Kotlin</code> 都会转换成基本数据类型调用</p><p>比如 <code>Java</code> 中有这么一个接口，然后用 <code>Java</code> 的类去实现接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">putNumber</span><span class="params">(<span class="keyword">int</span> num)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">putNumber</span><span class="params">(Integer num)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">AInterface</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">putNumber</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;int&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">putNumber</span><span class="params">(Integer num)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Integer&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Kotlin</code> 在调用调用的时候，提示用只有 <code>Kotlin</code> 的 <code>Int</code> 类型。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/android/android_kotlin.packaging.png" alt=""></p><p>最终的打印也只能打印出 <code>int</code> 。而且如果 <code>A</code> 是一个 <code>Kotlin</code>  类的话，重写方法也只能重写一个，否则会报错。</p><p><strong>说明 <code>Kotlin</code> 在运行时只会执行它基本数据类型的那个方法，而不会执行封装类型的方法 。<code>Kolin</code> 只有 <code>Int</code> 没有 <code>Integer</code> 类型。</strong></p><h3 id="Kotlin-类型空值敏感"><a href="#Kotlin-类型空值敏感" class="headerlink" title="Kotlin 类型空值敏感"></a>Kotlin 类型空值敏感</h3><p>通过一段代码说明，首先 <code>Java</code> 有一端这样的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">format</span><span class="params">(String string)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> string.isEmpty() ? <span class="keyword">null</span> : string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Kotlin</code> 去调用</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fmt1 = A.format(str) <span class="comment">//String!</span></span><br><span class="line"><span class="keyword">var</span> fmt2:String = A.format(str)</span><br><span class="line"><span class="keyword">var</span> fmt3:String? = A.format(str)</span><br></pre></td></tr></table></figure><p>分别有三种返回类型接收，</p><p>第一种是编译器自动推断的返回 <code>String!</code> ，这个类型只会在 <code>Kotlin</code> 互相调用的时候才会出现，我们是不可以手动声明这个类型的。</p><p>第二种是手动声明的 <code>String</code> 没有任何符号，第三种是一种可空的类型 <code>String?</code></p><p>如果我们将 <code>str =&quot;&quot;</code> ，那么 <code>fmt2</code> 将会报错，因为，我们返回的是一个 <code>null</code> 但是 <code>String</code> 却不能为空，所以会报 <code>IllegalStateException：format(str) must not be null</code></p><p>但是这并不表示其他返回类型就是可靠的，如果我们在分别调用一个方法</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">println(fmt1.length)</span><br><span class="line">println(fmt3?.length)</span><br></pre></td></tr></table></figure><p>执行发现 <code>fmt1.length</code> 会报空指针，因为 <code>String!</code> 是一个兼容类型，只能临时的使用它，但是如果调用这个值的方法，它会和 <code>Java</code> 语法调用一样去执行，在 <code>Java</code> 中 <code>null</code> 调用任何方法都会报错。</p><p>而 <code>fmt3.length</code> 不会报错，会输出一个 <code>null</code> 字符串</p><p><strong>说明，如果在赋值的时候我们不确定一个返回值是否为 <code>null</code> ，一定要赋值为可控类型 <code>String?</code> ，这要代码才能可靠。</strong></p><h3 id="Kotlin-没有静态变量与静态方法"><a href="#Kotlin-没有静态变量与静态方法" class="headerlink" title="Kotlin 没有静态变量与静态方法"></a>Kotlin 没有静态变量与静态方法</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Utils.kt 匿名内部类</span></span><br><span class="line"><span class="keyword">object</span> StaticTest &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sayMessage</span><span class="params">(msg: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        println(msg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Kotlin</span></span><br><span class="line">StaticTest.sayMessage(<span class="string">&quot;1&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Java</span></span><br><span class="line">StaticTest.INSTANCE.sayMessage(<span class="string">&quot;1&quot;</span>);</span><br></pre></td></tr></table></figure><p>这是上面讲过的一段代码，如果我们想让 <code>Java</code> 调用方式和 <code>Kotlin</code> 一样，或者说 <code>sayMessage</code> 编译后生成的是 <code>public static</code> 的方法。我们可以加入 <code>@JvmStatic</code> 就可以了。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Utils.kt 匿名内部类</span></span><br><span class="line"><span class="keyword">object</span> StaticTest &#123;</span><br><span class="line">    <span class="meta">@JvmStatic</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sayMessage</span><span class="params">(msg: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        println(msg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Kotlin</span></span><br><span class="line">StaticTest.sayMessage(<span class="string">&quot;1&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Java</span></span><br><span class="line">StaticTest.sayMessage(<span class="string">&quot;1&quot;</span>);</span><br></pre></td></tr></table></figure><h1 id="函数-与-Lambda-闭包"><a href="#函数-与-Lambda-闭包" class="headerlink" title="函数 与 Lambda 闭包"></a>函数 与 Lambda 闭包</h1><h2 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">echo</span><span class="params">(name: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    print(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>kotlin</code> 语法可以给参数设置默认值，在 <code>kotlin</code> 调用的时候可以不传参数使用默认值。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">echo</span><span class="params">(name: <span class="type">String</span> = <span class="string">&quot;CalmCenter&quot;</span>)</span></span> &#123;</span><br><span class="line">    print(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认参数<strong>通常用于重载函数过多时，默认参数可以大大减小重载函数的数量</strong></p><p>当函数体只有一个语句是，可以将语句赋值给这个函数</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">echo3</span><span class="params">(name: <span class="type">String</span> = <span class="string">&quot;CalmCenter&quot;</span>)</span></span> = print(name)</span><br></pre></td></tr></table></figure><h2 id="内部函数"><a href="#内部函数" class="headerlink" title="内部函数"></a>内部函数</h2><p>内部函数可以访问外部函数的局部变量，<strong>通常用在某些条件下触发递归的函数，或者不希望被外部函数访问到的函数</strong>。会降低代码的可读性</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">function</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> str = <span class="string">&quot;hello world&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">say</span><span class="params">(count: <span class="type">Int</span> = <span class="number">10</span>)</span></span> &#123;</span><br><span class="line">        println(str)</span><br><span class="line">        <span class="comment">// 条件递归</span></span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            say(count - <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    say()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩展函数"><a href="#扩展函数" class="headerlink" title="扩展函数"></a>扩展函数</h2><p>扩展函数书写方式，既然是函数肯定得 <code>fun</code> ，后面跟随 <code>需要扩展的类名.需要扩展的成员方法</code></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> File.<span class="title">readText</span><span class="params">(charset: <span class="type">Charset</span> = Charsets.UTF_8)</span></span>: String =</span><br><span class="line">        readBytes().toString(charset)</span><br></pre></td></tr></table></figure><p>这是 <code>FileReadWrite.kt</code> 中的一段代码，用来扩展 <code>File</code> 类。</p><p>在 <code>kotlin</code> 中的调用方式和 <code>File</code> 本身的成员函数使用方法相同，但这个函数是使用扩展函数<strong>静态添加</strong>的一个函数</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> file=File(<span class="string">&quot;Main.kt&quot;</span>)</span><br><span class="line">println(file.readText())</span><br></pre></td></tr></table></figure><p><code>Java</code> 在调用时略有不同，<code>Java</code>  在调用扩展函数时，需要用到 <code>Kotlin</code> 生成的那个类 <code>xxxKt</code> ，第一个参数是需要扩展的那个类的对象，第二个参数是函数本身的参数，但是函数即使写了默认参数，<code>Java</code> 调用时也得传，默认参数对 <code>Java</code> 端没有效果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">&quot;Main.kt&quot;</span>);</span><br><span class="line">String content = FilesKt.readText(file, Charsets.UTF_8);</span><br><span class="line">System.out.println(content);</span><br></pre></td></tr></table></figure><p><strong>扩展函数是静态的给一个类添加函数，需要注意，静态的不具备多态效果</strong></p><p><strong>通常用于第三方 <code>SDK</code> 中，不能够控制的类中，添加一些需要用到的方法的时候</strong></p><h2 id="Lambda-闭包"><a href="#Lambda-闭包" class="headerlink" title="Lambda 闭包"></a>Lambda 闭包</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> thread = Thread(<span class="keyword">object</span> :Runnable&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><p><code>Lambda</code> 闭包可以省略冗余信息，没有参数的方法，还可以省略 <code>-&gt;</code> </p><ul><li><pre><code class="kotlin"><span class="keyword">val</span> thread = Thread(Runnable &#123; -&gt; <span class="built_in">Unit</span> &#125;)<span class="keyword">val</span> thread = Thread(Runnable &#123; &#125;)<span class="keyword">val</span> thread = Thread(&#123;&#125;)&lt;!--code￼<span class="number">19</span>--&gt;</code></pre></li></ul></li><li><p>如果除 <code>lambda(匿名函数)</code>后没有其他参数，则可以省略类名后的 ()</p><ul><li><pre><code class="kotlin"><span class="keyword">val</span> thread = Thread &#123;&#125;&lt;!--code￼<span class="number">20</span>--&gt;</code></pre></li></ul></li></ul><p>很显然，<code>kotlin</code> 要方便很多。</p><p><strong>声明一个闭包</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> print = &#123; name:String -&gt;</span><br><span class="line">    println(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大括号括起来的地方就是闭包，闭包可以有参数，但是参数有上限，最多 <code>22</code> 个。多于 <code>22</code> 会报 <code>NoClassDefFoundError: kotlin/Function23</code> </p><p>因为 <code>kotlin</code> 的类在编译后会被编译成 <code>class</code> 文件，<code>kotlin</code> 的 <code>lambda</code> 在编译后会被编译成匿名内部类，有多少个参数就会生成 <code>FunctionX</code>，但是前提得有这个类。</p><p>在 <code>Functions.kt</code> 中，声明了 <code>0 ~ 22</code> 个参数的 <code>Function</code> 。所以如果想要使用 <code>23</code> 个参数的闭包，我们需要自己创建这个类。</p><p>在报错中我们可以看到 <code>kotlin/Funtion23</code> ，说明这个类应该在包名为 <code>kotlin</code> 下放着。</p><p>但是如果我们使用 <code>kotlin</code> 语言中在 <code>kolint</code> 包下创建一个 <code>Function23</code> ，编译时会有一个报错 <code>Only the Kotlin standard library is allowed to use the kotlin package</code>，只有 <code>Kotlin</code> 标准库才能使用 <code>kotlin</code> 这样的包名。</p><p>遇到这个问题，我们就应该想到 <code>Kotlin</code> 和 <code>Java</code> 是完全兼容的，如果我们不能用 <code>Kotlin</code> 语言声明一个类，我们可以使用 <code>Java</code> 语言实现。</p><p>在 <code>kotlin</code> 包下创建 <code>Funtion23.java</code> 文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> kotlin;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Function23</span>&lt;<span class="title">P1</span>, <span class="title">P2</span>, <span class="title">P3</span>, <span class="title">P4</span>, <span class="title">P5</span>, <span class="title">P6</span>, <span class="title">P7</span>, <span class="title">P8</span>, <span class="title">P9</span>, <span class="title">P10</span>, <span class="title">P11</span>, <span class="title">P12</span>, <span class="title">P13</span>, <span class="title">P14</span>, <span class="title">P15</span>, <span class="title">P16</span>, <span class="title">P17</span>, <span class="title">P18</span>, <span class="title">P19</span>, <span class="title">P20</span>, <span class="title">P21</span>, <span class="title">P22</span>,<span class="title">P23</span>, <span class="title">R</span>&gt; <span class="keyword">extends</span> <span class="title">Function</span>&lt;<span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">R <span class="title">invoke</span><span class="params">(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9, P10 p10, P11 p11, P12 p12, P13 p13, P14 p14, P15 p15, P16 p16, P17 p17, P18 p18, P19 p19, P20 p20, P21 p21, P22 p22, P23 p23)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用闭包函数时，和函数方法调用一样</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">&quot;hello&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>函数 或 <code>lambda(匿名函数)</code> 的参数又是一个 函数 或者 <code>lambda</code> 时，这个函数称为<strong>高阶函数</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">onlyif</span><span class="params">(isDebug: <span class="type">Boolean</span>, block: () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isDebug) &#123;</span><br><span class="line">        block()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>高阶函数也是函数，肯定也得用 <code>fun</code> 修饰</li><li>第二个匿名函数 返回值为 <code>Unit</code> <ul><li><code>Unit</code> 表示没有返回值的函数，默认返回的一个隐藏类型，在函数作为参数时必须显示表示出返回值</li></ul></li></ul><p>高阶函数的使用，</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">onlyif(<span class="literal">true</span>) &#123;</span><br><span class="line">    println(<span class="string">&quot;打印&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>函数的声明与传递</strong></p><p>获取函数声明，可以使用 <code>(对象名::方法名)</code> ，获取声明后可以赋值给函数对象，并且可以传递到高阶函数中。</p><p>高阶函数的参数传递时，只能是匿名函数或者一个函数声明，<code>(对象名.方法名)</code> 表示执行这个函数。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> runnable = Runnable &#123;</span><br><span class="line">    println(<span class="string">&quot;Runnable::run&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 函数对象</span></span><br><span class="line"><span class="keyword">val</span> function: () -&gt; <span class="built_in">Unit</span></span><br><span class="line"><span class="comment">// runnable::run   （对象::方法名) 这种写法表示这个函数的声明，  而不是 runnable.run() ，这表示执行这个函数</span></span><br><span class="line"><span class="comment">// 将 run 函数的声明 赋值给 function</span></span><br><span class="line">function = runnable::run</span><br><span class="line"><span class="comment">// 传递高阶函数的时候必须传递函数的声明，如果传递的是 runnable.run() ，实际传递的是 函数的返回值</span></span><br><span class="line">onlyif(<span class="literal">true</span>,function)</span><br></pre></td></tr></table></figure><h2 id="内联优化代码"><a href="#内联优化代码" class="headerlink" title="内联优化代码"></a>内联优化代码</h2><p>使用 <code>inline</code> 修饰一个函数</p><p><code>Kotlin</code> 的 <code>Lambda</code> 在编译后会生成一个匿名对象</p><p>可以使用 <code>inline</code> 修饰方法，这样当方法在编译时就会拆解方法的调用为语句调用(把函数内的方法直接复制到调用的地方)，进而减少创建不必要的对象</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">onlyif</span><span class="params">(isDebug: <span class="type">Boolean</span>, block: () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isDebug) &#123;</span><br><span class="line">        block()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">onlyif(<span class="literal">true</span>) &#123;</span><br><span class="line">    println(<span class="string">&quot;打印&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后，调用的地方会直接替换成以下代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> isDebug = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">if</span>(isDebug)&#123;</span><br><span class="line">    String str = <span class="string">&quot;打印&quot;</span>;</span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>过度使用 <code>inline</code> 会增加编译器的编译负担，并且回加大编译后的代码块，所以 <code>inline</code> <strong>通常只会用于修饰高阶函数，不会随便使用。</strong></p><h1 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>(), DialogInterface.OnClickListener</span><br></pre></td></tr></table></figure><ul><li><code>kotiln</code> 声明使用 <code>class</code> 一个类</li><li><code>:</code> 后跟随父类或接口，如果没有指定父类，那么他的父类是 <code>Any</code></li><li>实现接口只需要用 <code>,</code> 分割，继续添加就可以，不需要使用 <code>implements</code> 来声明，接口和父类没有先后关系。</li><li><code>kotlin</code> 的类默认 <code>public final</code> 的，如果不需要 <code>final</code> ，则需要添加 <code>open</code> 关键字</li></ul><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span></span>(<span class="keyword">var</span> int: <span class="built_in">Int</span>) : AppCompatActivity()</span><br></pre></td></tr></table></figure><p>声明一个构造函数，可以在类名后直接写构造参数，而不是写一个构造方法</p><p>如果想在构造函数中写逻辑，可以写在 <code>init</code> 代码块，<code>init</code> 是类的构造函数被调用的时候去执行的</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">init</span> &#123;</span><br><span class="line">    println(<span class="string">&quot;===init&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有多个构造函数，需要显示的声明次级构造函数，<code>主构造函数和次级构造函数可以同时写</code></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestView</span> : <span class="type">View &#123;</span></span></span><br><span class="line">    <span class="keyword">constructor</span>(context: Context?) : <span class="keyword">super</span>(context)&#123;</span><br><span class="line">        println(<span class="string">&quot;constructor&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constructor</span>(context: Context?, attrs: AttributeSet?) : <span class="keyword">this</span>(context, attrs,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">constructor</span>(context: Context?, attrs: AttributeSet?, defStyleAttr: <span class="built_in">Int</span>) : <span class="keyword">super</span>(context, attrs, defStyleAttr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主构造函数跟在类名后，这里重写了 三个次级构造函数，<strong>次级构造函数必须 直接 或 间接 的 继承 主构造函数 或 父类构造函数</strong>，比如上面代码中的这样 <code>: super(context)</code> 或 <code>: this(context, attrs,0)</code> </p><h2 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h2><p>在 <code>koltin</code> 中访问修饰符有：</p><ul><li><strong>private：</strong>类所有成员都是私有的</li><li><strong>protected：</strong>这个类以及子类都可以访问</li><li><strong>public：</strong>所有类都可以访问</li><li><strong>internal：</strong>同一模块可以访问<code>（同一 library/module）</code></li></ul><p>可用于项目结构化扩展。</p><h2 id="伴生对象"><a href="#伴生对象" class="headerlink" title="伴生对象"></a>伴生对象</h2><p>之前说过 <code>Kotlin</code> 中没有静态方法，解决办法之前也说过一种加入 <code>@JvmStatic</code>  ，就可以在编译后生成静态方法</p><p>还有第二种方法，就是伴生对象 <code>companion object</code> </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestCompanion</span> </span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">sayMessage</span><span class="params">(msg: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">            println(msg)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Java</span></span><br><span class="line">TestCompanion.Companion.sayMessage(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Kotlin</span></span><br><span class="line">TestCompanion.sayMessage(<span class="string">&quot;1&quot;</span>);</span><br></pre></td></tr></table></figure><p>伴生对象，在编译器编译后会在这个类里生成一个 <code>companion</code> 静态对象，<code>Java</code> 在调用时是调用静态对象，再调用内部方法。</p><p>那 <code>object</code> 和 <code>companion object</code> 有啥区别呢？</p><ul><li><code>object</code> 声明（一个类）是延迟加载的，只有当第一次被访问时才会初始化<ul><li><code>object</code> 可以定义在全局也可以在类的内部使用</li></ul></li><li><code>companion object</code> 是当包含它的类被加载时就初始化了的，这一点和 <code>Java</code> 的 <code>static</code> 还是一样的<ul><li><code>companion object</code> 只能定义在对应的类中</li><li><code>companion object</code> 就是 <code>Java</code> 中的 <code>static</code> 变量</li></ul></li></ul><h2 id="单例类"><a href="#单例类" class="headerlink" title="单例类"></a>单例类</h2><p>之前通过 <code>object</code> 生成过匿名内部类，这也是一种单例的写法</p><p>还有一种更好的写法就是通过伴生对象实现</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Single</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>()&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">()</span></span>:Single&#123;</span><br><span class="line">            <span class="keyword">return</span> Holder.instance</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">object</span> Holder&#123;</span><br><span class="line">        <span class="keyword">val</span> instance = Single()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">Single.<span class="keyword">get</span>()</span><br></pre></td></tr></table></figure><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p><code>Kotlin</code> 默认支持动态代理</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">bark</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> : <span class="type">Animal &#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">bark</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Wang&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 代理执行，将传入的 animal 作为代理，代理这个对象执行方法。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zoo</span></span>(animal: Animal):Animal <span class="keyword">by</span> animal</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">mainProxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Zoo(Dog()).bark()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 <code>Zoo</code> 重写了 <code>bark</code> 方法，那么代理将会失效</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zoo</span></span>(animal: Animal):Animal <span class="keyword">by</span> animal&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">bark</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Zoo&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将会返回 <code>Zoo</code> 。</p><p><strong><code>Kotlin</code> 的动态代理在编译后将会转换为静态代理去调用。所以 <code>Kotlin</code> 的动态代理一定比 <code>Java</code> 的动态代理效率高。因为 <code>Java</code> 的动态代理是通过反射实现的。</strong></p><h2 id="Kotlin-特有的类"><a href="#Kotlin-特有的类" class="headerlink" title="Kotlin 特有的类"></a>Kotlin 特有的类</h2><ul><li><strong>数据类</strong></li></ul><p>数据类是 <code>Kotlin</code> 中很特殊的一个类</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">var</span> id:<span class="built_in">Int</span>,<span class="keyword">var</span> name:String)</span><br></pre></td></tr></table></figure><p>它可以自动的将类中的成员变量生成 <code>geter()/setter()</code> ，以及我们经常需要重新的 <code>toString()/hashCode()/equals()/copy()</code> ，这些方法都是由编译器帮我们重写好了。</p><p>注意：数据类是 <code>final</code> 类型的，不可以添加 <code>open</code> 去修饰它。所以它不可以被继承。</p><ul><li><strong>密闭类</strong></li></ul><p><code>Kotlin</code> 中也有枚举类，和 <code>Java</code> 使用方式一样，但是平常 <code>Kotlin</code> 是不适用枚举类的，而是使用 <strong>密闭类</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperCommand</span></span>() &#123;</span><br><span class="line">    <span class="keyword">object</span> A :SuperCommand()</span><br><span class="line">    <span class="keyword">object</span> B :SuperCommand()</span><br><span class="line">    <span class="keyword">object</span> C :SuperCommand()</span><br><span class="line">    <span class="keyword">object</span> D :SuperCommand()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">exec</span><span class="params">(superCommand: <span class="type">SuperCommand</span>)</span></span> = <span class="keyword">when</span>(superCommand)&#123;</span><br><span class="line">    SuperCommand.A-&gt;&#123;&#125;</span><br><span class="line">    SuperCommand.B-&gt;&#123;&#125;</span><br><span class="line">    SuperCommand.C-&gt;&#123;&#125;</span><br><span class="line">    SuperCommand.D-&gt;&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>密闭类通过 <code>sealed</code> 修饰，密闭类可以有子类，但是必须在同一个文件中，所以子类一般写在密闭类内部。如上</p><p>密闭类使用方法和枚举基本相同，它的最大的特性就是可以扩展它的子类</p><p>比如我们需要对一个 <code>View</code> 做上下左右的移动 或者 放大缩小，可以通过密闭类，轻松的实现各个功能的分工，而且子类也可以传入参数，可以更灵活的控制和操作每一个选项。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperCommand</span></span>() &#123;</span><br><span class="line">    <span class="keyword">object</span> UP : SuperCommand()</span><br><span class="line">    <span class="keyword">object</span> DOWN : SuperCommand()</span><br><span class="line">    <span class="keyword">object</span> LEFT : SuperCommand()</span><br><span class="line">    <span class="keyword">object</span> RIGHT : SuperCommand()</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">PACE</span></span>(<span class="keyword">var</span> pace: <span class="built_in">Int</span>) : SuperCommand()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">exec</span><span class="params">(view: <span class="type">View</span>, superCommand: <span class="type">SuperCommand</span>)</span></span> = <span class="keyword">when</span> (superCommand) &#123;</span><br><span class="line">    SuperCommand.UP -&gt; &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    SuperCommand.DOWN -&gt; &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    SuperCommand.LEFT -&gt; &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    SuperCommand.RIGHT -&gt; &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">is</span> SuperCommand.PACE -&gt; &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h1><h2 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h2><p>在 <code>Kotlin</code> 中，允许将一个类拆解然后分别赋值</p><p>需要用到 <code>operator</code> 重载运算符，将已经有的函数赋予它们新的约定</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">var</span> age: <span class="built_in">Int</span>, <span class="keyword">var</span> name: String) &#123;</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">component1</span><span class="params">()</span></span> = age</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">component2</span><span class="params">()</span></span> = name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>component1 component2</code> 是固定的 <code>componentX</code>，如果需要解构这里不可以改变，也可以有 <code>component3、component4...</code></p><p><strong>类的解构</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> user = User(<span class="number">12</span>, <span class="string">&quot;name&quot;</span>)</span><br><span class="line"><span class="comment">// 将 user 赋值给一个拆解后的对象</span></span><br><span class="line"><span class="keyword">val</span> (age, name) = user</span><br><span class="line">println(age)</span><br><span class="line">println(name)</span><br></pre></td></tr></table></figure><p>将 <code>user</code> 才拆解后，分别赋值给 <code>age</code>、<code>name</code> ，<code>component1</code> 代表括号中的第一个元素，<code>component2</code> 代表第二个元素，以此类推</p><p><strong>Map 的解构</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> map = mapOf(<span class="string">&quot;key1&quot;</span> to <span class="string">&quot;value1&quot;</span>, <span class="string">&quot;key2&quot;</span> to <span class="string">&quot;value2&quot;</span>)</span><br><span class="line"><span class="comment">//for (entry in map) &#123;</span></span><br><span class="line"><span class="keyword">for</span> ((k, v) <span class="keyword">in</span> map) &#123;</span><br><span class="line">    println(<span class="string">&quot;<span class="variable">$k</span>   <span class="variable">$v</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将原本的 <code>entry</code> 直接解构成 <code>k , v</code> 进行操作。</p><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p>按照正常 <code>java</code> 思路，循环应该这样写</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count: <span class="built_in">Int</span></span><br><span class="line"><span class="keyword">for</span> (count = <span class="number">0</span>;count &lt; <span class="number">10</span>;count++)&#123;&#125;</span><br></pre></td></tr></table></figure><p>但是 <code>kotlin</code> 中没有这个语法，但是它有更多适合的语法</p><h3 id="Kotlin-循环符"><a href="#Kotlin-循环符" class="headerlink" title="Kotlin 循环符"></a>Kotlin 循环符</h3><p><code>kotlin</code> 用 <code>..</code> 运算符，表示一个区间</p><p>循环 <code>1</code> 到 <code>10</code> ，<code>i</code> 表示变量</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span>)&#123;</span><br><span class="line">    println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="until"><a href="#until" class="headerlink" title="until"></a>until</h3><p>循环 <code>1</code> 到 <code>9</code></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until <span class="number">10</span>)&#123;</span><br><span class="line">    println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>until</code> 是一个扩展函数</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span> <span class="built_in">Int</span>.<span class="title">until</span><span class="params">(to: <span class="type">Int</span>)</span></span>: IntRange &#123;</span><br><span class="line">    <span class="comment">// 是否合法  否则返回 空区间</span></span><br><span class="line">    <span class="keyword">if</span> (to &lt;= <span class="built_in">Int</span>.MIN_VALUE) <span class="keyword">return</span> IntRange.EMPTY</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span> .. (to - <span class="number">1</span>).toInt()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里只拿 <code>Int</code> 举例， 最终也是使用 <code>..</code> 运算符，执行到 <code>to - 1</code></p><h3 id="downTo"><a href="#downTo" class="headerlink" title="downTo"></a>downTo</h3><p>循环 <code>10</code> 到 <code>1</code></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">10</span> downTo <span class="number">1</span>)&#123;</span><br><span class="line">    println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>downTo</code> 源码</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span> <span class="built_in">Int</span>.<span class="title">downTo</span><span class="params">(to: <span class="type">Int</span>)</span></span>: IntProgression &#123;</span><br><span class="line">    <span class="comment">// 创建一个闭区间，每次步长为 -1 ，直到 to </span></span><br><span class="line">    <span class="keyword">return</span> IntProgression.fromClosedRange(<span class="keyword">this</span>, to, -<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="step"><a href="#step" class="headerlink" title="step"></a>step</h3><p> 循环 1 到 10 每次步长为 2，结果为  1 3 5 7 9</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span> step <span class="number">2</span>)&#123;</span><br><span class="line">    println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>step</code> 源码</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span> IntProgression.<span class="title">step</span><span class="params">(step: <span class="type">Int</span>)</span></span>: IntProgression &#123;</span><br><span class="line">    <span class="comment">// 只能为正数</span></span><br><span class="line">    checkStepIsPositive(step &gt; <span class="number">0</span>, step)</span><br><span class="line">    <span class="keyword">return</span> IntProgression.fromClosedRange(first, last, <span class="keyword">if</span> (<span class="keyword">this</span>.step &gt; <span class="number">0</span>) step <span class="keyword">else</span> -step)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="in"><a href="#in" class="headerlink" title="in"></a>in</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = arrayListOf(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> (str <span class="keyword">in</span> list) &#123;</span><br><span class="line">    println(str)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解构</span></span><br><span class="line"><span class="keyword">for</span> ((index,str) <span class="keyword">in</span> list.withIndex()) &#123;</span><br><span class="line">    println(<span class="string">&quot;第 <span class="variable">$index</span> 个元素 <span class="variable">$str</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>list.withIndex</code> 源码</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Iterable<span class="type">&lt;T&gt;</span>.<span class="title">withIndex</span><span class="params">()</span></span>: Iterable&lt;IndexedValue&lt;T&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> IndexingIterable &#123; iterator() &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里返回 <code>IndexedValue&lt;T&gt;</code> ，它实际是一个 <code>data class</code> 。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexedValue</span>&lt;<span class="type">out T</span>&gt;</span>(<span class="keyword">public</span> <span class="keyword">val</span> index: <span class="built_in">Int</span>, <span class="keyword">public</span> <span class="keyword">val</span> value: T)</span><br></pre></td></tr></table></figure><h3 id="repeat"><a href="#repeat" class="headerlink" title="repeat"></a>repeat</h3><p>这是一个高阶函数</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">internal</span>.InlineOnly</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">repeat</span><span class="params">(times: <span class="type">Int</span>, action: (<span class="type">Int</span>) -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    contract &#123; callsInPlace(action) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (index <span class="keyword">in</span> <span class="number">0</span> until times) &#123;</span><br><span class="line">        action(index)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际就是封装了一个 <code>for</code> 循环</p><h2 id="集合操作符"><a href="#集合操作符" class="headerlink" title="集合操作符"></a>集合操作符</h2><p> 与 <code>rxjava</code> 的操作符相同，<code>rxjava</code> 允许对数据进行一系列的链式调用，在每一步中对数据进行筛选或处理，最终得到我们想要的数据</p><p><code>kotlin</code> 对集合添加了很多操作符，<code>rxJava</code> 有的 在 <code>Kotlin</code> 中基本上都有</p><p>这里简单介绍几个</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">var</span> list = arrayListOf(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;e&#x27;</span>)</span><br><span class="line">        <span class="keyword">var</span> find = list.map &#123; it - <span class="string">&#x27;a&#x27;</span> &#125;</span><br><span class="line">                .filter &#123; it &gt; <span class="number">0</span> &#125;</span><br><span class="line">                .reduce &#123; s, s1 -&gt;</span><br><span class="line">                    s1 - s</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">//                .findLast &#123; it&gt;1 &#125;</span></span><br><span class="line"><span class="comment">//                .find &#123; it &gt; 1 &#125;</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>map：</strong>将数据进行改变处理，输入值和输出值类型可以不一样</p></li><li><p><strong>filter：</strong>筛选，返回满足条件的集合</p></li><li><p><strong>find：</strong>查找，返回满足条件的第一个值</p></li><li><p><strong>findLast：</strong>返回满足条件的最后一个值</p></li><li><p><strong>reduce：</strong>可以同时拿到两个值进行操作，第一次计算的结果是第二次的第一个值</p></li><li><p><strong>let：</strong><code>let</code> 扩展函数的实际上是一个作用域函数，当需要去定义一个变量在一个特定的作用域范围内，<code>let</code> 函数的是一个不错的选择；<code>let</code> 函数另一个作用就是可以避免写一些判断 <code>null</code> 的操作。</p><ul><li><pre><code class="kotlin"><span class="keyword">var</span> let:<span class="built_in">Int</span> = user?.let &#123;<span class="comment">//表示 user 不为 null 的条件下，才会去执行 let 函数体</span>    println(<span class="string">"my name is <span class="subst">$&#123;it.name&#125;</span>, I am <span class="subst">$&#123;it.age&#125;</span> years old, my phone number is <span class="subst">$&#123;it.phoneNum&#125;</span>"</span>) <span class="comment">// it 就不需要再写 ?</span>    <span class="number">1000</span>&#125;&lt;!--code￼<span class="number">56</span>--&gt;在使用 `User` 参数时，可以直接只用属性名，可以省去重复的 `user` 对象的书写，`result` 为函数块内最后一行或者 `<span class="keyword">return</span>` 指定返回的值</code></pre></li></ul></li><li><p><strong>run：</strong> <code>let</code> 和 <code>with</code> 两个函数的结合体，以闭包形式返回，返回值为最后一行的值或者指定的 <code>return</code> 的表达式。</p><ul><li><pre><code class="kotlin"><span class="keyword">var</span> run:<span class="built_in">Int</span> = user?.run &#123;    println(<span class="string">"my name is <span class="variable">$name</span>, I am <span class="variable">$age</span> years old, my phone number is <span class="variable">$phoneNum</span>"</span>)    <span class="number">1000</span>&#125;&lt;!--code￼<span class="number">57</span>--&gt;</code></pre></li></ul></li><li><p><strong>also：</strong><code>also</code> 函数的结构实际上和 <code>let</code> 很像唯一的区别就是返回值的不一样，let是以闭包的形式返回，返回函数体内最后一行的值，如果最后一行为空就返回一个 <code>Unit</code> 类型的默认值。而 <code>also</code> 函数返回的则是传入对象的本身</p><ul><li><pre><code class="kotlin"><span class="keyword">var</span> also:User = user?.also &#123;    println(<span class="string">"my name is <span class="subst">$&#123;it.name&#125;</span>, I am <span class="subst">$&#123;it.age&#125;</span> years old, my phone number is <span class="subst">$&#123;it.phoneNum&#125;</span>"</span>)&#125;&lt;!--code￼<span class="number">58</span>--&gt;</code></pre></li></ul></li></ul><p><code>MutableList</code> 可变集合，在 <code>Kotlin/JVM</code> 平台中，它的实现就相当于是 <code>ArrayList</code> 。</p><h2 id="作用域函数"><a href="#作用域函数" class="headerlink" title="作用域函数"></a>作用域函数</h2><h2 id="中缀表达式"><a href="#中缀表达式" class="headerlink" title="中缀表达式"></a>中缀表达式</h2><h2 id="DSL"><a href="#DSL" class="headerlink" title="DSL"></a>DSL</h2>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-行为型-访问者模式</title>
      <link href="2020/design-pattern-visitor.html"/>
      <url>2020/design-pattern-visitor.html</url>
      
        <content type="html"><![CDATA[<p><code>Allows for one or more operation to be applied to a set of objects at runtime, decoupling the operations from the object structure.(允许一个或者多个操作应用到一组对象上，解耦操作和对象本身。)</code></p><h1 id="代码场景"><a href="#代码场景" class="headerlink" title="代码场景"></a>代码场景</h1><p>现在要开发一个工具来处理 <code>PDF、PPT、Word</code> 资源文件。这个工具的其中一个功能是，把这些资源文件中的文本内容抽取出来放到 <code>txt</code> 文件中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceFile</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String filePath;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ResourceFile</span><span class="params">(String filePath)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.filePath = filePath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">extract2txt</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PPTFile</span> <span class="keyword">extends</span> <span class="title">ResourceFile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PPTFile</span><span class="params">(String filePath)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(filePath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">extract2txt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...省略一大坨从PPT中抽取文本的代码...</span></span><br><span class="line">        <span class="comment">//...将抽取出来的文本保存在跟filePath同名的.txt文件中...</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Extract PPT.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PdfFile</span> <span class="keyword">extends</span> <span class="title">ResourceFile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PdfFile</span><span class="params">(String filePath)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(filePath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">extract2txt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Extract PDF.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// WordFile ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToolApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;ResourceFile&gt; resourceFiles = listAllResourceFiles();</span><br><span class="line">        <span class="keyword">for</span> (ResourceFile resourceFile : resourceFiles) &#123;</span><br><span class="line">            resourceFile.extract2txt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;ResourceFile&gt; <span class="title">listAllResourceFiles</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;ResourceFile&gt; resourceFiles = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)</span></span><br><span class="line">        resourceFiles.add(<span class="keyword">new</span> PdfFile(<span class="string">&quot;a.pdf&quot;</span>));</span><br><span class="line">        resourceFiles.add(<span class="keyword">new</span> WordFile(<span class="string">&quot;b.word&quot;</span>));</span><br><span class="line">        resourceFiles.add(<span class="keyword">new</span> PPTFile(<span class="string">&quot;c.ppt&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> resourceFiles;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>成功完成需求！（技术文专业转折点！）</p><p>这时候产品要求可以支持压缩！不就在 <code>ResourceFile</code> 再写个抽象方法，所有子类重写实现以下呗 ~，那再加一个功能呢？（￣へ￣，你说加就加？那我岂不是很没面子？）</p><p>如果继续按照上面的实现思路，就会存在这样几个问题：</p><ul><li>违背开闭原则，添加一个新的功能，所有类的代码都要修改；</li><li>功能增多，每个类的代码都不断膨胀，可读性和可维护性都变差了；</li><li>把所有比较上层的业务逻辑都耦合到 <code>PdfFile、PPTFile、WordFile</code> 类中，导致这些类的职责不够单一，变成了大杂烩。</li></ul><h1 id="初步优化"><a href="#初步优化" class="headerlink" title="初步优化"></a>初步优化</h1><p>针对上面的问题，常用的解决方法就是拆分解耦，把业务操作 <code>(Extractor)</code> 跟具体的数据结构解耦 ，设计成独立的类。</p><p>如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceFile</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String filePath;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ResourceFile</span><span class="params">(String filePath)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.filePath = filePath;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PdfFile</span> <span class="keyword">extends</span> <span class="title">ResourceFile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PdfFile</span><span class="params">(String filePath)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(filePath);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PPTFile...  WordFile...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Extractor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">extract2txt</span><span class="params">(PPTFile pptFile)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Extract PPT.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">extract2txt</span><span class="params">(PdfFile pdfFile)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Extract PDF.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">extract2txt</span><span class="params">(WordFile wordFile)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Extract WORD.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToolApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Extractor extractor = <span class="keyword">new</span> Extractor();</span><br><span class="line">        List&lt;ResourceFile&gt; resourceFiles = listAllResourceFiles();</span><br><span class="line">        <span class="keyword">for</span> (ResourceFile resourceFile : resourceFiles) &#123;</span><br><span class="line">            <span class="comment">// 报错</span></span><br><span class="line">            <span class="comment">// extractor.extract2txt(resourceFile);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;ResourceFile&gt; <span class="title">listAllResourceFiles</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;ResourceFile&gt; resourceFiles = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)</span></span><br><span class="line">        resourceFiles.add(<span class="keyword">new</span> PdfFile(<span class="string">&quot;a.pdf&quot;</span>));</span><br><span class="line">        resourceFiles.add(<span class="keyword">new</span> WordFile(<span class="string">&quot;b.word&quot;</span>));</span><br><span class="line">        resourceFiles.add(<span class="keyword">new</span> PPTFile(<span class="string">&quot;c.ppt&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> resourceFiles;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这其中最关键的一点设计是，把抽取文本内容的操作，设计成了三个重载函数。</p><p>但是，在实际使用 <code>extract2txt</code>时， 编译报错了，为什么呢？</p><p>因为多态是一种动态绑定，可以在运行时获取对象的实际类型，来运行实际类型对应的方法。而函数重载是一种静态绑定，在编译时并不能获取对象的实际类型，而是根据声明类型执行声明类型对应的方法。上面 <code>resourceFiles</code> 所对应的对象的类型是 <code>ResourceFile</code>，而我们并没有在 <code>Extractor</code> 类中定义参数类型是 <code>ResourceFile</code> 的 <code>extract2txt()</code> 重载函数，所以在编译阶段就通过不了，更别说在运行时根据对象的实际类型执行不同的重载函数了。</p><p>解决方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceFile</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String filePath;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ResourceFile</span><span class="params">(String filePath)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.filePath = filePath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Extractor extractor)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Compressor compressor)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PdfFile</span> <span class="keyword">extends</span> <span class="title">ResourceFile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PdfFile</span><span class="params">(String filePath)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(filePath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Extractor extractor)</span> </span>&#123;</span><br><span class="line">        extractor.extract2txt(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Compressor compressor)</span> </span>&#123;</span><br><span class="line">        compressor.compress(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PPTFile...  WordFile...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Extractor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">extract2txt</span><span class="params">(PPTFile pptFile)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Extract PPT.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">extract2txt</span><span class="params">(PdfFile pdfFile)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Extract PDF.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">extract2txt</span><span class="params">(WordFile wordFile)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Extract WORD.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Compressor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">compress</span><span class="params">(PPTFile pptFile)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Extract PPT.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">compress</span><span class="params">(PdfFile pdfFile)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Extract PDF.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">compress</span><span class="params">(WordFile wordFile)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Extract WORD.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToolApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Extractor extractor = <span class="keyword">new</span> Extractor();</span><br><span class="line">        List&lt;ResourceFile&gt; resourceFiles = listAllResourceFiles();</span><br><span class="line">        <span class="keyword">for</span> (ResourceFile resourceFile : resourceFiles) &#123;</span><br><span class="line">            resourceFile.accept(extractor);</span><br><span class="line">        &#125;</span><br><span class="line">        Compressor compressor = <span class="keyword">new</span> Compressor();</span><br><span class="line">        <span class="keyword">for</span> (ResourceFile resourceFile : resourceFiles) &#123;</span><br><span class="line">            resourceFile.accept(compressor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;ResourceFile&gt; <span class="title">listAllResourceFiles</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;ResourceFile&gt; resourceFiles = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)</span></span><br><span class="line">        resourceFiles.add(<span class="keyword">new</span> PdfFile(<span class="string">&quot;a.pdf&quot;</span>));</span><br><span class="line">        resourceFiles.add(<span class="keyword">new</span> WordFile(<span class="string">&quot;b.word&quot;</span>));</span><br><span class="line">        resourceFiles.add(<span class="keyword">new</span> PPTFile(<span class="string">&quot;c.ppt&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> resourceFiles;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多态特性，程序会调用实际类型的 <code>accept</code> 函数，比如 <code>PdfFile</code> 的 <code>accept</code> 函数，然后将 <code>this</code> 传到对应的 <code>extract2txt,compress</code>中， 这里的 <code>this</code> 就是 <code>PdfFile</code> ，在编译的时候就确定了，所以会调用 <code>extractor</code> 的 <code>extract2txt(PdfFile pdfFile)</code> 这个重载函数。</p><h1 id="访问者模式优化"><a href="#访问者模式优化" class="headerlink" title="访问者模式优化"></a>访问者模式优化</h1><p>其实这样写还是有问题的，添加一个新的业务，还是需要修改每个资源文件类，违反了开闭原则。针对这个问题，我们抽象出来一个 <code>Visitor</code> 接口，包含是三个命名非常通用的 <code>visit()</code> 重载函数，分别处理三种不同类型的资源文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(PdfFile pdfFile)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(PPTFile pdfFile)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(WordFile pdfFile)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceFile</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String filePath;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ResourceFile</span><span class="params">(String filePath)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.filePath = filePath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PdfFile</span> <span class="keyword">extends</span> <span class="title">ResourceFile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PdfFile</span><span class="params">(String filePath)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(filePath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span> </span>&#123;</span><br><span class="line">        visitor.visit(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PPTFile...  WordFile...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Extractor</span> <span class="keyword">implements</span> <span class="title">Visitor</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(PPTFile pptFile)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Extract PPT.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(PdfFile pdfFile)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Extract PDF.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(WordFile wordFile)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Extract WORD.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Compressor...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToolApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Extractor extractor = <span class="keyword">new</span> Extractor();</span><br><span class="line">        List&lt;ResourceFile&gt; resourceFiles = listAllResourceFiles();</span><br><span class="line">        <span class="keyword">for</span> (ResourceFile resourceFile : resourceFiles) &#123;</span><br><span class="line">            resourceFile.accept(extractor);</span><br><span class="line">        &#125;</span><br><span class="line">        Compressor compressor = <span class="keyword">new</span> Compressor();</span><br><span class="line">        <span class="keyword">for</span> (ResourceFile resourceFile : resourceFiles) &#123;</span><br><span class="line">            resourceFile.accept(compressor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;ResourceFile&gt; <span class="title">listAllResourceFiles</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;ResourceFile&gt; resourceFiles = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)</span></span><br><span class="line">        resourceFiles.add(<span class="keyword">new</span> PdfFile(<span class="string">&quot;a.pdf&quot;</span>));</span><br><span class="line">        resourceFiles.add(<span class="keyword">new</span> WordFile(<span class="string">&quot;b.word&quot;</span>));</span><br><span class="line">        resourceFiles.add(<span class="keyword">new</span> PPTFile(<span class="string">&quot;c.ppt&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> resourceFiles;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Extractor</code> 负责抽取文本内容，<code>Compressor</code> 负责压缩。当我们新添加一个业务功能的时候，资源文件类不需要做任何修改，只需要修改 <code>ToolApplication</code> 的代码就可以了。</p><h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a><strong>感谢</strong></h1><blockquote><p><a href="https://time.geekbang.org/column/intro/250?utm_source=pinpaizhuanqu&utm_medium=geektime&utm_campaign=guanwang&utm_term=guanwang&utm_content=0511">设计模式之美</a></p><p>以及上文中的链接</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-行为型-状态模式</title>
      <link href="2020/design-pattern-state.html"/>
      <url>2020/design-pattern-state.html</url>
      
        <content type="html"><![CDATA[<p>状态模式一般用来实现状态机，状态机的实现方式有多种，除了状态模式，比较常用的还有 <strong>分支逻辑法</strong> 和 <strong>查表法</strong> 。</p><h1 id="什么是有限状态机？"><a href="#什么是有限状态机？" class="headerlink" title="什么是有限状态机？"></a>什么是有限状态机？</h1><p>有限状态机，英文翻译是 <code>Finite State Machine</code>，缩写为 <code>FSM</code>，简称为状态机。状态机有 3 个组成部分：状态（<code>State</code>）、事件（<code>Event</code>）、动作（<code>Action</code>）。其中，事件也称为转移条件（<code>Transition Condition</code>）。事件触发状态的转移及动作的执行。不过，<strong>动作不是必须的，也可能只转移状态，不执行任何动作。</strong></p><h1 id="举例实现"><a href="#举例实现" class="headerlink" title="举例实现"></a>举例实现</h1><p>“超级马里奥” 在游戏中，马里奥可以变身为多种形态，比如小马里奥（<code>Small Mario</code>）、超级马里奥（<code>Super Mario</code>）、火焰马里奥（<code>Fire Mario</code>）、斗篷马里奥（<code>Cape Mario</code>）等等。在不同的游戏情节下，各个形态会互相转化，并相应的增减积分。比如，初始形态是小马里奥，吃了蘑菇之后就会变成超级马里奥，并且增加 <code>100</code> 积分。</p><p>其中，马里奥的不同形态就是状态机中的 <strong>“状态”</strong>，游戏情节（比如吃了蘑菇）就是状态机中的 <strong>“事件”</strong>，加减积分就是状态机中的 <strong>“动作”</strong>。比如，吃蘑菇这个事件，会触发状态的转移：从小马里奥转移到超级马里奥，以及触发动作的执行（增加 <code>100</code> 积分）。</p><p><strong>具体状态与事件的关系</strong></p><table><thead><tr><th align="center">State\Event</th><th align="center">Got MushRoom</th><th align="center">Got Cape</th><th align="center">Got Fire Flower</th><th align="center">Met Monster</th></tr></thead><tbody><tr><td align="center"><strong>Small</strong></td><td align="center">Super / +100</td><td align="center">Cape / +200</td><td align="center">Fire / +300</td><td align="center">/</td></tr><tr><td align="center"><strong>Super</strong></td><td align="center">/</td><td align="center">Cape / +200</td><td align="center">Fire / +300</td><td align="center">Small / -100</td></tr><tr><td align="center"><strong>Cape</strong></td><td align="center">/</td><td align="center">/</td><td align="center">/</td><td align="center">Small / -200</td></tr><tr><td align="center"><strong>Fire</strong></td><td align="center">/</td><td align="center">/</td><td align="center">/</td><td align="center">Small / -300</td></tr></tbody></table><h2 id="状态机实现方式一：分支逻辑法"><a href="#状态机实现方式一：分支逻辑法" class="headerlink" title="状态机实现方式一：分支逻辑法"></a>状态机实现方式一：分支逻辑法</h2><p>最简单直接的实现方式，参照状态表，将每一个状态转移，原模原样地直译成代码。这样编写的代码会包含大量的 if-else 或 switch-case 分支判断逻辑，甚至是嵌套的分支判断逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    SMALL(<span class="number">0</span>), SUPER(<span class="number">1</span>), CAPE(<span class="number">2</span>), FIRE(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    State(<span class="keyword">int</span> value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MarioStateMachine</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> score;</span><br><span class="line">    <span class="keyword">private</span> State currentState;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MarioStateMachine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.score = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.currentState = State.SMALL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtainMushRoom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (currentState.equals(State.SMALL)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.currentState = State.SUPER;</span><br><span class="line">            <span class="keyword">this</span>.score += <span class="number">100</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtainCape</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (currentState.equals(State.SMALL) || currentState.equals(State.SUPER) ) &#123;</span><br><span class="line">            <span class="keyword">this</span>.currentState = State.CAPE;</span><br><span class="line">            <span class="keyword">this</span>.score += <span class="number">200</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtainFireFlower</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (currentState.equals(State.SMALL) || currentState.equals(State.SUPER) ) &#123;</span><br><span class="line">            <span class="keyword">this</span>.currentState = State.FIRE;</span><br><span class="line">            <span class="keyword">this</span>.score += <span class="number">300</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">meetMonster</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (currentState.equals(State.SUPER)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.currentState = State.SMALL;</span><br><span class="line">            <span class="keyword">this</span>.score -= <span class="number">100</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (currentState.equals(State.CAPE)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.currentState = State.SMALL;</span><br><span class="line">            <span class="keyword">this</span>.score -= <span class="number">200</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (currentState.equals(State.FIRE)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.currentState = State.SMALL;</span><br><span class="line">            <span class="keyword">this</span>.score -= <span class="number">300</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getScore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> State <span class="title">getCurrentState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.currentState;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中充斥着大量的 <code>if-else</code> 或者 <code>switch-case</code> 分支判断逻辑，可读性和可维护性都很差。如果哪天修改了状态机中的某个状态转移，我们要在冗长的分支逻辑中找到对应的代码进行修改，很容易改错，引入 <code>bug</code>。</p><hr><h2 id="状态机实现方式二：查表法"><a href="#状态机实现方式二：查表法" class="headerlink" title="状态机实现方式二：查表法"></a>状态机实现方式二：查表法</h2><p>上面列出的 <strong>具体状态与事件的关系</strong> 可以看出这是一个二维表，第一维表示当前状态，第二维表示事件，值表示当前状态经过事件之后，转移到的新状态及其执行的动作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Event</span> </span>&#123;</span><br><span class="line">    GOT_MUSHROOM(<span class="number">0</span>), GOT_CAPE(<span class="number">1</span>), GOT_FIRE(<span class="number">2</span>), MET_MONSTER(<span class="number">3</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Event</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MarioStateMachine</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> score;</span><br><span class="line">    <span class="keyword">private</span> State currentState;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> State[][] transitionTable = &#123;</span><br><span class="line">            &#123;SUPER, CAPE, FIRE, SMALL&#125;, </span><br><span class="line">            &#123;SUPER, CAPE, FIRE, SMALL&#125;, </span><br><span class="line">            &#123;CAPE, CAPE, CAPE, SMALL&#125;, </span><br><span class="line">            &#123;FIRE, FIRE, FIRE, SMALL&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[][] actionTable = &#123;</span><br><span class="line">            &#123;+<span class="number">100</span>, +<span class="number">200</span>, +<span class="number">300</span>, +<span class="number">0</span>&#125;, </span><br><span class="line">            &#123;+<span class="number">0</span>, +<span class="number">200</span>, +<span class="number">300</span>, -<span class="number">100</span>&#125;, </span><br><span class="line">            &#123;+<span class="number">0</span>, +<span class="number">0</span>, +<span class="number">0</span>, -<span class="number">200</span>&#125;, </span><br><span class="line">            &#123;+<span class="number">0</span>, +<span class="number">0</span>, +<span class="number">0</span>, -<span class="number">300</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MarioStateMachine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.score = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.currentState = State.SMALL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtainMushRoom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        executeEvent(Event.GOT_MUSHROOM);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtainCape</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        executeEvent(Event.GOT_CAPE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtainFireFlower</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        executeEvent(Event.GOT_FIRE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">meetMonster</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        executeEvent(Event.MET_MONSTER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">executeEvent</span><span class="params">(Event event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> stateValue = currentState.getValue();</span><br><span class="line">        <span class="keyword">int</span> eventValue = event.getValue();</span><br><span class="line">        <span class="keyword">this</span>.currentState = transitionTable[stateValue][eventValue];</span><br><span class="line">        <span class="keyword">this</span>.score += actionTable[stateValue][eventValue];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getScore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> State <span class="title">getCurrentState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.currentState;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相对于分支逻辑的实现方式，查表法的代码实现更加清晰，可读性和可维护性更好。当修改状态机时，我们只需要修改 <code>transitionTable</code> 和 <code>actionTable</code> 两个二维数组即可。<br>这里事件的触发只是简单的积分加减，所以，我们用一个 <code>int</code> 类型的二维数组 <code>actionTable</code> 就能表示，在多一个简单事件的话，可以再多写一个二维表，但是如果要执行的动作并非这么简单，而是一系列复杂的逻辑操作，就没法用如此简单的二维数组来表示了。这也就是说，<strong>查表法的实现方式有一定局限性。</strong> 这就引出了状态模式。</p><hr><h2 id="状态机实现方式三：状态模式"><a href="#状态机实现方式三：状态模式" class="headerlink" title="状态机实现方式三：状态模式"></a>状态机实现方式三：状态模式</h2><p>状态模式通过将事件触发的状态转移和动作执行，拆分到不同的状态类中，来避免分支判断逻辑。</p><p>现在 <code>MarioStateMachine</code> 只负责 <code>IMario</code> 的调度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IMario</span> </span>&#123;</span><br><span class="line">    <span class="function">State <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//以下是定义的事件</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">obtainMushRoom</span><span class="params">(MarioStateMachine stateMachine)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">obtainCape</span><span class="params">(MarioStateMachine stateMachine)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">obtainFireFlower</span><span class="params">(MarioStateMachine stateMachine)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">meetMonster</span><span class="params">(MarioStateMachine stateMachine)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MarioStateMachine</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> score;</span><br><span class="line">    <span class="keyword">private</span> IMario currentState;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MarioStateMachine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.score = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.currentState = SmallMario.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtainMushRoom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.currentState.obtainMushRoom(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtainCape</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.currentState.obtainCape(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtainFireFlower</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.currentState.obtainFireFlower(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">meetMonster</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.currentState.meetMonster(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getScore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> State <span class="title">getCurrentState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.currentState.getName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScore</span><span class="params">(<span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCurrentState</span><span class="params">(IMario currentState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.currentState = currentState;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是具体的状态代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmallMario</span> <span class="keyword">implements</span> <span class="title">IMario</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SmallMario instance = <span class="keyword">new</span> SmallMario();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SmallMario</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SmallMario <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> State <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> State.SMALL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtainMushRoom</span><span class="params">(MarioStateMachine stateMachine)</span> </span>&#123;</span><br><span class="line">        stateMachine.setCurrentState(SuperMario.getInstance());</span><br><span class="line">        stateMachine.setScore(stateMachine.getScore() + <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtainCape</span><span class="params">(MarioStateMachine stateMachine)</span> </span>&#123;</span><br><span class="line">        stateMachine.setCurrentState(CapeMario.getInstance());</span><br><span class="line">        stateMachine.setScore(stateMachine.getScore() + <span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtainFireFlower</span><span class="params">(MarioStateMachine stateMachine)</span> </span>&#123;</span><br><span class="line">        stateMachine.setCurrentState(FireMario.getInstance());</span><br><span class="line">        stateMachine.setScore(stateMachine.getScore() + <span class="number">300</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">meetMonster</span><span class="params">(MarioStateMachine stateMachine)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do nothing...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 省略SuperMario、CapeMario、FireMario类...</span></span><br></pre></td></tr></table></figure><p>状态模式会引入非常多的状态类，如果状态比较多会导致代码比较难维护，但是像电商下单、外卖下单这种类型的状态机，它们的状态不多，状态转移也比较简单，但事件触发执行的动作包含的业务逻辑可能会比较复杂，所以，使用状态模式来实现更合适。</p><h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a><strong>感谢</strong></h1><blockquote><p><a href="https://time.geekbang.org/column/intro/250?utm_source=pinpaizhuanqu&utm_medium=geektime&utm_campaign=guanwang&utm_term=guanwang&utm_content=0511">设计模式之美</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-行为型-责任链模式</title>
      <link href="2020/design-pattern-chainofresponsibility.html"/>
      <url>2020/design-pattern-chainofresponsibility.html</url>
      
        <content type="html"><![CDATA[<p><code>Avoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the request. Chain the receiving objects and pass the request along the chain until an object handles it.(将请求的发送和接收解耦，让多个接收对象都有机会处理这个请求。将这些接收对象串成一条链，并沿着这条链传递这个请求，直到链上的某个接收对象能够处理它为止。)</code></p><p><strong>职责链模式</strong>常用在框架开发中，用来实现<strong>框架的过滤器</strong>、<strong>拦截器</strong>功能，让框架的使用者在不需要修改框架源码的情况下，添加新的过滤拦截功能。这也体现了之前讲到的对扩展开放、对修改关闭的设计原则。</p><h1 id="1-责任链模式-UML"><a href="#1-责任链模式-UML" class="headerlink" title="1 责任链模式 UML"></a>1 责任链模式 UML</h1><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/design/design_uml_chain.webp" alt="图片来源于《Android 源码设计模式解析与实战》"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Handler successor = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSuccessor</span><span class="params">(Handler successor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.successor = successor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerA</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> handled = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">if</span> (!handled &amp;&amp; successor != <span class="keyword">null</span>) &#123;</span><br><span class="line">            successor.handle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerB</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> handled = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">if</span> (!handled &amp;&amp; successor != <span class="keyword">null</span>) &#123;</span><br><span class="line">            successor.handle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerChain</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Handler head = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> Handler tail = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addHandler</span><span class="params">(Handler handler)</span> </span>&#123;</span><br><span class="line">        handler.setSuccessor(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//链中还没有处理者</span></span><br><span class="line">            head = handler;</span><br><span class="line">            tail = handler;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将新的 hadler 添加到末尾 类似于 链表的 next 指针</span></span><br><span class="line">        tail.setSuccessor(handler);</span><br><span class="line">        <span class="comment">// 并用 tail 标记</span></span><br><span class="line">        tail = handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            head.handle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    HandlerChain chain = <span class="keyword">new</span> HandlerChain();</span><br><span class="line">    chain.addHandler(<span class="keyword">new</span> HandlerA());</span><br><span class="line">    chain.addHandler(<span class="keyword">new</span> HandlerB());</span><br><span class="line">    chain.handle();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种是最简单好理解的责任链模式的例子，每个 <code>handler</code> 执行完都回去执行 <code>successor</code>(相当于 <code>next</code> 指针) 的方法。这种方式需要在每个实现类中手动的调用 <code>successor</code> ，我们还可以做一下封装，将这部分逻辑交给父类，子类只需要控制是否需要继续执行下一个 <code>succesor</code> 即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Handler successor = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSuccessor</span><span class="params">(Handler successor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.successor = successor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> handled = doHandle();</span><br><span class="line">        <span class="keyword">if</span> (successor != <span class="keyword">null</span> &amp;&amp; !handled) &#123;</span><br><span class="line">            successor.handle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">doHandle</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 <code>Handler</code> 做如上修改，在 <code>handle()</code> 中做链表的处理，子类只需要返回是否需要继续执行，<code>HandlerChain</code>  不变。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerA</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">doHandle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> handled = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">return</span> handled;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然还有一种很好理解的方式，将所有的 <code>handler</code> 添加到一个 <code>List</code> 当中，循环执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">handle</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerA</span> <span class="keyword">implements</span> <span class="title">IHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> handled = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">return</span> handled;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerChain</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;IHandler&gt; handlers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addHandler</span><span class="params">(IHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.handlers.add(handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (IHandler handler : handlers) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> handled = handler.handle();</span><br><span class="line">            <span class="keyword">if</span> (handled) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有些情况是需要在每一级做一些处理，可以修改一下返回，就可以实现。</p><h1 id="2-简单实现"><a href="#2-简单实现" class="headerlink" title="2 简单实现"></a>2 简单实现</h1><p>假如需要报销一笔费用，首先给将报销单给 <strong>部门组长</strong> ，组长权限不够交给 <strong>部门主管</strong> ，主管权限不够交给 <strong>经理</strong> ，经理不够交给 <strong>老板</strong> 。这个过程就像一个责任链，我们只需要将报销单交给部门组长，具体谁报销不需要关系，我们在乎的只有结果… 责任链模式很好的将处理者与发起者解耦，避免写出成堆的 <code>if - else</code> 。</p><p>由于这里有统一的判断条件，那就是金额，所以将是否拦截统一交给父类，而不是子类处理拦截。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Leader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Leader superior = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSuccessor</span><span class="params">(Leader successor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.superior = successor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (money &lt;= limit()) &#123;</span><br><span class="line">            handle(money);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (superior != <span class="keyword">null</span>) &#123;</span><br><span class="line">                superior.handleRequest(money);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">limit</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(<span class="keyword">int</span> money)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupLeader</span> <span class="keyword">extends</span> <span class="title">Leader</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">limit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;组长批复报销&quot;</span> + money + <span class="string">&quot;元&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> <span class="keyword">extends</span> <span class="title">Leader</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">limit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5000</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;主管批复报销&quot;</span> + money + <span class="string">&quot;元&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 省略 Manager 与 Boss 类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理链表类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeaderChain</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Leader head = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> Leader tail = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLeader</span><span class="params">(Leader handler)</span> </span>&#123;</span><br><span class="line">        handler.setSuccessor(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//证明链中还没有处理者</span></span><br><span class="line">            head = handler;</span><br><span class="line">            tail = handler;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将新的 hadler 添加到末尾 类似于 链表的 next 指针</span></span><br><span class="line">        tail.setSuccessor(handler);</span><br><span class="line">        <span class="comment">// 并用 tail 标记</span></span><br><span class="line">        tail = handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            head.handleRequest(money);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LeaderChain chain = <span class="keyword">new</span> LeaderChain();</span><br><span class="line">chain.addLeader(<span class="keyword">new</span> GroupLeader());</span><br><span class="line">chain.addLeader(<span class="keyword">new</span> Director());</span><br><span class="line">chain.addLeader(<span class="keyword">new</span> Manager());</span><br><span class="line">chain.addLeader(<span class="keyword">new</span> Boss());</span><br><span class="line">chain.handleRequest(<span class="number">10000</span>);</span><br></pre></td></tr></table></figure><h1 id="3-Android-中的责任链模式"><a href="#3-Android-中的责任链模式" class="headerlink" title="3 Android 中的责任链模式"></a>3 Android 中的责任链模式</h1><ol><li><p>Touch 事件</p><p><a href="https://www.jianshu.com/p/c6b9e03f7cfe">事件分发(源码分析)</a></p></li><li><p>OkHTTP 拦截器</p><p>重点在于每个拦截器都换调用 <code>chain.proceed(request)</code> 调用下一个拦截器等待返回。<a href="[http://www.whdreamblog.cn/2019/04/22/OkHttp%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E8%B4%A3%E4%BB%BB%E9%93%BE%E5%88%86%E6%9E%90/](http://www.whdreamblog.cn/2019/04/22/OkHttp源码分析-责任链分析/)">OkHttp源码分析（二） 责任链实现篇 RealInterceptorChain</a></p></li></ol><h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a><strong>感谢</strong></h1><blockquote><p><a href="https://time.geekbang.org/column/intro/250?utm_source=pinpaizhuanqu&utm_medium=geektime&utm_campaign=guanwang&utm_term=guanwang&utm_content=0511">设计模式之美</a></p><p>《Android 源码设计模式解析与实战》</p><p>以及上文中的链接</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-行为型-策略模式</title>
      <link href="2020/design-pattern-strategy.html"/>
      <url>2020/design-pattern-strategy.html</url>
      
        <content type="html"><![CDATA[<p><code>Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it.(定义一系列算法，将每个算法分别封装起来，让它们可以互相替换。策略模式可以使算法的变化独立于使用它们的客户端（这里的客户端代指使用算法的代码）。)</code></p><p>策略模式，最常见的应用场景是，利用它来避免冗长的 <code>if-else</code>  或 <code>switch</code> 分支判断。不过，它的作用还不止如此。它也可以像模板模式那样，提供框架的扩展点等等。</p><p><strong>工厂模式</strong>是解耦对象的创建和使用，<strong>观察者模式</strong>是解耦观察者和被观察者。<strong>策略模式</strong>跟两者类似，也能起到解耦的作用，不过，它解耦的是策略的定义、创建、使用这三部分。</p><h1 id="1-策略模式-UML"><a href="#1-策略模式-UML" class="headerlink" title="1 策略模式 UML"></a>1 策略模式 UML</h1><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/design/design_uml_strategy2.webp" alt="图片来源于《Android 源码设计模式解析与实战》"></p><ul><li><strong>Context ：</strong> 用来操作策略的类</li><li><strong>Stragety：</strong>策略的抽象</li><li><strong>ConcreteStragetyA：</strong>具体的策略实现</li></ul><h2 id="策略模式的定义"><a href="#策略模式的定义" class="headerlink" title="策略模式的定义"></a>策略模式的定义</h2><p>根据上图可实现如下代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">algorithm</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategyA</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">algorithm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//具体的内容...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategyB</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">algorithm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//具体的内容...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="策略的创建"><a href="#策略的创建" class="headerlink" title="策略的创建"></a>策略的创建</h2><p>这里讲一下操作策略的类，如何创建策略，因为策略模式会包含一组策略，在使用它们的时候，一般会通过类型（type）来判断创建哪个策略来使用。如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyFactory</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Strategy <span class="title">getStrategy</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (type == <span class="keyword">null</span> || type.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;type should not be empty.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (type.equals(<span class="string">&quot;A&quot;</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ConcreteStrategyA();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">&quot;B&quot;</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ConcreteStrategyB();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了封装创建逻辑，我们需要对客户端代码屏蔽创建细节。我们可以把根据 <code>type</code> 创建策略的逻辑抽离出来，放到工厂类中。<br>如果策略类是无状态的，不包含成员变量，只是纯粹的算法实现，这样的策略对象是可以被共享使用的，不需要在每次调用 <code>getStrategy()</code> 的时候，都创建一个新的策略对象。针对这种情况，我们可以使用如下方式创建，事先创建好每个策略对象，缓存到工厂类中，用的时候直接返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyFactory</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Strategy&gt; strategies = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    strategies.put(<span class="string">&quot;A&quot;</span>, <span class="keyword">new</span> ConcreteStrategyA());</span><br><span class="line">    strategies.put(<span class="string">&quot;B&quot;</span>, <span class="keyword">new</span> ConcreteStrategyB());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Strategy <span class="title">getStrategy</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (type == <span class="keyword">null</span> || type.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;type should not be empty.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> strategies.get(type);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果策略类是有状态的，根据业务场景的需要，我们希望每次从工厂方法中，获得的都是新创建的策略对象，而不是缓存好可共享的策略对象，那就不可以用这种方式，还是得用第一种 <code>if - else</code> 方式。</p><h1 id="策略模式案例"><a href="#策略模式案例" class="headerlink" title="策略模式案例"></a>策略模式案例</h1><p>案例内容为按距离计算 公交、地铁 最终支付价格。首先先看第一版代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriceCalculator</span> </span>&#123;</span><br><span class="line">    <span class="comment">//公交车</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BUS = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//地铁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SUBWAY = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">busPrice</span><span class="params">(<span class="keyword">int</span> km)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 10 公里起步价 5 元</span></span><br><span class="line">        <span class="keyword">int</span> extraTotal = km - <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// 超过 10 公里，每 5 公里收 2 元,超过几个 5 公里</span></span><br><span class="line">        <span class="keyword">int</span> extraFactor = extraTotal / <span class="number">5</span>;</span><br><span class="line">        <span class="comment">// 查看最后是否有不满 5 公里。</span></span><br><span class="line">        <span class="keyword">int</span> fraction = extraTotal % <span class="number">5</span>;</span><br><span class="line">        <span class="comment">// 起步价 + 超出部分</span></span><br><span class="line">        <span class="keyword">int</span> price = <span class="number">5</span> + extraFactor * <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 最后不满 5 公里，只要多出部分大于一公里按 5 公里计算，  比如 (24-10) 14 / 5 = 2 .  剩下的 4 公里按 5 公里算</span></span><br><span class="line">        <span class="keyword">return</span> fraction &gt; <span class="number">1</span> ? price + <span class="number">2</span> : price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">subwayPrice</span><span class="params">(<span class="keyword">int</span> km)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (km &lt; <span class="number">6</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (km &gt;= <span class="number">6</span> &amp;&amp; km &lt; <span class="number">12</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (km &gt;= <span class="number">12</span> &amp;&amp; km &lt; <span class="number">22</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (km &gt;= <span class="number">22</span> &amp;&amp; km &lt; <span class="number">32</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">7</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculatePrice</span><span class="params">(<span class="keyword">int</span> km, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (type == BUS) &#123;</span><br><span class="line">            <span class="keyword">return</span> busPrice(km);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == SUBWAY) &#123;</span><br><span class="line">            <span class="keyword">return</span> subwayPrice(km);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码写完了，也能用，但是，如果现在添加一个 <code>TAXI</code> 类型，又得在 <code>PriceCalculator</code> 类中修改、添加很多代码，很明显这里并没有遵循单一职责，而且使用了 <code>if - else</code> 判断使用哪种计算方式，再添加时，只能再往后添加 <code>if - else</code>，造成代码的臃肿。</p><p>解决办法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CalculateStrategy</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按距离计算价格</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> km 公里</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 价格</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculatePrice</span><span class="params">(<span class="keyword">int</span> km)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BusStrategy</span> <span class="keyword">implements</span> <span class="title">CalculateStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculatePrice</span><span class="params">(<span class="keyword">int</span> km)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 10 公里起步价 5 元</span></span><br><span class="line">        <span class="keyword">int</span> extraTotal = km - <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// 超过 10 公里，每 5 公里收 2 元,超过几个 5 公里</span></span><br><span class="line">        <span class="keyword">int</span> extraFactor = extraTotal / <span class="number">5</span>;</span><br><span class="line">        <span class="comment">// 查看最后是否有不满 5 公里。</span></span><br><span class="line">        <span class="keyword">int</span> fraction = extraTotal % <span class="number">5</span>;</span><br><span class="line">        <span class="comment">// 起步价 + 超出部分</span></span><br><span class="line">        <span class="keyword">int</span> price = <span class="number">5</span> + extraFactor * <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 最后不满 5 公里，只要多出部分大于 1 公里按 5 公里计算，  比如 (24-10) 14 / 5 = 2 .  剩下的 4 公里按 5 公里算</span></span><br><span class="line">        <span class="keyword">return</span> fraction &gt; <span class="number">1</span> ? price + <span class="number">2</span> : price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AlgRange</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> end;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> alg;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AlgRange</span><span class="params">(<span class="keyword">long</span> start, <span class="keyword">long</span> end, <span class="keyword">int</span> alg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">        <span class="keyword">this</span>.alg = alg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAlg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> alg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">inRange</span><span class="params">(<span class="keyword">long</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size &gt;= start &amp;&amp; size &lt; end;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubWayStrategy</span> <span class="keyword">implements</span> <span class="title">CalculateStrategy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;AlgRange&gt; algs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        algs.add(<span class="keyword">new</span> AlgRange(<span class="number">0</span>, <span class="number">6</span>, <span class="number">3</span>));</span><br><span class="line">        algs.add(<span class="keyword">new</span> AlgRange(<span class="number">6</span>, <span class="number">12</span>, <span class="number">4</span>));</span><br><span class="line">        algs.add(<span class="keyword">new</span> AlgRange(<span class="number">12</span>, <span class="number">22</span>, <span class="number">5</span>));</span><br><span class="line">        algs.add(<span class="keyword">new</span> AlgRange(<span class="number">22</span>, <span class="number">32</span>, <span class="number">6</span>));</span><br><span class="line">        algs.add(<span class="keyword">new</span> AlgRange(<span class="number">32</span>, Long.MAX_VALUE, <span class="number">7</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculatePrice</span><span class="params">(<span class="keyword">int</span> km)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> price = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (AlgRange algRange : algs) &#123;</span><br><span class="line">            <span class="keyword">if</span> (algRange.inRange(km)) &#123;</span><br><span class="line">                price = algRange.getAlg();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 由于这里直接返回了所需要的的结果，还有可能是某个对象，在这里调用父类方法，达到策略选择的目的。</span></span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里只贴出了抽象和实现类，由于 <code>SubWayStrategy</code> 实现时，使用了大量的 <code>if - else</code>， 所以这里也可以使用策略模式整理代码，具体请看代码。<br>最后看看操作策略的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriceCalculator</span> </span>&#123;</span><br><span class="line">    <span class="comment">//公交车</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BUS = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//地铁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SUBWAY = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Integer, CalculateStrategy&gt; algs = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        algs.put(BUS, <span class="keyword">new</span> BusStrategy());</span><br><span class="line">        algs.put(SUBWAY, <span class="keyword">new</span> SubWayStrategy());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculatePrice</span><span class="params">(<span class="keyword">int</span> km, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> algs.get(type).calculatePrice(km);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就解决掉了所有 <code>if - else</code> ，并且在添加新的策略的时候不会影响到之前的逻辑代码。</p><h1 id="Android-中的策略模式"><a href="#Android-中的策略模式" class="headerlink" title="Android 中的策略模式"></a>Android 中的策略模式</h1><p>我们对动画设置不同的插值器(<code>TimeInterpolator</code> ) ，可以实现不同的动态效果</p><p><code>Animation</code> 就类似于上面的操作策略的类，之前都是提前初始化好实现类，但是在 <code>Interpolator</code> 是需要设置的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInterpolator</span><span class="params">(Interpolator i)</span> </span>&#123;</span><br><span class="line">    mInterpolator = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用的时候会根据设置的实现类调用相应的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">getTransformation</span><span class="params">(<span class="keyword">long</span> currentTime, Transformation outTransformation)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//...  </span></span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">float</span> interpolatedTime = mInterpolator.getInterpolation(normalizedTime);</span><br><span class="line">     <span class="comment">//...  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里简单看一下插值器结构图。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/design/design_uml_strategy3.webp" alt="图片来源于《Android 源码设计模式解析与实战》"></p><h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a><strong>感谢</strong></h1><blockquote><p><a href="https://time.geekbang.org/column/intro/250?utm_source=pinpaizhuanqu&utm_medium=geektime&utm_campaign=guanwang&utm_term=guanwang&utm_content=0511">设计模式之美</a></p><p>《Android 源码设计模式解析与实战》</p><p>以及上文中的链接</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-行为型-模板方法模式</title>
      <link href="2020/design-pattern-template.html"/>
      <url>2020/design-pattern-template.html</url>
      
        <content type="html"><![CDATA[<p><code>Define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm’s structure.(模板方法模式在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现。模板方法模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些步骤。)</code></p><p>这里的 “算法” ，也可以理解为广义上的 “业务逻辑” ，并不特指数据结构和算法中的 “算法” 。这里的算法骨架就是 “模板” ，包含算法骨架的方法就是 “模板方法” ，这也是模板方法模式名字的由来。</p><h1 id="模板方法模式实现"><a href="#模板方法模式实现" class="headerlink" title="模板方法模式实现"></a>模板方法模式实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractClass</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">templateMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    method1();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    method2();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteClass1</span> <span class="keyword">extends</span> <span class="title">AbstractClass</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteClass2</span> <span class="keyword">extends</span> <span class="title">AbstractClass</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AbstractClass demo = ConcreteClass1();</span><br><span class="line">demo.templateMethod();</span><br></pre></td></tr></table></figure><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>(复用、扩展)</p><ol><li>多个子类有公有的方法，并且逻辑基本相同时。</li><li>重要、复杂的算法，可以把核心算法设计为模板方法，周边的相关细节功能则由各个子类实现。</li><li>重构时，模板方法模式是一个经常使用的模式，把相同的代码抽取到父类中，然后通过钩子函数约束其行为。</li></ol><p>模板模式把一个算法中不变的流程抽象到父类的模板方法 <code>templateMethod()</code> 中，将可变的部分 <code>method1()</code>、<code>method2()</code> 留给子类 <code>ContreteClass1</code> 和 <code>ContreteClass2</code> 来实现。所有的子类都可以复用父类中模板方法定义的流程代码。</p><p>如果不需要把所有的方法都实现一遍，可以写一个 基类 将所有的方法都实现，然后其余子类继承这个 基类，按需重写就可以~</p><h1 id="模板模式与Callback回调函数有何区别和联系？"><a href="#模板模式与Callback回调函数有何区别和联系？" class="headerlink" title="模板模式与Callback回调函数有何区别和联系？"></a>模板模式与Callback回调函数有何区别和联系？</h1><p>回调的原理解析</p><blockquote><p>A 类事先注册某个函数 F 到 B 类，A 类在调用 B 类的 P 函数的时候，B 类反过来调用 A 类注册给它的 F 函数。这里的 F 函数就是“回调函数”。A 调用 B，B 反过来又调用 A，这种调用机制就叫作“回调”。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICallback</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">methodToCallback</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BClass</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(ICallback callback)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    callback.methodToCallback();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AClass</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    BClass b = <span class="keyword">new</span> BClass();</span><br><span class="line">    b.process(<span class="keyword">new</span> ICallback() &#123; <span class="comment">//回调对象</span></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodToCallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Call back me.&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回调跟模板模式一样，也具有复用和扩展的功能。除了回调函数之外，<code>BClass</code> 类的 <code>process()</code> 函数中的逻辑都可以复用。如果 <code>ICallback</code>、<code>BClass</code> 类是框架代码，<code>AClass</code> 是使用框架的客户端代码，我们可以通过 <code>ICallback</code> 定制 <code>process()</code> 函数，也就是说，框架因此具有了扩展的能力。</p><p>回调可以分为<strong>同步回调</strong>和异步回调（或者<strong>延迟回调</strong>）。<br><strong>同步回调</strong>指在函数返回之前执行回调函数；<br><strong>异步回调</strong>指的是在函数返回之后执行回调函数。<br>上面的代码实际上是<strong>同步回调</strong>的实现方式，在 <code>process()</code> 函数返回之前，执行完回调函数 <code>methodToCallback()</code>。<br><strong>异步回调</strong>在类似于支付，用户在发起支付请求之后，一般不会一直阻塞到支付结果返回，而是注册回调接口给三方支付系统，等三方支付系统执行完成之后，将结果通过回调接口返回给用户。<br>从应用场景上来看，<strong>同步回调</strong>看起来更像<strong>模板模式</strong>，<strong>异步回调</strong>看起来更像<strong>观察者模式</strong>。</p><p><strong>模板方法</strong>和<strong>回调</strong>应用场景是一致的，都是定义好算法骨架，并对外开放扩展点，符合开闭原则；<br>两者的却别是代码的实现上不同，<strong>模板方法</strong>是通过继承来实现，是自己调用自己；<strong>回调</strong>是类之间的组合。</p><h1 id="Android-源码中的模板方法模式"><a href="#Android-源码中的模板方法模式" class="headerlink" title="Android 源码中的模板方法模式"></a>Android 源码中的模板方法模式</h1><p>看了上面的例子，肯定可以想到 <code>Activity</code> 生命周期吧 ~，只要继承 <code>Activity</code> 子类，生命周期都可以重写，而且会在相应时机执行。</p><p><a href="http://gityuan.com/2016/03/18/start-activity-cycle/">简述Activity生命周期</a></p><p><a href="http://gityuan.com/2016/03/12/start-activity/">startActivity启动过程分析</a></p><h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a><strong>感谢</strong></h1><blockquote><p><a href="https://time.geekbang.org/column/intro/250?utm_source=pinpaizhuanqu&utm_medium=geektime&utm_campaign=guanwang&utm_term=guanwang&utm_content=0511">设计模式之美</a></p><p>《Android 源码设计模式解析与实战》</p><p>以及上文中的链接</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-行为型-观察模式</title>
      <link href="2020/design-pattern-observer.html"/>
      <url>2020/design-pattern-observer.html</url>
      
        <content type="html"><![CDATA[<p><strong>观察者模式</strong>（<code>Observer Design Pattern</code>）也被称为<strong>发布订阅模式</strong>（<code>Publish-Subscribe Design Pattern</code>）</p><blockquote><p>Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.</p></blockquote><p><code>在对象之间定义一个一对多的依赖，当一个对象状态改变的时候，所有依赖的对象都会自动收到通知。</code></p><p>一般情况下，被依赖的对象叫作被观察者（<code>Observable</code>），依赖的对象叫作观察者（<code>Observer</code>）。</p><h1 id="1-观察者模式-UML"><a href="#1-观察者模式-UML" class="headerlink" title="1 观察者模式 UML"></a>1 观察者模式 UML</h1><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/design/design_uml_observer.webp" alt="图片来源于《Android 源码设计模式解析与实战》"></p><ul><li>Subject：抽象主题，也就是被观察（Observable）的角色，抽象主题角色把所有观察者对象的引用保存在一个集合里，每个主题都可以有任意数量的观察者，抽象主题提供一个接口，可以增加和删除观察者对象。</li><li>ConcreteSubject：具体主题，该角色将有关状态存入具体观察者对象，在具体主题的内部状态发生改变时，给所有注册过的观察者发出通知，具体主题角色又叫做具体被观察者（Concrete Observable）角色。</li><li>Observer：抽象观察者，该角色是观察者的抽象类，它定义了一个更新接口，使得在得到主题的更改通知时更新自己。</li><li>ConcreteObserver：具体的观察者，该角色实现抽象观察者角色所定义的更新接口，以便在主题的状态发生变化时更新自身的状态。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">(Message message)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; observers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        observers.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer observer : observers) &#123;</span><br><span class="line">            observer.update(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(Message message)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserverOne</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Message message)</span> </span>&#123; <span class="comment">//<span class="doctag">TODO:</span> 获取消息通知，执行自己的逻辑...</span></span><br><span class="line">        System.out.println(<span class="string">&quot;ConcreteObserverOne is notified.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserverTwo</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Message message)</span> </span>&#123; <span class="comment">//<span class="doctag">TODO:</span> 获取消息通知，执行自己的逻辑...</span></span><br><span class="line">        System.out.println(<span class="string">&quot;ConcreteObserverTwo is notified.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ConcreteSubject subject = <span class="keyword">new</span> ConcreteSubject();</span><br><span class="line">subject.registerObserver(<span class="keyword">new</span> ConcreteObserverOne());</span><br><span class="line">subject.registerObserver(<span class="keyword">new</span> ConcreteObserverTwo());</span><br><span class="line">subject.notifyObservers(<span class="keyword">new</span> Message());</span><br></pre></td></tr></table></figure><h1 id="2-Android-源码分析-notifyDataSetChanged"><a href="#2-Android-源码分析-notifyDataSetChanged" class="headerlink" title="2 Android 源码分析 notifyDataSetChanged"></a>2 Android 源码分析 notifyDataSetChanged</h1><p>这次分析的是 <code>Adapter</code> 的 <code>notifyDataSetChanged</code> ，最终调用的是 <code>RecyclerView.Adapter</code> 的 <code>notifyDataSetChanged</code> 如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">notifyDataSetChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mObservable.notifyChanged();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>mObservable</code> 是 <code>AdapterDataObservable</code> 进入到 <code>norifyChanged()</code> 方法中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AdapterDataObservable</span> <span class="keyword">extends</span> <span class="title">Observable</span>&lt;<span class="title">AdapterDataObserver</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = mObservers.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            mObservers.get(i).onChanged();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>这里遍历了所有的观察者，并且调用它们的 <code>onChanged</code> 方法。这里的 <code>mObservers</code> 是父类中的一个 <code>ArrayList&lt;T&gt;</code> ，并且有一个 <code>register</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Observable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> ArrayList&lt;T&gt; mObservers = <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(T observer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (observer == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;The observer is null.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span>(mObservers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mObservers.contains(observer)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Observer &quot;</span> + observer + <span class="string">&quot; is already registered.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            mObservers.add(observer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br></pre></td></tr></table></figure><p><code>RecyclerView</code> 中调用 <code>registerObserver</code> 的地方是 <code>RecyclerView.Adapter</code> 的 <code>registerAdapterDataObserver</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerAdapterDataObserver</span><span class="params">(<span class="meta">@NonNull</span> AdapterDataObserver observer)</span> </span>&#123;</span><br><span class="line">    mObservable.registerObserver(observer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是在 <code>setAdapter</code> 中的 <code>setAdapterInternal</code> 中调用的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> RecyclerViewDataObserver mObserver = <span class="keyword">new</span> RecyclerViewDataObserver();  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setAdapterInternal</span><span class="params">(<span class="meta">@Nullable</span> Adapter adapter, <span class="keyword">boolean</span> compatibleWithPrevious,</span></span></span><br><span class="line"><span class="function"><span class="params">         <span class="keyword">boolean</span> removeAndRecycleViews)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line">     <span class="keyword">if</span> (adapter != <span class="keyword">null</span>) &#123;</span><br><span class="line">         adapter.registerAdapterDataObserver(mObserver);</span><br><span class="line">         adapter.onAttachedToRecyclerView(<span class="keyword">this</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>mObserver</code> 是 <code>RecyclerViewDataObserver</code> ，然后查看 <code>RecyclerViewDataObserver</code> 中的 <code>onChanged</code> 方法，这就是之前遍历的实现方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">RecyclerViewDataObserver</span> <span class="keyword">extends</span> <span class="title">AdapterDataObserver</span> </span>&#123;</span><br><span class="line">    RecyclerViewDataObserver() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assertNotInLayoutOrScroll(<span class="keyword">null</span>);</span><br><span class="line">        mState.mStructureChanged = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        processDataSetCompletelyChanged(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (!mAdapterHelper.hasPendingUpdates()) &#123;</span><br><span class="line">            requestLayout();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里最终调用了 <code>requestLayout</code> 刷新了 <code>RecyclerView</code> 页面。这！就是一个观察者模式。</p><p><strong>总结</strong> </p><ul><li>首先 <code>setAdapter</code> 会将 <code>RecyclerViewDataObserver</code> 添加到注册列表 <code>mObservers</code> 中。</li><li>当我们在调用 <code>norifyChanged()</code> 方法的时候，循环注册列表中的 <code>Observer</code> 的 <code>onChanged</code> 方法，其实就是调用 <code>RecyclerViewDataObserver</code> 的 <code>onChanged</code> </li><li><code>onChanged</code> 会获取新的数据并刷新 <code>RecyclerView</code> 重新布局。</li></ul><h1 id="3-Android-源码-Broadcast"><a href="#3-Android-源码-Broadcast" class="headerlink" title="3 Android  源码 Broadcast"></a>3 Android  源码 Broadcast</h1><p><a href="http://gityuan.com/2016/06/04/broadcast-receiver/">Android Broadcast广播机制分析</a></p><h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a><strong>感谢</strong></h1><blockquote><p><a href="https://time.geekbang.org/column/intro/250?utm_source=pinpaizhuanqu&utm_medium=geektime&utm_campaign=guanwang&utm_term=guanwang&utm_content=0511">设计模式之美</a></p><p>《Android 源码设计模式解析与实战》</p><p>以及上文中的链接</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-结构型-享元模式</title>
      <link href="2020/design-pattern-flyweight.html"/>
      <url>2020/design-pattern-flyweight.html</url>
      
        <content type="html"><![CDATA[<p>所谓 “享元”，顾名思义就是被共享的单元。享元模式的意图是复用对象，节省内存，前提是享元对象是不可变对象。</p><p>当一个系统中存在大量重复对象的时候，如果这些重复的对象是<strong>不可变对象</strong>，我们就可以利用享元模式将对象设计成享元，在内存中只保留一份实例，供多处代码引用。这样可以减少内存中对象的数量，起到节省内存的目的。</p><p>实际上，不仅仅相同对象可以设计成享元，对于相似对象，我们也可以将这些对象中相同的部分（字段）提取出来，设计成享元，让这些大量相似对象引用这些享元。</p><p>定义中的 “<strong>不可变对象</strong>” 指的是，一旦通过构造函数初始化完成之后，它的状态（对象的成员变量或者属性）就不会再被修改了。所以，不可变对象不能暴露任何 <code>set()</code> 等修改内部状态的方法。之所以要求享元是不可变对象，那是因为它会被多处代码共享使用，避免一处代码对享元进行了修改，影响到其他使用它的代码。</p><h1 id="1-享元模式-UML"><a href="#1-享元模式-UML" class="headerlink" title="1 享元模式 UML"></a>1 享元模式 UML</h1><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/design/design_uml_flyweight.webp" alt="图片来源于《Android 源码设计模式解析与实战》"></p><p>举个 🌰</p><p>过年回家买火车票是一件很困难的事，无数人用刷票插件软件在向服务端发出请求，对于每一个请求服务器都必须做出应答。</p><p>在用户设置好出发地和目的地之后，每次请求都返回一个查询的车票结果。那么当数以万计的人不间断在请求数据时，如果每次都重新创建一个查询的车票结果，那么必然会造成大量重复对象的创建、销毁，使得 <code>GC</code> 任务繁重、内存占用率高居不下。</p><p>而这类问题通过享元模式就能够得到很好地改善，从城市 <code>A</code> 到城市 <code>B</code> 的车辆是有限的，车上的铺位也就是硬卧、硬卧、坐票 3 种。我们将这些可以公用的对象缓存起来，在用户查询时优先使用缓存，如果没有缓存则重新创建。这样就将成千上万的对象变为了可选择的有限数量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Ticket</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showTicketInfo</span><span class="params">(String bunk)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrainTicket</span> <span class="keyword">implements</span> <span class="title">Ticket</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String from;</span><br><span class="line">    <span class="keyword">private</span> String to;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TrainTicket</span><span class="params">(String from, String to)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.from = from;</span><br><span class="line">        <span class="keyword">this</span>.to = to;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showTicketInfo</span><span class="params">(String bunk)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> price = <span class="keyword">new</span> Random().nextInt(<span class="number">300</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;购买 从 &quot;</span> + from + <span class="string">&quot; 到 &quot;</span> + to + <span class="string">&quot; 的 &quot;</span> + bunk + <span class="string">&quot; 火车票，价格：&quot;</span> + price);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Map&lt;String, Ticket&gt; sTringTicketMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Ticket <span class="title">getTicket</span><span class="params">(String from, String to)</span> </span>&#123;</span><br><span class="line">        String key = from + <span class="string">&quot;-&quot;</span> + to;</span><br><span class="line">        <span class="keyword">if</span> (sTringTicketMap.containsKey(key)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;使用缓存 ==&gt;&quot;</span> + key);</span><br><span class="line">            <span class="keyword">return</span> sTringTicketMap.get(key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;创建对象 ==&gt;&quot;</span> + key);</span><br><span class="line">            Ticket ticket = <span class="keyword">new</span> TrainTicket(from, to);</span><br><span class="line">            sTringTicketMap.put(key, ticket);</span><br><span class="line">            <span class="keyword">return</span> ticket;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-简单实现"><a href="#2-简单实现" class="headerlink" title="2 简单实现"></a>2 简单实现</h1><p>举个 🌰</p><p>假设我们在开发一个棋牌游戏（比如象棋）。一个游戏厅中有成千上万个“房间”，每个房间对应一个棋局。棋局要保存每个棋子的数据，比如：棋子类型（将、相、士、炮等）、棋子颜色（红方、黑方）、棋子在棋局中的位置。利用这些数据，我们就能显示一个完整的棋盘给玩家。</p><p>为了记录每个房间当前的棋局情况，我们需要给每个房间都创建一个 <code>ChessBoard</code> 棋局对象。因为游戏大厅中有成千上万的房间（实际上，百万人同时在线的游戏大厅也有很多），那保存这么多棋局对象就会消耗大量的内存。</p><p>这个时候，<strong>享元模式</strong>就可以派上用场了。像刚刚的实现方式，在内存中会有大量的相似对象。这些相似对象的 <code>id</code>、<code>text</code>、<code>color</code> 都是相同的，唯独 <code>positionX</code>、<code>positionY</code> 不同。实际上，我们可以将棋子的 <code>id</code>、<code>text</code>、<code>color</code> 属性拆分出来，设计成独立的类，并且作为享元供多个棋盘复用。这样，棋盘只需要记录每个棋子的位置信息就可以了。</p><p>棋盘上旗子颜色和字都是固定的，只需要全部添加，并且缓存使用就好。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChessPieceUnit</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String text;</span><br><span class="line">    <span class="keyword">private</span> Color color;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChessPieceUnit</span><span class="params">(<span class="keyword">int</span> id, String text, Color color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.text = text;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">enum</span> <span class="title">Color</span> </span>&#123;RED, BLACK&#125; <span class="comment">// ...省略其他属性和getter/setter方法...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChessPiece</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ChessPieceUnit chessPieceUnit;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> positionX;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> positionY;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChessPiece</span><span class="params">(ChessPieceUnit chessPieceUnit, <span class="keyword">int</span> positionX, <span class="keyword">int</span> positionY)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.chessPieceUnit = chessPieceUnit;</span><br><span class="line">        <span class="keyword">this</span>.positionX = positionX;</span><br><span class="line">        <span class="keyword">this</span>.positionY = positionX;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChessPieceUnitFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Integer, ChessPieceUnit&gt; pieces = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        pieces.put(<span class="number">1</span>, <span class="keyword">new</span> ChessPieceUnit(<span class="number">1</span>, <span class="string">&quot;車&quot;</span>, ChessPieceUnit.Color.BLACK));</span><br><span class="line">        pieces.put(<span class="number">2</span>, <span class="keyword">new</span> ChessPieceUnit(<span class="number">2</span>, <span class="string">&quot;馬&quot;</span>, ChessPieceUnit.Color.BLACK));</span><br><span class="line">        <span class="comment">//...省略摆放其他棋子的代码...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ChessPieceUnit <span class="title">getChessPiece</span><span class="params">(<span class="keyword">int</span> chessPieceId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pieces.get(chessPieceId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们利用工厂类来缓存 <code>ChessPieceUnit</code> 信息（也就是 <code>id</code>、<code>text</code>、<code>color</code>）。通过工厂类获取到的 <code>ChessPieceUnit</code> 就是享元。所有的 <code>ChessBoard</code> 对象共享这 30 个 <code>ChessPieceUnit</code> 对象（因为象棋中只有 30 个棋子）。在使用享元模式之前，记录 1 万个棋局，我们要创建 30 万（ 30*1 万）个棋子的 <code>ChessPieceUnit</code> 对象。利用享元模式，我们只需要创建 30 个享元对象供所有棋局共享使用即可，大大节省了内存。</p><p>享元模式实际上，它的代码实现非常简单，主要是通过工厂模式，在工厂类中，通过一个 <code>Map</code> 来缓存已经创建过的享元对象，来达到复用的目的。</p><h1 id="3-享元模式-vs-单例、缓存、对象池"><a href="#3-享元模式-vs-单例、缓存、对象池" class="headerlink" title="3 享元模式 vs 单例、缓存、对象池"></a>3 享元模式 vs 单例、缓存、对象池</h1><p>在上面的讲解中，我们多次提到 “共享” “缓存” “复用” 这些字眼，那它跟单例、缓存、对象池这些概念有什么区别呢？</p><h2 id="3-1-享元模式跟单例的区别"><a href="#3-1-享元模式跟单例的区别" class="headerlink" title="3.1 享元模式跟单例的区别"></a>3.1 享元模式跟单例的区别</h2><p>在单例模式中，一个类只能创建一个对象，而在享元模式中，一个类可以创建多个对象，每个对象被多处代码引用共享。实际上，享元模式有点类似于之前讲到的单例的变体：多例。</p><p>区别两种设计模式，不能光看代码实现，而是要看设计意图，也就是要解决的问题。应用享元模式是为了对象复用，节省内存，而应用多例模式是为了限制对象的个数。</p><h2 id="3-2-享元模式跟缓存的区别"><a href="#3-2-享元模式跟缓存的区别" class="headerlink" title="3.2 享元模式跟缓存的区别"></a>3.2 享元模式跟缓存的区别</h2><p>在享元模式的实现中，我们通过工厂类来 “缓存” 已经创建好的对象。这里的 “缓存” 实际上是 “存储” 的意思，跟我们平时所说的 “数据库缓存” “CPU 缓存” “<code>MemCache</code> 缓存” 是两回事。我们平时所讲的缓存，主要是为了提高访问效率，而非复用。</p><h2 id="3-3-享元模式跟对象池的区别"><a href="#3-3-享元模式跟对象池的区别" class="headerlink" title="3.3 享元模式跟对象池的区别"></a>3.3 享元模式跟对象池的区别</h2><p>池化技术中的 “复用” 可以理解为 “重复使用” ，主要目的是节省时间（比如从数据库池中取一个连接，不需要重新创建）。<strong>在任意时刻，每一个对象、连接、线程，并不会被多处使用，而是被一个使用者独占，当使用完成之后，放回到池中，再由其他使用者重复利用</strong>。享元模式中的“复用”可以理解为 “共享使用”，<strong>在整个生命周期中，都是被所有使用者共享的</strong>，主要目的是节省空间。</p><h1 id="4-享元模式在-Integer、String-中的应用"><a href="#4-享元模式在-Integer、String-中的应用" class="headerlink" title="4 享元模式在 Integer、String 中的应用"></a>4 享元模式在 Integer、String 中的应用</h1><h2 id="4-1-Integer"><a href="#4-1-Integer" class="headerlink" title="4.1 Integer"></a>4.1 Integer</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 = <span class="number">56</span>;</span><br><span class="line">Integer i2 = <span class="number">56</span>;</span><br><span class="line">Integer i3 = <span class="number">129</span>;</span><br><span class="line">Integer i4 = <span class="number">129</span>;</span><br><span class="line">System.out.println(i1 == i2);</span><br><span class="line">System.out.println(i3 == i4);</span><br></pre></td></tr></table></figure><p>要正确地分析上面的代码，我们需要弄清楚下面两个问题：</p><ul><li>如何判定两个 <code>Java</code> 对象是否相等（也就代码中的 “==” 操作符的含义）？</li><li>什么是自动装箱（<code>Autoboxing</code>）和自动拆箱（<code>Unboxing</code>）？</li></ul><p>所谓的<strong>自动装箱</strong>，就是自动将基本数据类型转换为包装器类型。所谓的<strong>自动拆箱</strong>，也就是自动将包装器类型转化为基本数据类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="number">56</span>; <span class="comment">//自动装箱</span></span><br><span class="line"><span class="keyword">int</span> j = i; <span class="comment">//自动拆箱</span></span><br></pre></td></tr></table></figure><p>数值 <code>56</code> 是基本数据类型 <code>int</code>，当赋值给包装器类型（<code>Integer</code>）变量的时候，触发自动装箱操作，创建一个 <code>Integer</code> 类型的对象，并且赋值给变量 <code>i</code>。其底层相当于执行了下面这条语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="number">59</span>；底层执行了：Integer i = Integer.valueOf(<span class="number">59</span>);</span><br></pre></td></tr></table></figure><p>当我们通过 “==” 来判定两个对象是否相等的时候，实际上是在<strong>判断两个局部变量存储的地址是否相同</strong>，换句话说，是在<strong>判断两个局部变量是否指向相同的对象</strong>。</p><p>回头看那段代码，前 <code>4</code> 行赋值语句都会触发自动装箱操作，也就是会创建 <code>Integer</code> 对象并且赋值给 <code>i1</code>、<code>i2</code>、<code>i3</code>、<code>i4</code> 这四个变量。根据刚刚的讲解，<code>i1</code>、<code>i2</code> 尽管存储的数值相同，都是 <code>56</code>，但是指向不同的 <code>Integer</code> 对象，所以通过 <code>“==”</code> 来判定是否相同的时候，会返回 false。同理，<code>i3==i4</code> 判定语句也会返回 <code>false</code>。</p><p>以为这样就完了吗？上面的分析还是不对，答案并非是两个 <code>false</code>，而是一个 <code>true</code>，一个 <code>false</code>。<br>这正是因为 <code>Integer</code> 用到了享元模式来复用对象，才导致了这样的运行结果。当我们通过自动装箱，也就是调用 <code>valueOf()</code> 来创建 <code>Integer</code> 对象的时候，如果要创建的 <code>Integer</code> 对象的值在 <code>-128</code> 到 <code>127</code> 之间，会从 <code>IntegerCache</code> 类中直接返回，否则才调用 <code>new</code> 方法创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>IntegerCache</code> 相当于享元对象的工厂类，只不过名字不叫 <code>xxxFactory</code> 而已。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Cache to support the object identity semantics of autoboxing for values between</span></span><br><span class="line"><span class="comment"> * -128 and 127 (inclusive) as required by JLS.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The cache is initialized on first usage.  The size of the cache</span></span><br><span class="line"><span class="comment"> * may be controlled by the &#123;<span class="doctag">@code</span> -XX:AutoBoxCacheMax=&lt;size&gt;&#125; option.</span></span><br><span class="line"><span class="comment"> * During VM initialization, java.lang.Integer.IntegerCache.high property</span></span><br><span class="line"><span class="comment"> * may be set and saved in the private system properties in the</span></span><br><span class="line"><span class="comment"> * sun.misc.VM class.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">        String integerCacheHighPropValue =</span><br><span class="line">            sun.misc.VM.getSavedProperty(<span class="string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        high = h;</span><br><span class="line"></span><br><span class="line">        cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> j = low;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">        <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么 <code>IntegerCache</code> 只缓存 <code>-128</code> 到 <code>127</code> 之间的整型值呢？</p><p>在 <code>IntegerCache</code> 的代码实现中，当这个类被加载的时候，缓存的享元对象会被集中一次性创建好。毕竟整型值太多了，我们不可能在 <code>IntegerCache</code> 类中预先创建好所有的整型值，这样既占用太多内存，也使得加载 <code>IntegerCache</code> 类的时间过长。所以，我们只能选择缓存对于大部分应用来说最常用的整型值，也就是一个字节的大小（<code>-128</code> 到 <code>127</code> 之间的数据）。</p><p>如何修改这个值呢？</p><p><code>JDK</code> 提供了方法来让我们可以自定义缓存的最大值，但没有提供设置最小值的方法。这里只有 <code>idea</code> 的设置参数。<code>Android Studio</code> 还没有找到相关的设置方法，我试过了再 <code>studio64.exe.vmoptions</code> 中设置，并且执行了 <code>Invalidate Caches/Restart...</code> 但是没有效果。</p><p>希望哪位大佬指点一下 ~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;方法一：</span><br><span class="line">-Djava.lang.Integer.IntegerCache.high&#x3D;255</span><br><span class="line">&#x2F;&#x2F;方法二：</span><br><span class="line">-XX:AutoBoxCacheMax&#x3D;255</span><br></pre></td></tr></table></figure><p>除了 <code>Integer</code> 类型之外，其他包装器类型，比如 <code>Long</code>、<code>Short</code>、<code>Byte</code> 等，也都利用了享元模式来缓存 <code>-128</code> 到 <code>127</code> 之间的数据。具体查看对应的 <code>valueOf()</code> 方法。</p><p>在我们平时的开发中，对于下面这样三种创建整型对象的方式，我们优先使用后两种。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer a = <span class="keyword">new</span> Integer(<span class="number">123</span>);</span><br><span class="line">Integer a = <span class="number">123</span>;</span><br><span class="line">Integer a = Integer.valueOf(<span class="number">123</span>);</span><br></pre></td></tr></table></figure><p>第一种创建方式并不会使用到 <code>IntegerCache</code>，而后面两种创建方法可以利用 <code>IntegerCache</code> 缓存，返回共享的对象，以达到节省内存的目的。</p><h2 id="4-2-String"><a href="#4-2-String" class="headerlink" title="4.2 String"></a>4.2 String</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">String s2 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(s1 == s2);</span><br><span class="line">System.out.println(s1 == s3);</span><br></pre></td></tr></table></figure><p>上面代码的运行结果是：一个 <code>true</code>，一个 <code>false</code>。</p><p><code>String</code> 类利用享元模式来复用相同的字符串常量。<code>JVM</code> 会专门开辟一块存储区来存储字符串常量，这块存储区叫作 <strong>“字符串常量池”</strong>。</p><p><code>String</code> 类的享元模式的设计，跟 <code>Integer</code> 类稍微有些不同。<code>Integer</code> 类中要共享的对象，是在类加载的时候，就集中一次性创建好的。但是，对于字符串来说，我们没法事先知道要共享哪些字符串常量，所以没办法事先创建好，只能在某个字符串常量第一次被用到的时候，存储到常量池中，当之后再用到的时候，直接引用常量池中已经存在的即可，就不需要再重新创建了。</p><h1 id="5-Android-源码中的享元（Handler）"><a href="#5-Android-源码中的享元（Handler）" class="headerlink" title="5 Android 源码中的享元（Handler）"></a>5 Android 源码中的享元（Handler）</h1><p>万万没想到，很不常用的享元模式，竟然在我们经常使用的 <code>Handler</code> 中用到了！说起 <code>Handler</code> ，一般都是在耗时操作的时候才会使用 <code>Handler</code> ，比如更新 <code>UI</code>，大家肯定听过一句话，<code>UI</code> 不能够在子线程中更新。这原本就是一个伪命题，因为并不是 <code>UI</code> 不可以在子线程更新，而是 <code>UI</code> 不可以在不是它的创建线程里进行更新。只是绝大多数情况下 <code>UI</code> 都是从 <code>UI</code> 线程中创建的，因此，在其他线程更新时会抛出异常。</p><p><a href="https://blog.csdn.net/lmj623565791/article/details/105624391">Android UI 线程更新UI也会崩溃？？？</a></p><p>这里插入一个小小的知识点，然后回到我们的猪脚 ^(*￣(oo)￣)^  <code>handler</code> 中。</p><p>我们在通过 <code>Handler</code> 中传递消息时会传递一个 <code>Runnable</code>，<code>Runnable</code> 会被包装到一个 <code>Message</code> 对象中，然后再投递到 <code>UI</code> 线程的消息队列。具体看 <code>post</code> 代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span>  sendMessageDelayed(getPostMessage(r), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Message <span class="title">getPostMessage</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">    Message m = Message.obtain();</span><br><span class="line">    m.callback = r;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到，<code>Message</code> 并不是 <code>new</code> 出来的，这个 <code>obtain</code> 有点蹊跷 ~ 这里只研究和享元模式相关的部分，其他部分看下面扩展 ~ </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sPool != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Message m = sPool;</span><br><span class="line">            sPool = m.next;</span><br><span class="line">            m.next = <span class="keyword">null</span>;<span class="comment">// 从sPool中取出一个 Message 对象，并消息链表断开(单独的一个节点)</span></span><br><span class="line">            m.flags = <span class="number">0</span>; <span class="comment">// clear in-use flag</span></span><br><span class="line">            sPoolSize--; <span class="comment">//消息池的可用大小进行减1操作</span></span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Message();<span class="comment">// 当消息池为空时，直接创建Message对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到，在 <code>mPool</code> 为 <code>null</code> 时才会去重新 <code>new</code> 一个 <code>Message</code> ，那我们只需要知道这个 <code>sPoolSync</code> 和 <code>sPool</code> 是什么，就可以知道这里的缓存是怎么做的了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Defines a message containing a description and arbitrary data object that can be</span></span><br><span class="line"><span class="comment"> * sent to a &#123;<span class="doctag">@link</span> Handler&#125;.  This object contains two extra int fields and an</span></span><br><span class="line"><span class="comment"> * extra object field that allow you to not do allocations in many cases.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p class=&quot;note&quot;&gt;While the constructor of Message is public, the best way to get</span></span><br><span class="line"><span class="comment"> * one of these is to call &#123;<span class="doctag">@link</span> #obtain Message.obtain()&#125; or one of the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Handler#obtainMessage Handler.obtainMessage()&#125; methods, which will pull</span></span><br><span class="line"><span class="comment"> * them from a pool of recycled objects.&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object sPoolSync = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Message sPool;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> sPoolSize = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>首先 <code>Message</code> 文档第一段的意思就是介绍了一下这个 <code>Message</code> 类的字段，以及说明 <code>Message</code> 对象是被发送到 <code>Handler</code> 的，对于我们来说作用不大。</p><p>第二段的意思是建议我们使用 <code>Message</code> 的 <code>obtain</code> 方法获取 <code>Message</code> 对象，而不是通过 <code>Message</code> 的构造函数，因为 <code>obtain</code> 方法会从被回收的对象池中获取 <code>Message</code> 对象。</p><p>然后再看看关键的字段，<code>sPoolSync</code> 是一个普通的 <code>Object</code> 对象，它的作用就是用于在获取 <code>Message</code> 对象时进行同步锁。再看 <code>sPool</code> 居然是一个 <code>Message</code> 对象，居然不是消息池之类的东西，既然它命名为 <code>sPool</code> 不可能是有名无实吧。原来还有一个比较总要的字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sometimes we store linked lists of these things</span></span><br><span class="line">Message next;</span><br></pre></td></tr></table></figure><p>原来 <code>Message</code> 消息池没有使用 <code>map</code> 这样的容器，使用的是链表！这个 <code>next</code> 就是指向下一个 <code>Message</code> 的。</p><p>每个 <code>Message</code> 对象都有一个同类型的 <code>next</code> 字段，这个 <code>next</code> 指向的就是下一个可用的 <code>Message</code> ，最后一个可用的 <code>Message</code> 的 <code>next</code> 则为空。这样一来，所有可用的 <code>Message</code> 对象就通过 <code>next</code> 串连成一个可用的 <code>Message</code> 池。</p><p>我们在 <code>obtain</code> 函数中只看到了从链表中获取，并且看到存储。如果消息池链表中没有可用对象的时候，<code>obtain</code> 中则是直接返回一个通过 <code>new</code> 创建的 <code>Message</code> 对象，而且并没有存储到链表中。那么这些 <code>Message</code> 对象什么时候会被放到链表中呢？</p><p><code>“which will pull them from a pool of recycled objects.”</code>，这是 <code>Message</code> 注释中的第二句话末尾的一句话，原来在创建的时候不会把 <code>Message</code> 对象放到池中，在回收（这里的回收并不是指虚拟机回收<code>Message</code> 对象）该对象时才会将该对象添加到链表中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否该消息还在使用</span></span><br><span class="line">    <span class="keyword">if</span> (isInUse()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (gCheckRecycle) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;This message cannot be recycled because it &quot;</span></span><br><span class="line">                    + <span class="string">&quot;is still in use.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清空状态，并且将消息添加到消息池中</span></span><br><span class="line">    recycleUnchecked();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对于不再使用的消息，加入到消息池 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recycleUnchecked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//清空消息状态，设置该消息 in - use flag</span></span><br><span class="line">    flags = FLAG_IN_USE;</span><br><span class="line">    what = <span class="number">0</span>;</span><br><span class="line">    arg1 = <span class="number">0</span>;</span><br><span class="line">    arg2 = <span class="number">0</span>;</span><br><span class="line">    obj = <span class="keyword">null</span>;</span><br><span class="line">    replyTo = <span class="keyword">null</span>;</span><br><span class="line">    sendingUid = -<span class="number">1</span>;</span><br><span class="line">    when = <span class="number">0</span>;</span><br><span class="line">    target = <span class="keyword">null</span>;</span><br><span class="line">    callback = <span class="keyword">null</span>;</span><br><span class="line">    data = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 回收消息到消息池中</span></span><br><span class="line">    <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sPoolSize &lt; MAX_POOL_SIZE) &#123; <span class="comment">//当消息池没有满时，将Message对象加入消息池</span></span><br><span class="line">            next = sPool;</span><br><span class="line">            sPool = <span class="keyword">this</span>;</span><br><span class="line">            sPoolSize++;<span class="comment">//消息池的可用大小进行加1操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>recycle</code> 函数会将一个 <code>Message</code> 对象回收到一个全局的池中，这个池也就是链表。<br><code>recycle</code> 函数首先判断该消息是否还在使用，如果还在使用则抛出异常，否则调用 <code>recycleUnchecked</code> 函数处理该消息。</p><p><code>recycleUnchecked</code> 函数中先清空该消息的各字段，并且将 <code>flags</code> 设置为 <code>FLAG_IN_USE</code> ，表明该消息已被使用，这个 <code>flag</code> 在 <code>obtain</code> 函数中会被置为 <code>0</code> ，这样根据这个 <code>flag</code> 就能够追踪该消息的状态。</p><p>然后判断是否要将该消息回收到消息池中，如果池的大小小于 <code>MAX_POOL_SIZE</code> 时，将<strong>自身添加到链表的表头</strong>。</p><p>例如，当链表中还没有元素时，将第一个<code>Message</code> 对象添加到链表中，此时 <code>sPool</code> 为null，<code>next</code> 指向了 <code>sPool</code> ，因此，<code>next</code> 也为 <code>null</code> ，然后 <code>sPool</code> 又指向了 <code>this</code> ，因此，<code>sPool</code> 就指向了当前这个被回收的对象，并且 <code>sPoolSize</code> 加1。<strong>相当于当前要回收的 <code>Message</code> (既然是要被回收的，肯定是一个独立的节点) <code>next</code> 指向回收池的头节点，再将 <code>sPool(头指针)</code>  指向当前节点，作为头节点。<code>obtain</code> 取的时候就是将头节点与之后的节点断开，单独取出来使用。</strong></p><p>这里的 <code>Message</code> 相当于承担了享元模式中 3 个元素的职责，即是 <code>Flyweight</code> 抽象，又是 <code>ConcreteFlyweight</code> 角色，同时又承担了 <code>FlyweightFactory</code> 管理对象池的职责。因为 <code>Android</code> 应用是事件驱动的，因此，如果通过 <code>new</code> 创建 <code>Message</code> 就会创建大量重复的 <code>Message</code> 对象，导致内存占用率高、频繁 <code>GC</code> 等问题，通过享元模式创建一个大小为 50 的消息池，避免了上述问题的产生，使得这些问题迎刃而解。</p><p><strong><code>Handler</code> 扩展</strong></p><p><a href="http://gityuan.com/2015/12/26/handler-message-framework/">Android消息机制-Handler(framework篇)</a></p><p><a href="http://gityuan.com/2015/12/27/handler-message-native/">Android消息机制-Handler(native篇)</a></p><p><a href="http://gityuan.com/2016/01/01/handler-message-usage/">Android消息机制3-Handler(实战)</a></p><h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a><strong>感谢</strong></h1><blockquote><p><a href="https://time.geekbang.org/column/intro/250?utm_source=pinpaizhuanqu&utm_medium=geektime&utm_campaign=guanwang&utm_term=guanwang&utm_content=0511">设计模式之美</a></p><p>《Android 源码设计模式解析与实战》</p><p>以及上文中的链接</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-结构型-组合模式</title>
      <link href="2020/design-pattern-composite.html"/>
      <url>2020/design-pattern-composite.html</url>
      
        <content type="html"><![CDATA[<p><code>Compose objects into tree structure to represent part-whole hierarchies.Composite lets client treat individual objects and compositions of objects uniformly.</code> </p><p><code>(将一组对象组织（Compose）成树形结构，以表示一种“部分 - 整体”的层次结构。组合让客户端（在很多设计模式书籍中，“客户端”代指代码的使用者。）可以统一单个对象和组合对象的处理逻辑。)</code></p><p>组合模式的数据必须能表示成树形结构，这也导致了这种模式在实际的项目开发中并不那么常用。但是，一旦数据满足树形结构，应用这种模式就能发挥很大的作用，能让代码变得非常简洁。</p><h1 id="1-组合模式-UML"><a href="#1-组合模式-UML" class="headerlink" title="1 组合模式 UML"></a>1 组合模式 UML</h1><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/design/design_uml_composite2.webp" alt="图片来源于《Android 源码设计模式解析与实战》"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象根节点，为组合中的对象声明接口。</span></span><br><span class="line"><span class="comment"> * 在适当的情况下，实现所有类共有接口的缺省行为。</span></span><br><span class="line"><span class="comment"> * 声明一个接口用于访问和管理 Component 的子节点。可在递归结构中定义一个接口，用于访问一个父节点，并在合适的情况下实现它。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Component</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">addChild</span><span class="params">(Component child)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">removeChild</span><span class="params">(Component child)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Component <span class="title">getChildren</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义有子节点的那些枝干节点的行为，存储子节点，在 Component 接口中实现与子节点有关的操作。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Composite</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Component&gt; components = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Composite</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != components) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Component c : components) &#123;</span><br><span class="line">                c.doSomething();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addChild</span><span class="params">(Component child)</span> </span>&#123;</span><br><span class="line">        components.add(child);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeChild</span><span class="params">(Component child)</span> </span>&#123;</span><br><span class="line">        components.remove(child);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Component <span class="title">getChildren</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> components.get(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在组合中表示叶子节点对象，叶子节点没有子节点，在组合中定义节点对象的行为。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Leaf</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Leaf</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addChild</span><span class="params">(Component child)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span>  <span class="keyword">new</span> UnsupportedOperationException(<span class="string">&quot;叶子节点没有子节点&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeChild</span><span class="params">(Component child)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span>  <span class="keyword">new</span> UnsupportedOperationException(<span class="string">&quot;叶子节点没有子节点&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Component <span class="title">getChildren</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span>  <span class="keyword">new</span> UnsupportedOperationException(<span class="string">&quot;叶子节点没有子节点&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//构造一个根节点</span></span><br><span class="line">Component root = <span class="keyword">new</span> Composite(<span class="string">&quot;Root&quot;</span>);</span><br><span class="line"><span class="comment">//构造连个枝干节点</span></span><br><span class="line">Component branch1 = <span class="keyword">new</span> Composite(<span class="string">&quot;Branch1&quot;</span>);</span><br><span class="line">Component branch2 = <span class="keyword">new</span> Composite(<span class="string">&quot;Branch2&quot;</span>);</span><br><span class="line"><span class="comment">//构造两个叶子节点</span></span><br><span class="line">Component leaf1 = <span class="keyword">new</span> Leaf(<span class="string">&quot;Leaf1&quot;</span>);</span><br><span class="line">Component leaf2 = <span class="keyword">new</span> Leaf(<span class="string">&quot;Leaf2&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将叶子节点添加至枝干节点</span></span><br><span class="line">branch1.addChild(leaf1);</span><br><span class="line">branch2.addChild(leaf2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将枝干节点添加至根节点中</span></span><br><span class="line">root.addChild(branch1);</span><br><span class="line">root.addChild(branch2);</span><br><span class="line"></span><br><span class="line">root.doSomething();</span><br></pre></td></tr></table></figure><p>像这样将组合所使用的方法定义在抽象类的方式称为<strong>透明的组合模式</strong>，而还有一种组合模式则称为<strong>安全的组合模式</strong>。</p><p>透明组合模式中不管是叶子节点还是枝干节点都有着相同的结构，那意味着我们无法通过 <code>getChildren</code> 方法得到子节点的类型，而必须在方法实现的内部进行判断。</p><p>安全的组合模式在使用时都必须直接使用具体的实现类。<code>UML</code> 如下，下面的 文件目录 例子是一个安全的组合模式。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/design/design_uml_composite.webp" alt="图片来源于《Android 源码设计模式解析与实战》"></p><h1 id="2-组合模式的简单实现"><a href="#2-组合模式的简单实现" class="headerlink" title="2 组合模式的简单实现"></a>2 组合模式的简单实现</h1><p>设计一个类来表示文件系统中的目录，能方便地实现下面这些功能：</p><ul><li>动态地添加、删除某个目录下的子目录或文件；</li><li>统计指定目录下的文件个数；</li><li>统计指定目录下的文件总大小。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FileSystemNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String path;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileSystemNode</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.path = path;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//文件数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">countNumOfFiles</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">countSizeOfFiles</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">File</span> <span class="keyword">extends</span> <span class="title">FileSystemNode</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">File</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(path);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNumOfFiles</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">countSizeOfFiles</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        java.io.File file = <span class="keyword">new</span> java.io.File(path);</span><br><span class="line">        <span class="keyword">if</span> (!file.exists()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> file.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Directory</span> <span class="keyword">extends</span> <span class="title">FileSystemNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;FileSystemNode&gt; subNodes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Directory</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(path);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNumOfFiles</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> numOfFiles = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (FileSystemNode fileOrDir : subNodes) &#123;</span><br><span class="line">            numOfFiles += fileOrDir.countNumOfFiles();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numOfFiles;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">countSizeOfFiles</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> sizeofFiles = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (FileSystemNode fileOrDir : subNodes) &#123;</span><br><span class="line">            sizeofFiles += fileOrDir.countSizeOfFiles();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sizeofFiles;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addSubNode</span><span class="params">(FileSystemNode fileOrDir)</span> </span>&#123;</span><br><span class="line">        subNodes.add(fileOrDir);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeSubNode</span><span class="params">(FileSystemNode fileOrDir)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = subNodes.size();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; size; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (subNodes.get(i).getPath().equalsIgnoreCase(fileOrDir.getPath())) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; size) &#123;</span><br><span class="line">            subNodes.remove(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * /</span></span><br><span class="line"><span class="comment"> * /wz/</span></span><br><span class="line"><span class="comment"> * /wz/a.txt</span></span><br><span class="line"><span class="comment"> * /wz/b.txt</span></span><br><span class="line"><span class="comment"> * /wz/movies/</span></span><br><span class="line"><span class="comment"> * /wz/movies/c.avi</span></span><br><span class="line"><span class="comment"> * /xzg/</span></span><br><span class="line"><span class="comment"> * /xzg/docs/</span></span><br><span class="line"><span class="comment"> * /xzg/docs/d.txt</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Directory fileSystemTree = <span class="keyword">new</span> Directory(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">Directory node_wz = <span class="keyword">new</span> Directory(<span class="string">&quot;/wz/&quot;</span>);</span><br><span class="line">Directory node_xzg = <span class="keyword">new</span> Directory(<span class="string">&quot;/xzg/&quot;</span>);</span><br><span class="line">fileSystemTree.addSubNode(node_wz);</span><br><span class="line">fileSystemTree.addSubNode(node_xzg);</span><br><span class="line"></span><br><span class="line">File node_wz_a = <span class="keyword">new</span> File(<span class="string">&quot;/wz/a.txt&quot;</span>);</span><br><span class="line">File node_wz_b = <span class="keyword">new</span> File(<span class="string">&quot;/wz/b.txt&quot;</span>);</span><br><span class="line">Directory node_wz_movies = <span class="keyword">new</span> Directory(<span class="string">&quot;/wz/movies/&quot;</span>);</span><br><span class="line">node_wz.addSubNode(node_wz_a);</span><br><span class="line">node_wz.addSubNode(node_wz_b);</span><br><span class="line">node_wz.addSubNode(node_wz_movies);</span><br><span class="line"></span><br><span class="line">File node_wz_movies_c = <span class="keyword">new</span> File(<span class="string">&quot;/wz/movies/c.avi&quot;</span>);</span><br><span class="line">node_wz_movies.addSubNode(node_wz_movies_c);</span><br><span class="line"></span><br><span class="line">Directory node_xzg_docs = <span class="keyword">new</span> Directory(<span class="string">&quot;/xzg/docs/&quot;</span>);</span><br><span class="line">node_xzg.addSubNode(node_xzg_docs);</span><br><span class="line"></span><br><span class="line">File node_xzg_docs_d = <span class="keyword">new</span> File(<span class="string">&quot;/xzg/docs/d.txt&quot;</span>);</span><br><span class="line">node_xzg_docs.addSubNode(node_xzg_docs_d);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;/ files num:&quot;</span> + fileSystemTree.countNumOfFiles());</span><br><span class="line">System.out.println(<span class="string">&quot;/wz/ files num:&quot;</span> + node_wz.countNumOfFiles());</span><br></pre></td></tr></table></figure><p>组合模式的定义：“将一组对象（文件和目录）组织成树形结构，以表示一种 ‘部分 - 整体’ 的层次结构（目录与子目录的嵌套结构）。组合模式让客户端可以统一单个对象（文件）和组合对象（目录）的处理逻辑（递归遍历）。”</p><p>这种组合模式的设计思路，与其说是一种设计模式，倒不如说是对业务场景的一种数据结构和算法的抽象。其中，数据可以表示成树这种数据结构，业务需求可以通过在树上的递归遍历算法来实现。</p><h1 id="3-Android-源码中的模式实现"><a href="#3-Android-源码中的模式实现" class="headerlink" title="3 Android 源码中的模式实现"></a>3 Android 源码中的模式实现</h1><p>在 <code>Android</code> 中，说到树，脱口而出的就是 <code>View</code> 树，是树形结构跑不了了！先看看 <code>UML</code></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/design/design_uml_view.webp" alt="图片来源于《Android 源码设计模式解析与实战》"></p><p>这里省略了 <code>View</code> 和 <code>ViewGroup</code> 类中的一些方法，在 <code>Android</code> 的这个视图层级中，容器一定是 <code>ViewGroup</code> ，而且只有 <code>ViewGroup</code> 才能包含其他的 <code>View</code> ，比如 <code>LinearLayout</code> 能包含 <code>TextView</code> 、<code>Button</code>、<code>CheckBox</code> 等，但是反过来 <code>TextView</code> 是不能包含 <code>LinearLayout</code> 的，因为 <code>TextView</code> 直接继承于<code>View</code>，其并非一个容器。这里 <code>View</code> 的视图层级中使用到的其实是一种安全的设计模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">View</span> <span class="keyword">implements</span> <span class="title">Drawable</span>.<span class="title">Callback</span>, <span class="title">KeyEvent</span>.<span class="title">Callback</span>,</span></span><br><span class="line"><span class="class">        <span class="title">AccessibilityEventSource</span> </span>&#123;</span><br><span class="line">          </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewGroup</span> <span class="keyword">extends</span> <span class="title">View</span> <span class="keyword">implements</span> <span class="title">ViewParent</span>, <span class="title">ViewManager</span> </span>&#123;  </span><br></pre></td></tr></table></figure><p>从继承的角度来说 <code>ViewGroup</code> 拥有 <code>View</code> 类所有的非私有方法，既然如此，两者的差别就在于 <code>ViewGroup</code> 所实现的 <code>ViewParent</code> 和 <code>ViewManager</code> 接口上，而事实也是如此，<code>ViewManager</code> 接口定义了 <code>addView</code> 、<code>removeView</code> 等对子视图操作的方法。</p><p>而 <code>ViewParent</code> 则定义了刷新容器的接口 <code>requestLayout</code> 和其他一些焦点事件的处理的接口。</p><p><code>ViewGroup</code> 除了所实现的这两个接口与 <code>View</code> 不一样外，还有重要的一点就是 <code>ViewGroup</code> 是抽象类，其将 <code>View</code> 中的 <code>onLayout</code> 方法重置为抽象方法，也就是说容器子类必须实现该方法来实现布局定位，我们知道 <code>View</code> 中的该方法是个空实现，因为对于一个普通的 <code>View</code> 来说该方法并没有什么实现价值，但是 <code>ViewGroup</code> 就不一样，要必须实现。除此之外，在 <code>View</code> 中比较重要的两个测绘流程的方法 <code>onMeasure</code> 和 <code>onDraw</code> 在 <code>ViewGroup</code> 中都没有被重写，相对于 <code>onMeasure</code> 方法，在 <code>ViewGroup</code> 中增加了一些计算子 <code>View</code> 的方法，如 <code>measureChildren</code>、<code>measureChildrenWithMargins</code> 等；而对于 <code>onDraw</code> 方法，<code>ViewGroup</code> 定义了一个 <code>dispatchDraw</code> 方法来调用其每一个子 <code>View</code> 的 <code>onDraw</code> 方法，由此可见，<code>ViewGroup</code> 真的就象一个容器一样，其职责只是负责对子元素的操作而非具体的个体行为。</p><h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a><strong>感谢</strong></h1><blockquote><p><a href="https://time.geekbang.org/column/intro/250?utm_source=pinpaizhuanqu&utm_medium=geektime&utm_campaign=guanwang&utm_term=guanwang&utm_content=0511">设计模式之美</a></p><p>《Android 源码设计模式解析与实战》</p><p>以及上文中的链接</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-结构型-适配器模式</title>
      <link href="2020/design-pattern-adapter.html"/>
      <url>2020/design-pattern-adapter.html</url>
      
        <content type="html"><![CDATA[<p>适配器是将两个不兼容的类融合在一起，它有点像粘合剂，将不同的东西通过一种转换使得它们能够协作起来。例如，经常碰到要在两个没有关系的类型之间进行交互，第一个解决方案是修改各自类的接口，但是如果没有源代码或者我们不愿意为了一个应用而修改各自的接口，此时怎么办？这种情况我们往往会使用一个 <code>Adapter</code> ，在这两种接口之间创建一个 “混血儿” 接口，这个 <code>Adapter</code> 会将这两个接口进行兼容，在不修改原有代码的情况下满足需求。</p><h1 id="1-适配器模式-UML"><a href="#1-适配器模式-UML" class="headerlink" title="1 适配器模式 UML"></a>1 适配器模式 UML</h1><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/design/design_adapter_uml.webp" alt="图片来源于《Android 源码设计模式解析与实战》"></p><ul><li>冲突：<code>Target</code> 期待调用 <code>operation2</code> 方法，而 <code>Adaptee</code> 并没有（这就是所谓的不兼容了）。</li><li>解决方案：为使 <code>Target</code> 能够使用 <code>Adaptee</code> 类里的 <code>operation3</code> 方法，故提供一个中间环节Adapter类（继承 <code>Adaptee</code> &amp; 实现 <code>Target</code> 接口），把<code>Adaptee</code> 的 <code>API</code>  与 <code>Target</code> 的 <code>API</code> 衔接起来（适配）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//目标抽象类定义客户所需接口，可以是一个抽象类或接口，也可以是具体类。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//适配者即被适配的角色，它定义了一个已经存在的接口，</span></span><br><span class="line"><span class="comment">// 这个接口需要适配，适配者类一般是一个具体类，包含了客户希望使用的业务方法，在某些情况下可能没有适配者类的源代码。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;被适配者的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//适配器可以调用另一个接口，作为一个转换器，对Adaptee和Target进行适配，</span></span><br><span class="line"><span class="comment">// 适配器类是适配器模式的核心，在对象适配器中，它通过继承Target并关联一个Adaptee对象使二者产生联系。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Adaptee</span> <span class="keyword">implements</span> <span class="title">Target</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...一些操作...</span></span><br><span class="line">        <span class="keyword">super</span>.operation3();</span><br><span class="line">        <span class="comment">//...一些操作...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Target adapterTarget = <span class="keyword">new</span> Adapter();</span><br><span class="line">adapterTarget.operation2();</span><br></pre></td></tr></table></figure><p>这是继承的方式，当然也可以用组合的方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">implements</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    Adaptee adaptee;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Adapter</span><span class="params">(Adaptee adaptee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.adaptee = adaptee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...一些操作...</span></span><br><span class="line">        adaptee.operation3();</span><br><span class="line">        <span class="comment">//...一些操作...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Target adapterTarget = <span class="keyword">new</span> Adapter(<span class="keyword">new</span> Adaptee());</span><br><span class="line">adapterTarget.operation2();</span><br></pre></td></tr></table></figure><h1 id="2-装饰模式案例-电压适配器"><a href="#2-装饰模式案例-电压适配器" class="headerlink" title="2 装饰模式案例 电压适配器"></a>2 装饰模式案例 电压适配器</h1><p>我们国家的民用电都是 <code>220V</code>，有些国家是 <code>110V</code>，而我们的手机充电一般需要 <code>5V</code>，这时候要充电，就需要一个电压适配器，将 <code>220V</code> 或者 <code>100V</code> 的输入电压变换为 <code>5V</code> 输出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Adaptee</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AC</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">outputAC</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AC110</span> <span class="keyword">implements</span> <span class="title">AC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> output = <span class="number">110</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">outputAC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AC220</span> <span class="keyword">implements</span> <span class="title">AC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> output = <span class="number">220</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">outputAC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Target</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DC5Adapter</span> </span>&#123;</span><br><span class="line">    <span class="comment">//用于检查输入的电压是否与适配器匹配</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">support</span><span class="params">(AC ac)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用于将输入的电压变换为 5V 后输出</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">outputDC5V</span><span class="params">(AC ac)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//adapter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PowerAdapter110</span> <span class="keyword">implements</span> <span class="title">DC5Adapter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> voltage = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">support</span><span class="params">(AC ac)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (voltage == ac.outputAC());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">outputDC5V</span><span class="params">(AC ac)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> adapterInput = ac.outputAC();</span><br><span class="line">        <span class="comment">//变压器...</span></span><br><span class="line">        <span class="keyword">int</span> adapterOutput = adapterInput / <span class="number">22</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用 PowerAdapter110 变压适配器，输入AC:&quot;</span> + adapterInput + <span class="string">&quot;V&quot;</span> + <span class="string">&quot;，输出DC:&quot;</span> + adapterOutput + <span class="string">&quot;V&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> adapterOutput;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PowerAdapter220</span> <span class="keyword">implements</span> <span class="title">DC5Adapter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> voltage = <span class="number">220</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">support</span><span class="params">(AC ac)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (voltage == ac.outputAC());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">outputDC5V</span><span class="params">(AC ac)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> adapterInput = ac.outputAC();</span><br><span class="line">        <span class="comment">//变压器...</span></span><br><span class="line">        <span class="keyword">int</span> adapterOutput = adapterInput / <span class="number">44</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用 PowerAdapter220 变压适配器，输入AC:&quot;</span> + adapterInput + <span class="string">&quot;V&quot;</span> + <span class="string">&quot;，输出DC:&quot;</span> + adapterOutput + <span class="string">&quot;V&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> adapterOutput;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;DC5Adapter&gt; adapters = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Client</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.adapters.add(<span class="keyword">new</span> PowerAdapter220());</span><br><span class="line">        <span class="keyword">this</span>.adapters.add(<span class="keyword">new</span> PowerAdapter110());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据电压找合适的变压器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DC5Adapter <span class="title">getPowerAdapter</span><span class="params">(AC ac)</span> </span>&#123;</span><br><span class="line">        DC5Adapter adapter = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (DC5Adapter ad : <span class="keyword">this</span>.adapters) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ad.support(ac)) &#123;</span><br><span class="line">                adapter = ad;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (adapter == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;没有找到合适的变压适配器&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> adapter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Adapter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Client test = <span class="keyword">new</span> Client();</span><br><span class="line"><span class="comment">//        AC ac = new AC220();</span></span><br><span class="line">        AC ac = <span class="keyword">new</span> AC110();</span><br><span class="line">        <span class="comment">//通过外部传入 ac 确定电压适配器</span></span><br><span class="line">        DC5Adapter adapter = test.getPowerAdapter(ac);</span><br><span class="line">        adapter.outputDC5V(ac);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-Android-源码中的适配器模式"><a href="#4-Android-源码中的适配器模式" class="headerlink" title="4 Android 源码中的适配器模式"></a>4 Android 源码中的适配器模式</h1><p>说起 <code>Android</code> 最常见的就是 <code>Adapter</code> 了吧，那就整个学习一下 <code>RecyclerView</code> 、<code>LayoutManager</code> 和 <code>Adapter</code> </p><p>通过<strong>桥接模式</strong>，使 <code>RecyclerView</code> 将布局方式独立成 <code>LayoutManager</code>，实现对布局的定制化。</p><p>通过<strong>组合模式</strong>，使 <code>RecycleView</code> 通过 <code>dispatchLayout</code> 对 <code>Item View</code> 进行布局绘制的。</p><p>通过<strong>适配器模式</strong>，<code>ViewHolder</code> 将 <code>RecycleView</code> 与 <code>ItemView</code> 联系起来，使得 <code>RecycleView</code> 方便操作 <code>ItemView</code>。</p><p>通过<strong>观察者模式</strong>，给 <code>ViewHolder</code> 注册观察者，当调用 <code>notifyDataSetChanged</code> 时，就能重新绘制。</p><p><a href="https://www.jianshu.com/p/c52b947fe064">RecyclerView 源码解析</a></p><p><a href="https://www.jianshu.com/p/eabb00c500ef">RecyclerView 相关面试</a></p><h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a><strong>感谢</strong></h1><blockquote><p><a href="https://time.geekbang.org/column/intro/250?utm_source=pinpaizhuanqu&utm_medium=geektime&utm_campaign=guanwang&utm_term=guanwang&utm_content=0511">设计模式之美</a></p><p>《Android 源码设计模式解析与实战》</p><p>以及上文中的链接</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-结构型-装饰模式</title>
      <link href="2020/design-pattern-decorator.html"/>
      <url>2020/design-pattern-decorator.html</url>
      
        <content type="html"><![CDATA[<p>装饰模式（<code>Decorator Pattern</code>）也称为包装模式（<code>Wrapper Pattern</code>），使用一种对客户端透明的方式来动态地扩展对象的功能，同时它也是继承关系的一种替代方案之一。在现实生活中你也可以看见很多装饰模式的例子，或者可以大胆地说装饰模式无处不在，就拿人来说，人需要各式各样的衣着，不管你穿着怎样，但是，对于个人的本质来说是不变的，充其量只是在外面披上一层遮羞物而已，这就是装饰模式，装饰物也许各不相同但是装饰的对象本质是不变的。</p><h1 id="1-装饰模式-UML"><a href="#1-装饰模式-UML" class="headerlink" title="1 装饰模式 UML"></a>1 装饰模式 UML</h1><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/design/design_uml_decorator.webp" alt="图片来源于《Android 源码设计模式解析与实战》"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象类， 被装饰的原始对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="comment">//返回类型可以改变，从而实现装饰不同的属性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">operate</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//组件的具体实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="comment">//最基础的实现方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象装饰者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Component component;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decorator</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.component = component;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        component.operate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteDecoratorA</span> <span class="keyword">extends</span> <span class="title">Decorator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteDecoratorA</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//装饰基础方法，可以在在调用前后</span></span><br><span class="line">        <span class="comment">//如果父类有返回类型也可以接着处理返回对象，最后返回最终昂对象</span></span><br><span class="line">        operateA();</span><br><span class="line">        <span class="keyword">super</span>.operate();</span><br><span class="line">        operateB();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operateA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//装饰 A</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operateB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//装饰 B</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//具体调用，初始化基础类</span></span><br><span class="line">Component component = <span class="keyword">new</span> ConcreteComponent();</span><br><span class="line"><span class="comment">//基础类进行装饰</span></span><br><span class="line">Decorator decorator = <span class="keyword">new</span> ConcreteDecoratorA(component);</span><br><span class="line">decorator.operate();</span><br></pre></td></tr></table></figure><h1 id="2-简单实现"><a href="#2-简单实现" class="headerlink" title="2 简单实现"></a>2 简单实现</h1><p>开头说过人需要各式各样的衣着，不管你穿着怎样，但是，对于个人的本质来说是不变的，充其量只是在外面披上一层遮羞物而已，这就是装饰模式。那就用穿衣举例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">dressed</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类就是抽象类， 被装饰的原始对象，然后我们需要一个基础实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Boy</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dressed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;穿平角内裤&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是一个正常男生，实现了最基础的方法，当然你可以新增加一个屌丝男士，穿个丁字的 ~。然后我们需要对这个男生进行包装！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象装饰者，抽象方法过多时，可以统一重写子类不需要重写的方法，避免代码重复</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonCloth</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Person mPerson;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PersonCloth</span><span class="params">(Person mPerson)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mPerson = mPerson;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dressed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mPerson.dressed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExpensiveCloth</span> <span class="keyword">extends</span> <span class="title">PersonCloth</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExpensiveCloth</span><span class="params">(Person mPerson)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(mPerson);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dressShirt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;穿件短袖&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dressLeather</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;穿件皮衣&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dressJean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;穿条牛仔裤&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dressed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.dressed();</span><br><span class="line">        dressShirt();</span><br><span class="line">        dressLeather();</span><br><span class="line">        dressJean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheapCloth</span> <span class="keyword">extends</span> <span class="title">PersonCloth</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CheapCloth</span><span class="params">(Person mPerson)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(mPerson);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dressShorts</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;穿个短裤&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dressed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.dressed();</span><br><span class="line">        dressShorts();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是两种不同价位的包装（装饰），两者都是为原本 <code>Boy</code> 类中的 <code>dressed</code> 方法提供功能扩展，不过这种扩展并非是直接修改原有的方法逻辑或结构，更恰当地说，仅仅是在另一个类中将原有方法和新逻辑进行封装整合而已。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Person person = <span class="keyword">new</span> Boy();</span><br><span class="line"></span><br><span class="line">PersonCloth clothCheap = <span class="keyword">new</span> CheapCloth(person);</span><br><span class="line">clothCheap.dressed();</span><br><span class="line"></span><br><span class="line">PersonCloth clothExpensive = <span class="keyword">new</span> ExpensiveCloth(person);</span><br><span class="line">clothExpensive.dressed();</span><br></pre></td></tr></table></figure><h1 id="3-Java-中的装饰模式（Java-IO）"><a href="#3-Java-中的装饰模式（Java-IO）" class="headerlink" title="3 Java 中的装饰模式（Java IO）"></a>3 Java 中的装饰模式（Java IO）</h1><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/design/design_decorator_java.webp" alt="图片来源于极客时间"></p><p>在初学 <code>Java</code> 的时候，曾经对 <code>Java IO</code> 的一些用法产生过很大疑惑。我们打开文件 <code>test.txt</code>，从中读取数据。其中，<code>InputStream</code> 是一个抽象类，<code>FileInputStream</code> 是专门用来读取文件流的子类。<code>BufferedInputStream</code> 是一个支持带缓存功能的数据读取类，可以提高数据读取的效率。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">InputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;/test.txt&quot;</span>);</span><br><span class="line">InputStream bin = <span class="keyword">new</span> BufferedInputStream(in);</span><br><span class="line"><span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">128</span>];</span><br><span class="line"><span class="keyword">while</span> (bin.read(data) != -<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的装饰模式有个特殊的使用场景（之前的例子代码上也可以，只是场景不合适），装饰器类和原始类继承同样的父类，这样我们可以对原始类 “嵌套” 多个装饰器类。</p><p>对 <code>FileInputStream</code> 嵌套了两个装饰器类：<code>BufferedInputStream</code> 和 <code>DataInputStream</code>，让它既支持缓存读取，又支持按照基本数据类型来读取数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">InputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;/test.txt&quot;</span>);</span><br><span class="line">InputStream bin = <span class="keyword">new</span> BufferedInputStream(in);</span><br><span class="line">DataInputStream din = <span class="keyword">new</span> DataInputStream(bin);</span><br><span class="line"><span class="keyword">int</span> data = din.readInt();</span><br></pre></td></tr></table></figure><p>其实 <code>BufferedInputStream</code> 和 <code>DataInputStream</code> 继承自 <code>FilterInputStream</code>，<code>Java IO</code> 抽象出的一个装饰器父类，他就类似于 抽象装饰者(<code>PersonCloth</code>)  ，因为这两个装饰类只是对部分方法进行装饰，还有一部分方法没必要重写 <code>FilterInputStream</code> 就是统一重写方法，避免代码重复。</p><p>具体可以看 <code>JDK</code> 源码，和上面例子基本类似。</p><h1 id="4-Android-源码中的装饰模式（Context）"><a href="#4-Android-源码中的装饰模式（Context）" class="headerlink" title="4 Android 源码中的装饰模式（Context）"></a>4 Android 源码中的装饰模式（Context）</h1><p><a href="http://gityuan.com/2017/04/09/android_context/">理解Android Context</a></p><h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a><strong>感谢</strong></h1><blockquote><p><a href="https://time.geekbang.org/column/intro/250?utm_source=pinpaizhuanqu&utm_medium=geektime&utm_campaign=guanwang&utm_term=guanwang&utm_content=0511">设计模式之美</a></p><p>《Android 源码设计模式解析与实战》</p><p>以及上文中的链接</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 功能原理记录</title>
      <link href="2020/git-principle.html"/>
      <url>2020/git-principle.html</url>
      
        <content type="html"><![CDATA[<p><code>Git</code> 是一个版本管理软件，由 <code>Linux</code> 之父花了 <strong>三天</strong> 搞出来的东西。</p><p>手动惭愧 (〃’▽’〃)</p><h2 id="一-clone-项目"><a href="#一-clone-项目" class="headerlink" title="一 clone(项目)"></a>一 clone(项目)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;CalmCenter&#x2F;UiStarge.git ui-starge</span><br></pre></td></tr></table></figure><p>最后那个 <code>ui-starge</code> 表示手动指定本地仓库目录名称。</p><p>使用 <code>git clone</code> 时，除了从远程仓库把 <code>.git</code> 这个仓库目录下载到工作目录中，还会 <code>checkout</code> （签出） <code>master</code>（<code>checkout</code> 的意思就是把某个 <code>commit</code> 作为<strong>当前</strong> <code>commit</code>，把 <code>HEAD</code> 移动过去，并把工作目录的文件内容替换成这个 <code>commit</code> 所对应的内容）。</p><h2 id="二-push-提交"><a href="#二-push-提交" class="headerlink" title="二 push(提交)"></a>二 push(提交)</h2><h3 id="add-添加至暂存区"><a href="#add-添加至暂存区" class="headerlink" title="add(添加至暂存区)"></a>add(添加至暂存区)</h3><p><code>push</code> 做的事是：把当前 <code>branch</code> 的位置（即它指向哪个 <code>commit</code>）上传到远端仓库，并把它的路径上的  <code>commits</code>  一并上传。</p><p>基础步骤 <code>add -&gt; commit -&gt; push</code> ，接下来一个一个看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add test.txt</span><br></pre></td></tr></table></figure><p><code>add</code> 后面可以使文件或者文件夹，如果是文件夹 <code>test/</code> 。如果文件或文件夹名字有空格，比如 <code>text 1.txt</code> 文件 或 <code>text 2</code> 文件夹 ，需要写成  <code>get add test\ 1.txt</code> 或 <code>get add test\ 2/</code> ，将空格转义一下。</p><p>还有一个更方便的方法 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure><p><code>add</code> 指令除了 <code>git add 文件名</code> 这种用法外，还可以使用 <code>add .</code> 来直接把工作目录下的所有改动全部放进暂存区。这个用法没什么特别的好处，但就一个字：方便 (^_−)☆。</p><p>添加或删除的文件都需要 <code>add</code> ，也包括<strong>改名</strong>前的文件。 </p><p>你在 <code>add</code> 后，如果再次修改的已经添加的文件，需要再次 <code>add</code> ，因为通过 add 添加进暂存区的不是文件名，而是具体的对改动内容的一个快照。</p><h3 id="commit-提交到本地仓库"><a href="#commit-提交到本地仓库" class="headerlink" title="commit(提交到本地仓库)"></a>commit(提交到本地仓库)</h3><p>正常提交 <code>-m</code> 后面写提交信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;test&quot;</span><br></pre></td></tr></table></figure><p>当提交后，发现内容有误，需要怎么办？修改后重新提交一个 <code>commit</code> ？ 当然可以，不过还有一个更加优雅和简单的解决方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -—amend</span><br></pre></td></tr></table></figure><p><code>&quot;amend&quot;</code> 是「修正」的意思。在提交时，如果加上 <code>--amend</code> 参数，<code>Git</code> 不会在当前 <code>commit</code> 上增加 <code>commit</code>，而是会把当前 <code>commit</code> 里的内容和暂存区里的内容合并起来后创建一个新的 <code>commit</code>，<strong>用这个新的 <code>commit</code> 把当前 <code>commit</code> 替换掉</strong>。</p><p>需要注意：<code>commit --amend</code> 并不是直接修改原 <code>commit</code> 的内容，而是生成一条新的 <code>commit</code> ，替换掉旧的 <code>commit</code> 。如果旧的 <code>commit</code> 已经 <code>push</code> 到远程仓库，替换后 <code>push</code> 的时候需要在 <code>push</code> 后加 <code>-f</code> ：<code>git push -f</code> 强制更新远程仓库历史。</p><p>这种方式只能修改最新的 <code>commit</code> ，那如果要修改倒数第二个、第三个 <code>commit</code> 怎么办呢？<code>八 rebase 4.1</code> 中会详细说明。</p><h3 id="push"><a href="#push" class="headerlink" title="push"></a>push</h3><p>提交到远程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure><p><code>git push</code> 是提交当前分支已经 <code>commit</code> 的文件。<strong>分支提交请查看  <code>Branch(分支)</code> 部分</strong></p><h3 id="push-上去了才发现写错怎么办？"><a href="#push-上去了才发现写错怎么办？" class="headerlink" title="push 上去了才发现写错怎么办？"></a>push 上去了才发现写错怎么办？</h3><p><strong>出错的内容在你自己的 <code>branch</code></strong>，不会影响到其他人，那没关系用本文的方法把写错的 <code>commit</code> 修改或者删除掉，然后再 <code>push</code> 上去就好了。</p><p>如果是修改或删掉了本地的 <code>commit</code> 需要用下面的命令强制更新远程才可以  ~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin branch1 -f</span><br></pre></td></tr></table></figure><p><strong>当出错的内容已经合并到 <code>master</code></strong> ，同事的工作都在 <code>master</code> 上，永远不知道一次强制 <code>push</code> 会不会洗掉同事刚发上去的新提交。<br>除非人员数量和行为都完全可控的超小团队，可以和同事做到无死角的完美沟通，不然一定别在 <code>master</code> 上强制 <code>push</code>。</p><p>在这种时候，你只能退一步，选用另一种策略：<br>增加一个新的提交，把之前提交的内容抹掉。例如之前你增加了一行代码，你希望撤销它，那么你就做一个删掉这行代码的提交；<br>如果你删掉了一行代码，你希望撤销它，那么你就做一个把这行代码还原回来的提交。</p><p>这种事做起来也不算麻烦，因为 Git 有一个对应的指令：<code>revert</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert HEAD^</span><br></pre></td></tr></table></figure><p>上面这行代码就会增加一条新的 <code>commit</code>，它的内容和倒数第二个 <code>commit</code> 是相反的，从而和倒数第二个 <code>commit</code> 相互抵消，达到撤销的效果。</p><p>在 <code>revert</code> 完成之后，把新的 <code>commit</code> 再 <code>push</code> 上去，这个 <code>commit</code> 的内容就被撤销了。它和前面所介绍的撤销方式相比，最主要的区别是，这次改动只是被「反转」了，并没有在历史中消失掉，你的历史中会存在两条 <code>commit</code> ：一个原始 <code>commit</code> ，一个对它的反转 <code>commit</code>。</p><h2 id="三-pull-拉取"><a href="#三-pull-拉取" class="headerlink" title="三 pull(拉取)"></a>三 pull(拉取)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure><p>这个命令可以 <code>拉取文件</code> 比如其他人提交或合并了文件，还可以 <code>拉取远程分支</code> 比如其他人将分支提交到了远程仓库，<code>pull</code> 的实际操作其实是把远端仓库的内容用 <code>fetch</code> 取下来之后，用 <code>merge</code> 来合并。</p><h2 id="四-查看提交记录"><a href="#四-查看提交记录" class="headerlink" title="四 查看提交记录"></a>四 查看提交记录</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit 2c796942b103740176aae9eab1e2ead364c75787 (HEAD -&gt; master, origin&#x2F;master, origin&#x2F;HEAD)</span><br><span class="line">Author: Pc</span><br><span class="line">Date:   Thu Jul 16 16:04:31 2020 +0800</span><br><span class="line"></span><br><span class="line">    delete</span><br><span class="line"></span><br><span class="line">commit efc90131928c01ff3c8db1feae58461c766c78cd</span><br><span class="line">Author: Calm Lv</span><br><span class="line">Date:   Thu Jul 16 16:02:28 2020 +0800</span><br><span class="line"></span><br><span class="line">    Delete test 1.txt</span><br><span class="line"></span><br><span class="line">commit 24078eeecdaae6091e65170d86dcd4e20a474817</span><br><span class="line">Author: Pc</span><br><span class="line">Date:   Thu Jul 16 16:00:17 2020 +0800</span><br><span class="line"></span><br><span class="line">    test</span><br></pre></td></tr></table></figure><p>第一行的 <code>commit</code> 后面括号里的 <code>HEAD -&gt; master, origin/master, origin/HEAD</code> ，是几个指向这个 <code>commit</code> 的<strong>「引用」</strong>。</p><ul><li><p><strong>commit 唯一标识</strong></p><p>每一个 <code>commit</code> 都有一个它唯一的指定方式，它的 <code>SHA-1</code> 校验和，也就是上图中每个 <code>commit</code> 右边的那一长串字符。</p><p>两个 <code>SHA-1</code> 值的重复概率极低，所以可以使用这个 <code>SHA-1</code> 值来指代 <code>commit</code>，也可以只使用它的前几位来指代它（例如第一个 <code>2c796942b...75787</code>，你使用 ``2c79694<code>甚至</code>2c79` 来指代它）</p><p>但毕竟这种没有任何含义的字符串是很难记忆的，所以 <code>Git</code> 提供了「引用」的机制：使用固定的字符串作为「引用」，指向某个 <code>commit</code>，作为操作 <code>commit</code> 时的快捷方式。</p></li><li><p><strong>HEAD</strong></p><p> <code>HEAD</code> 是「引用」中最特殊的一个：它是指向当前 <code>commit</code> 的「引用」，也就是当前工作目录所对应的 <code>commit</code>。</p></li><li><p><strong>origin/master、origin/HEAD</strong></p><p> 它们是对远端仓库的 <code>master</code> 和 <code>HEAD</code> 的本地镜像</p></li></ul><p><code>git log</code> 可以查看提交记录，但是看不到更多的细节，如何查看更多的细节呢？</p><h3 id="查看每个-commit-单行显示"><a href="#查看每个-commit-单行显示" class="headerlink" title="查看每个 commit 单行显示"></a>查看每个 commit 单行显示</h3><p>只显示 <code>commit SHA-1</code> 校验和 ，以及 提交说明。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --oneline</span><br></pre></td></tr></table></figure><h3 id="查看每个-commit-图标显示"><a href="#查看每个-commit-图标显示" class="headerlink" title="查看每个 commit 图标显示"></a>查看每个 commit 图标显示</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --oneline --graph --all</span><br></pre></td></tr></table></figure><h3 id="查看每个-commit-大致改动"><a href="#查看每个-commit-大致改动" class="headerlink" title="查看每个 commit 大致改动"></a>查看每个 commit 大致改动</h3><p>如果你只想大致看一下改动内容，但并不想深入每一行的细节（例如你想回顾一下自己是在哪个 <code>commit</code> 中修改了 <code>xxx.txt</code> 文件）可以使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --stat</span><br></pre></td></tr></table></figure><h3 id="查看每个-commit-详细改动"><a href="#查看每个-commit-详细改动" class="headerlink" title="查看每个 commit 详细改动"></a>查看每个 commit 详细改动</h3><p><code>-p</code> 是 <code>--patch</code> 的缩写，通过 <code>-p</code> 参数，你可以看到具体每个 <code>commit</code> 的改动细节</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log -p</span><br></pre></td></tr></table></figure><h3 id="查看当前-commit-的改动内容"><a href="#查看当前-commit-的改动内容" class="headerlink" title="查看当前 commit 的改动内容"></a>查看当前 <code>commit</code> 的改动内容</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git show</span><br></pre></td></tr></table></figure><h3 id="查看任意一个-commit"><a href="#查看任意一个-commit" class="headerlink" title="查看任意一个 commit"></a>查看任意一个 commit</h3><p>在 <code>show</code> 后面加上这个 <code>commit</code> 的引用（<code>branch</code> 或 <code>HEAD</code> 标记）或它的 <code>SHA-1</code> 码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git show 03c8</span><br></pre></td></tr></table></figure><h3 id="查看指定-commit-中的指定文件改动内容"><a href="#查看指定-commit-中的指定文件改动内容" class="headerlink" title="查看指定 commit 中的指定文件改动内容"></a>查看指定 commit 中的指定文件改动内容</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git show 03c8 branch1.txt</span><br></pre></td></tr></table></figure><h3 id="查看未提交的内容"><a href="#查看未提交的内容" class="headerlink" title="查看未提交的内容"></a>查看未提交的内容</h3><p>使用 <code>git diff --staged</code> 可以显示 暂存区( <code>add</code> 后的内容) 和 上一条提交 之间的不同，换句话说，这条指令可以让你看到「输入 <code>git commit</code> 后，你将会提交什么」</p><h4 id="比对暂存区和上一条提交"><a href="#比对暂存区和上一条提交" class="headerlink" title="比对暂存区和上一条提交"></a>比对暂存区和上一条提交</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff --staged</span><br></pre></td></tr></table></figure><p><code>--staged</code> 有一个等价的选项叫做 <code>--cached</code>。这里所谓的「等价」，是真真正正的等价，它们的意思完全相同。</p><h4 id="比对工作目录和暂存区"><a href="#比对工作目录和暂存区" class="headerlink" title="比对工作目录和暂存区"></a>比对工作目录和暂存区</h4><p>使用 <code>git diff</code> （不加选项参数）可以显示 工作目录 和 暂存区之间 的不同。换句话说，这条指令可以让你看到「执行 <code>add .</code> ，你会向暂存区中增加哪些内容」</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></table></figure><h4 id="比对工作目录和上一条提交"><a href="#比对工作目录和上一条提交" class="headerlink" title="比对工作目录和上一条提交"></a>比对工作目录和上一条提交</h4><p>它是上面这二者的内容相加。换句话说，这条指令可以让你看到「现在把所有文件都 <code>add</code> 然后 <code>git commit</code>，你将会提交什么」（不过需要注意，没有被 <code>Git</code> 记录在案的文件（即从来没有被 <code>add</code> 过 的文件，<code>untracked files</code> 并不会显示出来。为什么？因为对 <code>Git</code> 来说它并不存在啊，新创建的文件不会显示）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff HEAD</span><br></pre></td></tr></table></figure><p>如果你把 <code>HEAD</code> 换成其他的 <code>commit</code>，也可以显示当前工作目录和这条 <code>commit</code> 的区别。</p><h3 id="Reflog-查看引用移动记录"><a href="#Reflog-查看引用移动记录" class="headerlink" title="Reflog 查看引用移动记录"></a>Reflog 查看引用移动记录</h3><p><code>reflog</code> 是 <code>&quot;reference log&quot;</code> 的缩写，使用它可以查看 <code>Git</code> 仓库中的引用的移动记录。如果不指定引用，它会显示 <code>HEAD</code> 的移动记录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog</span><br><span class="line">347cd98 (HEAD -&gt; master, origin&#x2F;master, origin&#x2F;HEAD) HEAD@&#123;0&#125;: checkout: moving from feature2 to master</span><br><span class="line">3a10357 (feature2) HEAD@&#123;1&#125;: checkout: moving from master to feature2</span><br></pre></td></tr></table></figure><p>这里可以查看之前分支的 <code>commit</code> 信息，如果 <code>feature2</code> 在这之后被删除了，可以查看之前 <code>feature2</code> 最后的切换信息，例如上面的 <code>347cd98</code> 表示 <code>HEAD</code> 的最后一次移动行为是「从 <code>feature2</code> 移动到 <code>master</code>」，如果之后 <code>feature2</code> 被删除了，我们可以切换回 <code>347cd98</code>，然后重新创建 <code>feature2</code> ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout 347cd98</span><br><span class="line">git checkout -b feature2</span><br></pre></td></tr></table></figure><p>这样就实现了分支追回。</p><blockquote><p>注意：不再被引用直接或间接指向的 <code>commit</code> 会在一定时间后被 <code>Git</code> 回收，所以使用 <code>reflog</code> 来找回删除的 <code>branch</code> 的操作一定要及时，不然有可能会由于 <code>commit</code> 被回收而再也找不回来。</p></blockquote><h2 id="五-Branch-分支"><a href="#五-Branch-分支" class="headerlink" title="五 Branch(分支)"></a>五 Branch(分支)</h2><p><code>HEAD</code> 是 <code>Git</code> 中一个独特的「引用」，它是唯一的。而除了 <code>HEAD</code> 之外，<code>Git</code> 还有一种「引用」，叫做 <code>branch</code>（分支）。</p><p><code>HEAD</code> 除了可以指向 <code>commit</code>，还可以指向一个 <code>branch</code>，当它指向某个 <code>branch</code> 的时候，会通过这个 <code>branch</code> 来间接地指向某个 <code>commit</code></p><p>上面的 <code>git log</code> 输出中，<code>HEAD -&gt; master</code> 中的 <code>master</code> 就是一个 <code>branch</code> 的名字，并且它是默认的 <code>branch</code>，而它左边的箭头 <code>-&gt;</code> 表示 <code>HEAD</code> 正指向它（当然，也会间接地指向它所指向的 <code>commit</code>）。</p><p>当我们执行 <code>git commit</code> 后 ，<code>HEAD</code> 和 <code>master</code> 这两个「引用」都指向了新的 <code>commit</code>，而 <code>origin/master</code> 和 <code>origin/HEAD</code> 则依然停留在原先的位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit 0b4d1da7f998bc5fb724b0a74b4034c5dab9e35a (HEAD -&gt; master)</span><br><span class="line">Author: Pc </span><br><span class="line">Date:   Thu Jul 16 16:46:58 2020 +0800</span><br><span class="line"></span><br><span class="line">    add</span><br><span class="line"></span><br><span class="line">commit 2c796942b103740176aae9eab1e2ead364c75787 (origin&#x2F;master, origin&#x2F;HEAD)</span><br><span class="line">Author: Pc </span><br><span class="line">Date:   Thu Jul 16 16:04:31 2020 +0800</span><br><span class="line"></span><br><span class="line">    delete</span><br></pre></td></tr></table></figure><h3 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch &lt;分支名&gt;</span><br></pre></td></tr></table></figure><h3 id="提交分支"><a href="#提交分支" class="headerlink" title="提交分支"></a>提交分支</h3><p>这里会将本地创建的分支更新到远程，并提交分支中的 <code>commits</code>。</p><p>如果本地当前 <code>HEAD</code> 处于新分支并且没有和远程关联，需要输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin &lt;分支名&gt;</span><br></pre></td></tr></table></figure><p>才能提交当前分支以及分支中的文件到远程仓库</p><p><code>origin</code> 是远程仓库的别名，是你在 <code>git clone</code> 的时候 <code>Git</code> 自动帮你起的，然后指明分支名称。这两个参数合起来指定了你要 <code>push</code> 到的目标仓库和目标分支。</p><p>如果进行了关联 （设置本地分支追踪远程分支）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push --set-upstream origin &lt;分支名&gt;</span><br><span class="line">git push -u origin &lt;分支名&gt;</span><br></pre></td></tr></table></figure><p>关联后就可以在当前分支使用 <code>git push</code> 直接提交。</p><p><a href="https://stackoverflow.com/questions/5697750/what-exactly-does-the-u-do-git-push-u-origin-master-vs-git-push-origin-ma">What exactly does the “u” do? “git push -u origin master” vs “git push origin master”</a></p><p><a href="https://www.zhihu.com/question/20019419/answer/138627544">git push 的 -u 参数具体适合含义？</a></p><h3 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure><h3 id="切换分支（checkout）"><a href="#切换分支（checkout）" class="headerlink" title="切换分支（checkout）"></a>切换分支（checkout）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;分支名&gt;</span><br></pre></td></tr></table></figure><p>还有一种方式是创建分支，创建并切换到刚创建的分支。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b &lt;分支名&gt;</span><br></pre></td></tr></table></figure><h4 id="checkout-本质："><a href="#checkout-本质：" class="headerlink" title="checkout 本质："></a><code>checkout</code> 本质：</h4><p><code>checkout</code> 并不止可以切换 <code>branch</code>。<code>checkout</code> 本质上的功能其实是：签出（ checkout ）指定的 <code>commit</code>。</p><p><code>git checkout branch名</code> 的本质，其实是把 <code>HEAD</code> 指向指定的 <code>branch</code>，然后签出这个 <code>branch</code> 所对应的 <code>commit</code> 的工作目录。所以同样的，<code>checkout</code> 的目标也可以不是 <code>branch</code>，而直接指定某个 <code>commit</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout HEAD^^</span><br><span class="line">git checkout 78a4bc</span><br></pre></td></tr></table></figure><p>在 <code>git status</code> 的提示语中，<code>Git</code> 会告诉你可以用 <code>checkout -- 文件名</code> 的格式，通过「签出」的方式来撤销工作目录中指定文件的修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is ahead of &#39;origin&#x2F;master&#39; by 8 commits.</span><br><span class="line">  (use &quot;git push&quot; to publish your local commits)</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">        modified:   branch1.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and&#x2F;or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- branch1.txt</span><br></pre></td></tr></table></figure><p>然后刚刚对这个文件的修改就都被撤回了 ~ </p><h4 id="checkout-和-reset-的不同"><a href="#checkout-和-reset-的不同" class="headerlink" title="checkout 和 reset 的不同"></a><code>checkout</code> 和 <code>reset</code> 的不同</h4><p><code>reset</code> 后面会讲，但是这里先说一下不同，既然说不同那肯定就有相同的地方：</p><p><code>checkout</code> 和 <code>reset</code> 都可以切换 <code>HEAD</code> 的位置，它们除了有许多细节的差异外，最大的区别在于：<code>reset</code> 在移动 <code>HEAD</code> 时会带着它所指向的 <code>branch(引用)</code> 一起移动，而 <code>checkout</code> 不会。</p><p><code>checkout</code> 有一个专门用来只让 <code>HEAD</code> 和 <code>branch</code> 脱离而不移动 <code>HEAD</code> 的用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout --detach</span><br></pre></td></tr></table></figure><p>现在提交 <code>commit</code> 之前所依赖的 <code>branch</code> 将不会一起移动。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">commit 347cd9856e1edf4c0a96cb15bad227ab8d255cda (HEAD)</span><br><span class="line">Author: Pc</span><br><span class="line">Date:   Tue Sep 29 18:27:18 2020 +0800</span><br><span class="line"></span><br><span class="line">    head</span><br><span class="line"></span><br><span class="line">commit 81bb6988fc9698699f697613876f5ad43a698564 (master)</span><br><span class="line">Author: Pc</span><br><span class="line">Date:   Tue Sep 29 18:26:43 2020 +0800</span><br><span class="line"></span><br><span class="line">    c</span><br></pre></td></tr></table></figure><p>应用场景：<br>比如想在某个 <code>commit</code> 出写一些临时的新的 <code>commits</code>，但不确定是否保留这些内容（或者倾向于不保留），那么就：</p><ol><li>不希望把当前的 branch 带跑；</li><li>不想新建一个别的 branch。</li></ol><p>那么就可以 <code>detach</code> 一下，这样就可以在后面的 <code>commits</code> 中只有 <code>HEAD</code> 在跟着 <code>commits</code> 跑，而 <code>branch</code> 一直留在原地。</p><h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d &lt;分支名&gt;</span><br></pre></td></tr></table></figure><ul><li><code>HEAD</code> 指向的 <code>branch</code> 不能删除。如果要删除 <code>HEAD</code> 指向的 <code>branch</code>，需要先用 <code>checkout</code> 把 <code>HEAD</code> 指向其他地方。</li><li>由于 <code>Git</code> 中的 <code>branch</code> 只是一个「引用」，所以删除 <code>branch</code> 的操作也只会删掉这个「引用」，并不会删除任何的 <code>commit(分支提交的内容)</code>。（不过如果一个 <code>commit</code> 不在任何一个 <code>branch</code> 的「路径」上，或者换句话说，如果没有任何一个 <code>branch</code> 可以回溯到这条 <code>commit</code>（也许可以称为野生 <code>commit</code>？），那么在一定时间后，它会被 <code>Git</code> 的回收机制删除掉。）</li><li>出于安全考虑，没有被合并到 <code>master</code> 的 <code>branch</code> 在删除时会失败<code>(前提是有新内容)</code>，这种情况如果你确认是要删除这个 <code>branch</code> （例如某个未完成的功能被团队确认永久毙掉了，不再做了），可以把 <code>-d</code> 改成 <code>-D</code>，小写换成大写，就能删除了。</li></ul><p><strong>「引用」的本质</strong></p><p>所谓「引用」（<code>reference</code>），其实就是一个个的字符串。这个字符串可以是一个 <code>commit</code> 的 <code>SHA-1</code> 码（例：<code>c08de9a4d8771144cd23986f9f76c4ed729e69b0</code>），也可以是一个 <code>branch</code>（例：<code>ref: refs/heads/feature3</code>）。拿到这个字符串，就知道当前引用指向谁。</p><p><code>Git</code> 中的 <code>HEAD</code> 和每一个 <code>branch</code> 以及其他的引用，都是以文本文件的形式存储在本地仓库 <code>.git</code> 目录中，而 <code>Git</code> 在工作的时候，就是通过这些文本文件的内容来判断这些所谓的「引用」是指向谁的。</p><h2 id="六-merge-合并"><a href="#六-merge-合并" class="headerlink" title="六  merge(合并)"></a>六  merge(合并)</h2><p><code>merge</code> 的意思是「合并」，它做的事也是合并：指定一个 <code>commit</code>，把它合并到当前的 <code>commit</code> 来。</p><p><strong>把目标 <code>commit</code> 的路径上的所有 <code>commit</code> 的内容一并应用到当前 <code>commit</code> （即 <code>HEAD</code> 所指向的 <code>commit</code>），然后自动生成一个新的 <code>commit</code>。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge &lt;目标分支名&gt;</span><br></pre></td></tr></table></figure><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li><p>合并分支</p><p>当一个 <code>branch</code> 的开发已经完成，需要把内容合并回去时，用 <code>merge</code> 来进行合并。</p></li><li><p><code>pull</code> 的内部操作</p><p><code>pull</code> 的实际操作其实是把远端仓库的内容用 <code>fetch</code> 取下来之后，用 <code>merge</code> 来合并。</p></li></ul><h3 id="特殊情况-1：冲突"><a href="#特殊情况-1：冲突" class="headerlink" title="特殊情况 1：冲突"></a>特殊情况 1：冲突</h3><p><code>merge</code> 在做合并的时候，是有一定的自动合并能力的：<br>如果一个分支改了 <code>A</code> 文件，另一个分支改了 <code>B</code> 文件，那么合并后就是既改 <code>A</code>也改 <code>B</code>，这个动作会自动完成；<br>如果两个分支都改了同一个文件，但一个改的是第 <code>1</code> 行，另一个改的是第 <code>2</code> 行，那么合并后就是第 <code>1</code> 行和第 <code>2</code> 行都改，也是自动完成。</p><p>但是，如果两个分支修改了同一部分内容，<code>merge</code> 的自动算法就搞不定了。这种情况 <code>Git</code> 称之为：冲突（<code>Conflict</code>）。</p><p>两个分支改了相同的内容，<code>Git</code> 不知道应该以哪个为准。如果在 <code>merge</code> 的时候发生了这种情况，<code>Git</code> 就会把问题交给你来决定。它会告诉你 <code>merge</code> 失败，以及失败的原因。</p><p>我再 <code>feature1</code> 分支 <code>mergeTest.txt</code> 文件第一行写了几个字，并 <code>commit</code> 提交，然后切换到 <code>master</code> 分支，这时 <code>mergeTest.txt</code> 文件是没东西的，又在第一行写了几个字，并 <code>commit</code> 提交，最后在 <code>master</code> 分支去合并 <code>feature1</code> 分支，提示如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git merge feature1</span><br><span class="line">Auto-merging mergeTest.txt</span><br><span class="line">CONFLICT (content): Merge conflict in mergeTest.txt</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure><p>提示信息中心说 <code>mergeTest.txt</code> 中出现合并冲突，自动合并失败，要求把冲突解决后再提交。意思就是需要<strong>先 解决冲突 ，然后手动 <code>commit</code> 一下</strong></p><h4 id="1-解决冲突"><a href="#1-解决冲突" class="headerlink" title="1.解决冲突"></a>1.解决冲突</h4><p>现在打开冲突的文件，会发现是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">烦烦烦</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">奥德赛</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1</span><br></pre></td></tr></table></figure><p><code>Git</code> 虽然没有帮你完成自动 <code>merge</code>，但它对文件还是做了一些工作：它把两个分支冲突的内容放在了一起，并用 <code>=======</code> 符号标记出了它们的边界以及它们的出处。</p><p><code>HEAD</code> 中的内容是 <code>烦烦烦</code>，而 <code>feature1</code> 中的内容则是 <code>奥德赛</code>。这两个改动 <code>Git</code> 不知道应该怎样合并，于是把它们放在一起，由你来决定。假设你决定保留 <code>HEAD</code> 的修改，那么只要删除掉 <code>feature1</code> 的修改，再把 Git 添加的那三行 <code>&lt;&lt;&lt;</code> <code>===</code> <code>&gt;&gt;&gt;</code> 辅助文字也删掉，保存文件退出，所谓的「解决掉冲突」就完成了。</p><p>修改后只能剩下需要的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">烦烦烦</span><br></pre></td></tr></table></figure><h4 id="2-提交"><a href="#2-提交" class="headerlink" title="2.提交"></a>2.提交</h4><p>解决完冲突以后，就可以进行第二步—— <code>commit</code> 了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add mergeTest.txt</span><br><span class="line">git commit</span><br></pre></td></tr></table></figure><p>被冲突中断的 <code>merge</code>，在手动 <code>commit</code> 的时候依然会自动填写提交信息。这是因为在发生冲突后，<code>Git</code> 仓库处于一个「<code>merge</code> 冲突待解决」的中间状态，在这种状态下 <code>commit</code>，<code>Git</code> 就会自动地帮你添加「这是一个 <code>merge commit</code>」的提交信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Merge branch &#39;feature1&#39; into master</span><br><span class="line"></span><br><span class="line"># Conflicts:</span><br><span class="line">#mergeTest.txt</span><br></pre></td></tr></table></figure><h4 id="3-放弃解决冲突，取消-merge"><a href="#3-放弃解决冲突，取消-merge" class="headerlink" title="3.放弃解决冲突，取消 merge"></a>3.放弃解决冲突，取消 merge</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge --abort</span><br></pre></td></tr></table></figure><p>输入这行代码，你的 <code>Git</code> 仓库就会回到 <code>merge</code> 前的状态。</p><h3 id="特殊情况-2：HEAD-领先于目标-commit"><a href="#特殊情况-2：HEAD-领先于目标-commit" class="headerlink" title="特殊情况 2：HEAD 领先于目标 commit"></a>特殊情况 2：HEAD 领先于目标 commit</h3><p>如果 <code>merge</code> 时的目标 <code>commit</code> 和 <code>HEAD</code> 处的 <code>commit</code> 并不存在分叉，而是 <code>HEAD</code> 领先于目标 <code>commit</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1          2          3</span><br><span class="line">           ↑          ↑</span><br><span class="line">       feature1  HEAD&#x2F;master</span><br></pre></td></tr></table></figure><p>那么 <code>merge</code> 就没必要再创建一个新的 <code>commit</code> 来进行合并操作，因为并没有什么需要合并的。在这种情况下， <code>Git</code> 什么也不会做，<code>merge</code> 是一个空操作。</p><h3 id="特殊情况-3：HEAD-落后于目标-commit"><a href="#特殊情况-3：HEAD-落后于目标-commit" class="headerlink" title="特殊情况 3：HEAD 落后于目标 commit"></a>特殊情况 3：HEAD 落后于目标 commit</h3><p>这种又叫 <code>fast-forward</code></p><p>另一种情况：如果 <code>HEAD</code> 和目标 <code>commit</code> 依然是不存在分叉，但 <code>HEAD</code> 不是领先于目标 <code>commit</code>，而是落后于目标 <code>commit</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1          2          3          4</span><br><span class="line">                      ↑          ↑</span><br><span class="line">                 HEAD&#x2F;master   origin&#x2F;master</span><br></pre></td></tr></table></figure><p>那么 <code>Git</code> 会直接把 <code>HEAD</code> 移动到目标 <code>commit</code> </p><p>这种操作有一个专有称谓，叫做 <code>&quot;fast-forward&quot;</code>（快速前移）。</p><p>一般情况下，创建新的 <code>branch</code> 都是会和原 <code>branch</code> 并行开发的，不然没必要开 <code>branch</code> ，直接在原 <code>branch</code> 上开发就好。</p><p>但事实上，这种情形其实很常见，因为这其实是 <code>pull</code> 操作的一种经典情形：<strong>本地的 <code>master</code> 没有新提交，而远端仓库中有同事提交了新内容到 <code>master</code>。</strong><br>那么这时如果在本地执行一次 <code>pull</code> 操作，就会由于 <code>HEAD</code> 落后于目标 <code>commit</code> （也就是远端的 <code>master</code>）而造成 <code>&quot;fast-forward&quot;</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ git pull</span><br><span class="line">remote: Enumerating objects: 2, done.</span><br><span class="line">remote: Counting objects: 100% (2&#x2F;2), done.</span><br><span class="line">remote: Total 2 (delta 1), reused 2 (delta 1), pack-reused 0</span><br><span class="line">Unpacking objects: 100% (2&#x2F;2), done.</span><br><span class="line">From https:&#x2F;&#x2F;github.com&#x2F;CalmCenter&#x2F;UiStarge</span><br><span class="line">   195efe8..61213f7  master     -&gt; origin&#x2F;master</span><br><span class="line">Updating 195efe8..61213f7</span><br><span class="line">Fast-forward</span><br><span class="line"> branch1.txt   | 1 +</span><br><span class="line"> mergeTest.txt | 1 +</span><br><span class="line"> test1.txt     | 1 +</span><br><span class="line"> 3 files changed, 3 insertions(+)</span><br><span class="line"> create mode 100644 branch1.txt</span><br><span class="line"> create mode 100644 mergeTest.txt</span><br></pre></td></tr></table></figure><p>现在把 <code>git pull</code> 拆分执行：</p><p>第一步</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch</span><br></pre></td></tr></table></figure><p>下载远端仓库内容时，这两个镜像引用得到了更新，<code>origin/master</code> 和 <code>origin/HEAD</code> 移动到了最新的 <code>commit</code>。</p><p>在输入 <code>git log</code> 后你会发现找不到 <code>(origin/master, origin/HEAD)</code>  这个引用了，因为到更新到最新的 <code>commit</code> 了，这里只能打印当前 <code>commit</code>  以下的信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit 61213f7813ad116abdd498bd3575e7b4173b4c8e (HEAD -&gt; master)</span><br><span class="line">Merge: 195efe8 75aa327</span><br><span class="line">Author: Pc </span><br><span class="line">Date:   Wed Sep 23 14:32:33 2020 +0800</span><br><span class="line"></span><br><span class="line">    Merge branch &#39;feature2&#39;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>而 <code>git pull</code> 的第二步操作 <code>merge</code> 的目标 <code>commit</code> ，是远端仓库的 <code>HEAD</code>，也就是 <code>origin/HEAD</code> ，所以 <code>git pull</code> 的第二步的完整内容是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git merge origin&#x2F;HEAD</span><br><span class="line">Updating 61213f7..6c2bcc2</span><br><span class="line">Fast-forward</span><br><span class="line"> mergeTest.txt | 2 +-</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit 6c2bcc2a8ca9d872338d36df45dee8a95d900148 (HEAD -&gt; master, origin&#x2F;master, origin&#x2F;HEAD)</span><br><span class="line">Author: Pc</span><br><span class="line">Date:   Wed Sep 23 14:39:43 2020 +0800</span><br><span class="line"></span><br><span class="line">    test</span><br><span class="line"></span><br><span class="line">commit 61213f7813ad116abdd498bd3575e7b4173b4c8e</span><br><span class="line">Merge: 195efe8 75aa327</span><br><span class="line">Author: Pc </span><br><span class="line">Date:   Wed Sep 23 14:32:33 2020 +0800</span><br><span class="line"></span><br><span class="line">    Merge branch &#39;feature2&#39;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>因此 <code>HEAD</code> 就会带着 <code>master</code> 一起，也指向了最新 <code>commit</code> 。</p><p>如果不想用 <code>fast-forward</code> ，可以使用如下命令 <code>--no-ff：不使用 fast-forward 方式合并，保留分支的 commit 历史</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge --no-ff feature</span><br></pre></td></tr></table></figure><h2 id="七-Feature-Branch-最流行的工作流"><a href="#七-Feature-Branch-最流行的工作流" class="headerlink" title="七 Feature Branch(最流行的工作流)"></a>七 Feature Branch(最流行的工作流)</h2><p>目前最流行（不论是中国还是世界）的团队开发的工作流：<code>Feature Branch</code>。</p><p>这种工作流的核心内容可以总结为两点：</p><ol><li>任何新的功能（<code>feature</code>）或 <code>bug</code> 修复全都新建一个 <code>branch</code> 来写；</li><li><code>branch</code> 写完后，合并到 <code>master</code>，然后删掉这个 <code>branch</code>。</li></ol><p>这种工作流似乎没什么特别之处。但实质上，<code>Feature Branching</code> 这种工作流，为团队开发时两个关键的问题—— <strong>代码分享</strong> 和 <strong>一人多任务</strong> ——提供了解决方案。</p><h3 id="1-代码分享"><a href="#1-代码分享" class="headerlink" title="1.代码分享"></a>1.代码分享</h3><p>假设需要开发一个新功能，于是创建了一个新的 <code>branch</code> 叫做 <code>books</code>，然后开始在 <code>books</code> 上进行开发工作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b books</span><br></pre></td></tr></table></figure><p>在十几个 <code>commit</code> 过后，功能开发完毕，把代码 <code>push</code> 到中央仓库（例如 <code>GitHub</code>）去，然后告诉 <code>review</code> 的同事：「嘿，功能写完了，分支名是 <code>books</code>，谁有空的话帮我 <code>review</code> 一下吧。」</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin books</span><br></pre></td></tr></table></figure><p>然后负责 <code>review</code> 的同事就可以从中央仓库拉下来你的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br><span class="line">git chekcout books</span><br></pre></td></tr></table></figure><p>然后可以根据同事要求修改、更新，<code>review</code> 通过后，就可以合并到 <code>master</code> 上了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git pull </span><br><span class="line">git merge books</span><br></pre></td></tr></table></figure><p><code>merge</code> 之前 <code>pull</code> 一下，让 <code>master</code> 更新到和远程仓库同步</p><p>然后把合并后的结果 <code>push</code> 到了中央仓库，并删掉了 <code>books</code> 这个 <code>branch</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br><span class="line">git branch -d books</span><br><span class="line">git push origin -d books </span><br></pre></td></tr></table></figure><p><code>git push origin -d books</code> 用 <code>-d</code>参数把远程仓库的 <code>branch</code> 也删了</p><h3 id="2-Pull-Request"><a href="#2-Pull-Request" class="headerlink" title="2.Pull Request"></a>2.Pull Request</h3><p>上面这个流程，还可以利用 <code>Pull Request</code> 来进一步简化。</p><p><code>Pull Request</code> 并不是 <code>Git</code> 的内容，而是一些 Git 仓库服务提供方（例如 <code>GitHub</code>）所提供的一种便捷功能，它可以让团队的成员方便地讨论一个 <code>branch</code> ，并在讨论结束后一键合并这个 <code>branch</code> 到 <code>master</code>。</p><p>同样是把写好的 <code>branch</code> 给同事看，使用 <code>Pull Request</code> 的话可以这样：</p><p>首先创建一个 <code>pull request</code> </p><p>这是在 <code>push</code> 分支之后，会有一个这么个按钮快捷创建 <code>pull request</code>，但我现在试着不是每次都出~</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/git/git_pull_requests_7.png" alt=""></p><p>下面是正常创建流程。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/git/git_pull_requests_1.webp" alt=""></p><p>点击 <code>New pull request</code> 然后选择需要分享的分支，这里是 <code>feature2</code> ，选择后就可以看到修改内容，并且 <code>create pull request</code> 也可以点击了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/git/git_pull_requests_2.webp" alt=""></p><p>这里需要写修改内容 <code>md</code> 格式的。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/git/git_pull_requests_4.webp" alt=""></p><p>然后你的同事就可以在 <code>GitHub</code> 上看到你创建的 <code>Pull Request</code> 了。他们可以在 <code>GitHub</code> 的这个页面查看你的 <code>commits</code>，也可以给你评论表示赞同或提意见，你接下来也可以根据他们的意见把新的 <code>commits</code>  <code>push</code> 上来，页面会随着你新的 <code>push</code> 而展示出最新的 <code>commits</code>。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/git/git_pull_requests_5.webp" alt=""></p><p>在讨论结束以后，认为这个 <code>branch</code> 可以合并了，只需要点一下页面中那个绿色的 <code>&quot;Merge pull request&quot;</code> 按钮，<code>GitHub</code> 就会自动地在中央仓库帮你把 <code>branch</code> 合并到 <code>master</code> 了。</p><p>然后你只要在本地 <code>pull</code> 一下，把最新的内容拉到你的电脑上，这件事情就算完成了。</p><p>另外，<code>GitHub</code> 还设计了一个贴心的 <code>&quot;Delete branch&quot;</code> 按钮，方便你在合并之后一键删除 <code>branch</code>。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/git/git_pull_requests_6.webp" alt=""></p><h3 id="3-一人多任务"><a href="#3-一人多任务" class="headerlink" title="3.一人多任务"></a>3.一人多任务</h3><p>除了代码分享的便捷，基于 <code>Feature Branch</code> 的工作流对于<strong>一人多任务</strong>的工作需求也提供了很好的支持。</p><p>安安心心做事不被打扰，做完一件再做下一件自然是很美好的事，但现实往往不能这样。对于程序员来说，一种很常见的情况是，你正在认真写着代码，忽然紧急需要新填另外一个功能！</p><p>其实，虽然这种情况确实有点烦，但如果你是在独立的 <code>branch</code> 上做事，切换任务是很简单的。你只要稍微把目前未提交的代码简单收尾一下，然后做一个带有「未完成」标记的提交（例如，在提交信息里标上<code>「TODO」</code>），然后回到 <code>master</code> 去创建一个新的 <code>branch</code> 就好了。</p><p>如果有一天需要回来继续做这个 <code>branch</code>，你只要用 <code>checkout</code> 切回来，就可以继续了。</p><h2 id="八-rebase（变基）"><a href="#八-rebase（变基）" class="headerlink" title="八 rebase（变基）"></a>八 rebase（变基）</h2><p><code>rebase</code> ，又是一个中国人看不懂的词。这个词的意思，你如果查一下的话是 <code>变基</code>  (〃’▽’〃)    。 不忍直视 ~ (<em>/ω＼</em>)</p><p>其实这个翻译还是比较准确的。<code>rebase</code> 的意思是，给你的 <code>commit</code> 序列重新设置基础点（也就是父 <code>commit</code>）。展开来说就是，把你指定的 <code>commit</code> 以及它所在的 <code>commit</code> 串，以指定的目标 <code>commit</code> 为基础，依次重新提交一次。</p><p>一般情况下是在子分支去 <code>rebase</code> 主分支</p><h3 id="1-rebase-和-merge-的区别"><a href="#1-rebase-和-merge-的区别" class="headerlink" title="1. rebase 和 merge 的区别"></a>1. <code>rebase</code> 和 <code>merge</code> 的区别</h3><p>先看一下 <code>rebase</code> 的情况。</p><p>当前分支情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">                      master</span><br><span class="line">                        ↓</span><br><span class="line">1   →   2   →   3   →   4      </span><br><span class="line">          ↘</span><br><span class="line">             ↘</span><br><span class="line">                5   →   6</span><br><span class="line">                        ↑</span><br><span class="line">                     feature2</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout feature2</span><br><span class="line">git rebase master</span><br></pre></td></tr></table></figure><p>执行完后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">                      master         feature2</span><br><span class="line">                        ↓               ↓</span><br><span class="line">1   →   2   →   3   →   4   →   7   →   8      </span><br><span class="line">          ↘</span><br><span class="line">             ↘</span><br><span class="line">                5   →   6</span><br><span class="line">                       </span><br></pre></td></tr></table></figure><p>通过 <code>rebase</code>，<code>feature2</code> 把基础点从 <code>2</code> 换成了 <code>4</code> ，<code>feature2</code> 中的 <code>5</code> 和 <code>6</code> 两条 <code>commit</code> 也 变成了新的 <code>commit</code>  <code>7</code> 和 <code>8</code> ，但是内容是没有变的。<br>通过这样的方式，就让本来分叉了的提交历史重新回到了一条线。这种「重新设置基础点」的操作，就是 <code>rebase</code> 的含义。</p><p>更直观一点：</p><p>这是 <code>sourTree</code> 的历史日志，<code>feature2</code> 当前的在 <code>delete branch</code> 这个 <code>commit</code> 的基础下，更改了一些内容，并且当前 <code>master</code> 也有了新的更新，现在需要把 <code>master</code> 的内容合并到 <code>feature2</code> 上</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/git/git_log_2.png" alt=""></p><p>使用 <code>rebase</code> 合并后</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/git/git_log.png" alt=""></p><p><code>feature2</code> 的基准点变了，成了当前 <code>master</code> 指向的 <code>commit</code> ，并且他们的提交历史变成了一条直线。</p><p>那 <code>merge</code> 呢？</p><p><code>feature2</code> 当前的在 <code>branch 更新</code> 这个 <code>commit</code> 的基础下，更改了一些内容，并且当前 <code>master</code> 也有了新的更新，现在需要把 <code>master</code> 的内容合并到 <code>feature2</code> 上</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/git/git_log_3.png" alt=""></p><p>使用 <code>merge</code> 合并后</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/git/git_log_4.png" alt=""></p><p>这里可以明显的看到，多了一个 <code>commit</code> ，并且提交历史也是分叉的，如果分支多的情况下，会很乱的！</p><blockquote><p>现在，基本明白了 <code>rebase</code> 的作用，可以减少 <code>commit</code> 的数量以及减少分叉数量，使得提交历史干净整洁。</p></blockquote><p>当然这只是其中一部分作用。</p><h3 id="2-rebase-时出现了冲突怎么办？"><a href="#2-rebase-时出现了冲突怎么办？" class="headerlink" title="2.rebase 时出现了冲突怎么办？"></a>2.<code>rebase</code> 时出现了冲突怎么办？</h3><p>如果出现了冲突，在 <code>git</code> 页面中会出现 <code>REBASE 1/1</code> 。 <code>merge</code> 冲突时也会出现类似的提示，解决办法相同，把 <code>rebase</code> 改成 <code>merge</code> 即可。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/git/git_rebase_conflict.png" alt=""></p><p>需要手动解决，解决完后，用 <code>git add .</code> 或者某个文件名，来标记已解决，最后执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase --continue</span><br></pre></td></tr></table></figure><p>继续执行 <code>rebase</code> 完成变基。</p><p>如果想回到 <code>rebase</code> 执行之前的状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase --abort</span><br></pre></td></tr></table></figure><h3 id="3-使用-rebase-需要注意什么？"><a href="#3-使用-rebase-需要注意什么？" class="headerlink" title="3. 使用 rebase 需要注意什么？"></a>3. 使用 <code>rebase</code> 需要注意什么？</h3><p><code>rebase</code> 在为理解透彻之前，是不能随便使用的！</p><p>但是，有一个黄金定律，只要满足，就可以安全使用，并且比 <code>merge</code> 要好用很多。</p><blockquote><p><strong>只要你的分支上需要 <code>rebase</code> 的所有 <code>commits</code> 历史还没有被 <code>push</code> 过，就可以安全地使用 <code>git rebase</code> 来操作。</strong></p></blockquote><p>也就是说永远不要 <code>rebase</code> 一个已经在中央库中存在的 <code>commit</code> ，只能 <code>rebase</code> 你自己使用的私有 <code>commit</code>。</p><p>那 <code>rebase</code> 了一个已经 <code>push</code> 过的 <code>commit</code> 会怎么办呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">                      master</span><br><span class="line">                        ↓</span><br><span class="line">1   →   2   →   3   →   4      </span><br><span class="line">          ↘</span><br><span class="line">             ↘</span><br><span class="line">                5   →   6</span><br><span class="line">                ↑       ↑</span><br><span class="line">    origin&#x2F;feature2  feature2 </span><br><span class="line">                     </span><br></pre></td></tr></table></figure><p>还是这张图，假设 <code>5</code> 已经被 <code>push</code> 到远程，现在 <code>rebase</code> 到 <code>master</code> 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">                      master         feature2</span><br><span class="line">                        ↓               ↓</span><br><span class="line">1   →   2   →   3   →   4   →   7   →   8      </span><br><span class="line">          ↘</span><br><span class="line">             ↘</span><br><span class="line">                5   →   6</span><br><span class="line">                ↑</span><br><span class="line">         origin&#x2F;feature2</span><br></pre></td></tr></table></figure><p>现在看着没什么问题，但是你查看远程时，发现 <code>5</code> 那个 <code>commit</code> 是可以 <code>pull</code> 下来的。因为本地的 <code>5</code> 已经变成了新的  <code>commit 7</code> ，本地已经没有 <code>5</code> 的记录了，但是远程有。</p><p>如果你在 <code>5</code> 的时候添加的一些文件并 <code>push</code> 到了远程，在 <code>6</code> 的时候删除了那些文件，执行 <code>rebase</code> 后你是可以 <code>pull</code> 的， <code>pull</code> 远程后，你会发现那些删除的文件又回来了！</p><p>这里这种问题，可以通过下面的命令，强制提交，不需要 <code>pull</code> 而是直接覆盖中央仓库的历史。(<code>--force</code>)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -f</span><br></pre></td></tr></table></figure><p>这只是本人亲身经历过的一种情况，所以一定要遵循 <code>rebase 黄金定律</code> 。</p><h3 id="4-交互式-rebase-i"><a href="#4-交互式-rebase-i" class="headerlink" title="4.交互式 rebase -i"></a>4.交互式 <code>rebase -i</code></h3><h4 id="偏移符号"><a href="#偏移符号" class="headerlink" title="偏移符号"></a>偏移符号</h4><p>在了解交互式 <code>rebase -i</code> 之前，先了解下偏移符号。</p><p>说明：在 <code>Git</code> 中，有两个「偏移符号」： <code>^</code> 和 <code>~</code>。</p><p><code>^</code> 的用法：在 <code>commit</code> 的后面加一个或多个 <code>^</code> 号，可以把 <code>commit</code> 往回偏移，偏移的数量是 <code>^</code> 的数量。例如：<code>master^</code> 表示 <code>master</code> 指向的 <code>commit</code> 之前的那个 <code>commit</code>； <code>HEAD^^</code> 表示 <code>HEAD</code> 所指向的 <code>commit</code> 往前数两个 <code>commit</code>。</p><p><code>~</code> 的用法：在 <code>commit</code> 的后面加上 <code>~</code> 号和一个数，可以把 <code>commit</code> 往回偏移，偏移的数量是 <code>~</code> 号后面的数。例如：<code>HEAD~5</code> 表示 <code>HEAD</code> 指向的 <code>commit</code>往前数 5 个 <code>commit</code>。</p><p>下面详细说明。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git log --oneline --graph --all</span><br><span class="line">*   1699603 (HEAD -&gt; master) Merge branch &#39;feature2&#39;</span><br><span class="line">|\</span><br><span class="line">| * 2b21ec9 (feature2) feature2 第二次提交</span><br><span class="line">| * 2fb7de8 feature2 第一次提交</span><br><span class="line">* | 528eb23 (feature1) feature1 第二次提交</span><br><span class="line">* | d4faecf feature1 第一次提交</span><br><span class="line">|&#x2F;</span><br><span class="line">* 9001713 (origin&#x2F;master, origin&#x2F;feature2, origin&#x2F;feature1, origin&#x2F;HEAD) 第二次添加</span><br></pre></td></tr></table></figure><p>先看一下 <code>~</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git show --oneline HEAD~1</span><br><span class="line">528eb23 (feature1) feature1 第二次提交</span><br><span class="line"></span><br><span class="line">$ git show --oneline HEAD~2</span><br><span class="line">d4faecf feature1 第一次提交</span><br><span class="line"></span><br><span class="line">$ git show --oneline HEAD~3</span><br><span class="line">9001713 (origin&#x2F;master, origin&#x2F;feature2, origin&#x2F;feature1, origin&#x2F;HEAD) 第二次添加</span><br></pre></td></tr></table></figure><p>然后看 <code>^</code> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git show --oneline HEAD^</span><br><span class="line">528eb23 (feature1) feature1 第二次提交</span><br><span class="line"></span><br><span class="line">$ git show --oneline HEAD^^</span><br><span class="line">d4faecf feature1 第一次提交</span><br><span class="line"></span><br><span class="line">$ git show --oneline HEAD^^^</span><br><span class="line">9001713 (origin&#x2F;master, origin&#x2F;feature2, origin&#x2F;feature1, origin&#x2F;HEAD) 第二次添加</span><br></pre></td></tr></table></figure><p>可以看到这里并没有打印到 <code>feature2</code> 的提交，那如何就可以打印了呢？</p><p>切换分支 ~ </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git show --oneline HEAD^2</span><br><span class="line">2b21ec9 (feature2) feature2 第二次提交</span><br><span class="line"></span><br><span class="line">$ git show --oneline HEAD^2^</span><br><span class="line">2fb7de8 feature2 第一次提交</span><br><span class="line"></span><br><span class="line">$ git show --oneline HEAD^2~1</span><br><span class="line">2fb7de8 feature2 第一次提交</span><br></pre></td></tr></table></figure><p><code>^2</code> 这里没有偏移，只是切换分支。当然，还可以切换引用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git show --oneline feature2^</span><br><span class="line">2fb7de8 feature2 第一次提交</span><br></pre></td></tr></table></figure><p>总结</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 当前提交</span><br><span class="line">HEAD &#x3D; HEAD~0 &#x3D; HEAD^0</span><br><span class="line"></span><br><span class="line"># 主线回溯(最靠左边的即为主线)</span><br><span class="line">HEAD~1 &#x3D; HEAD^ 主线的上一次提交</span><br><span class="line">HEAD~2 &#x3D; HEAD^^ 主线的上二次提交</span><br><span class="line">HEAD~3 &#x3D; HEAD^^^ 主线的上三次提交</span><br><span class="line"></span><br><span class="line"># 如果某个节点有其他分支并入</span><br><span class="line">HEAD^1 主线提交（第一个父提交）</span><br><span class="line">HEAD^2 切换到了第2个并入的分支并得到最近一次的提交</span><br><span class="line">HEAD^2~3 切换到了第2个并入的分支并得到最近第 4 次的提交</span><br><span class="line">HEAD^3~2 切换到了第3个并入的分支并得到最近第 3 次的提交</span><br><span class="line"></span><br><span class="line"># ^&#123;n&#125; 和 ^ 重复 n 次的区别 </span><br><span class="line">HEAD~1 &#x3D; HEAD^</span><br><span class="line">HEAD~2 &#x3D; HEAD^^</span><br><span class="line">HEAD~3 &#x3D; HEAD^^^</span><br><span class="line"></span><br><span class="line"># 切换父级</span><br><span class="line">HEAD^1~3 &#x3D; HEAD~4 </span><br><span class="line">HEAD^2~3 &#x3D; HEAD^2^^^</span><br><span class="line">HEAD^3~3 &#x3D; HEAD^3^^^</span><br></pre></td></tr></table></figure><h4 id="修改之前的-commit"><a href="#修改之前的-commit" class="headerlink" title="修改之前的 commit"></a>修改之前的 <code>commit</code></h4><p>之前讲过 <code>git commit -—amend</code> 可以 修复/替换 最新 <code>commit</code> 的错误，那倒数第二个，第三个 <code>commit</code> 需要修改怎么办呢？</p><p>那就需要用到 <code>rebase -i</code> 了，它是 <code>rebase --interactive</code> 的缩写形式，意为「交互式 <code>rebase</code>」。</p><p>所谓「交互式 <code>rebase</code>」，就是在 <code>rebase</code> 的操作执行之前，你可以指定要 <code>rebase</code> 的 <code>commit</code> 链中的每一个 <code>commit</code> 是否需要进一步修改。</p><p>当前我提交了几个 <code>commit</code> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">*   1699603 (HEAD -&gt; master) Merge branch &#39;feature2&#39;</span><br><span class="line">|\</span><br><span class="line">| * 2b21ec9 (feature2) feature2 第二次提交</span><br><span class="line">| * 2fb7de8 feature2 第一次提交</span><br><span class="line">* | 528eb23 (feature1) feature1 第二次提交</span><br><span class="line">* | d4faecf feature1 第一次提交</span><br><span class="line">|&#x2F;</span><br><span class="line">*</span><br></pre></td></tr></table></figure><p>但是我发现在 <code>feature1 第二次提交</code> 的 <code>commit</code> 中需要修改一些内容，这时使用 <code>commit --amend</code> 已经晚了。我们需要使用下面的命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i HEAD^^</span><br></pre></td></tr></table></figure><p>会进入编辑界面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">pick 528eb23 feature1 第二次提交</span><br><span class="line">pick 2fb7de8 feature2 第一次提交</span><br><span class="line">pick 2b21ec9 feature2 第二次提交</span><br><span class="line"></span><br><span class="line"># Rebase d4faecf..5b7f84f onto d4faecf (3 commands)</span><br><span class="line">#</span><br><span class="line"># Commands:</span><br><span class="line"># p, pick &lt;commit&gt; &#x3D; use commit</span><br><span class="line"># r, reword &lt;commit&gt; &#x3D; use commit, but edit the commit message</span><br><span class="line"># e, edit &lt;commit&gt; &#x3D; use commit, but stop for amending</span><br><span class="line"># s, squash &lt;commit&gt; &#x3D; use commit, but meld into previous commit</span><br><span class="line"># f, fixup &lt;commit&gt; &#x3D; like &quot;squash&quot;, but discard this commit&#39;s log message</span><br><span class="line"># x, exec &lt;command&gt; &#x3D; run command (the rest of the line) using shell</span><br><span class="line"># b, break &#x3D; stop here (continue rebase later with &#39;git rebase --continue&#39;)</span><br><span class="line"># d, drop &lt;commit&gt; &#x3D; remove commit</span><br><span class="line"># l, label &lt;label&gt; &#x3D; label current HEAD with a name</span><br><span class="line"># t, reset &lt;label&gt; &#x3D; reset HEAD to a label</span><br><span class="line"># m, merge [-C &lt;commit&gt; | -c &lt;commit&gt;] &lt;label&gt; [# &lt;oneline&gt;]</span><br><span class="line"># .       create a merge commit using the original merge commit&#39;s</span><br><span class="line"># .       message (or the oneline, if no original merge commit was</span><br><span class="line"># .       specified). Use -c &lt;commit&gt; to reword the commit message.</span><br><span class="line">#</span><br><span class="line"># These lines can be re-ordered; they are executed from top to bottom.</span><br><span class="line">#</span><br><span class="line"># If you remove a line here THAT COMMIT WILL BE LOST.</span><br></pre></td></tr></table></figure><p>这里可以看到， <code>rebase -i HEAD^^</code> 和我们之前讲的 <code>git show --oneline HEAD^^</code> 预期是不一样的。</p><p>为什么不一样呢？</p><p><code>rebase -i HEAD^^</code> 表示列出倒数第三个 <code>commit</code> 之前的提交记录，<strong>不包括倒数第三个</strong>。</p><p><code>git show --oneline HEAD^^</code> 表示显示倒数第三个 <code>commit</code> 的记录。</p><p>又因为这里用了 <code>merge</code> ，在 <code>rebase -i HEAD^</code> 时，会列出 <code>merge</code> 操作中合并的所有 <code>commit</code> ，这里正好 <code>merge</code> 了两个 <code>commit</code>，<br>所以第一个 <code>^</code> 会列出主线倒数第一个 <code>commit</code>，但是这个 <code>commit</code> 是个 <code>merge</code> 操作，然后就去寻找 <code>merge</code> 了那些 <code>commit</code> 并列出 ，第二个 <code>^</code> 是主线倒数第二个 <code>commit</code>。</p><p>这个编辑界面的最顶部，列出了将要「被 <code>rebase</code>」的所有 <code>commit</code> 。需要注意，这个排列是正序的，旧的 <code>commit</code> 会排在上面，新的排在下面。</p><p>这两行指示了两个信息：</p><ol><li>需要处理哪些 <code>commit</code>；</li><li>怎么处理它们。</li></ol><p>每个 <code>commit</code> 默认的操作都是 <code>pick</code> ，表示「直接应用这个 <code>commit</code>」。如果直接退出的话，那么这次就是一次空操作。</p><p>各个操作的意思：</p><ol><li><code>pick</code>：直接应用这个 <code>commit</code> </li><li><code>reword</code>：使用此 <code>commit</code>， 编辑 <code>commit message</code>，<code>message</code> 就是 <code>commit -m</code> 命令后面写到说明，下同。</li><li><code>edit</code>：使用此 <code>commit</code>，但是不编辑 <code>commit message</code>，保持原有 <code>commit message</code> </li><li><code>squash</code>：使用此 <code>commit</code>，但是合并到前一个 <code>commit</code> 中去 </li><li><code>fixup</code>： 和 <code>squash</code> 类似，但是放弃此 <code>commit</code> 的 <code>message</code> </li><li><code>drop</code>：删除 <code>commit</code></li><li>其余的没用过 ~ </li></ol><p>点击 <code>i</code> 键进行编辑。我们的目的是修改 <code>feature1 第二次提交</code> ，我们需要把那一行的 <code>pick</code> 改成 <code>edit</code> 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">edit 528eb23 feature1 第二次提交</span><br><span class="line">pick 2fb7de8 feature2 第一次提交</span><br><span class="line">pick 2b21ec9 feature2 第二次提交</span><br></pre></td></tr></table></figure><p>修改完后，按 <code>esc</code> 然后 <code>:wq</code> 这是三个按键依次按，之前我也不懂，但是学习 <code>linux</code> 之后就懂了 ~ 保存退出的意思 ~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase -i HEAD^^</span><br><span class="line">Stopped at 528eb23...  feature1 第二次提交</span><br><span class="line">You can amend the commit now, with</span><br><span class="line"></span><br><span class="line">  git commit --amend</span><br><span class="line"></span><br><span class="line">Once you are satisfied with your changes, run</span><br><span class="line"></span><br><span class="line">  git rebase --continue</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上图的提示信息说明，<code>rebase</code> 过程已经停在了第二个 <code>commit</code> 的位置，那么现在可以去修改想修改的内容了。</p><p>修改完成之后，用 <code>commit --amend</code> 来把修正应用到当前最新的 <code>commit</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit --amend</span><br></pre></td></tr></table></figure><p>在修复完成之后，就可以用 <code>rebase --continue</code> 来继续 <code>rebase</code> 过程，把后面的 <code>commit</code> 直接应用上去。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase --continue</span><br></pre></td></tr></table></figure><p>这里可能出现冲突，解决办法之前讲过 ~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ git log --oneline</span><br><span class="line">2d77504 (HEAD -&gt; master) feature2 第二次提交</span><br><span class="line">82d685f feature2 第一次提交</span><br><span class="line">5729656 feature1 第二次提交</span><br><span class="line">d4faecf feature1 第一次提交</span><br><span class="line"></span><br><span class="line">$ git log --oneline --graph --all</span><br><span class="line">* 2d77504 (HEAD -&gt; master) feature2 第二次提交</span><br><span class="line">* 82d685f feature2 第一次提交</span><br><span class="line">* 5729656 feature1 第二次提交</span><br><span class="line">| * 2b21ec9 (feature2) feature2 第二次提交</span><br><span class="line">| * 2fb7de8 feature2 第一次提交</span><br><span class="line">| | * 528eb23 (feature1) feature1 第二次提交</span><br><span class="line">| |&#x2F;</span><br><span class="line">|&#x2F;|</span><br><span class="line">* | d4faecf feature1 第一次提交</span><br><span class="line">|&#x2F;</span><br><span class="line">* 9001713 (origin&#x2F;master, origin&#x2F;feature2, origin&#x2F;feature1, origin&#x2F;HEAD) 第二次添加</span><br></pre></td></tr></table></figure><p>再次查看，<code>log</code> 发现后三个 <code>commit</code> 的 <code>SHA-1</code> 值都变了，说明是新的 <code>commit</code> 。查看图表会更明确一点，之前的 <code>commit</code> 都还在但是 <code>merge</code> 的那个 <code>commit</code> 不见了，子分支的 <code>commit</code> 的内容，都在主分支都复制了一份，说明使用 <code>rebase -i</code> 不仅可以执行我们制定的操作，还会重新组织历史记录合并在一条主线上，然后清理无用的 <code>commit</code> 。</p><h4 id="删除之前的-commit"><a href="#删除之前的-commit" class="headerlink" title="删除之前的 commit"></a>删除之前的 <code>commit</code></h4><p>和修改的炒作类似，只是在编辑的时候删除我们需要删除的那个 <code>commit</code> 即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pick 528eb23 feature1 第二次提交</span><br><span class="line">pick 2fb7de8 feature2 第一次提交</span><br><span class="line">pick 2b21ec9 feature2 第二次提交</span><br></pre></td></tr></table></figure><p>删掉 <code>feature1 第二次提交</code>，或者将 <code>pick</code> 改为 <code>drop</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pick 2fb7de8 feature2 第一次提交</span><br><span class="line">pick 2b21ec9 feature2 第二次提交</span><br></pre></td></tr></table></figure><p>如果把这一行删掉，那就相当于在 <code>rebase</code> 的过程中跳过了这个 <code>commit</code>，从而也就把这个 <code>commit</code> 撤销掉了。</p><p>那这两种操作有什么不同呢？ <code>emmm….</code> 表面上也没啥区别，具体实质性的却别就不清楚了 ~<br><a href="https://stackoverflow.com/questions/35846154/git-rebase-interactive-drop-vs-deleting-the-commit-line">Git rebase interactive drop vs deleting the commit line</a></p><p>剩下的操作和上面一样。</p><h3 id="5-rebase-–onto"><a href="#5-rebase-–onto" class="headerlink" title="5. rebase –onto"></a>5. <code>rebase –onto</code></h3><p>我们之前讲过 <code>git rebase master</code> ，<code>rebase</code> 的「起点」是自动判定的：选取当前 <code>commit</code>  和目标 <code>commit</code> 在历史上的交叉点作为起点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">                      master</span><br><span class="line">                        ↓</span><br><span class="line">1   →   2   →   3   →   4      </span><br><span class="line">          ↘</span><br><span class="line">             ↘</span><br><span class="line">                5   →   6</span><br><span class="line">                        ↑</span><br><span class="line">                    HEAD&#x2F;feature2</span><br></pre></td></tr></table></figure><p>比如这里执行  <code>git rebase master</code> ，那么 <code>Git</code> 会自动选取 <code>4</code> 和 <code>6</code> 的历史交叉点 <code>2</code> 作为 <code>rebase</code> 的起点，依次将 <code>5</code> 和 <code>6</code> 重新提交到 <code>4</code> 的路径上去。</p><p>而 <code>--onto</code> 参数，就可以额外给 <code>rebase</code> 指定它的起点。例如同样以上图为例，如果我只想把 <code>6</code> 提交到 <code>4</code> 上，不想附带上 <code>5</code>，那么我可以执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase --onto 4(commit) 5(commit) feature2</span><br></pre></td></tr></table></figure><p><code>--onto</code> 参数后面有三个附加参数：目标 <code>commit</code>、起点 <code>commit</code>（注意：<code>rebase</code> 的时候会把起点排除在外）、终点 <code>commit</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">                      master HEAD&#x2F;feature2</span><br><span class="line">                        ↓       ↓</span><br><span class="line">1   →   2   →   3   →   4   →   7(6的内容)</span><br><span class="line">          ↘</span><br><span class="line">             ↘</span><br><span class="line">                5   →   6</span><br></pre></td></tr></table></figure><p>还可以撤销提交：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git log --oneline --graph --all</span><br><span class="line">* 0b6cb82 (HEAD -&gt; feature2) add</span><br><span class="line">* b8b5146 add new File</span><br><span class="line">* 8b2c2f7 new File</span><br><span class="line">* e657879 rebase</span><br><span class="line">* 99854db feature</span><br></pre></td></tr></table></figure><p>这是生成的一点测试记录，执行下面的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase --onto HEAD^^^ HEAD^ feature2</span><br></pre></td></tr></table></figure><p>上面的意思为，以倒数第二个 <code>commit</code> 为起点（不包括起点），<code>feature2</code> 指向的 <code>commit</code> 为终点，<code>rebase</code> 到倒数第四个 <code>commit</code> 上， 结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git log --oneline --graph --all</span><br><span class="line">* 3a10357 (HEAD -&gt; feature2) add</span><br><span class="line">* e657879 rebase</span><br><span class="line">* 99854db feature</span><br></pre></td></tr></table></figure><p><code>HEAD^^^</code> 目标 <code>commit</code> 之后的 <code>commit</code> 都会被清除掉，起点（<code>HEAD^</code>） 到 终点（<code>feature2</code>） 之间的 <code>commit</code> （不包括 起点<code>HEAD^</code> 本身），会提前复制出一份生成新的 <code>commit</code>，最后连接到目标 <code>commit</code> 后面。<br>相当于 目标（<code>HEAD^^^</code>） 到 起点（<code>HEAD^</code>） 之间的 <code>commit</code> 都会被删除，不包括目标 <code>commit</code> ，包括起点 <code>commit</code> 。</p><h2 id="九-reset（重置）"><a href="#九-reset（重置）" class="headerlink" title="九 reset（重置）"></a>九 reset（重置）</h2><p><code>reset</code> 的本质：移动 <code>HEAD</code> 以及它所指向的 <code>branch</code></p><p>这样就可以起到撤销某个 <code>commit</code> 的作用 ，不是删除，只要记下 <code>SHA-1</code> 还可以再撤回来 ~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br></pre></td></tr></table></figure><p>偏移符号之前讲过，如果移动后想回往回移动，但是已经没有了 <code>SHA-1</code>，可以使用 <code>git reflog</code> 来查看操作记录。</p><blockquote><p>Git 的历史只能往回看，不能向未来看，所以把 <code>HEAD</code> 和 <code>branch</code> 往回移动，就能起到撤回 <code>commit</code> 的效果。</p></blockquote><p>所以同理，<code>reset --hard</code> 不仅可以撤销提交，还可以用来把 <code>HEAD</code> 和 <code>branch</code> 移动到其他的任何地方。</p><h3 id="reset-–hard：重置工作目录"><a href="#reset-–hard：重置工作目录" class="headerlink" title="reset –hard：重置工作目录"></a>reset –hard：重置工作目录</h3><p><code>reset --hard</code> 会在重置 <code>HEAD</code> 和 <code>branch</code> 的同时，重置工作目录里的内容。当你在 <code>reset</code> 后面加了 <code>--hard</code> 参数时，你的工作目录里的内容会被完全重置为和 <code>HEAD</code> 的新位置相同的内容。换句话说，就是<strong>未提交（<code>commit</code>）的修改会被全部擦除，不管它们是否被放进暂存区。添加到暂存区的新增也会被擦除，但是没有添加到缓存区的新增不会！</strong> </p><p><code>modifiedFile.txt</code> 和 <code>addModifiedFile.txt</code> 是当前 <code>commit</code> 新增的（证明已经 <code>commit</code> 上去了），<br>然后修改 <code>addModifiedFile.txt</code> 文件并添加缓存区，然后修改 <code>modifiedFile.txt</code> 文件，不添加到缓存区。这里表示<strong>修改操作</strong>添加暂存区和不添加暂存区的情况。<br>添加 <code>newFile.txt</code> 和 <code>addNewFile.txt</code> 并把   <code>addNewFile.txt</code> 添加到缓存区。这里表示<strong>新增操作</strong>添加暂存区和不添加暂存区的情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch feature2</span><br><span class="line">Your branch and &#39;origin&#x2F;feature2&#39; have diverged,</span><br><span class="line">and have 1 and 2 different commits each, respectively.</span><br><span class="line">  (use &quot;git pull&quot; to merge the remote branch into yours)</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">        new file:   addNewFile.txt</span><br><span class="line">        modified:   addModifiedFile.txt</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">        modified:   modifiedFile.txt</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line"></span><br><span class="line">        newFile.txt</span><br></pre></td></tr></table></figure><p>然后执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br></pre></td></tr></table></figure><p>工作目录里的新改动也一起全都消失了，不管它们是否被放进暂存区<br>只有没有添加到缓冲区新创建的文件，不会清除，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch feature2</span><br><span class="line">Your branch is behind &#39;origin&#x2F;feature2&#39; by 2 commits, and can be fast-forwarded.</span><br><span class="line">  (use &quot;git pull&quot; to update your local branch)</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line"></span><br><span class="line">        newFile.txt</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>只留下了<strong>新创建的并且没有添加缓存区</strong>的 <code>addHard</code> 文件。其他的修改和添加都被清除了。</p><h3 id="reset-–soft：保留工作目录"><a href="#reset-–soft：保留工作目录" class="headerlink" title="reset –soft：保留工作目录"></a>reset –soft：保留工作目录</h3><p><code>reset --soft</code> 会在重置 <code>HEAD</code> 和 <code>branch</code> 时，保留工作目录和暂存区中的内容，<strong>并把重置 <code>HEAD</code> 所带来的新的差异</strong>放进暂存区。</p><p>「重置 <code>HEAD</code> 所带来的新的差异」 就是当前 <code>HEAD</code> 与 <code>reset</code> 目标之间的 <code>commit</code> 提交的文件。</p><p>初始文件状态和上面一样。</p><p>执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --soft HEAD^</span><br></pre></td></tr></table></figure><p>重点观看 <code>hard.txt</code> 和 <code>reset.txt</code> ，它俩被重新添加到暂存区，并且标记 <code>new file</code> 。这两个文件就是两个 <code>commit</code> 的差异。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch feature2</span><br><span class="line">Your branch is behind &#39;origin&#x2F;feature2&#39; by 2 commits, and can be fast-forwarded.</span><br><span class="line">  (use &quot;git pull&quot; to update your local branch)</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">        new file:   addModifiedFile.txt</span><br><span class="line">        new file:   addNewFile.txt</span><br><span class="line">        new file:   modifiedFile.txt</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">        modified:   modifiedFile.txt</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line"></span><br><span class="line">        newFile.txt</span><br></pre></td></tr></table></figure><p>这就是 <code>--soft</code> 和 <code>--hard</code> 的区别：<code>--hard</code> 会清空暂存目录的改动和新增，以及工作目录的改动，而 <code>--soft</code> 则会保留工作目录的内容，并把因为保留工作目录内容所带来的新的文件差异放进暂存区。</p><h3 id="reset-不加参数：保留工作目录，并清空暂存区（–mixed）"><a href="#reset-不加参数：保留工作目录，并清空暂存区（–mixed）" class="headerlink" title="reset 不加参数：保留工作目录，并清空暂存区（–mixed）"></a>reset 不加参数：保留工作目录，并清空暂存区（–mixed）</h3><p><code>reset</code> 如果不加参数，那么默认使用 <code>--mixed</code> 参数。它的行为是：保留工作目录，并且清空暂存区。</p><p>初始文件状态和上面一样。</p><p>执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD^</span><br></pre></td></tr></table></figure><p>将差异文件、暂存目录的文件、工作目录的文件都保存了下来，但是都放在了工作目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch feature2</span><br><span class="line">Your branch is behind &#39;origin&#x2F;feature2&#39; by 2 commits, and can be fast-forwarded.</span><br><span class="line">  (use &quot;git pull&quot; to update your local branch)</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line"></span><br><span class="line">        addModifiedFile.txt</span><br><span class="line">        addNewFile.txt</span><br><span class="line">        modifiedFile.txt</span><br><span class="line">        newFile.txt</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br></pre></td></tr></table></figure><h2 id="十-stash（临时存储）"><a href="#十-stash（临时存储）" class="headerlink" title="十 stash（临时存储）"></a>十 stash（临时存储）</h2><p><code>&quot;stash&quot;</code> 这个词，和它意思比较接近的中文翻译是「藏匿」，是「把东西放在一个秘密的地方以备未来使用」的意思。</p><p>在 <code>Git</code> 中，<code>stash</code> 指令可以帮你把工作目录的内容全部放在你本地的一个独立的地方，它不会被提交，也不会被删除，你把东西放起来之后就可以去做你的临时工作了，做完以后再来取走，就可以继续之前手头的事了。</p><p>具体说来，<code>stash</code> 的用法很简单。当你手头有一件临时工作要做，需要把工作目录暂时清理干净，那么可以：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure><p>现在工作目录的改动就被清空了，所有改动都被存了起来。</p><p>当手头工作做完后，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash pop</span><br></pre></td></tr></table></figure><p>之前的代码又回来了！</p><blockquote><p>注意：没有被 <code>track</code> 的文件（即从来没有被 add 过的文件不会被 stash 起来，因为 Git 会忽略它们。如果想把这些文件也一起 stash，可以加上 <code>-u</code> 参数，它是 <code>--include-untracked</code> 的简写。就像这样：</p></blockquote><h2 id="十一-tag（引用）"><a href="#十一-tag（引用）" class="headerlink" title="十一 tag（引用）"></a>十一 tag（引用）</h2><h3 id="添加-Tag"><a href="#添加-Tag" class="headerlink" title="添加 Tag"></a>添加 Tag</h3><p><code>tag</code> 是一个和 <code>branch</code> 非常相似的概念，它和 <code>branch</code> 最大的区别是：<code>tag</code> 不能移动。所以在很多团队中，<code>tag</code> 被用来在关键版本处打标记用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -a v1.1 -m &quot;my Tag 1.1&quot;</span><br></pre></td></tr></table></figure><p>这是在当前 <code>commit</code> 创建一个 名为 <code>v1.1</code> 的标签。<code>-m</code> 选项指定了一条将会存储在标签中的信息。 如果没有为附注标签指定一条信息，Git 会启动编辑器要求你输入信息。</p><p>如何给之前的 <code>commit</code> 添加 <code>tag</code> 呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -a v1.0 81bb698 -m &quot;my Tag 1.0&quot;</span><br></pre></td></tr></table></figure><p>只需要在标签名后面加入 <code>commit</code> 的 <code>SHA-1</code> 校验和 。</p><h3 id="查看-Tag"><a href="#查看-Tag" class="headerlink" title="查看 Tag"></a>查看 Tag</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git log --oneline</span><br><span class="line">347cd98 (HEAD -&gt; master, tag: v1.1, origin&#x2F;master, origin&#x2F;HEAD) head</span><br><span class="line">81bb698 (tag: v1.0) c</span><br></pre></td></tr></table></figure><p>也可以使用如下只查看标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git tag</span><br><span class="line">v1.0</span><br><span class="line">v1.1</span><br></pre></td></tr></table></figure><p>通过使用 <code>git show</code> 命令可以看到标签信息和与之对应的提交信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ git show v1.1</span><br><span class="line">tag v1.1</span><br><span class="line">Tagger: companyPc &lt;lvyanv@163.com&gt;</span><br><span class="line">Date:   Fri Oct 9 10:59:57 2020 +0800</span><br><span class="line"></span><br><span class="line">my Tag 1.1</span><br><span class="line"></span><br><span class="line">commit 347cd9856e1edf4c0a96cb15bad227ab8d255cda (HEAD -&gt; master, tag: v1.1, origin&#x2F;master, origin&#x2F;HEAD)</span><br><span class="line">Author: companyPc &lt;lvyanv@163.com&gt;</span><br><span class="line">Date:   Tue Sep 29 18:27:18 2020 +0800</span><br><span class="line"></span><br><span class="line">    head</span><br><span class="line"></span><br><span class="line">diff --git a&#x2F;branch1.txt b&#x2F;branch1.txt</span><br><span class="line">index b3a843b..b9176c0 100644</span><br><span class="line">--- a&#x2F;branch1.txt</span><br><span class="line">+++ b&#x2F;branch1.txt</span><br><span class="line">@@ -4,7 +4,7 @@</span><br><span class="line"> 11</span><br><span class="line"> 11</span><br><span class="line"> 11</span><br><span class="line">-</span><br><span class="line">+22</span><br></pre></td></tr></table></figure><p>输出显示了打标签者的信息、打标签的日期时间、附注信息，然后显示具体的提交信息。</p><h3 id="删除-Tag"><a href="#删除-Tag" class="headerlink" title="删除 Tag"></a>删除 Tag</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -d v1.0</span><br><span class="line">Deleted tag &#39;v1.0&#39; (was a390a5f)</span><br></pre></td></tr></table></figure><p>注意上述命令并不会从任何远程仓库中移除这个标签，通过如下命令可以更新远程分支情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin : refs&#x2F;tags&#x2F;v1.0</span><br></pre></td></tr></table></figure><p>第二种更直观的删除远程标签的方式是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin --delete v1.0</span><br></pre></td></tr></table></figure><h3 id="检出标签"><a href="#检出标签" class="headerlink" title="检出标签"></a>检出标签</h3><p><code>tag</code> 创建后，就相当于一个应用，可以同个 <code>checkout</code> 检出到当前标签的位置 ~ </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout v1.0</span><br><span class="line">Note: checking out &#39;v1.0&#39;.</span><br><span class="line"></span><br><span class="line">You are in &#39;detached HEAD&#39; state. You can look around, make experimental</span><br><span class="line">changes and commit them, and you can discard any commits you make in this</span><br><span class="line">state without impacting any branches by performing another checkout.</span><br><span class="line"></span><br><span class="line">If you want to create a new branch to retain commits you create, you may</span><br><span class="line">do so (now or later) by using -b with the checkout command again. Example:</span><br><span class="line"></span><br><span class="line">  git checkout -b &lt;new-branch-name&gt;</span><br><span class="line"></span><br><span class="line">HEAD is now at 81bb698 c</span><br></pre></td></tr></table></figure><h2 id="十二-Gitflow-工作流"><a href="#十二-Gitflow-工作流" class="headerlink" title="十二 Gitflow 工作流"></a>十二 Gitflow 工作流</h2><p><code>Git-flow</code> 是 <code>Git</code> 的包装器</p><h3 id="Develop-和-Master-分支"><a href="#Develop-和-Master-分支" class="headerlink" title="Develop 和 Master 分支"></a><code>Develop</code> 和 <code>Master</code> 分支</h3><p><strong>master</strong></p><ul><li>主分支 , 产品的功能全部实现后 , 最终在 <code>master</code> 分支对外发布</li><li>该分支为只读唯一分支 , 只能从其他分支 <code>(release/hotfix)</code> 合并 , 不能在此分支修改</li><li>另外所有在 <code>master</code> 分支的推送应该<strong>打标签做记录</strong>,方便追溯</li><li>例如 <code>release</code> 合并到 <code>master</code> , 或 <code>hotfix</code> 合并到 <code>master</code></li></ul><p><strong>develop</strong></p><ul><li>主开发分支 , 基于 <code>master</code> 分支克隆</li><li>包含所有要发布到下一个 <code>release</code> 的代码</li><li>该分支为只读唯一分支 , 只能从其他分支合并</li><li><code>feature</code> 功能分支完成 , 合并到 <code>develop</code> (不推送)</li><li><code>develop</code> 拉取 <code>release</code> 分支 , 提测</li><li><code>release/hotfix</code> 分支上线完毕 , 合并到 <code>develop</code> 并推送</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/git/git_flow_1.svg" alt="图片来源于文末链接中的 Gitflow"></p><p>这个工作流使用两个分支来记录项目的历史，而不是单一的 <code>master</code>。 <code>master</code> 存储官方发布历史记录，而 <code>develop</code> 分支充当功能的集成分支。用版本号标记 <code>master</code> 中的所有提交也很方便。</p><p>第一步是用一个 <code>develop</code> 分支来补充默认的 <code>master</code> 。一个简单的方法是一个开发人员在本地创建一个空的 <code>develop</code> 分支，并将其推到服务器:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch develop </span><br><span class="line">git push -u origin develop</span><br></pre></td></tr></table></figure><p>该分支将包含项目的完整历史记录，而<code>master</code>将包含简化版本。现在，其他开发人员现在应该 <code>clone</code> 中央存储库，并为 <code>develop</code> 创建 <code>tracking</code> 分支。</p><p>当使用 <code>git-flow</code> 扩展库时，在已有的 <code>repo</code> 上执行 <code>git flow init</code> 将创建开发分支:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ git flow init</span><br><span class="line"></span><br><span class="line">Which branch should be used for bringing forth production releases?</span><br><span class="line">   - develop</span><br><span class="line">   - master</span><br><span class="line">Branch name for production releases: [master]</span><br><span class="line"></span><br><span class="line">Which branch should be used for integration of the &quot;next release&quot;?</span><br><span class="line">   - develop</span><br><span class="line">Branch name for &quot;next release&quot; development: [develop]</span><br><span class="line"></span><br><span class="line">How to name your supporting branch prefixes?</span><br><span class="line">Feature branches? [] feature&#x2F;</span><br><span class="line">Bugfix branches? [] bugfix&#x2F;</span><br><span class="line">Release branches? [] release&#x2F;</span><br><span class="line">Hotfix branches? [] hotfix&#x2F;</span><br><span class="line">Support branches? [] support&#x2F;</span><br><span class="line">Version tag prefix? [] version&#x2F;</span><br><span class="line">Hooks and filters directory? [C:&#x2F;Users&#x2F;Beepay&#x2F;Desktop&#x2F;新建文件夹&#x2F;ui-starge&#x2F;.git&#x2F;hooks]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>git flow init</code> 命令是缺省 <code>git init</code> 命令的扩展，除了为您创建分支外，它不会更改存储库中的任何内容。</p><p>设置前缀的时候加上 <code>/</code> 相当于分组了。试一试下面的过程就知道啦。</p><p>如果使用 <code>Sourcetree</code> ，也可以点击工具中右上角 <code>Git 工作流</code> 切换到 <code>git flow</code> 工作流。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/git/git_flow_1_1.png" alt=""></p><p>之后的操作就是弹框中的，之后就不一一列出 <code>Sourcetree</code> 的操作了。</p><h3 id="Feature-功能-分支"><a href="#Feature-功能-分支" class="headerlink" title="Feature(功能) 分支"></a><code>Feature</code>(功能) 分支</h3><p><strong>feature</strong></p><ul><li>功能开发分支 , 基于 <code>develop</code> 分支克隆 , 主要用于新需求新功能的开发</li><li>功能开发完毕后合到 <code>develop</code> 分支(未正式上线之前不推送到远程中央仓库!!!)</li><li><code>feature</code> 分支可同时存在多个 , 用于团队中多个功能同时开发 , 属于临时分支 , 功能完成后可选删除</li></ul><p>每一个新功能的开发都应该各自使用独立的分支，可以推送到中央存储库进行备份/协作。但是，<code>feature</code> 分支使用 <code>develop</code> 作为它们的父分支，而不是 <code>master</code> 分支。当一个 功能 完成时，它会被合并回到 <code>feature</code> 中。<strong><code>feature</code> 不应该直接与 <code>master</code> 交互。</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/git/git_flow_2.svg" alt="图片来源于文末链接中的 Gitflow"></p><p><strong>注意</strong>：组合使用 <code>feature</code> 分支和 <code>develop</code> 分支的这种设计，其实完全就是 <code>Feature Branch Workflow</code>的理念。然而，<code>Gitflow</code> 流程并不止于此。且看下文分解。</p><p><strong>创建一个工作分支：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout develop </span><br><span class="line">git checkout -b feature_branch </span><br></pre></td></tr></table></figure><p>使用 <code>git-flow</code> 扩展时：(这里注意 <code>init</code> 时的前缀加 <code>/</code> )</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git flow feature start feature_branch</span><br></pre></td></tr></table></figure><p>执行这个命令不需要切换分支，会自动已本地 <code>develop</code> 最新 <code>commit</code> 为基点， 之后像往常一样使用继续 <code>Git</code> 就可以。</p><p><strong>完成/合并 一个工作分支：</strong></p><p>（执行之前记得 <code>add</code> 以及 <code>commit</code> 更新的内容）当完成了 <code>feature</code> 的开发工作后，下一步是将 <code>feature_branch</code> 合并到 <code>develop</code> 中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout develop </span><br><span class="line">git merge feature_branch</span><br><span class="line">git branch -d feature_branch</span><br></pre></td></tr></table></figure><p>使用 <code>git-flow</code> 扩展时：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git flow feature finish feature_branch</span><br></pre></td></tr></table></figure><h3 id="Release-分支"><a href="#Release-分支" class="headerlink" title="Release 分支"></a><code>Release</code> 分支</h3><p><strong>release</strong></p><ul><li>测试分支 , 基于 <code>feature</code> 分支合并到 <code>develop</code> 之后  , 从 <code>develop</code> 分支克隆</li><li>主要用于提交给测试人员进行功能测试 , 测试过程中发现的 <code>BUG</code> 在本分支进行修复 , 修复完成上线后合并到 <code>develop/master</code> 分支并推送(完成功能) , 打<code>Tag</code> </li><li>属于临时分支 , 功能上线后可选删除</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/git/git_flow_3.svg" alt="图片来源于文末链接中的 Gitflow"></p><p>一旦 <code>develop</code> 分支积聚了足够多的新功能（或者预定的发布日期临近了），你可以基于 <code>develop</code> 分支建立一个用于产品发布的分支。这个分支的创建意味着一个发布周期的开始，也意味着本次发布不会再增加新的功能，在这个分支上只能修复 <code>bug</code> ，做一些文档工作或者跟发布相关的任务。在一切准备就绪的时候，这个分支会被合并入 <code>master</code> ，并且用版本号打上 <code>tag</code>。<br>另外，<code>release</code> 分支上的改动还应该合并入 <code>develop</code> 分支，在发布周期内，<code>develop</code> 分支仍然在被使用（一些开发者会把其他功能集成到 <code>develop</code> 分支）。</p><p>使用专门的一个分支来为发布做准备的好处是，在一个团队忙于当前的发布的同时，另一个团队可以继续为接下来的一次发布开发新功能。</p><p><strong>创建 <code>release</code> 分支</strong>是另一个简单的分支操作。与 <code>feature</code> 分支一样，<code>release</code> 分支也基于 <code>develop</code> 分支。可以使用以下方法创建一个新的 <code>release</code> 分支。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout develop </span><br><span class="line">git checkout -b release&#x2F;0.1.0</span><br></pre></td></tr></table></figure><p>使用 <code>git-flow</code> 扩展时：(这里注意 <code>init</code> 时的前缀加 <code>/</code> )</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git flow release start 0.1.0</span><br></pre></td></tr></table></figure><p><strong>要 完成/合并 一个发布分支</strong>（执行之前记得 <code>add</code> 以及 <code>commit</code> 更新的内容），使用以下方法: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git checkout master </span><br><span class="line">git merge release&#x2F;0.1.0</span><br><span class="line">git checkout develop </span><br><span class="line">git merge release&#x2F;0.1.0</span><br><span class="line">git branch -d release&#x2F;0.1.0</span><br></pre></td></tr></table></figure><p>使用 <code>git-flow</code> 扩展时：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git flow release finish &#39;0.1.0&#39; -m &quot;my version 0.1.0&quot;</span><br></pre></td></tr></table></figure><p>这里可以不写 <code>-m</code> ，但是在合并 <code>develop</code> 的时候弹出的编辑页面需要再次写入提交信息，否者会导致提交失败。如果写了 <code>-m</code> 只需要两次 <code>:wq</code> 即可。</p><h3 id="Hotfix-分支"><a href="#Hotfix-分支" class="headerlink" title="Hotfix 分支"></a><code>Hotfix</code> 分支</h3><p><strong>hotfix</strong></p><ul><li>补丁分支 , 基于 <code>master</code> 分支克隆 , 主要用于对线上的版本进行 <code>BUG</code> 修复</li><li>修复完毕后合并到 <code>develop/master</code> 分支并推送 , 打 <code>Tag</code> </li><li>属于临时分支 , 补丁修复上线后可选删除</li><li>所有 <code>hotfix</code> 分支的修改会进入到下一个 <code>release</code> </li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/git/git_flow_4.svg" alt="图片来源于文末链接中的 Gitflow"></p><p><code>hotfix</code> 分支用于快速对生产版本进行补丁。<code>hotfix</code> 分支很像 <code>release</code> 分支和 <code>feature</code> 分支，除了 <code>hotfix</code> 是基于 <code>master</code> 分支而不是 <code>develop</code>。这是唯一一个从主分支 <code>fork</code> 的。一旦修复完成，它应该被合并到 <code>master</code> 和 <code>develop</code> (或者当前的 <code>release</code> 分支)中，并且 <code>master</code> 应该被标记为一个更新的版本号。</p><p>拥有专门的 <code>bug</code> 修复开发线可以让团队解决问题同时，并且不会中断其余的工作流程或等待下一个发布周期。</p><p>可以将维护分支视为直接与 <code>master</code>一起工作的临时 <code>release</code> 分支。</p><p><strong>创建 <code>hotifx</code> 分支</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout master </span><br><span class="line">git checkout -b hotfix_branch</span><br></pre></td></tr></table></figure><p>使用 <code>git-flow</code> 扩展时：(这里注意 <code>init</code> 时的前缀加 <code>/</code> )</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git flow hotfix start hotfix_branch</span><br></pre></td></tr></table></figure><p><strong>完成/合并 一个 <code>hotfix</code> 分支</strong>（执行之前记得 <code>add</code> 以及 <code>commit</code> 更新的内容）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git checkout master </span><br><span class="line">git merge hotfix_branch </span><br><span class="line">git checkout develop </span><br><span class="line">git merge hotfix_branch </span><br><span class="line">git branch -d hotfix_branch</span><br></pre></td></tr></table></figure><p>使用 <code>git-flow</code> 扩展时：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git flow hotfix finish hotfix_branch  -m &quot;my hotfix commit&quot;</span><br></pre></td></tr></table></figure><p>这里可以不写 <code>-m</code> ，但是在合并 <code>develop</code> 的时候弹出的编辑页面需要再次写入提交信息，否者会导致提交失败。如果写了 <code>-m</code> 只需要两次 <code>:wq</code> 即可。</p><p><code>Gitflow</code> 的总体流程为：</p><ol><li>从<code>master</code> 创建一个 <code>develop</code>分支</li><li><code>release</code>从 <code>develop</code>  分支创建</li><li><code>feature</code> 从 <code>develop</code> 分支创建</li><li>当<code>feature</code>完成后，会合并到<code>develop</code> 分支</li><li>当<code>release</code>分支完成后，会合并到<code>develop</code>和<code>master</code></li><li>如果<code>master</code>检测到问题，则从 <code>master</code> 创建 <code>hotfix</code> 程序分支</li><li><code>hotfix</code>完成后，会被合并到两个<code>develop</code>及<code>master</code></li></ol><p><strong>感谢：</strong></p><p><a href="https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow">Gitflow</a></p><p><a href="https://git-scm.com/book/zh/v2">Git</a></p><p> <a href="https://segmentfault.com/a/1190000022506884">git HEAD / HEAD^ / HEAD~ 的含义</a></p><p> <a href="https://www.cnblogs.com/kidsitcn/p/5339382.html">git rebase vs git merge详解</a></p><p><a href="https://juejin.im/book/6844733697996881928/">Git 原理详解及实用指南</a></p><p><strong>更多：</strong></p><p><a href="https://juejin.im/entry/6844903581087170574">Git+Gerrit如何永久删除历史文件（大文件/私密文件）</a></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-结构型-桥接模式</title>
      <link href="2020/design-pattern-bridge.html"/>
      <url>2020/design-pattern-bridge.html</url>
      
        <content type="html"><![CDATA[<p><code>GoF</code> 的《设计模式》 中，桥接模式是这么定义的：<code>Decouple an abstraction from its implementation so that the two can vary independently。(将抽象和实现解耦，让它们可以独立变化。)</code> </p><p>其他资料的解释：<code>一个类存在两个（或多个）独立变化的维度，我们通过组合的方式，让这两个（或多个）维度可以独立进行扩展。</code> 通过组合关系来替代继承关系，避免继承层次的指数级爆炸。这种理解方式非常类似于，我们之前讲过的“组合优于继承”设计原则。</p><h1 id="1-桥接模式举例"><a href="#1-桥接模式举例" class="headerlink" title="1 桥接模式举例"></a>1 桥接模式举例</h1><p>举个栗子🌰 </p><p>我们点咖啡的时候，可以选小杯，大杯，可以加糖，或原味。那用设计模式怎么灵活装配这些需求呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Coffee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> CoffeeAdditives impl;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Coffee</span><span class="params">(CoffeeAdditives impl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.impl = impl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 咖啡具体是什么样子由子类决定</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">makeCoffee</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LatgeCoffee</span> <span class="keyword">extends</span> <span class="title">Coffee</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LatgeCoffee</span><span class="params">(CoffeeAdditives impl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(impl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeCoffee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;大杯的&quot;</span> + impl + <span class="string">&quot;咖啡&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmallCoffee</span> <span class="keyword">extends</span> <span class="title">Coffee</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SmallCoffee</span><span class="params">(CoffeeAdditives impl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(impl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeCoffee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小杯的&quot;</span> + impl + <span class="string">&quot;咖啡&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Coffee</code> 类中保持了对 <code>CoffeeAdditives</code> 的引用，以便调用具体的实现。同样的，咖啡还分大杯小杯，定义两个子类继承于 <code>Coffee</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CoffeeAdditives</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 具体要往咖啡里添加什么由子类实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">addSomething</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sugar</span> <span class="keyword">extends</span> <span class="title">CoffeeAdditives</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;加糖&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ordinary</span> <span class="keyword">extends</span> <span class="title">CoffeeAdditives</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;原味&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>CoffeeAdditives</code> 其实实现部分，而 <code>Coffee</code> 则对应于抽象部分，模式定义中所谓的 “抽象” 与 “实现” 实质上对应的是两个独立变化的维度，因此，任何多维度变化类或者说多个树状类之间的耦合都可以使用桥接模式来实现解耦。</p><p><code>Coffee</code> 类虽是一个抽象类，但它并非是所谓的 “抽象部分” ，而 <code>CoffeeAdditives</code> 类也并非一定就是 “实现部分” ，两者各自为一维度，独立变化，仅此而已，所谓的 “抽象与实现分离” 更偏向于我们实际的程序开发，两者并不一定挂钩，这里其实就可以看到桥接模式的应用性其实很广泛，并不局限于程序设计。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Ordinary implOrdinary = <span class="keyword">new</span> Ordinary();</span><br><span class="line">Sugar implSugar = <span class="keyword">new</span> Sugar();</span><br><span class="line"></span><br><span class="line"><span class="comment">//大杯原味</span></span><br><span class="line">LatgeCoffee latgeCoffeeOrdinary = <span class="keyword">new</span> LatgeCoffee(implOrdinary);</span><br><span class="line">latgeCoffeeOrdinary.makeCoffee();</span><br><span class="line"></span><br><span class="line"><span class="comment">//小杯原味</span></span><br><span class="line">SmallCoffee smallCoffeeOrdinary = <span class="keyword">new</span> SmallCoffee(implOrdinary);</span><br><span class="line">smallCoffeeOrdinary.makeCoffee();</span><br><span class="line"></span><br><span class="line"><span class="comment">//大杯加糖</span></span><br><span class="line">LatgeCoffee latgeCoffeeSugar = <span class="keyword">new</span> LatgeCoffee(implSugar);</span><br><span class="line">latgeCoffeeSugar.makeCoffee();</span><br><span class="line"></span><br><span class="line"><span class="comment">//小杯加糖</span></span><br><span class="line">SmallCoffee smallCoffeeSugar = <span class="keyword">new</span> SmallCoffee(implSugar);</span><br><span class="line">smallCoffeeSugar.makeCoffee();</span><br></pre></td></tr></table></figure><p>这时候如果需要新增 中杯 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MiddleCoffee</span> <span class="keyword">extends</span> <span class="title">Coffee</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MiddleCoffee</span><span class="params">(CoffeeAdditives impl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(impl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeCoffee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;中杯的&quot;</span> + impl + <span class="string">&quot;咖啡&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中杯加糖</span></span><br><span class="line">MiddleCoffee middleCoffeeSugar = <span class="keyword">new</span> MiddleCoffee(implSugar);</span><br><span class="line">middleCoffeeSugar.makeCoffee();</span><br><span class="line"></span><br><span class="line"><span class="comment">//中杯原味</span></span><br><span class="line">MiddleCoffee middleCoffeeOrdinary = <span class="keyword">new</span> MiddleCoffee(implOrdinary);</span><br><span class="line">middleCoffeeOrdinary.makeCoffee();</span><br></pre></td></tr></table></figure><p>我也可以让 <code>CoffeeAdditives</code> 类变化起来，比如加奶、加蜂蜜。不管是 <code>Coffee</code> 变化了还是 <code>CoffeeAdditives</code> 变化了，其相对于对方而言都是独立的没有什么过多的交集，两者之间唯一的联系就是 <code>Coffee</code> 中保持的对 <code>CoffeeAdditives</code> 的引用，此乃两者之纽带，这就是桥接模式。</p><h1 id="2-Android-源码中的桥接模式"><a href="#2-Android-源码中的桥接模式" class="headerlink" title="2 Android 源码中的桥接模式"></a>2 Android 源码中的桥接模式</h1><p>首先是 <code>Adapter</code> 与 <code>AdapterView</code> <a href="https://blog.csdn.net/zhangzeyuaaa/article/details/40151983">AdapterView 与 Adapter</a> </p><p>这里引用原文两张图片，<code>Adapter</code> 对应抽象部分，<code>Adapter</code>对应实现部分。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/design/bridge_adapter.png" alt="adapter"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/design/bridge_adapterview.png" alt="adapterView"></p><p>还有是 <code>View</code> 的视图层级中，<code>CheckBox</code>、<code>CompoundButton</code>、<code>Button</code>、<code>TextView</code> 和 <code>View</code> 之间构成一个继承关系的视图层级，每一层视图都仅仅是对一种类型控件的描述，其定义了该类控件所拥有的基本属性和行为，但是将它们真正绘制到屏幕的部分是由与 <code>View</code> 相关的功能实现类 <code>DisplayList</code> 、<code>HardwareLayer</code> 和 <code>Canvas</code> 负责。</p><p>还有就是 <code>Window</code> 和 <code>WindowManager</code></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/design/bridge_window_manager.png" alt="图片来源于 Android 源码设计模式解析与实战"></p><p>在 <code>framework</code> 中 <code>Window</code> 和 <code>PhoneWindow</code> 构成窗口的抽象部分，其中 <code>Window</code> 类为该抽象部分的抽象接口，<code>PhoneWindow</code> 为抽象部分具体的实现及扩展。而 <code>WindowManager</code> 则为实现部分的基类，<code>WindowManagerlmpl</code> 为实现部分具体的逻辑实现，其使用 <code>WindowManagerGlobal</code> 通过 <code>IWindowManager</code>  接口与<code>WindowManagerService</code>（也就是我们常说的 <code>WMS</code> ）进行交互，并由 <code>WMS</code> 完成具体的窗口管理工作，如下为 <code>Window</code> 与 <code>WindowManager</code> 桥梁搭建的主要代码，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Window</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWindowManager</span><span class="params">(WindowManager wm, IBinder appToken, String appName)</span> </span>&#123;</span><br><span class="line">        setWindowManager(wm, appToken, appName, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWindowManager</span><span class="params">(WindowManager wm, IBinder appToken, String appName,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> hardwareAccelerated)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">if</span> (wm == <span class="keyword">null</span>) &#123;</span><br><span class="line">            wm = (WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE);</span><br><span class="line">        &#125;</span><br><span class="line">        mWindowManager = ((WindowManagerImpl)wm).createLocalWindowManager(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以毫不夸张地说，<code>Android</code> 的 <code>framework</code> 层主要就是由它与另外一个系统服务 <code>ActivityManagerService</code>（简称 <code>AMS</code> ）还有 <code>View</code> 所构成，这 <code>3</code> 个模块穿插交互在整个 <code>framework</code> 中，掌握了它们之间的关系以及每一个步骤的逻辑，你对 <code>framework</code> 就至少了解百分之五十了。</p><p><a href="http://gityuan.com/2017/01/08/windowmanger/">WindowManager启动篇</a></p><h1 id="3-桥接模式-Android-实战"><a href="#3-桥接模式-Android-实战" class="headerlink" title="3 桥接模式 Android 实战"></a>3 桥接模式 Android 实战</h1><p><code>View</code> 的视图层级与执行真正的硬件绘制相关类之间的关系可以看作是一种桥接模式，其实这里也可以模仿这种行为来让我们的自定义控件以桥接的方式提供多种不同的实现机制，逻辑很简单，这里以进度条为例，鉴于进度条的逻辑并不复杂，我们可以自己继承View类来实现进度条控件，这里就以自定义水平、垂直和圆形 <code>3</code> 种不同的进度条为例，为了后期扩展，我们以一个实现类来声明不同进度条需要实现的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseProgressBar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HORIZONTAL = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VERTICAL = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CIRCLE = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Paint mPaint;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法内完成一些具体的初始化信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">BaseProgressBar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mPaint = <span class="keyword">new</span> Paint(Paint.ANTI_ALIAS_FLAG | Paint.DITHER_FLAG);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取测试高度，由具体子类实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getMeasureHeight</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取测试宽度，由具体子类实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getMeasureWidth</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 具体的绘制操作，由子类实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(View view, Canvas canvas)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircleProgressBar</span> <span class="keyword">extends</span> <span class="title">BaseProgressBar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMeasureHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">50</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMeasureWidth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(View view, Canvas canvas)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//具体绘制</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HorizontalProgressBar</span> <span class="keyword">extends</span> <span class="title">BaseProgressBar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMeasureHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">50</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMeasureWidth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(View view, Canvas canvas)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//具体绘制</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VerticalProgressBar</span> <span class="keyword">extends</span> <span class="title">BaseProgressBar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMeasureHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">50</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMeasureWidth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(View view, Canvas canvas)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//具体绘制</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后用一个继承于 <code>View</code> 的进度条来分派绘制逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProgressBar</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HEIGHT = <span class="number">0x6846</span>, WIDTH = <span class="number">0x7889</span>;</span><br><span class="line">    <span class="keyword">private</span> BaseProgressBar mBaseProgressBar;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> style = BaseProgressBar.CIRCLE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProgressBar</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProgressBar</span><span class="params">(Context context, <span class="meta">@Nullable</span> AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, attrs, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProgressBar</span><span class="params">(Context context, <span class="meta">@Nullable</span> AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.ProgressBar, defStyleAttr, <span class="number">0</span>);</span><br><span class="line">        style = a.getInt(R.styleable.ProgressBar_style, BaseProgressBar.CIRCLE);</span><br><span class="line">        <span class="keyword">if</span> (style == BaseProgressBar.HORIZONTAL) &#123;</span><br><span class="line">            mBaseProgressBar = <span class="keyword">new</span> HorizontalProgressBar();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (style == BaseProgressBar.VERTICAL) &#123;</span><br><span class="line">            mBaseProgressBar = <span class="keyword">new</span> VerticalProgressBar();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mBaseProgressBar = <span class="keyword">new</span> CircleProgressBar();</span><br><span class="line">        &#125;</span><br><span class="line">        a.recycle();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">        setMeasuredDimension(measureDimension(WIDTH, widthMeasureSpec), measureDimension(HEIGHT, heightMeasureSpec));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">measureDimension</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (style == BaseProgressBar.CIRCLE) &#123;</span><br><span class="line">            <span class="keyword">return</span> mBaseProgressBar.getMeasureWidth();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result;</span><br><span class="line">        <span class="keyword">int</span> mode = MeasureSpec.getMode(measureSpec);</span><br><span class="line">        <span class="keyword">int</span> size = MeasureSpec.getSize(measureSpec);</span><br><span class="line">        <span class="keyword">if</span> (mode == MeasureSpec.EXACTLY) &#123;</span><br><span class="line">            result = size;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (type == HEIGHT) &#123;</span><br><span class="line">                result = mBaseProgressBar.getMeasureHeight();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result = mBaseProgressBar.getMeasureWidth();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mode == MeasureSpec.AT_MOST) &#123;</span><br><span class="line">                result = Math.min(result, size);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDraw(canvas);</span><br><span class="line">        mBaseProgressBar.draw(<span class="keyword">this</span>, canvas);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>ProgressBar</code> 类持有 <code>BaseProgressBar</code> 类的引用，通过在不同的绘制阶段调用不同进度条实现类的相应方法完成具体的逻辑。如本文所说，桥接模式的应用其实非常的广泛，除了上面我们提到的控件例子外，在进行数据库 <code>dao</code> 类设计时我们有时也会需要使用到桥接模式。<br>而且对于 <code>Android</code> 来说，应用层与 <code>Native</code> 层之间的交互就是一个最好的例子，在需要操纵 <code>Android</code> 设备硬件时就需要使用一个连接应用层与 <code>Native</code> 的桥梁，这个桥梁通常是一个具体的类，比如提供操作相机的 <code>Camera</code> 、播放音视频的 <code>MediaPlayer</code> 、提供图形绘制接口的 <code>OpenCV</code> 等，这些 <code>API</code> 类为我们操作底层硬件提供了可能。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对于这个模式有两种不同的理解方式。在 <code>GoF</code>  的《设计模式》一书中，桥接模式被定义为：</p><p>“将抽象和实现解耦，让它们可以独立变化。”</p><p>在其他资料和书籍中，还有另外一种更加简单的理解方式：</p><p>“一个类存在两个（或多个）独立变化的维度，我们通过组合的方式，让这两个（或多个）维度可以独立进行扩展。”</p><p>对于第一种 <code>GoF</code> 的理解方式，弄懂定义中 “抽象” 和 “实现” 两个概念，是理解它的关键。</p><p>定义中的 “抽象” ，指的并非 “抽象类” 或 “接口” ，而是被抽象出来的一套 “类库” ，它只包含骨架代码，真正的业务逻辑需要委派给定义中的 “实现” 来完成。而定义中的 “实现” ，也并非 “接口的实现类” ，而是一套独立的 “类库” 。“抽象” 和 “实现” 独立开发，通过对象之间的组合关系，组装在一起。</p><h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a><strong>感谢</strong></h1><blockquote><p><a href="https://time.geekbang.org/column/intro/250?utm_source=pinpaizhuanqu&utm_medium=geektime&utm_campaign=guanwang&utm_term=guanwang&utm_content=0511">设计模式之美</a></p><p>《Android 源码设计模式解析与实战》</p><p>以及上文中的链接</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-结构型-代理模式</title>
      <link href="2020/design-pattern-proxy.html"/>
      <url>2020/design-pattern-proxy.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-静态代理"><a href="#1-静态代理" class="headerlink" title="1 静态代理"></a>1 静态代理</h1><p>在不改变原始类（或叫被代理类）代码的情况下，通过引入代理类来给原始类附加功能。</p><p>举个栗子🌰 监控登录注册接口调用时长。</p><p><code>MetricsCollector</code> 类用来收集接口请求的原始数据，比如访问时间、处理时长等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...省略其他属性和方法...</span></span><br><span class="line">  <span class="keyword">private</span> MetricsCollector metricsCollector; <span class="comment">// 依赖注入</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> UserVo <span class="title">login</span><span class="params">(String telephone, String password)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> startTimestamp = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 省略login逻辑...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> endTimeStamp = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> responseTime = endTimeStamp - startTimestamp;</span><br><span class="line">    RequestInfo requestInfo = <span class="keyword">new</span> RequestInfo(<span class="string">&quot;login&quot;</span>, responseTime, startTimestamp);</span><br><span class="line">    metricsCollector.recordRequest(requestInfo);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...返回UserVo数据...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> UserVo <span class="title">register</span><span class="params">(String telephone, String password)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> startTimestamp = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 省略register逻辑...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> endTimeStamp = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> responseTime = endTimeStamp - startTimestamp;</span><br><span class="line">    RequestInfo requestInfo = <span class="keyword">new</span> RequestInfo(<span class="string">&quot;register&quot;</span>, responseTime, startTimestamp);</span><br><span class="line">    metricsCollector.recordRequest(requestInfo);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...返回UserVo数据...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显，上面的写法有两个问题。</p><ul><li>性能计数器框架代码侵入到业务代码中，跟业务代码高度耦合。如果未来需要替换这个框架，那替换的成本会比较大。</li><li>收集接口请求的代码跟业务代码无关，本就不应该放到一个类中。业务类最好职责更加单一，只聚焦业务处理。</li></ul><p>为了将框架代码和业务代码解耦，代理模式就派上用场了。</p><p>代理类 <code>UserControllerProxy</code> 和原始类 <code>UserController</code> 实现相同的接口 <code>IUserController</code>。<code>UserController</code> 类只负责业务功能。代理类 <code>UserControllerProxy</code> 负责在业务代码执行前后附加其他逻辑代码，并通过委托的方式调用原始类来执行业务代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUserController</span> </span>&#123;</span><br><span class="line">  <span class="function">UserVo <span class="title">login</span><span class="params">(String telephone, String password)</span></span>;</span><br><span class="line">  <span class="function">UserVo <span class="title">register</span><span class="params">(String telephone, String password)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> <span class="keyword">implements</span> <span class="title">IUserController</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...省略其他属性和方法...</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> UserVo <span class="title">login</span><span class="params">(String telephone, String password)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...省略login逻辑...</span></span><br><span class="line">    <span class="comment">//...返回UserVo数据...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> UserVo <span class="title">register</span><span class="params">(String telephone, String password)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...省略register逻辑...</span></span><br><span class="line">    <span class="comment">//...返回UserVo数据...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserControllerProxy</span> <span class="keyword">implements</span> <span class="title">IUserController</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> MetricsCollector metricsCollector;</span><br><span class="line">  <span class="keyword">private</span> UserController userController;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">UserControllerProxy</span><span class="params">(UserController userController)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.userController = userController;</span><br><span class="line">    <span class="keyword">this</span>.metricsCollector = <span class="keyword">new</span> MetricsCollector();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> UserVo <span class="title">login</span><span class="params">(String telephone, String password)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> startTimestamp = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 委托</span></span><br><span class="line">    UserVo userVo = userController.login(telephone, password);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> endTimeStamp = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> responseTime = endTimeStamp - startTimestamp;</span><br><span class="line">    RequestInfo requestInfo = <span class="keyword">new</span> RequestInfo(<span class="string">&quot;login&quot;</span>, responseTime, startTimestamp);</span><br><span class="line">    metricsCollector.recordRequest(requestInfo);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> userVo;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> UserVo <span class="title">register</span><span class="params">(String telephone, String password)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> startTimestamp = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    UserVo userVo = userController.register(telephone, password);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> endTimeStamp = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> responseTime = endTimeStamp - startTimestamp;</span><br><span class="line">    RequestInfo requestInfo = <span class="keyword">new</span> RequestInfo(<span class="string">&quot;register&quot;</span>, responseTime, startTimestamp);</span><br><span class="line">    metricsCollector.recordRequest(requestInfo);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> userVo;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//UserControllerProxy使用举例</span></span><br><span class="line"><span class="comment">//因为原始类和代理类实现相同的接口，是基于接口而非实现编程</span></span><br><span class="line"><span class="comment">//将UserController类对象替换为UserControllerProxy类对象，不需要改动太多代码</span></span><br><span class="line">IUserController userController = <span class="keyword">new</span> UserControllerProxy(<span class="keyword">new</span> UserController());</span><br></pre></td></tr></table></figure><p>参照基于接口而非实现编程的设计思想，将原始类对象替换为代理类对象的时候，为了让代码改动尽量少，在刚刚的代理模式的代码实现中，代理类和原始类需要实现相同的接口。<br>但是，如果原始类并没有定义接口，并且原始类代码并不是我们开发维护的（比如它来自一个第三方的类库），我们也没办法直接修改原始类，给它重新定义一个接口。在这种情况下，我们该如何实现代理模式呢？</p><p>对于这种外部类的扩展，我们一般都是采用继承的方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserControllerProxy</span> <span class="keyword">extends</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> MetricsCollector metricsCollector;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">UserControllerProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.metricsCollector = <span class="keyword">new</span> MetricsCollector();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> UserVo <span class="title">login</span><span class="params">(String telephone, String password)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> startTimestamp = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    UserVo userVo = <span class="keyword">super</span>.login(telephone, password);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> endTimeStamp = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> responseTime = endTimeStamp - startTimestamp;</span><br><span class="line">    RequestInfo requestInfo = <span class="keyword">new</span> RequestInfo(<span class="string">&quot;login&quot;</span>, responseTime, startTimestamp);</span><br><span class="line">    metricsCollector.recordRequest(requestInfo);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> userVo;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> UserVo <span class="title">register</span><span class="params">(String telephone, String password)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> startTimestamp = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    UserVo userVo = <span class="keyword">super</span>.register(telephone, password);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> endTimeStamp = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> responseTime = endTimeStamp - startTimestamp;</span><br><span class="line">    RequestInfo requestInfo = <span class="keyword">new</span> RequestInfo(<span class="string">&quot;register&quot;</span>, responseTime, startTimestamp);</span><br><span class="line">    metricsCollector.recordRequest(requestInfo);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> userVo;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//UserControllerProxy使用举例</span></span><br><span class="line">UserController userController = <span class="keyword">new</span> UserControllerProxy();</span><br></pre></td></tr></table></figure><h1 id="2-动态代理"><a href="#2-动态代理" class="headerlink" title="2 动态代理"></a>2 动态代理</h1><p>可以发现，静态代理完美的分离了收集代码与请求业务代码，但是，如果我们需要收集的类过多时，每个类都要写一个代理类，这会导致项目中类的个数成倍增加，增加了代码维护成本。并且，每个代理类中的代码都有点像模板式的 “重复” 代码，也增加了不必要的开发成本。</p><p>现在就是动态代理的表现的时候，就是我们不事先为每个原始类编写代理类，而是在运行的时候，动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。<br>动态代理底层依赖的就是 <code>Java</code> 的反射语法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MetricsCollectorProxy</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> MetricsCollector metricsCollector;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MetricsCollectorProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.metricsCollector = <span class="keyword">new</span> MetricsCollector();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">createProxy</span><span class="params">(Object proxiedObject)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt;[] interfaces = proxiedObject.getClass().getInterfaces();</span><br><span class="line">    DynamicProxyHandler handler = <span class="keyword">new</span> DynamicProxyHandler(proxiedObject);</span><br><span class="line">    <span class="keyword">return</span> Proxy.newProxyInstance(proxiedObject.getClass().getClassLoader(), interfaces, handler);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxyHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object proxiedObject;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicProxyHandler</span><span class="params">(Object proxiedObject)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.proxiedObject = proxiedObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">      <span class="keyword">long</span> startTimestamp = System.currentTimeMillis();</span><br><span class="line">      Object result = method.invoke(proxiedObject, args);</span><br><span class="line">      <span class="keyword">long</span> endTimeStamp = System.currentTimeMillis();</span><br><span class="line">      <span class="keyword">long</span> responseTime = endTimeStamp - startTimestamp;</span><br><span class="line">      String apiName = proxiedObject.getClass().getName() + <span class="string">&quot;:&quot;</span> + method.getName();</span><br><span class="line">      RequestInfo requestInfo = <span class="keyword">new</span> RequestInfo(apiName, responseTime, startTimestamp);</span><br><span class="line">      metricsCollector.recordRequest(requestInfo);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//MetricsCollectorProxy使用举例</span></span><br><span class="line">MetricsCollectorProxy proxy = <span class="keyword">new</span> MetricsCollectorProxy();</span><br><span class="line">IUserController userController = (IUserController) proxy.createProxy(<span class="keyword">new</span> UserController());</span><br></pre></td></tr></table></figure><p><code>android-aspectjx AOP</code> 底层的实现原理就是基于动态代理。</p><h1 id="3-Android-源码中的代理模式实现"><a href="#3-Android-源码中的代理模式实现" class="headerlink" title="3 Android 源码中的代理模式实现"></a>3 Android 源码中的代理模式实现</h1><p><a href="http://gityuan.com/2016/09/04/binder-start-service/">彻底理解Android Binder通信架构</a> </p><p><a href="http://gityuan.com/2015/11/22/binder-use/">Binder系列8—如何使用Binder</a> </p><p><a href="http://gityuan.com/2015/11/23/binder-aidl/">Binder系列9—如何使用AIDL</a></p><h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h1><p>代理模式最常用的一个应用场景就是，在业务系统中开发一些非功能性需求，比如：监控、统计、鉴权、限流、事务、幂等、日志。我们将这些附加功能与业务功能解耦，放到代理类中统一处理，让程序员只需要关注业务方面的开发。实际上，前面举的搜集接口请求信息的例子，就是这个应用场景的一个典型例子。</p><h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a><strong>感谢</strong></h1><blockquote><p><a href="https://time.geekbang.org/column/intro/250?utm_source=pinpaizhuanqu&utm_medium=geektime&utm_campaign=guanwang&utm_term=guanwang&utm_content=0511">设计模式之美</a></p><p>《Android 源码设计模式解析与实战》</p><p>以及上文中的链接</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-创建型-原型模式</title>
      <link href="2020/design-pattern-prototype.html"/>
      <url>2020/design-pattern-prototype.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-什么是原型模式？"><a href="#1-什么是原型模式？" class="headerlink" title="1 什么是原型模式？"></a>1 什么是原型模式？</h1><p>如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同），在这种情况下，我们可以利用对已有对象（原型）进行复制（或者叫拷贝）的方式，来创建新对象，以达到节省创建时间的目的。这种基于原型来创建对象的方式就叫作原型设计模式，简称原型模式。</p><p>实际上，创建对象包含的申请内存、给成员变量赋值这一过程，本身并不会花费太多时间，或者说对于大部分业务系统来说，这点时间完全是可以忽略的。应用一个复杂的模式，只得到一点点的性能提升，这就是所谓的过度设计，得不偿失。</p><p>但是，如果对象中的数据需要经过复杂的计算才能得到（比如排序、计算哈希值），或者需要从 <code>RPC</code>、网络、数据库、文件系统等非常慢速的 IO 中读取，这种情况下，我们就可以利用原型模式，从其他已有对象中直接拷贝得到，而不用每次在创建新对象的时候，都重复执行这些耗时的操作。</p><p>举个栗子🌰</p><p>我们在这个例子中首先创建了一个文档对象，即 <code>WordDocument</code> ，这个文档中含有文字和图片。<br>用户经过了长时间的内容编辑后，打算对该文档做进一步的编辑，但是，这个编辑后的文档是否会被采用还不确定，因此，为了安全起见，用户需要将当前文档拷贝一份，然后再在文档副本上进行修改，这与 <code>《Effective Java》</code> 一书中提到的<strong>保护性拷贝</strong>有些类似，如此，这个原始文档就是样板实例，也就是将要被 “克隆” 的对象，称为原型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordDocument</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String mText;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; mImages = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WordDocument <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            WordDocument doc = (WordDocument) <span class="keyword">super</span>.clone();</span><br><span class="line">            doc.mText = <span class="keyword">this</span>.mText;</span><br><span class="line">            doc.mImages = <span class="keyword">this</span>.mImages;</span><br><span class="line">            <span class="keyword">return</span> doc;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getmText</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mText;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setmText</span><span class="params">(String mText)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mText = mText;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">getmImages</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mImages;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addImages</span><span class="params">(String mImages)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mImages.add(mImages);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showDocument</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;----------Word Content Start------------&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Text :&quot;</span> + mText);</span><br><span class="line">        System.out.println(<span class="string">&quot;Image List :&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String mImage : mImages) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;image name :&quot;</span> + mImage);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;----------Word Content End------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>WordDocumen</code> 类模拟了 <code>Word</code> 文档中的基本元素，即文字和图片 。 <code>WordDocument</code> 中的 <code>clone</code> 方法用以实现对象克隆。注意，这个方法并不是 <code>Cloneable</code> 接口中的，而是 <code>Object</code> 中的方法。 <code>Cloneable</code> 也是一个标识接口，它表明这个类的对象是可拷贝的。如果没有实现 <code>Cloneable</code> 接口却调用了 <code>clone（）</code>函数将抛出异常。在这个示例中，通过实现 <code>Cloneable</code> 接口和覆写 <code>clone</code> 方法实现原型模式。<br> <code>Client</code> 端的使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        WordDocument originDoc = <span class="keyword">new</span> WordDocument();</span><br><span class="line">        originDoc.setmText(<span class="string">&quot;这是一篇文档&quot;</span>);</span><br><span class="line">        originDoc.addImages(<span class="string">&quot;图片 1&quot;</span>);</span><br><span class="line">        originDoc.addImages(<span class="string">&quot;图片 2&quot;</span>);</span><br><span class="line">        originDoc.addImages(<span class="string">&quot;图片 3&quot;</span>);</span><br><span class="line">        originDoc.showDocument();</span><br><span class="line"></span><br><span class="line">        WordDocument doc2 = originDoc.clone();</span><br><span class="line">        doc2.showDocument();</span><br><span class="line"></span><br><span class="line">        doc2.setmText(<span class="string">&quot;修改&quot;</span>);</span><br><span class="line">        doc2.addImages(<span class="string">&quot;哈哈 123&quot;</span>);</span><br><span class="line">        doc2.showDocument();</span><br><span class="line"></span><br><span class="line">        originDoc.showDocument();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">----------Word Content Start------------</span><br><span class="line">Text :这是一篇文档</span><br><span class="line">Image List :</span><br><span class="line">image name :图片 1</span><br><span class="line">image name :图片 2</span><br><span class="line">image name :图片 3</span><br><span class="line">----------Word Content End------------</span><br><span class="line">----------Word Content Start------------</span><br><span class="line">Text :这是一篇文档</span><br><span class="line">Image List :</span><br><span class="line">image name :图片 1</span><br><span class="line">image name :图片 2</span><br><span class="line">image name :图片 3</span><br><span class="line">----------Word Content End------------</span><br><span class="line">----------Word Content Start------------</span><br><span class="line">Text :修改</span><br><span class="line">Image List :</span><br><span class="line">image name :图片 1</span><br><span class="line">image name :图片 2</span><br><span class="line">image name :图片 3</span><br><span class="line">image name :哈哈 123</span><br><span class="line">----------Word Content End------------</span><br><span class="line">----------Word Content Start------------</span><br><span class="line">Text :这是一篇文档</span><br><span class="line">Image List :</span><br><span class="line">image name :图片 1</span><br><span class="line">image name :图片 2</span><br><span class="line">image name :图片 3</span><br><span class="line">image name :哈哈 123</span><br><span class="line">----------Word Content End------------</span><br></pre></td></tr></table></figure><p>从输出中可以看到，<code>doc2</code> 是通过 <code>originDoc.clone()</code> 创建的，并且 <code>doc2</code> 第一次输出的时候和 <code>originDoc</code> 输出是一样的，即 <code>doc2</code> 是 <code>originDoc</code> 的一份拷贝，它们的内容是一样的，而 <code>doc2</code> 修改了文本内容以后并不会影响 <code>originDoc</code> 的文本内容，这就保证了 <code>originDoc</code> 的安全性。还需要注意的是，通过 <code>clone</code> 拷贝对象时并不会执行构造函数！因此，如果在构造函数中需要一些特殊的初始化操作的类型，在使用 <code>Cloneable</code> 实现拷贝时，需要注意构造函数不会执行的问题。</p><h1 id="2-深拷贝浅拷贝"><a href="#2-深拷贝浅拷贝" class="headerlink" title="2 深拷贝浅拷贝"></a>2 深拷贝浅拷贝</h1><p>上述原型模式的实现实际上只是一个浅拷贝，也称为影子拷贝，这份拷贝实际上并不是将原始文档的所有字段都重新构造了一份，而是副本文档的字段引用原始文档的字段</p><p>仔细查看，发现 <code>doc2</code> 添加照片之后，<code>originDoc</code> 也被修改了。这是怎么回事呢？<br>这是因为上文中 <code>WordDocument</code> 的 <code>clone</code> 方法中只是简单地进行浅拷贝，引用类型的新对象 <code>doc2</code> 的 <code>mlmages</code> 只是单纯地指向了 <code>this.mlmages</code> 引用，并没有重新构造一个 <code>mlimages</code>  对象，然后将原始文档中的图片添加到新的 <code>mlmages</code> 对象中，这样就导致 <code>doc2</code> 中的 <code>mlmages</code> 与原始文档中的是同一个对象，因此，修改了其中一个文档中的图片，另一个文档也会受影响。那如何解决这个问题呢？答案就是采用深拷贝，即在拷贝对象时，对于引用型的字段也要采用拷贝的形式，而不是单纯引用的形式。<code>clone</code> 方法修改如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> WordDocument <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        WordDocument doc = (WordDocument) <span class="keyword">super</span>.clone();</span><br><span class="line">        doc.mText = <span class="keyword">this</span>.mText;</span><br><span class="line">        doc.mImages = (ArrayList&lt;String&gt;) <span class="keyword">this</span>.mImages.clone();</span><br><span class="line">        <span class="keyword">return</span> doc;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以了，为什么 <code>Text</code>  不会被影响？</p><p>因为他是一个 <code>String</code> 类型，赋值的时候可能创建一个或者不创建对象，如果赋值的内容在 <code>java String</code> 池里不存在，会在 <code>java String</code> 池里创建一个创建一个 <code>String</code> 对象，然后指向这个内存地址。而不是去修改当前地址，因为 <code>String</code> 是不可修改的。之后再赋同样的值的时候就不会创建新的对象。</p><h1 id="3-Android-源码中的原型模式实现"><a href="#3-Android-源码中的原型模式实现" class="headerlink" title="3 Android 源码中的原型模式实现"></a>3 Android 源码中的原型模式实现</h1><p>在上述的文档深拷贝示例中，<code>mlmages</code> 对象调用了 <code>clone0</code> 方法，这就是原型模式。我们知道，<code>mlmages</code> 的实际类型为 <code>ArrayList</code> ，相关源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) <span class="keyword">super</span>.clone();</span><br><span class="line">        v.elementData = Arrays.copyOf(elementData, size);</span><br><span class="line">        v.modCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="comment">// this shouldn&#x27;t happen, since we are Cloneable</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>Android</code> 中，<code>Intent</code> 可能是我们最早接触的几个类型之一，它用于跳转 <code>Activity</code> 、启动服务、发布广播等功能，它是 <code>Android</code> 系统各组件之间的纽带，也是组件之间传递数据的载体，正是Intent的存在才使得 <code>Android</code>各个组件之间的耦合性很低，Android的组件才如此灵活。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Uri uri = Uri.parse(<span class="string">&quot;smsto:0800000123&quot;</span>);</span><br><span class="line">Intent shareIntent = <span class="keyword">new</span> Intent(Intent.ACTION_SENDTO,uri);</span><br><span class="line">shareIntent.putExtra(<span class="string">&quot;sms_body&quot;</span>,<span class="string">&quot;The SMS test&quot;</span>);</span><br><span class="line"></span><br><span class="line">Intent intent= (Intent) shareIntent.clone();</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure><p>首先构造了一个发送短信的 <code>Intent</code> 对象，并且设置了短信内容，然后通过原始 <code>Intent</code> 的 <code>clone0</code> 方法构建了一个副本 <code>Intent</code> ，再使用这个副本 <code>Intent</code> 进行跳转</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Intent(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 <code>clone</code> 方法实际上在内部并没有调用 <code>super.clone()</code>方法来实现对象拷贝，而是调用了 <code>new Intent（this）</code> 。使用 <code>clone</code> 和 <code>new</code> 需要根据构造对象的成本来决定，如果对象的构造成本比较高或者构造较为麻烦，那么使用 <code>clone() 函数效率较高，否则可以使用</code> <code>new</code> 的形式。</p><p><a href="https://www.jianshu.com/p/420395facf88">Android 源码 Intent 的查找和匹配</a>  <code>parseBaseApplication</code> 方法是解析 <code>application</code>，可以在文章中搜索。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>优点<br>原型模式是在内存中二进制流的拷贝，要比直接 <code>new</code> 一个对象性能好很多，特别是要在一个循环体内产生大量的对象时，原型模式可以更好地体现其优点。</li><li>缺点<br>这既是它的优点也是缺点，直接在内存中拷贝，构造函数是不会执行的，在实际开发当中应该注意这个潜在的问题。优点就是减少了约束，缺点也是减少了约束，需要在实际应用时考虑。</li></ul><h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a><strong>感谢</strong></h1><blockquote><p><a href="https://time.geekbang.org/column/intro/250?utm_source=pinpaizhuanqu&utm_medium=geektime&utm_campaign=guanwang&utm_term=guanwang&utm_content=0511">设计模式之美</a></p><p>《Android 源码设计模式解析与实战》</p><p>以及上文中的链接</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-创建型-Builder 模式</title>
      <link href="2020/design-pattern-builder.html"/>
      <url>2020/design-pattern-builder.html</url>
      
        <content type="html"><![CDATA[<p><strong>Builder 模式</strong>一个比较常用的创建型设计模式，中文翻译为<strong>建造者模式</strong>或者<strong>构建者模式</strong>，也有人叫它<strong>生成器模式</strong>。</p><h1 id="1-为什么需要建造者模式？"><a href="#1-为什么需要建造者模式？" class="headerlink" title="1 为什么需要建造者模式？"></a>1 为什么需要建造者模式？</h1><p>举个栗子🌰 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourcePoolConfig</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MAX_TOTAL = <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MAX_IDLE = <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MIN_IDLE = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> maxTotal = DEFAULT_MAX_TOTAL;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> maxIdle = DEFAULT_MAX_IDLE;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> minIdle = DEFAULT_MIN_IDLE;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ResourcePoolConfig</span><span class="params">(String name, Integer maxTotal, Integer maxIdle, Integer minIdle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(name)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;name should not be empty.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (maxTotal != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (maxTotal &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;maxTotal should be positive.&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.maxTotal = maxTotal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (maxIdle != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (maxIdle &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;maxIdle should not be negative.&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.maxIdle = maxIdle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (minIdle != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (minIdle &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;minIdle should not be negative.&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.minIdle = minIdle;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...省略getter方法...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是构建一个对象最常见、最容易想到的实现思路，因为 <code>maxTotal</code>、<code>maxIdle</code>、<code>minIdle</code> 不是必填变量，所以在创建 <code>ResourcePoolConfig</code> 对象的时候，我们通过往构造函数中，给这几个参数传递 <code>null</code> 值，来表示使用默认值。</p><p>但是，如果可配置项逐渐增多，变成了 <code>8</code> 个、<code>10</code> 个，甚至更多，那继续沿用现在的设计思路，构造函数的参数列表会变得很长，代码在可读性和易用性上都会变差。<br>在使用构造函数的时候，我们就容易搞错各参数的顺序，传递进错误的参数值，导致非常隐蔽的 <code>bug</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数太多，导致可读性差、参数可能传递错误</span></span><br><span class="line">ResourcePoolConfig config = <span class="keyword">new</span> ResourcePoolConfig(<span class="string">&quot;dbconnectionpool&quot;</span>, <span class="number">16</span>, <span class="keyword">null</span>, <span class="number">8</span>, <span class="keyword">null</span>, <span class="keyword">false</span> , <span class="keyword">true</span>, <span class="number">10</span>, <span class="number">20</span>，<span class="keyword">false</span>， <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><p>解决这种问题，我们可以用 <code>set()</code> 函数来给成员变量赋值，以替代冗长的构造函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourcePoolConfig</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MAX_TOTAL = <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MAX_IDLE = <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MIN_IDLE = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> maxTotal = DEFAULT_MAX_TOTAL;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> maxIdle = DEFAULT_MAX_IDLE;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> minIdle = DEFAULT_MIN_IDLE;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ResourcePoolConfig</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(name)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;name should not be empty.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMaxTotal</span><span class="params">(<span class="keyword">int</span> maxTotal)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (maxTotal &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;maxTotal should be positive.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.maxTotal = maxTotal;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMaxIdle</span><span class="params">(<span class="keyword">int</span> maxIdle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (maxIdle &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;maxIdle should not be negative.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.maxIdle = maxIdle;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMinIdle</span><span class="params">(<span class="keyword">int</span> minIdle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minIdle &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;minIdle should not be negative.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.minIdle = minIdle;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...省略getter方法...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>name</code> 是必填项，所有还就在了构造函数里。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ResourcePoolConfig使用举例</span></span><br><span class="line">ResourcePoolConfig config = <span class="keyword">new</span> ResourcePoolConfig(<span class="string">&quot;dbconnectionpool&quot;</span>);</span><br><span class="line">config.setMaxTotal(<span class="number">16</span>);</span><br><span class="line">config.setMaxIdle(<span class="number">8</span>);</span><br></pre></td></tr></table></figure><p>没有了冗长的函数调用和参数列表，代码在可读性和易用性上提高了很多。</p><p>但是还有几个问题：</p><ul><li><code>name</code> 是必填的，所以，我们把它放到构造函数中，强制创建对象的时候就设置。如果必填的配置项有很多，把这些必填配置项都放到构造函数中设置，那构造函数就又会出现参数列表很长的问题。如果我们把必填项也通过 <code>set()</code> 方法设置，那校验这些必填项是否已经填写的逻辑就无处安放了。</li><li>如果属性之间有依赖关系，比如，如果用户设置了 <code>maxTotal</code>、<code>maxIdle</code>、<code>minIdle</code> 其中一个，就必须显式地设置另外两个；或者配置项之间有一定的约束条件，比如，<code>maxIdle</code> 和 <code>minIdle</code> 要小于等于 <code>maxTotal</code>。如果我们继续使用现在的设计思路，那这些配置项之间的依赖关系或者约束条件的校验逻辑就无处安放了。</li><li>如果我们希望 <code>ResourcePoolConfig</code> 类对象是不可变对象，也就是说，对象在创建好之后，就不能再修改内部的属性值。要实现这个功能，我们就不能在 <code>ResourcePoolConfig</code> 类中暴露 <code>set()</code> 方法。</li></ul><p><strong>现在建造者模式就派上用场了。</strong>🗼🗼</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourcePoolConfig</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> maxTotal;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> maxIdle;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> minIdle;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">ResourcePoolConfig</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = builder.name;</span><br><span class="line">    <span class="keyword">this</span>.maxTotal = builder.maxTotal;</span><br><span class="line">    <span class="keyword">this</span>.maxIdle = builder.maxIdle;</span><br><span class="line">    <span class="keyword">this</span>.minIdle = builder.minIdle;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...省略getter方法...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//我们将Builder类设计成了ResourcePoolConfig的内部类。</span></span><br><span class="line">  <span class="comment">//我们也可以将Builder类设计成独立的非内部类ResourcePoolConfigBuilder。</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MAX_TOTAL = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MAX_IDLE = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MIN_IDLE = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxTotal = DEFAULT_MAX_TOTAL;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxIdle = DEFAULT_MAX_IDLE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> minIdle = DEFAULT_MIN_IDLE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResourcePoolConfig <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 校验逻辑放到这里来做，包括必填项校验、依赖关系校验、约束条件校验等</span></span><br><span class="line">      <span class="keyword">if</span> (StringUtils.isBlank(name)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (maxIdle &gt; maxTotal) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (minIdle &gt; maxTotal || minIdle &gt; maxIdle) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ResourcePoolConfig(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (StringUtils.isBlank(name)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">setMaxTotal</span><span class="params">(<span class="keyword">int</span> maxTotal)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (maxTotal &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.maxTotal = maxTotal;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">setMaxIdle</span><span class="params">(<span class="keyword">int</span> maxIdle)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (maxIdle &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.maxIdle = maxIdle;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">setMinIdle</span><span class="params">(<span class="keyword">int</span> minIdle)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (minIdle &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.minIdle = minIdle;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这段代码会抛出IllegalArgumentException，因为minIdle&gt;maxIdle</span></span><br><span class="line">ResourcePoolConfig config = <span class="keyword">new</span> ResourcePoolConfig.Builder()</span><br><span class="line">        .setName(<span class="string">&quot;dbconnectionpool&quot;</span>)</span><br><span class="line">        .setMaxTotal(<span class="number">16</span>)</span><br><span class="line">        .setMaxIdle(<span class="number">10</span>)</span><br><span class="line">        .setMinIdle(<span class="number">12</span>)</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure><p>这样就解决了上面三个问题。使用建造者模式创建对象，还能避免对象存在无效状态。比如我们定义了一个长方形类，如果不使用建造者模式，采用先创建后 <code>set</code> 的方式，那就会导致在第一个 <code>set</code> 之后，对象处于无效状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Rectangle r = <span class="keyword">new</span> Rectange(); <span class="comment">// r is invalid</span></span><br><span class="line">r.setWidth(<span class="number">2</span>); <span class="comment">// r is invalid</span></span><br><span class="line">r.setHeight(<span class="number">3</span>); <span class="comment">// r is valid</span></span><br></pre></td></tr></table></figure><p>为了避免这种无效状态的存在，我们就需要使用构造函数一次性初始化好所有的成员变量。如果构造函数参数过多，我们就需要考虑使用建造者模式，先设置建造者的变量，然后再一次性地创建对象，让对象一直处于有效状态。</p><h1 id="2-与工厂模式有何区别？"><a href="#2-与工厂模式有何区别？" class="headerlink" title="2 与工厂模式有何区别？"></a>2 与工厂模式有何区别？</h1><p>建造者模式是让建造者类来负责对象的创建工作。工厂模式，是由工厂类来负责对象创建的工作。那它们之间有什么区别呢？</p><p>工厂模式是用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。<br>建造者模式是用来创建一种类型的复杂对象，通过设置不同的可选参数，“定制化”地创建不同的对象。</p><p>网上有一个经典的例子很好地解释了两者的区别。顾客走进一家餐馆点餐，我们利用工厂模式，根据用户不同的选择，来制作不同的食物，比如披萨、汉堡、沙拉。对于披萨来说，用户又有各种配料可以定制，比如奶酪、西红柿、起司，我们通过建造者模式根据用户选择的不同配料来制作披萨。</p><h1 id="3-Android-源码中的建造者模式"><a href="#3-Android-源码中的建造者模式" class="headerlink" title="3 Android 源码中的建造者模式"></a>3 Android 源码中的建造者模式</h1><p>在 <code>Android</code> 源码中，最常用到的 <code>Builder</code> 模式就是 <code>AlertDialog.Builder</code>，使用该 <code>Builder</code> 来构建复杂的 <code>AlertDialog</code> 对象。在开发过程中，我们经常用到 <code>AlertDialog</code>，具体示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">builder.setIcon(R.mipmap.ic_launcher)</span><br><span class="line">        .setTitle(<span class="string">&quot;Title&quot;</span>)</span><br><span class="line">        .setMessage(<span class="string">&quot;Message&quot;</span>)</span><br><span class="line">        .setPositiveButton(<span class="string">&quot;Button1&quot;</span>, <span class="keyword">new</span> DialogInterface.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(DialogInterface dialog, <span class="keyword">int</span> which)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).create().show();</span><br></pre></td></tr></table></figure><p>从类名就可以看出这就是一个 <code>Builder</code> 模式，通过 <code>Builder</code> 对象来组装<code>Dialog</code> 的各个部分，如 <code>title</code> 、<code>buttons</code> 、<code>Message</code> 等，将 <code>Dialog</code> 的构造和表示进行分离。</p><p> <code>AlertDialog</code> 的相关源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AlertDialog</span> <span class="keyword">extends</span> <span class="title">Dialog</span> <span class="keyword">implements</span> <span class="title">DialogInterface</span> </span>&#123;</span><br><span class="line"><span class="comment">//在 create 时接收 Builder 成员变量 P 中的各个参数。</span></span><br><span class="line">    <span class="keyword">private</span> AlertController mAlert;</span><br><span class="line">  </span><br><span class="line">    AlertDialog(Context context, <span class="meta">@StyleRes</span> <span class="keyword">int</span> themeResId, <span class="keyword">boolean</span> createContextThemeWrapper) &#123;</span><br><span class="line">        <span class="keyword">super</span>(context, createContextThemeWrapper ? resolveDialogTheme(context, themeResId) : <span class="number">0</span>,createContextThemeWrapper);</span><br><span class="line">        mWindow.alwaysReadCloseOnTouchAttr();</span><br><span class="line">        mAlert = AlertController.create(getContext(), <span class="keyword">this</span>, getWindow());</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTitle</span><span class="params">(CharSequence title)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setTitle(title);</span><br><span class="line">        <span class="comment">//实际操作的是 mAlert 的 setTitle</span></span><br><span class="line">        mAlert.setTitle(title);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessage</span><span class="params">(CharSequence message)</span> </span>&#123;</span><br><span class="line">        mAlert.setMessage(message);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 存储 AlertDialog 的各个参数，如 Title、Message、icon 等。</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AlertController.AlertParams P;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setTitle</span><span class="params">(<span class="meta">@StringRes</span> <span class="keyword">int</span> titleId)</span> </span>&#123;</span><br><span class="line">          <span class="comment">//设置 P 的参数。</span></span><br><span class="line">            P.mTitle = P.mContext.getText(titleId);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setTitle</span><span class="params">(CharSequence title)</span> </span>&#123;</span><br><span class="line">            P.mTitle = title;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="function"><span class="keyword">public</span> AlertDialog <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 调用 new AlertDialog 构造对象，并且将参数传递给个体 AlertDialog</span></span><br><span class="line">            <span class="keyword">final</span> AlertDialog dialog = <span class="keyword">new</span> AlertDialog(P.mContext, <span class="number">0</span>, <span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">//将 p 中的参数应用到 dialog 中的 mAlert 对象中</span></span><br><span class="line">            P.apply(dialog.mAlert);</span><br><span class="line">            dialog.setCancelable(P.mCancelable);</span><br><span class="line">            <span class="keyword">if</span> (P.mCancelable) &#123;</span><br><span class="line">                dialog.setCanceledOnTouchOutside(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            dialog.setOnCancelListener(P.mOnCancelListener);</span><br><span class="line">            dialog.setOnDismissListener(P.mOnDismissListener);</span><br><span class="line">            <span class="keyword">if</span> (P.mOnKeyListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                dialog.setOnKeyListener(P.mOnKeyListener);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> dialog;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，<code>Builder</code> 类可以设置 <code>AlertDialog</code> 中的 <code>title</code> 、<code>message</code> 、<code>button</code> 等参数，这些参数都存储在类型为 <code>AlertController.AlertParams</code> 的成员变量 <code>P</code> 中，<code>AlertController.AlertParams</code> 中包含了与 <code>AlertDialog</code> 视图中对应的成员变量。在调用 <code>Builder</code> 类的 <code>create</code> 函数时会创建<code>AlertDialog</code> ，并且将 <code>Builder</code> 成员变量P中保存的参数应用到 <code>AlertDialog</code> 的 <code>mAlert</code> 对象中，即 <code>P.apply（dialog.mAlert）</code> 代码段。</p><p><code>apply</code> 函数的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(AlertController dialog)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mCustomTitleView != <span class="keyword">null</span>) &#123;</span><br><span class="line">        dialog.setCustomTitle(mCustomTitleView);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mTitle != <span class="keyword">null</span>) &#123;</span><br><span class="line">            dialog.setTitle(mTitle);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mIcon != <span class="keyword">null</span>) &#123;</span><br><span class="line">            dialog.setIcon(mIcon);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mIconId != <span class="number">0</span>) &#123;</span><br><span class="line">            dialog.setIcon(mIconId);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mIconAttrId != <span class="number">0</span>) &#123;</span><br><span class="line">            dialog.setIcon(dialog.getIconAttributeResId(mIconAttrId));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mMessage != <span class="keyword">null</span>) &#123;</span><br><span class="line">        dialog.setMessage(mMessage);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mPositiveButtonText != <span class="keyword">null</span> || mPositiveButtonIcon != <span class="keyword">null</span>) &#123;</span><br><span class="line">        dialog.setButton(DialogInterface.BUTTON_POSITIVE, mPositiveButtonText,</span><br><span class="line">                mPositiveButtonListener, <span class="keyword">null</span>, mPositiveButtonIcon);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mNegativeButtonText != <span class="keyword">null</span> || mNegativeButtonIcon != <span class="keyword">null</span>) &#123;</span><br><span class="line">        dialog.setButton(DialogInterface.BUTTON_NEGATIVE, mNegativeButtonText,</span><br><span class="line">                mNegativeButtonListener, <span class="keyword">null</span>, mNegativeButtonIcon);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mNeutralButtonText != <span class="keyword">null</span> || mNeutralButtonIcon != <span class="keyword">null</span>) &#123;</span><br><span class="line">        dialog.setButton(DialogInterface.BUTTON_NEUTRAL, mNeutralButtonText,</span><br><span class="line">                mNeutralButtonListener, <span class="keyword">null</span>, mNeutralButtonIcon);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// For a list, the client can either supply an array of items or an</span></span><br><span class="line">    <span class="comment">// adapter or a cursor</span></span><br><span class="line">    <span class="keyword">if</span> ((mItems != <span class="keyword">null</span>) || (mCursor != <span class="keyword">null</span>) || (mAdapter != <span class="keyword">null</span>)) &#123;</span><br><span class="line">        createListView(dialog);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mView != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mViewSpacingSpecified) &#123;</span><br><span class="line">            dialog.setView(mView, mViewSpacingLeft, mViewSpacingTop, mViewSpacingRight,</span><br><span class="line">                    mViewSpacingBottom);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dialog.setView(mView);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mViewLayoutResId != <span class="number">0</span>) &#123;</span><br><span class="line">        dialog.setView(mViewLayoutResId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>apply</code> 函数中，只是将 <code>AlertParams</code> 参数设置到 <code>AlertController</code> 中，例如，将标题设置到 <code>Dialog</code> 对应的标题视图中，将 <code>Message</code> 设置到内容视图中等。当我们获取到 <code>AlertDialog</code> 对象后，通过 <code>show</code> 函数就可以显示这个对话框。 <code>Dialog</code> 的 <code>show</code> 函数（该函数在 <code>Dialog</code> 类中）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mShowing) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mDecor != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mWindow.hasFeature(Window.FEATURE_ACTION_BAR)) &#123;</span><br><span class="line">                mWindow.invalidatePanelMenu(Window.FEATURE_ACTION_BAR);</span><br><span class="line">            &#125;</span><br><span class="line">            mDecor.setVisibility(View.VISIBLE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mCanceled = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mCreated) &#123;</span><br><span class="line">        dispatchOnCreate(<span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Fill the DecorView in on any configuration changes that</span></span><br><span class="line">        <span class="comment">// may have occured while it was removed from the WindowManager.</span></span><br><span class="line">        <span class="keyword">final</span> Configuration config = mContext.getResources().getConfiguration();</span><br><span class="line">        mWindow.getDecorView().dispatchConfigurationChanged(config);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    onStart();</span><br><span class="line">    mDecor = mWindow.getDecorView();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mActionBar == <span class="keyword">null</span> &amp;&amp; mWindow.hasFeature(Window.FEATURE_ACTION_BAR)) &#123;</span><br><span class="line">        <span class="keyword">final</span> ApplicationInfo info = mContext.getApplicationInfo();</span><br><span class="line">        mWindow.setDefaultIcon(info.icon);</span><br><span class="line">        mWindow.setDefaultLogo(info.logo);</span><br><span class="line">        mActionBar = <span class="keyword">new</span> WindowDecorActionBar(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    WindowManager.LayoutParams l = mWindow.getAttributes();</span><br><span class="line">    <span class="keyword">boolean</span> restoreSoftInputMode = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> ((l.softInputMode</span><br><span class="line">            &amp; WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION) == <span class="number">0</span>) &#123;</span><br><span class="line">        l.softInputMode |=</span><br><span class="line">                WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;</span><br><span class="line">        restoreSoftInputMode = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mWindowManager.addView(mDecor, l);</span><br><span class="line">    <span class="keyword">if</span> (restoreSoftInputMode) &#123;</span><br><span class="line">        l.softInputMode &amp;=</span><br><span class="line">                ~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mShowing = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    sendShowMessage();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在 <code>show</code> 函数中主要做了如下几个事情：</p><ul><li>通过 <code>dispatchOnCreate</code> 函数来调用 <code>AlertDialog</code> 的 <code>onCreate</code> 函数；</li><li>然后调用 <code>AlertDialog</code> 的 <code>onStart</code> 函数；</li><li>最后将 <code>Dialog</code> 的 <code>DecorView</code> 添加到 <code>WindowManager</code> 中。</li></ul><p>很明显，这就是一系列典型的生命周期函数。那么按照惯例，<code>AlertDialog</code> 的内容视图构建按理应该在 <code>onCreate</code> 函数中；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        mAlert.installContent();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">AlertController.java</span><br><span class="line">  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">installContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> contentView = selectContentView();</span><br><span class="line">        mDialog.setContentView(contentView);</span><br><span class="line">        setupView();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">AppCompatDialog.java</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="meta">@LayoutRes</span> <span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">        getDelegate().setContentView(layoutResID);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里就和 <code>Activity</code> 中的 <code>setContentView</code> 逻辑一样了。</p><p><code>setContentView</code> 后续 <a href="https://juejin.im/post/5b1202de6fb9a01e5f3e1467#heading-0">Android setContentView源码解析</a> </p><h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a><strong>感谢</strong></h1><blockquote><p><a href="https://time.geekbang.org/column/intro/250?utm_source=pinpaizhuanqu&utm_medium=geektime&utm_campaign=guanwang&utm_term=guanwang&utm_content=0511">设计模式之美</a></p><p>《Android 源码设计模式解析与实战》</p><p>以及上文中的链接</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-创建型-工厂模式</title>
      <link href="2020/design-pattern-factory.html"/>
      <url>2020/design-pattern-factory.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-简单工厂模式"><a href="#1-简单工厂模式" class="headerlink" title="1 简单工厂模式"></a>1 简单工厂模式</h1><p>举个栗子🌰 我们根据配置文件的后缀（<code>json</code>、<code>xml</code>、<code>yaml</code>、<code>properties</code>），选择不同的解析器（<code>JsonRuleConfigParser</code>、<code>XmlRuleConfigParser</code>……），将存储在文件中的配置解析成内存对象 <code>RuleConfig</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuleConfigSource</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> RuleConfig <span class="title">load</span><span class="params">(String ruleConfigFilePath)</span> </span>&#123;</span><br><span class="line">    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);</span><br><span class="line">    IRuleConfigParser parser = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;json&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class="line">      parser = <span class="keyword">new</span> JsonRuleConfigParser();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;xml&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class="line">      parser = <span class="keyword">new</span> XmlRuleConfigParser();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;yaml&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class="line">      parser = <span class="keyword">new</span> YamlRuleConfigParser();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;properties&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class="line">      parser = <span class="keyword">new</span> PropertiesRuleConfigParser();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> InvalidRuleConfigException(</span><br><span class="line">             <span class="string">&quot;Rule config file format is not supported: &quot;</span> + ruleConfigFilePath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String configText = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">//从ruleConfigFilePath文件中读取配置文本到configText中</span></span><br><span class="line">    RuleConfig ruleConfig = parser.parse(configText);</span><br><span class="line">    <span class="keyword">return</span> ruleConfig;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> String <span class="title">getFileExtension</span><span class="params">(String filePath)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...解析文件名获取扩展名，比如rule.json，返回json</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;json&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这块代码都耦合进了 <code>load()</code> 函数中，为了让类的职责更加单一、代码更加清晰，我们可以将功能独立到一个类中，让这个类只负责对象的创建。而这个类就是我们现在要讲的简单工厂模式类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuleConfigSource</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> RuleConfig <span class="title">load</span><span class="params">(String ruleConfigFilePath)</span> </span>&#123;</span><br><span class="line">    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);</span><br><span class="line">    IRuleConfigParser parser = RuleConfigParserFactory.createParser(ruleConfigFileExtension);</span><br><span class="line">    <span class="keyword">if</span> (parser == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> InvalidRuleConfigException(</span><br><span class="line">              <span class="string">&quot;Rule config file format is not supported: &quot;</span> + ruleConfigFilePath);</span><br><span class="line">    &#125;</span><br><span class="line">    String configText = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">//从ruleConfigFilePath文件中读取配置文本到configText中</span></span><br><span class="line">    RuleConfig ruleConfig = parser.parse(configText);</span><br><span class="line">    <span class="keyword">return</span> ruleConfig;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> String <span class="title">getFileExtension</span><span class="params">(String filePath)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...解析文件名获取扩展名，比如rule.json，返回json</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;json&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuleConfigParserFactory</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IRuleConfigParser <span class="title">createParser</span><span class="params">(String configFormat)</span> </span>&#123;</span><br><span class="line">    IRuleConfigParser parser = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;json&quot;</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class="line">      parser = <span class="keyword">new</span> JsonRuleConfigParser();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;xml&quot;</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class="line">      parser = <span class="keyword">new</span> XmlRuleConfigParser();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;yaml&quot;</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class="line">      parser = <span class="keyword">new</span> YamlRuleConfigParser();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;properties&quot;</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class="line">      parser = <span class="keyword">new</span> PropertiesRuleConfigParser();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parser;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大部分工厂类都是以 <code>“Factory”</code> 这个单词结尾的，但也不是必须的，比如 <code>Java</code> 中的 <code>DateFormat</code>、<code>Calender</code>。<br>除此之外，工厂类中创建对象的方法一般都是 <code>create</code> 开头，比如代码中的 <code>createParser()</code>，但有的也命名为 <code>getInstance()</code>、<code>createInstance()</code>、<code>newInstance()</code>，有的甚至命名为 <code>valueOf()</code>（比如 <code>Java String</code> 类的 <code>valueOf()</code> 函数）等等。</p><p>我们还可以将单例结合进来，像之前单例中讲的那样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuleConfigParserFactory</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, RuleConfigParser&gt; cachedParsers = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    cachedParsers.put(<span class="string">&quot;json&quot;</span>, <span class="keyword">new</span> JsonRuleConfigParser());</span><br><span class="line">    cachedParsers.put(<span class="string">&quot;xml&quot;</span>, <span class="keyword">new</span> XmlRuleConfigParser());</span><br><span class="line">    cachedParsers.put(<span class="string">&quot;yaml&quot;</span>, <span class="keyword">new</span> YamlRuleConfigParser());</span><br><span class="line">    cachedParsers.put(<span class="string">&quot;properties&quot;</span>, <span class="keyword">new</span> PropertiesRuleConfigParser());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IRuleConfigParser <span class="title">createParser</span><span class="params">(String configFormat)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (configFormat == <span class="keyword">null</span> || configFormat.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">//返回null还是IllegalArgumentException全凭你自己说了算</span></span><br><span class="line">    &#125;</span><br><span class="line">    IRuleConfigParser parser = cachedParsers.get(configFormat.toLowerCase());</span><br><span class="line">    <span class="keyword">return</span> parser;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-工厂方法"><a href="#2-工厂方法" class="headerlink" title="2 工厂方法"></a>2 工厂方法</h1><p>现在在初始化 <code>RuleConfigParserFactory</code>  的时候已经将所有的 <code>Parser</code> 对象都实例化了。我们可以利用多态，延迟初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IRuleConfigParserFactory</span> </span>&#123;</span><br><span class="line">  <span class="function">IRuleConfigParser <span class="title">createParser</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonRuleConfigParserFactory</span> <span class="keyword">implements</span> <span class="title">IRuleConfigParserFactory</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> IRuleConfigParser <span class="title">createParser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> JsonRuleConfigParser();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XmlRuleConfigParserFactory</span> <span class="keyword">implements</span> <span class="title">IRuleConfigParserFactory</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> IRuleConfigParser <span class="title">createParser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> XmlRuleConfigParser();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略YamlConfigParserFactory和PropertiesConfigParserFactory代码</span></span><br></pre></td></tr></table></figure><p>这样当我们新增一种 <code>parser</code> 的时候，只需要新增一个实现了 <code>IRuleConfigParserFactory</code> 接口的 <code>Factory</code> 类即可。<br>所以，工厂方法模式比起简单工厂模式更加符合开闭原则。</p><p>可以仿照 <code>LayoutInflater</code> 中 <code>createService</code> 逻辑实现复用。先调用 <code>getService</code> 去获取有没有缓存，没有再 <code>create</code>。</p><p>我们可以为工厂类再创建一个简单工厂，也就是工厂的工厂，用来创建工厂类对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuleConfigSource</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> RuleConfig <span class="title">load</span><span class="params">(String ruleConfigFilePath)</span> </span>&#123;</span><br><span class="line">    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);</span><br><span class="line"></span><br><span class="line">    IRuleConfigParserFactory parserFactory = RuleConfigParserFactoryMap.getParserFactory(ruleConfigFileExtension);</span><br><span class="line">    <span class="keyword">if</span> (parserFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> InvalidRuleConfigException(<span class="string">&quot;Rule config file format is not supported: &quot;</span> + ruleConfigFilePath);</span><br><span class="line">    &#125;</span><br><span class="line">    IRuleConfigParser parser = parserFactory.createParser();</span><br><span class="line"></span><br><span class="line">    String configText = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">//从ruleConfigFilePath文件中读取配置文本到configText中</span></span><br><span class="line">    RuleConfig ruleConfig = parser.parse(configText);</span><br><span class="line">    <span class="keyword">return</span> ruleConfig;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> String <span class="title">getFileExtension</span><span class="params">(String filePath)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...解析文件名获取扩展名，比如rule.json，返回json</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;json&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//因为工厂类只包含方法，不包含成员变量，完全可以复用，</span></span><br><span class="line"><span class="comment">//不需要每次都创建新的工厂类对象，所以，简单工厂模式的第二种实现思路更加合适。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuleConfigParserFactoryMap</span> </span>&#123; <span class="comment">//工厂的工厂</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, IRuleConfigParserFactory&gt; cachedFactories = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    cachedFactories.put(<span class="string">&quot;json&quot;</span>, <span class="keyword">new</span> JsonRuleConfigParserFactory());</span><br><span class="line">    cachedFactories.put(<span class="string">&quot;xml&quot;</span>, <span class="keyword">new</span> XmlRuleConfigParserFactory());</span><br><span class="line">    cachedFactories.put(<span class="string">&quot;yaml&quot;</span>, <span class="keyword">new</span> YamlRuleConfigParserFactory());</span><br><span class="line">    cachedFactories.put(<span class="string">&quot;properties&quot;</span>, <span class="keyword">new</span> PropertiesRuleConfigParserFactory());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IRuleConfigParserFactory <span class="title">getParserFactory</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (type == <span class="keyword">null</span> || type.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    IRuleConfigParserFactory parserFactory = cachedFactories.get(type.toLowerCase());</span><br><span class="line">    <span class="keyword">return</span> parserFactory;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们需要添加新的规则配置解析器的时候，我们只需要创建新的 <code>parser</code> 类和 <code>parser factory</code> 类，并且在 <code>RuleConfigParserFactoryMap</code> 类中，将新的 <code>parser factory</code> 对象添加到 <code>cachedFactories</code> 中即可。代码的改动非常少，基本上符合开闭原则。</p><p>我们还可以用反射来创建具体工厂，这样就不需要那么多工厂类，传入相应的 <code>JsonRuleConfigParser</code> 或 <code>XmlRuleConfigParser</code> 就可以。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuleConfigParserFactory</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> &lt;T extends IRuleConfigParser&gt; <span class="function">T <span class="title">createParser</span><span class="params">(Class&lt;T&gt; clz)</span></span>&#123;</span><br><span class="line">    IRuleConfigParser parser = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      parser = (IRuleConfigParser) Class.forName(clz.getName()).newInstance();</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-1-工厂方法-Android-实战"><a href="#2-1-工厂方法-Android-实战" class="headerlink" title="2.1 工厂方法 Android 实战"></a>2.1 工厂方法 Android 实战</h2><p>工厂方法模式比较简单，可以在很多编程实战的地方应用到它，以一个数据存储为例，大家知道 <code>Android</code> 数据持久化有很多种方式，可以使用 <code>Android</code> 为我们提供的 <code>SharedPreferences</code> 和 <code>SQLite</code> ，也可以使用常规的文件存储，但是，对数据操作的方法无非就是增、删、改、查，我们可以将每一种数据操作的方式作为一个产品类，在抽象产品类中定义操作的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">IOHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加一条个人信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id 身份证号码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 名字</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String id, String name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除一条个人信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(String id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新一条个人信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String id, String name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询身份证对应的人名字</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">query</span><span class="params">(String id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每一种持久化方式我们定义一个具体的 <code>IO</code> 处理类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileHandler</span> <span class="keyword">extends</span> <span class="title">IOHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String id, String name)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(String id)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String id, String name)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">query</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;file&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XMLHandler</span> <span class="keyword">extends</span> <span class="title">IOHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String id, String name)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(String id)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String id, String name)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">query</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;xml&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里只是 <code>query</code> 做了区分。接下里是工厂类的定义，这里使用反射。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IOFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends IOHandler&gt; <span class="function">T <span class="title">getIOHandler</span><span class="params">(Class&lt;T&gt; clz)</span> </span>&#123;</span><br><span class="line">        IOHandler handler = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            handler = (IOHandler) Class.forName(clz.getName()).newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (T) handler;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后的使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IOHandler handler = IOFactory.getIOHandler(FileHandler.class);</span><br><span class="line">handler.query(<span class="string">&quot;handler&quot;</span>);</span><br><span class="line">IOHandler handler2 = IOFactory.getIOHandler(XMLHandler.class);</span><br><span class="line">handler2.query(<span class="string">&quot;handler&quot;</span>);</span><br></pre></td></tr></table></figure><p>最后会输出不同的值。</p><h1 id="3-抽象工厂"><a href="#3-抽象工厂" class="headerlink" title="3 抽象工厂"></a>3 抽象工厂</h1><p>抽象工厂模式的应用场景比较特殊，没有前两种常用。</p><p>在简单工厂和工厂方法中，类只有一种分类方式。<br>比如，在规则配置解析那个例子中，解析器类只会根据配置文件格式<code>（Json、Xml、Yaml……）</code>来分类。<br>但是，如果类有两种分类方式，比如，我们既可以按照配置文件格式来分类，也可以按照解析的对象（<code>Rule</code> 规则配置还是 <code>System</code> 系统配置）来分类，那就会对应下面这 <code>8</code> 个 <code>parser</code> 类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">针对规则配置的解析器：基于接口IRuleConfigParser</span><br><span class="line">JsonRuleConfigParser</span><br><span class="line">XmlRuleConfigParser</span><br><span class="line">YamlRuleConfigParser</span><br><span class="line">PropertiesRuleConfigParser</span><br><span class="line"></span><br><span class="line">针对系统配置的解析器：基于接口ISystemConfigParser</span><br><span class="line">JsonSystemConfigParser</span><br><span class="line">XmlSystemConfigParser</span><br><span class="line">YamlSystemConfigParser</span><br><span class="line">PropertiesSystemConfigParser</span><br></pre></td></tr></table></figure><p>如果还是继续用工厂方法来实现的话，我们要针对每个 <code>parser</code> 都编写一个工厂类，也就是要编写 <code>8</code> 个工厂类。</p><p>抽象工厂就是针对这种非常特殊的场景而诞生的。我们可以让一个工厂负责创建多个不同类型的对象（<code>IRuleConfigParser</code>、<code>ISystemConfigParser</code> 等），而不是只创建一种 <code>parser</code> 对象。这样就可以有效地减少工厂类的个数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IConfigParserFactory</span> </span>&#123;</span><br><span class="line">  <span class="function">IRuleConfigParser <span class="title">createRuleParser</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">ISystemConfigParser <span class="title">createSystemParser</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">//此处可以扩展新的parser类型，比如IBizConfigParser</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonConfigParserFactory</span> <span class="keyword">implements</span> <span class="title">IConfigParserFactory</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> IRuleConfigParser <span class="title">createRuleParser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> JsonRuleConfigParser();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ISystemConfigParser <span class="title">createSystemParser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> JsonSystemConfigParser();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XmlConfigParserFactory</span> <span class="keyword">implements</span> <span class="title">IConfigParserFactory</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> IRuleConfigParser <span class="title">createRuleParser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> XmlRuleConfigParser();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ISystemConfigParser <span class="title">createSystemParser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> XmlSystemConfigParser();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略YamlConfigParserFactory和PropertiesConfigParserFactory代码</span></span><br></pre></td></tr></table></figure><h2 id="3-1-抽象工厂-Android-实战"><a href="#3-1-抽象工厂-Android-实战" class="headerlink" title="3.1 抽象工厂 Android 实战"></a>3.1 抽象工厂 Android 实战</h2><p>这里模拟一个车场，分别生产 <code>Q3  Q7</code>是一个车系，但是零部件都不一样。</p><p>首先是轮胎部件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ITire</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 轮胎</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tire</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NormalTire</span> <span class="keyword">implements</span> <span class="title">ITire</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LogUtils.i(<span class="string">&quot;普通轮胎&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SUVTire</span> <span class="keyword">implements</span> <span class="title">ITire</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LogUtils.i(<span class="string">&quot;越野轮胎&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是发动机部件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IEngine</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发动机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">engine</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DomesticEngine</span> <span class="keyword">implements</span> <span class="title">IEngine</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">engine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LogUtils.i(<span class="string">&quot;国产发动机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImportEngine</span> <span class="keyword">implements</span> <span class="title">IEngine</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">engine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LogUtils.i(<span class="string">&quot;进口发动机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是制动系统。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IBrake</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 制动系统</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">brake</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NormalBrake</span> <span class="keyword">implements</span> <span class="title">IBrake</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">brake</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LogUtils.i(<span class="string">&quot;普通制动&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeniorBrake</span> <span class="keyword">implements</span> <span class="title">IBrake</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">brake</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LogUtils.i(<span class="string">&quot;高级制动&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后是汽车制造工厂类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CarFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产轮胎</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ITire <span class="title">createTire</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产发动机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> IEngine <span class="title">createEngine</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产制动系统</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> IBrake <span class="title">createBrake</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不同的车间生成不同的车，生产方式一样，但是部件不同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Q3Factory</span> <span class="keyword">extends</span> <span class="title">CarFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ITire <span class="title">createTire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NormalTire();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEngine <span class="title">createEngine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DomesticEngine();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBrake <span class="title">createBrake</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NormalBrake();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Q7Factory</span> <span class="keyword">extends</span> <span class="title">CarFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ITire <span class="title">createTire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SUVTire();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEngine <span class="title">createEngine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ImportEngine();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBrake <span class="title">createBrake</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SeniorBrake();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CarFactory factoryQ3=<span class="keyword">new</span> Q3Factory();</span><br><span class="line">factoryQ3.createTire().tire();</span><br><span class="line">factoryQ3.createEngine().engine();</span><br><span class="line">factoryQ3.createBrake().brake();</span><br></pre></td></tr></table></figure><h1 id="6-Android-源码的工厂模式"><a href="#6-Android-源码的工厂模式" class="headerlink" title="6 Android 源码的工厂模式"></a>6 Android 源码的工厂模式</h1><p>其实平时工作中也偷偷使用着工厂方法模式。以 <code>List</code> 和 <code>Set</code> 为例，<code>List</code> 和 <code>Set</code> 都继承于 <code>Collection</code> 接口，而 <code>Collection</code> 接口继承于 <code>Iterable</code> 接口，<code>Iterable</code> 接口很简单，就一个 <code>iterator</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="function">Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这意味着 <code>List</code> 和 <code>Set</code> 接口也会继承该方法，平时比较常用的两个间接实现类 <code>ArrayList</code> 和 <code>HashSet</code> 中 <code>iterator</code> 方法的实现就是构造并返回一个迭代器对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">int</span> limit = ArrayList.<span class="keyword">this</span>.size;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> cursor;       <span class="comment">// index of next element to return</span></span><br><span class="line">        <span class="keyword">int</span> lastRet = -<span class="number">1</span>; <span class="comment">// index of last element returned; -1 if no such</span></span><br><span class="line">        <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> cursor &lt; limit;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; consumer)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>HashSet</code> 的 <code>iterator</code> 方法中会返回成员变量 <code>map</code> 中对应 <code>HashSet</code> 对象元素的迭代器对象，最终返回的是 <code>KeySet</code> 中的一个迭代器对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.keySet().iterator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;K&gt; <span class="title">iterator</span><span class="params">()</span>     </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> KeyIterator(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ArrayList</code> 和 <code>HashSet HashMap</code>  中的 <code>iterator</code> 方法其实相当于一个工厂方法，专为 <code>new</code> 对象而生，这里 <code>iterator</code> 方法是构造并返回一个具体的迭代器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle bundle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(bundle);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再仔细看 <code>onCreate</code> 方法，感觉也像一个工厂方法模式，因为我们每个 <code>Activity</code> 都会重新 <code>onCreate</code> 设置不同的布局，这不就是一个工厂模式的结构吗？</p><p>关于 <code>onCreate</code> <a href="http://gityuan.com/2016/03/12/start-activity/">startActivity启动过程分析</a></p><h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a><strong>感谢</strong></h1><blockquote><p><a href="https://time.geekbang.org/column/intro/250?utm_source=pinpaizhuanqu&utm_medium=geektime&utm_campaign=guanwang&utm_term=guanwang&utm_content=0511">设计模式之美</a></p><p>《Android 源码设计模式解析与实战》</p><p>以及上文中的链接</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-创建型-单例模式</title>
      <link href="2020/design-pattern-singleton.html"/>
      <url>2020/design-pattern-singleton.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-为什么要使用单例？"><a href="#1-为什么要使用单例？" class="headerlink" title="1 为什么要使用单例？"></a>1 为什么要使用单例？</h1><p>为什么我们需要单例这种设计模式？它能解决哪些问题？</p><ul><li>处理资源访问冲突</li></ul><p>比如文件访问、数据库访问。</p><p>在多线程环境下，如果两个线程同时给同一个共享变量加 <code>1</code>，因为共享变量是竞争资源，所以，共享变量最后的结果有可能并不是加了 <code>2</code>，而是只加了 <code>1</code>。</p><p>我们可以用<strong>类级别锁</strong>来解决这个问题，因为在不同线程创建不同的对象，所以<strong>对象锁</strong>是没有用的。</p><p>我们还可以使用并发队列 <code>BlockingQueue</code> ，但是实现起来比较麻烦。</p><p>最后比较简单的解决思路就是使用<strong>单例模式</strong>了，<strong>单例模式</strong>相对于之前<strong>类级别锁</strong>的好处是，不用创建那么多对象，一方面节省内存空间，另一方面节省系统文件句柄（对于操作系统来说，文件句柄也是一种资源，不能随便浪费）。</p><p>举个栗子🌰 文件日志，在多线程情况下肯定也会出现上面的问题，线程同时执行，会覆盖前一次的写入。但是单例就没问题了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> FileWriter writer;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger instance = <span class="keyword">new</span> Logger();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Logger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">&quot;/Users/wangzheng/log.txt&quot;</span>);</span><br><span class="line">    writer = <span class="keyword">new</span> FileWriter(file, <span class="keyword">true</span>); <span class="comment">//true表示追加写入</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Logger <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">    writer.write(mesasge);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Logger类的应用示例：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">(String username, String password)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...省略业务逻辑代码...</span></span><br><span class="line">    Logger.getInstance().log(username + <span class="string">&quot; logined!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderController</span> </span>&#123;  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">(OrderVo order)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...省略业务逻辑代码...</span></span><br><span class="line">    Logger.getInstance().log(<span class="string">&quot;Created a order: &quot;</span> + order.toString());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>表示全局唯一类</li></ul><p>从业务概念上，如果有些数据在系统中只应保存一份，那就比较适合设计为单例类。</p><p>举个栗子🌰，唯一递增 <code>ID</code> 号码生成器，如果程序中有两个对象，那就会存在生成重复 ID 的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicLong;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdGenerator</span> </span>&#123;</span><br><span class="line">  <span class="comment">// AtomicLong是一个Java并发库中提供的一个原子变量类型,</span></span><br><span class="line">  <span class="comment">// 它将一些线程不安全需要加锁的复合操作封装为了线程安全的原子操作，</span></span><br><span class="line">  <span class="comment">// 比如下面会用到的incrementAndGet().</span></span><br><span class="line">  <span class="keyword">private</span> AtomicLong id = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> IdGenerator instance = <span class="keyword">new</span> IdGenerator();</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">IdGenerator</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IdGenerator <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> id.incrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IdGenerator使用举例</span></span><br><span class="line"><span class="keyword">long</span> id = IdGenerator.getInstance().getId();</span><br></pre></td></tr></table></figure><h1 id="2-如何实现一个单例？"><a href="#2-如何实现一个单例？" class="headerlink" title="2 如何实现一个单例？"></a>2 如何实现一个单例？</h1><h2 id="2-1-饿汉式"><a href="#2-1-饿汉式" class="headerlink" title="2.1 饿汉式"></a>2.1 饿汉式</h2><p>在类加载的时候，<code>instance</code> 静态实例就已经创建并初始化好了，所以，<code>instance</code> 实例的创建过程是线程安全的。不过，这样的实现方式不支持延迟加载（不是在真正用到 <code>IdGenerator</code> 的时候创建实例），从名字中我们也可以看出这一点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdGenerator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> AtomicLong id = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> IdGenerator instance = <span class="keyword">new</span> IdGenerator();</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">IdGenerator</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IdGenerator <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> id.incrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为不支持延迟加载，导致实例占用资源多（比如占用内存多）或初始化耗时长（比如需要加载各种配置文件），提前初始化实例是一种浪费资源的行为。最好的方法应该在用到的时候再去初始化。有些需要提前初始化的时候可以这样用，在真正使用的时候节省了时间。</p><h2 id="2-2-懒汉式"><a href="#2-2-懒汉式" class="headerlink" title="2.2 懒汉式"></a>2.2 懒汉式</h2><p>有饿汉式，对应的，就有懒汉式。懒汉式相对于饿汉式的优势是支持延迟加载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdGenerator</span> </span>&#123; </span><br><span class="line">  <span class="keyword">private</span> AtomicLong id = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> IdGenerator instance;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">IdGenerator</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> IdGenerator <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">      instance = <span class="keyword">new</span> IdGenerator();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> id.incrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过懒汉式的缺点也很明显，我们给 <code>getInstance()</code> 这个方法加了一把大锁（<code>synchronzed</code>），导致这个函数的并发度很低。<br>如果这个单例类偶尔会被用到，那这种实现方式还可以接受。<br>但是，如果频繁地用到，那频繁加锁、释放锁及并发度低等问题，会导致性能瓶颈，这种实现方式就不可取了。</p><h2 id="2-3-双重检测"><a href="#2-3-双重检测" class="headerlink" title="2.3 双重检测"></a>2.3 双重检测</h2><p>饿汉式不支持延迟加载，懒汉式有性能问题，不支持高并发。那我们再来看一种既支持延迟加载、又支持高并发的单例实现方式，也就是双重检测实现方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdGenerator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> AtomicLong id = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> IdGenerator instance;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">IdGenerator</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IdGenerator <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span>(IdGenerator.class) &#123; <span class="comment">// 此处为类级别的锁</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">          instance = <span class="keyword">new</span> IdGenerator();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> id.incrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种实现方式中，只要 <code>instance</code> 被创建之后，即便再调用 <code>getInstance()</code> 函数也不会再进入到加锁逻辑中了。</p><p>这里有一个问题，在低版本 <code>Java</code> 中，因为指令重排序，可能会导致 <code>IdGenerator</code> 对象被 <code>new</code> 出来，并且赋值给 <code>instance</code> 之后，还没来得及初始化（执行构造函数中的代码逻辑），就被另一个线程使用了。<br>要解决这个问题，我们需要给 <code>instance</code> 成员变量加上 <code>volatile</code> 关键字，禁止指令重排序才行。</p><h2 id="2-4-静态内部类"><a href="#2-4-静态内部类" class="headerlink" title="2.4 静态内部类"></a>2.4 静态内部类</h2><p>静态内部类比双重检测更加简单，利用 <code>Java</code> 静态内部类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdGenerator</span> </span>&#123; </span><br><span class="line">  <span class="keyword">private</span> AtomicLong id = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">IdGenerator</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> IdGenerator instance = <span class="keyword">new</span> IdGenerator();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IdGenerator <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SingletonHolder.instance;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> id.incrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有当调用 <code>getInstance()</code> 方法时，<code>SingletonHolder</code> 才会被加载，这个时候才会创建 <code>instance</code>。<code>instance</code> 的唯一性、创建过程的线程安全性，都由 <code>JVM</code> 来保证。所以，这种实现方法既保证了线程安全，又能做到延迟加载。</p><h2 id="2-5-枚举"><a href="#2-5-枚举" class="headerlink" title="2.5 枚举"></a>2.5 枚举</h2><p>还有一种最简单的实现方式，基于枚举类型的单例实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">IdGenerator</span> </span>&#123;</span><br><span class="line">  INSTANCE;</span><br><span class="line">  <span class="keyword">private</span> AtomicLong id = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> id.incrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种实现方式通过 <code>Java</code> 枚举类型本身的特性，保证了实例创建的线程安全性和实例的唯一性。</p><h1 id="3-如何实现线程唯一的单例？"><a href="#3-如何实现线程唯一的单例？" class="headerlink" title="3 如何实现线程唯一的单例？"></a>3 如何实现线程唯一的单例？</h1><p>定义中提到， “一个类只允许创建唯一一个对象” 。那对象的唯一性的作用范围是什么呢？是指线程内只允许创建一个对象，还是指进程内只允许创建一个对象？答案是后者，也就是说，单例模式创建的对象是进程唯一的。</p><p>那如何实现一个线程唯一的单例呢？</p><p>在代码中，我们通过一个 <code>HashMap</code> 来存储对象，其中 <code>key</code> 是线程 <code>ID</code>，<code>value</code> 是对象。这样我们就可以做到，不同的线程对应不同的对象，同一个线程只能对应一个对象。实际上，<code>Java</code> 语言本身提供了 <code>ThreadLocal</code> 工具类，可以更加轻松地实现线程唯一单例。不过，<code>ThreadLocal</code> 底层实现原理也是基于下面代码中所示的 <code>HashMap</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdGenerator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> AtomicLong id = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentHashMap&lt;Long, IdGenerator&gt; instances</span><br><span class="line">          = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">IdGenerator</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IdGenerator <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Long currentThreadId = Thread.currentThread().getId();</span><br><span class="line">    instances.putIfAbsent(currentThreadId, <span class="keyword">new</span> IdGenerator());</span><br><span class="line">    <span class="keyword">return</span> instances.get(currentThreadId);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> id.incrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-单例存在哪些问题"><a href="#4-单例存在哪些问题" class="headerlink" title="4 单例存在哪些问题?"></a>4 单例存在哪些问题?</h1><p>大部分情况下，我们在项目中使用单例，都是用它来表示一些全局唯一类，比如配置信息类、公共类等。<br>单例模式书写简洁、使用方便，在代码中，我们不需要创建对象，直接通过类似 <code>IdGenerator.getInstance().getId()</code> 这样的方法来调用就可以了。<br>但是，这种使用方法有点类似硬编码（<code>hard code</code>），会带来诸多问题。</p><h2 id="4-1-单例对代码的扩展性不友好"><a href="#4-1-单例对代码的扩展性不友好" class="headerlink" title="4.1 单例对代码的扩展性不友好"></a>4.1 单例对代码的扩展性不友好</h2><p>单例这种设计模式对于抽象、继承、多态都支持得不好。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">long</span> id = IdGenerator.getInstance().getId();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">long</span> id = IdGenerator.getInstance().getId();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果未来某一天，我们希望针对不同的业务采用不同的 <code>ID</code> 生成算法。比如，订单 <code>ID</code> 和用户 <code>ID</code> 采用不同的 <code>ID</code> 生成器来生成。为了应对这个需求变化，我们需要修改所有用到 <code>IdGenerator</code> 类的地方，这样代码的改动就会比较大。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">long</span> id = IdGenerator.getInstance().getId();</span><br><span class="line">    <span class="comment">// 需要将上面一行代码，替换为下面一行代码</span></span><br><span class="line">    <span class="keyword">long</span> id = OrderIdGenerator.getIntance().getId();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">long</span> id = IdGenerator.getInstance().getId();</span><br><span class="line">    <span class="comment">// 需要将上面一行代码，替换为下面一行代码</span></span><br><span class="line">    <span class="keyword">long</span> id = UserIdGenerator.getIntance().getId();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-2-单例对代码的可测试性不友好"><a href="#4-2-单例对代码的可测试性不友好" class="headerlink" title="4.2 单例对代码的可测试性不友好"></a>4.2 单例对代码的可测试性不友好</h2><p>单例模式的使用会影响到代码的可测试性。如果单例类依赖比较重的外部资源，比如 <code>DB</code>，我们在写单元测试的时候，希望能通过 <code>mock</code> 的方式将它替换掉。而单例类这种硬编码式的使用方式，导致无法实现 <code>mock</code> 替换。</p><p>除此之外，如果单例类持有成员变量（比如 <code>IdGenerator</code> 中的 <code>id</code> 成员变量），那它实际上相当于一种全局变量，被所有的代码共享。如果这个全局变量是一个可变全局变量，也就是说，它的成员变量是可以被修改的，那我们在编写单元测试的时候，还需要注意不同测试用例之间，修改了单例类中的同一个成员变量的值，从而导致测试结果互相影响的问题。</p><h1 id="5-如何实现一个多例模式？"><a href="#5-如何实现一个多例模式？" class="headerlink" title="5 如何实现一个多例模式？"></a>5 如何实现一个多例模式？</h1><p>跟单例模式概念相对应的还有一个多例模式。那如何实现一个多例模式呢？</p><p>“单例” 指的是，一个类只能创建一个对象。对应地，“多例” 指的就是，一个类可以创建多个对象，但是个数是有限制的，比如只能创建 <code>3</code> 个对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BackendServer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> serverNo;</span><br><span class="line">  <span class="keyword">private</span> String serverAddress;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SERVER_COUNT = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Long, BackendServer&gt; serverInstances = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    serverInstances.put(<span class="number">1L</span>, <span class="keyword">new</span> BackendServer(<span class="number">1L</span>, <span class="string">&quot;192.134.22.138:8080&quot;</span>));</span><br><span class="line">    serverInstances.put(<span class="number">2L</span>, <span class="keyword">new</span> BackendServer(<span class="number">2L</span>, <span class="string">&quot;192.134.22.139:8080&quot;</span>));</span><br><span class="line">    serverInstances.put(<span class="number">3L</span>, <span class="keyword">new</span> BackendServer(<span class="number">3L</span>, <span class="string">&quot;192.134.22.140:8080&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">BackendServer</span><span class="params">(<span class="keyword">long</span> serverNo, String serverAddress)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.serverNo = serverNo;</span><br><span class="line">    <span class="keyword">this</span>.serverAddress = serverAddress;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> BackendServer <span class="title">getInstance</span><span class="params">(<span class="keyword">long</span> serverNo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> serverInstances.get(serverNo);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> BackendServer <span class="title">getRandomInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Random r = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">int</span> no = r.nextInt(SERVER_COUNT)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> serverInstances.get(no);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一种理解方式：同一类型的只能创建一个对象，不同类型的可以创建多个对象。这里的 “类型” 如何理解呢？</p><p>在代码中，<code>logger name</code> 就是刚刚说的 “类型” ，同一个 <code>logger name</code> 获取到的对象实例是相同的，不同的 <code>logger name</code> 获取到的对象实例是不同的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, Logger&gt; instances</span><br><span class="line">          = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Logger</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Logger <span class="title">getInstance</span><span class="params">(String loggerName)</span> </span>&#123;</span><br><span class="line">    instances.putIfAbsent(loggerName, <span class="keyword">new</span> Logger());</span><br><span class="line">    <span class="keyword">return</span> instances.get(loggerName);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//l1==l2, l1!=l3</span></span><br><span class="line">Logger l1 = Logger.getInstance(<span class="string">&quot;User.class&quot;</span>);</span><br><span class="line">Logger l2 = Logger.getInstance(<span class="string">&quot;User.class&quot;</span>);</span><br><span class="line">Logger l3 = Logger.getInstance(<span class="string">&quot;Order.class&quot;</span>);</span><br></pre></td></tr></table></figure><p>这种多例模式的理解方式有点类似工厂模式。<br>它跟工厂模式的不同之处是，多例模式创建的对象都是同一个类的对象，而工厂模式创建的是不同子类的对象</p><p>在上面的问题中如果 <code>IdGenerator</code> 分为 <code>OrderIdGenerator</code> 和 <code>UserIdGenerator</code> ，有什么办法解决呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IIdGenerator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Order实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderIdGenerator</span> <span class="keyword">implements</span> <span class="title">IIdGenerator</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//User实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserIdGenerator</span> <span class="keyword">implements</span> <span class="title">IIdGenerator</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//多例操作类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdGeneratorPresenter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Long, IIdGenerator&gt; imgInstances = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Long ORDER = <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Long USER = <span class="number">2L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        imgInstances.put(ORDER, <span class="keyword">new</span> OrderIdGenerator());</span><br><span class="line">        imgInstances.put(USER, <span class="keyword">new</span> UserIdGenerator());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IIdGenerator <span class="title">getInstance</span><span class="params">(Long type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> imgInstances.get(type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">IdGeneratorPresenter.getInstance(IdGeneratorPresenter.ORDER).getId()</span><br><span class="line">IdGeneratorPresenter.getInstance(IdGeneratorPresenter.USER).getId()</span><br></pre></td></tr></table></figure><p>类似于简单工厂和单例的结合。</p><h1 id="6-Android-源码中的单例模式实现"><a href="#6-Android-源码中的单例模式实现" class="headerlink" title="6 Android 源码中的单例模式实现"></a>6 Android 源码中的单例模式实现</h1><p>我们来看看 <code>LayoutInflater</code> 是如何拿到的。</p><p>通常我们使用 <code>LayoutInflater.from(Context)</code> 来获取 <code>LayoutInflater</code> 服务, 下面我们看看 <code>LayoutInflater.from(Context)</code> 的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Obtains the LayoutInflater from the given context.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LayoutInflater <span class="title">from</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    LayoutInflater LayoutInflater =(LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);</span><br><span class="line">    <span class="keyword">if</span> (LayoutInflater == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">&quot;LayoutInflater not found.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> LayoutInflater;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 <code>from(Context)</code> 函数内部调用的是 <code>Context</code> 类的 <code>getSystemService(String key)</code> 方法，我们跟踪到 <code>Context</code> 类看到，该类是抽象类。<code>Context</code>的实现类为 <code>ComtextImpl</code> 类。我们继续跟踪到 <code>ContextImpl</code> 类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSystemService</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SystemServiceRegistry.getSystemService(<span class="keyword">this</span>, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看 <code>SystemServiceRegistry</code> 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 : service容器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HashMap&lt;String, ServiceFetcher&lt;?&gt;&gt; SYSTEM_SERVICE_FETCHERS =</span><br><span class="line">          <span class="keyword">new</span> HashMap&lt;String, ServiceFetcher&lt;?&gt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2: 注册服务器</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">registerService</span><span class="params">(String serviceName, Class&lt;T&gt; serviceClass,</span></span></span><br><span class="line"><span class="function"><span class="params">          ServiceFetcher&lt;T&gt; serviceFetcher)</span> </span>&#123;</span><br><span class="line">      SYSTEM_SERVICE_NAMES.put(serviceClass, serviceName);</span><br><span class="line">      SYSTEM_SERVICE_FETCHERS.put(serviceName, serviceFetcher);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3: 静态语句块, 第一次加载该类时执行 ( 只执行一次, 保证实例的唯一性. )</span></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">      <span class="comment">//  代码省略</span></span><br><span class="line">      <span class="comment">// 注册Activity Servicer</span></span><br><span class="line">      registerService(Context.ACTIVITY_SERVICE, ActivityManager.class,</span><br><span class="line">              <span class="keyword">new</span> CachedServiceFetcher&lt;ActivityManager&gt;() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> ActivityManager <span class="title">createService</span><span class="params">(ContextImpl ctx)</span> </span>&#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">new</span> ActivityManager(ctx.getOuterContext(), ctx.mMainThread.getHandler());</span><br><span class="line">          &#125;&#125;);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 注册LayoutInflater service</span></span><br><span class="line">registerService(Context.LAYOUT_INFLATER_SERVICE, LayoutInflater.class,</span><br><span class="line">              <span class="keyword">new</span> CachedServiceFetcher&lt;LayoutInflater&gt;() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> LayoutInflater <span class="title">createService</span><span class="params">(ContextImpl ctx)</span> </span>&#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">new</span> PhoneLayoutInflater(ctx.getOuterContext());</span><br><span class="line">        &#125;&#125;);</span><br><span class="line">      <span class="comment">// ....代码省略</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4: 根据key获取对应的服务, </span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getSystemService</span><span class="params">(ContextImpl ctx, String name)</span> </span>&#123;</span><br><span class="line">      ServiceFetcher&lt;?&gt; fetcher = SYSTEM_SERVICE_FETCHERS.get(name);</span><br><span class="line">      <span class="keyword">return</span> fetcher != <span class="keyword">null</span> ? fetcher.getService(ctx) : <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>从 <code>ContextImpl</code> 类的部分代码中可以看到，在虚拟机第一次加载该类时会注册各种服务，其中就包含了 <code>LayoutInflater Service</code>，将这些服务以键值对的形式存储在一个 <code>HashMap</code> 中，用户使用时只需要根据 <code>key</code> 来获取到对应的服务，从而达到单例的效果。</p><p>源码中和我之前写的 <code>IIdGenerator</code> 类似<br>但是源码在初始化的时候并没有真正的 <code>new PhoneLayoutInflater()</code> 而在 <code>getSystemService</code> 的时候才去创建实例（ <code>getService</code> 中的 <code>service</code> 不会创建第二次），所以我之前写的代码还可以优化延迟加载。<br>源码中在实例化的时候封装了一层属于<strong>多对象单例</strong>，我写的属于利用多态实现的<strong>单对象多例</strong>。</p><p>系统核心服务以单例形式存在，并且延迟加载，减少了资源消耗。再次为源码点赞！</p><h1 id="7-总结"><a href="#7-总结" class="headerlink" title="7 总结"></a>7 总结</h1><p><strong>优点</strong></p><ul><li>由于单例模式在内存中只有一个实例，减少了内存开支，特别是一个对象需要频繁地创建、销毁时，而且创建或销毁时性能又无法优化，单例模式的优势就非常明显。</li><li>由于单例模式只生成一个实例，所以减少了系统的性能开销，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后用永久驻留内存的方式来解决；</li><li>单例模式可以避免对资源的多重占用，例如一个写文件动作，由于只有一个实例存在内存中，避免对同一个资源文件的同时写操作。</li><li>单例模式可以在系统设置全局的访问点，优化和共享资源访问，例如可以设计一个单例类，负责所有数据表的映射处理。</li></ul><p><strong>缺点</strong></p><ul><li>单例模式一般没有接口，扩展很困难，若要扩展，除了修改代码基本上没有第二种途径可以实现。</li></ul><h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a><strong>感谢</strong></h1><blockquote><p><a href="https://time.geekbang.org/column/intro/250?utm_source=pinpaizhuanqu&utm_medium=geektime&utm_campaign=guanwang&utm_term=guanwang&utm_content=0511">设计模式之美</a></p><p>《Android 源码设计模式解析与实战》</p><p>以及上文中的链接</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-编码规范篇</title>
      <link href="2020/code-standards.html"/>
      <url>2020/code-standards.html</url>
      
        <content type="html"><![CDATA[<h1 id="本文主要记载"><a href="#本文主要记载" class="headerlink" title="本文主要记载"></a>本文主要记载</h1><ul><li>1 命名多长最合适？</li><li>2 利用上下文简化命名</li><li>3 命名要可读、可搜索</li><li>4 如何命名接口和抽象类？</li><li>5 注释到底该写什么？</li><li>6 注释是不是越多越好？</li><li>7 类、函数多大才合适？</li><li>8 一行代码多长最合适？</li><li>9 善用空行分割单元块</li><li>10 四格缩进还是两格缩进？</li><li>11 大括号是否要另起一行？</li><li>12 类中成员的排列顺序</li><li>13 把代码分割成更小的单元块</li><li>14 避免函数参数过多</li><li>15 勿用函数参数来控制逻辑</li><li>16 函数设计要职责单一</li><li>17 移除过深的嵌套层次</li><li>18 常量取代魔法数字</li><li>19 使用解释性变量来解释复杂表达式</li><li>20 统一编码规范</li></ul><p>编码规范大部分都简单明了，在代码细节方面，能立竿见影地改善质量。</p><h1 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h1><p>大到项目名、模块名、包名、对外暴露的接口，小到类名、函数名、变量名、参数名，只要是做开发，我们就逃不过“起名字”这一关。<br>命名的好坏，对于代码的可读性来说非常重要，甚至可以说是起决定性作用的。<br>除此之外，命名能力也体现了一个程序员的基本编程素养。</p><p>那具体应该怎么命名呢？好的命名有啥标准吗？</p><h2 id="1-命名多长最合适？"><a href="#1-命名多长最合适？" class="headerlink" title="1 命名多长最合适？"></a>1 命名多长最合适？</h2><p>有的人喜欢很长的命名方式，觉得命名一定要准确达意，哪怕长一点也没关系，所以，这类同事的项目里，类名、函数名都很长。<br>有的人喜欢短的命名方式，能用缩写就尽量用缩写，所以，项目里到处都是包含各种缩写的命名。<br>这两种命名方式，哪种更值得推荐呢？</p><p>实际上，在足够表达其含义的情况下，命名当然是越短越好。但是，大部分情况下，短的命名都没有长的命名更能达意。<br>可以使用大家都熟知的缩写，比如，<code>sec</code> 表示 <code>second</code>、<code>str</code> 表示 <code>string</code>、<code>num</code> 表示 <code>number</code>、<code>doc</code> 表示 <code>document</code>。<br>对于作用域比较小的变量，我们可以使用相对短的命名，比如一些函数内的临时变量。<br>相反，对于类名这种作用域比较大的，我更推荐用长的命名方式。</p><p>总之，命名的一个原则就是可以能够准确达意思为目标。<br>命名的时候，我们一定要学会换位思考，假设自己不熟悉这块代码，从代码阅读者的角度去考量命名是否足够直观。</p><h2 id="2-利用上下文简化命名"><a href="#2-利用上下文简化命名" class="headerlink" title="2 利用上下文简化命名"></a>2 利用上下文简化命名</h2><p>看一个简单的例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String userName;</span><br><span class="line">  <span class="keyword">private</span> String userPassword;</span><br><span class="line">  <span class="keyword">private</span> String userAvatarUrl;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>User</code> 类这样一个上下文中，我们没有在成员变量的命名中重复添加 “user” 这样一个前缀单词，而是直接命名为 <code>name</code>、<code>password</code>、<code>avatarUrl</code>。<br>在使用这些属性时候，我们能借助对象这样一个上下文，表意也足够明确。<br>具体代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line">user.getName(); <span class="comment">// 借助user对象这个上下文</span></span><br></pre></td></tr></table></figure><p>除了类之外，函数参数也可以借助函数这个上下文来简化命名。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uploadUserAvatarImageToAliyun</span><span class="params">(String userAvatarImageUri)</span></span>;</span><br><span class="line"><span class="comment">//利用上下文简化为：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uploadUserAvatarImageToAliyun</span><span class="params">(String imageUri)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="3-命名要可读、可搜索"><a href="#3-命名要可读、可搜索" class="headerlink" title="3 命名要可读、可搜索"></a>3 命名要可读、可搜索</h2><p>这里所说的 “可读” ，指的是不要用一些特别生僻、难发音的英文单词来命名。</p><p>这个单词最好是简单的，你不一定知道它表示什么意思，但基本上都能读得上来，不影响沟通交流，这就算是一个比较好的命名。</p><p>我们在命名的时候，统一规约是很重要的，能减少很多不必要的麻烦。<br>大家都用 <code>“selectXXX”</code> 表示查询，你就不要用 <code>“queryXXX”</code> ；大家都用 <code>“insertXXX”</code> 表示插入一条数据，你就要不用 <code>“addXXX”</code> </p><h2 id="4-如何命名接口和抽象类？"><a href="#4-如何命名接口和抽象类？" class="headerlink" title="4 如何命名接口和抽象类？"></a>4 如何命名接口和抽象类？</h2><p>对于接口的命名，一般有两种比较常见的方式。一种是加前缀 <code>“I”</code> ，表示一个 <code>Interface</code> 。比如 <code>IUserService</code> ，对应的实现类命名为 <code>UserService</code> 。另一种是不加前缀，比如 <code>UserService</code> ，对应的实现类加后缀 <code>“Impl”</code> ，比如 <code>UserServiceImpl</code>。</p><p>对于抽象类的命名，也有两种方式，一种是带上前缀 <code>“Abstract”</code>，比如 <code>AbstractConfiguration</code>；另一种是不带前缀 <code>“Abstract”</code>。实际上，对于接口和抽象类，选择哪种命名方式都是可以的，只要项目里能够统一就行。</p><h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p>命名很重要，注释跟命名同等重要。<br>很多书籍认为，好的命名完全可以替代注释。如果需要注释，那说明命名不够好，需要在命名上下功夫，而不是添加注释。<br>但是命名再好，毕竟有长度限制，不可能足够详尽，而这个时候，注释就是一个很好的补充。</p><h2 id="5-注释到底该写什么？"><a href="#5-注释到底该写什么？" class="headerlink" title="5 注释到底该写什么？"></a>5 注释到底该写什么？</h2><p>注释的目的就是让代码更容易看懂。只要符合这个要求的内容，你就可以将它写到注释里。<br>总结一下，注释的内容主要包含这样三个方面：做什么<code>（what）</code>、为什么<code>（why）</code>、怎么做<code>（how）</code>。</p><p>对于一些复杂的类和接口，我们可能还需要写明 “如何用” 。</p><h2 id="6-注释是不是越多越好？"><a href="#6-注释是不是越多越好？" class="headerlink" title="6 注释是不是越多越好？"></a>6 注释是不是越多越好？</h2><p>注释太多和太少都有问题。<br>太多，有可能意味着代码写得不够可读，需要写很多注释来补充。除此之外，注释太多也会对代码本身的阅读起到干扰。而且，后期的维护成本也比较高，有时候代码改了，注释忘了同步修改，就会让代码阅读者更加迷惑。<br>如果代码中一行注释都没有，那只能说明这个程序员很懒，我们要适当督促一下，让他注意添加一些必要的注释。</p><p>类和函数一定要写注释，而且要写得尽可能全面、详细，而函数内部的注释要相对少一些，一般都是靠好的命名、提炼函数、解释性变量、总结性注释来提高代码的可读性。</p><h1 id="代码风格"><a href="#代码风格" class="headerlink" title="代码风格"></a>代码风格</h1><h2 id="7-类、函数多大才合适？"><a href="#7-类、函数多大才合适？" class="headerlink" title="7 类、函数多大才合适？"></a>7 类、函数多大才合适？</h2><p>总体上来讲，类或函数的代码行数不能太多，但也不能太少。<br>类或函数的代码行数太多，一个类上千行，一个函数几百行，逻辑过于繁杂，阅读代码的时候，很容易就会看了后面忘了前面。<br>相反，类或函数的代码行数太少，在代码总量相同的情况下，被分割成的类和函数就会相应增多，调用关系就会变得更复杂，阅读某个代码逻辑的时候，需要频繁地在 <code>n</code> 多类或者 <code>n</code> 多函数之间跳来跳去，阅读体验也不好。</p><p>对于函数代码行数的最大限制，网上有一种说法，那就是不要超过一个显示屏的垂直高度。<br>比如，在我的电脑上，如果要让一个函数的代码完整地显示在 <code>IDE</code> 中，那最大代码行数不能超过 <code>50</code><br>因为超过一屏之后，在阅读代码的时候，为了串联前后的代码逻辑，就可能需要频繁地上下滚动屏幕，阅读体验不好不说，还容易出错。</p><h2 id="8-一行代码多长最合适？"><a href="#8-一行代码多长最合适？" class="headerlink" title="8 一行代码多长最合适？"></a>8 一行代码多长最合适？</h2><p>在 <a href="https://google.github.io/styleguide/javaguide.html">Google Java Style Guide</a> 文档中，一行代码最长限制为 <code>100</code> 个字符。<br>不过，不同的编程语言、不同的规范、不同的项目团队，对此的限制可能都不相同。<br>不管这个限制是多少，总体上来讲要遵循的一个原则是：一行代码最长不能超过 <code>IDE</code> 显示的宽度。需要滚动鼠标才能查看一行的全部代码，显然不利于代码的阅读。当然，这个限制也不能太小，太小会导致很多稍长点的语句被折成两行，也会影响到代码的整洁，不利于阅读。</p><h2 id="9-善用空行分割单元块"><a href="#9-善用空行分割单元块" class="headerlink" title="9 善用空行分割单元块"></a>9 善用空行分割单元块</h2><p>对于比较长的函数，如果逻辑上可以分为几个独立的代码块，在不方便将这些独立的代码块抽取成小函数的情况下，为了让逻辑更加清晰，除了之前提到的用注释的方法之外，我们还可以使用空行来分割各个代码块。</p><p>除此之外，在类的成员变量与函数之间、静态成员变量与普通成员变量之间、各函数之间、甚至各成员变量之间，我们都可以通过添加空行的方式，让这些不同模块的代码之间，界限更加明确。写代码就类似写文章，善于应用空行，可以让代码的整体结构看起来更加有清晰、有条理。</p><h2 id="10-四格缩进还是两格缩进？"><a href="#10-四格缩进还是两格缩进？" class="headerlink" title="10 四格缩进还是两格缩进？"></a>10 四格缩进还是两格缩进？</h2><h2 id="11-大括号是否要另起一行？"><a href="#11-大括号是否要另起一行？" class="headerlink" title="11 大括号是否要另起一行？"></a>11 大括号是否要另起一行？</h2><h2 id="12-类中成员的排列顺序"><a href="#12-类中成员的排列顺序" class="headerlink" title="12 类中成员的排列顺序"></a>12 类中成员的排列顺序</h2><p>因为是代码风格，所以每个人意见都是不同的，只要团队统一、自己看着舒服就好，项目里添加统一的 <code>format</code> 规则，格式化后显示相同代码<br>然后有一个叫 <code>Alibaba Java Coding Guidelines</code> 的插件，可以按照插件中的要求编码。</p><h1 id="编程技巧"><a href="#编程技巧" class="headerlink" title="编程技巧"></a>编程技巧</h1><h2 id="13-把代码分割成更小的单元块"><a href="#13-把代码分割成更小的单元块" class="headerlink" title="13 把代码分割成更小的单元块"></a>13 把代码分割成更小的单元块</h2><p>大部分人阅读代码的习惯都是，先看整体再看细节。<br>所以，我们要有模块化和抽象思维，善于将大块的复杂逻辑提炼成类或者函数，屏蔽掉细节，让阅读代码的人不至于迷失在细节中，这样能极大地提高代码的可读性。<br>不过，只有代码逻辑比较复杂的时候，我们其实才建议提炼类或者函数。毕竟如果提炼出的函数只包含两三行代码，在阅读代码的时候，还得跳过去看一下，这样反倒增加了阅读成本。</p><p>举个栗子🌰</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重构前的代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invest</span><span class="params">(<span class="keyword">long</span> userId, <span class="keyword">long</span> financialProductId)</span> </span>&#123;</span><br><span class="line">  Calendar calendar = Calendar.getInstance();</span><br><span class="line">  calendar.setTime(date);</span><br><span class="line">  calendar.set(Calendar.DATE, (calendar.get(Calendar.DATE) + <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">if</span> (calendar.get(Calendar.DAY_OF_MONTH) == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重构后的代码：提炼函数之后逻辑更加清晰</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invest</span><span class="params">(<span class="keyword">long</span> userId, <span class="keyword">long</span> financialProductId)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isLastDayOfMonth(<span class="keyword">new</span> Date())) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLastDayOfMonth</span><span class="params">(Date date)</span> </span>&#123;</span><br><span class="line">  Calendar calendar = Calendar.getInstance();</span><br><span class="line">  calendar.setTime(date);</span><br><span class="line">  calendar.set(Calendar.DATE, (calendar.get(Calendar.DATE) + <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">if</span> (calendar.get(Calendar.DAY_OF_MONTH) == <span class="number">1</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码重构之后，我们将这部分逻辑抽象成一个函数，并且命名为 <code>isLastDayOfMonth</code>，从名字就能清晰地了解它的功能，判断今天是不是当月的最后一天。这里，我们就是通过将复杂的逻辑代码提炼成函数，大大提高了代码的可读性。</p><h2 id="14-避免函数参数过多"><a href="#14-避免函数参数过多" class="headerlink" title="14 避免函数参数过多"></a>14 避免函数参数过多</h2><p>参数过多，会影响到代码的可读性，使用起来也不方便。针对参数过多的情况，一般有 2 种处理方法。</p><ul><li><p>考虑函数是否职责单一，是否能通过拆分成多个函数的方式来减少参数。示例代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(String username, String telephone, String email)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拆分成多个函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUserByUsername</span><span class="params">(String username)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUserByTelephone</span><span class="params">(String telephone)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUserByEmail</span><span class="params">(String email)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>将函数的参数封装成对象。</p><p>如果函数是对外暴露的远程接口，将参数封装成对象，还可以提高接口的兼容性。在往接口中添加新的参数的时候，老的远程接口调用者有可能就不需要修改代码来兼容新的接口了。</p></li></ul><h2 id="15-勿用函数参数来控制逻辑"><a href="#15-勿用函数参数来控制逻辑" class="headerlink" title="15 勿用函数参数来控制逻辑"></a>15 勿用函数参数来控制逻辑</h2><p>不要在函数中使用布尔类型的标识参数来控制内部逻辑，<code>true</code> 的时候走这块逻辑，<code>false</code> 的时候走另一块逻辑。<br>这明显违背了单一职责原则和接口隔离原则。<br>可以将其拆成两个函数，可读性上也要更好。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buyCourse</span><span class="params">(<span class="keyword">long</span> userId, <span class="keyword">long</span> courseId, <span class="keyword">boolean</span> isVip)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将其拆分成两个函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buyCourse</span><span class="params">(<span class="keyword">long</span> userId, <span class="keyword">long</span> courseId)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buyCourseForVip</span><span class="params">(<span class="keyword">long</span> userId, <span class="keyword">long</span> courseId)</span></span>;</span><br></pre></td></tr></table></figure><p>还有一种 “根据参数是否为 <code>null</code>” 来控制逻辑的情况。<br>针对这种情况，我们也应该将其拆分成多个函数。拆分之后的函数职责更明确，不容易用错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Transaction&gt; <span class="title">selectTransactions</span><span class="params">(Long userId, Date startDate, Date endDate)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (startDate != <span class="keyword">null</span> &amp;&amp; endDate != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 查询两个时间区间的transactions</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (startDate != <span class="keyword">null</span> &amp;&amp; endDate == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 查询startDate之后的所有transactions</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (startDate == <span class="keyword">null</span> &amp;&amp; endDate != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 查询endDate之前的所有transactions</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (startDate == <span class="keyword">null</span> &amp;&amp; endDate == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 查询所有的transactions</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拆分成多个public函数，更加清晰、易用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Transaction&gt; <span class="title">selectTransactionsBetween</span><span class="params">(Long userId, Date startDate, Date endDate)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> selectTransactions(userId, startDate, endDate);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Transaction&gt; <span class="title">selectTransactionsStartWith</span><span class="params">(Long userId, Date startDate)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> selectTransactions(userId, startDate, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Transaction&gt; <span class="title">selectTransactionsEndWith</span><span class="params">(Long userId, Date endDate)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> selectTransactions(userId, <span class="keyword">null</span>, endDate);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Transaction&gt; <span class="title">selectAllTransactions</span><span class="params">(Long userId)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> selectTransactions(userId, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;Transaction&gt; <span class="title">selectTransactions</span><span class="params">(Long userId, Date startDate, Date endDate)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="16-函数设计要职责单一"><a href="#16-函数设计要职责单一" class="headerlink" title="16 函数设计要职责单一"></a>16 函数设计要职责单一</h2><p>单一职责原则针对的是类、模块这样的应用对象。<br>实际上，对于函数的设计来说，更要满足单一职责原则。相对于类和模块，函数的粒度比较小，代码行数少，所以在应用单一职责原则的时候，没有像应用到类或者模块那样模棱两可，能多单一就多单一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkUserIfExisting</span><span class="params">(String telephone, String username, String email)</span>  </span>&#123; </span><br><span class="line">  <span class="keyword">if</span> (!StringUtils.isBlank(telephone)) &#123;</span><br><span class="line">    User user = userRepo.selectUserByTelephone(telephone);</span><br><span class="line">    <span class="keyword">return</span> user != <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (!StringUtils.isBlank(username)) &#123;</span><br><span class="line">    User user = userRepo.selectUserByUsername(username);</span><br><span class="line">    <span class="keyword">return</span> user != <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (!StringUtils.isBlank(email)) &#123;</span><br><span class="line">    User user = userRepo.selectUserByEmail(email);</span><br><span class="line">    <span class="keyword">return</span> user != <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拆分成三个函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkUserIfExistingByTelephone</span><span class="params">(String telephone)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkUserIfExistingByUsername</span><span class="params">(String username)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkUserIfExistingByEmail</span><span class="params">(String email)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="17-移除过深的嵌套层次"><a href="#17-移除过深的嵌套层次" class="headerlink" title="17 移除过深的嵌套层次"></a>17 移除过深的嵌套层次</h2><ul><li><p>去掉多余的 <code>if</code> 或 <code>else</code> 语句。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例一</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">caculateTotalAmount</span><span class="params">(List&lt;Order&gt; orders)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (orders == <span class="keyword">null</span> || orders.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 此处的else可以去掉</span></span><br><span class="line">    <span class="keyword">double</span> amount = <span class="number">0.0</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> amount;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例二</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">matchStrings</span><span class="params">(List&lt;String&gt; strList,String substr)</span> </span>&#123;</span><br><span class="line">  List&lt;String&gt; matchedStrings = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">if</span> (strList != <span class="keyword">null</span> &amp;&amp; substr != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (String str : strList) &#123;</span><br><span class="line">      <span class="keyword">if</span> (str != <span class="keyword">null</span>) &#123; <span class="comment">// 跟下面的if语句可以合并在一起</span></span><br><span class="line">        <span class="keyword">if</span> (str.contains(substr)) &#123;</span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> matchedStrings;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用编程语言提供的 <code>continue</code>、<code>break</code>、<code>return</code> 关键字，提前退出嵌套。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重构后的代码：使用continue提前退出</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">matchStrings</span><span class="params">(List&lt;String&gt; strList,String substr)</span> </span>&#123;</span><br><span class="line">  List&lt;String&gt; matchedStrings = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">if</span> (strList != <span class="keyword">null</span> &amp;&amp; substr != <span class="keyword">null</span>)&#123; </span><br><span class="line">    <span class="keyword">for</span> (String str : strList) &#123;</span><br><span class="line">      <span class="keyword">if</span> (str == <span class="keyword">null</span> || !str.contains(substr)) &#123;</span><br><span class="line">        <span class="keyword">continue</span>; </span><br><span class="line">      &#125;</span><br><span class="line">      matchedStrings.add(str);</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> matchedStrings;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>调整执行顺序来减少嵌套。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重构后的代码：使用continue提前退出</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">matchStrings</span><span class="params">(List&lt;String&gt; strList,String substr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (strList == <span class="keyword">null</span> || substr == <span class="keyword">null</span>) &#123;<span class="comment">//先判空 </span></span><br><span class="line">    <span class="keyword">return</span> Collections.emptyList(); </span><br><span class="line">  &#125;</span><br><span class="line">  List&lt;String&gt; matchedStrings = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (String str : strList) &#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span> || !str.contains(substr)) &#123;</span><br><span class="line">      <span class="keyword">continue</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    matchedStrings.add(str);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> matchedStrings;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将部分嵌套逻辑封装成函数调用，以此来减少嵌套。</p></li><li><p>常用的还有通过使用多态来替代 if-else、switch-case 条件判断的方法。</p></li></ul><h2 id="18-常量取代魔法数字"><a href="#18-常量取代魔法数字" class="headerlink" title="18 常量取代魔法数字"></a>18 常量取代魔法数字</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">CalculateCircularArea</span><span class="params">(<span class="keyword">double</span> radius)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="number">3.1415</span>) * radius * radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常量替代魔法数字</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Double PI = <span class="number">3.1415</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">CalculateCircularArea</span><span class="params">(<span class="keyword">double</span> radius)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> PI * radius * radius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="19-使用解释性变量来解释复杂表达式"><a href="#19-使用解释性变量来解释复杂表达式" class="headerlink" title="19 使用解释性变量来解释复杂表达式"></a>19 使用解释性变量来解释复杂表达式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (date.after(SUMMER_START) &amp;&amp; date.before(SUMMER_END)) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入解释性变量后逻辑更加清晰</span></span><br><span class="line"><span class="keyword">boolean</span> isSummer = date.after(SUMMER_START)&amp;&amp;date.before(SUMMER_END);</span><br><span class="line"><span class="keyword">if</span> (isSummer) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="20-统一编码规范"><a href="#20-统一编码规范" class="headerlink" title="20 统一编码规范"></a>20 统一编码规范</h2><p>最后，还有一条非常重要的，那就是，项目、团队，甚至公司，一定要制定统一的编码规范，并且通过 <code>Code Review</code> 督促执行，这对提高代码质量有立竿见影的效果。</p>]]></content>
      
      
      <categories>
          
          <category> 编码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式篇-单元测试</title>
      <link href="2020/unit-testing.html"/>
      <url>2020/unit-testing.html</url>
      
        <content type="html"><![CDATA[<h1 id="本文主要记载"><a href="#本文主要记载" class="headerlink" title="本文主要记载"></a>本文主要记载</h1><ul><li><strong>什么是单元测试？</strong></li><li><strong>为什么要写单元测试？</strong></li><li><strong>如何编写单元测试？</strong><ul><li>重构代码适配单元测试例子</li></ul></li></ul><h1 id="1-什么是单元测试？"><a href="#1-什么是单元测试？" class="headerlink" title="1 什么是单元测试？"></a>1 什么是单元测试？</h1><p>单元测试由研发工程师自己来编写，用来测试自己写的代码的正确性。我们常常将它跟集成测试放到一块来对比。</p><p>单元测试相对于集成测试 <code>（Integration Testing）</code> 来说，测试的粒度更小一些。</p><p>集成测试的测试对象是整个系统或者某个功能模块，比如测试用户注册、登录功能是否正常，是一种端到端 <code>（end to end）</code> 的测试。</p><p>而单元测试的测试对象是类或者函数，用来测试一个类和函数是否都按照预期的逻辑执行。这是代码层级的测试。</p><h1 id="2-为什么要写单元测试？"><a href="#2-为什么要写单元测试？" class="headerlink" title="2 为什么要写单元测试？"></a>2 为什么要写单元测试？</h1><p>单元测试除了能有效地为重构保驾护航之外，也是保证代码质量最有效的两个手段之一（另一个是 Code Review）。</p><ul><li><p><strong>单元测试能有效地帮你发现代码中的 bug</strong></p><p>能否写出 <code>bug free</code> 的代码，是判断工程师编码能力的重要标准之一，也是很多大厂面试考察的重点，单元测试可以帮助开发者快速方便的测试逻辑代码。</p><p>坚持写单元测试是保证代码质量的一个 “杀手锏” ，也是帮助自己拉开与其他人差距的一个 “小秘密” 。</p></li><li><p><strong>写单元测试能帮你发现代码设计上的问题</strong></p><p>代码的可测试性是评判代码质量的一个重要标准。对于一段代码，如果很难为其编写单元测试，或者单元测试写起来很吃力，需要依靠单元测试框架里很高级的特性才能完成，那往往就意味着代码设计得不够合理，比如，没有使用依赖注入、大量使用静态函数、全局变量、代码高度耦合等。</p></li><li><p><strong>单元测试是对集成测试的有力补充</strong></p><p>程序运行的 <code>bug</code> 往往出现在一些边界条件、异常情况下，比如，除数未判空、网络超时。而大部分异常情况都比较难在测试环境中模拟。单元测试可以利用 <code>mock</code> 的方式，控制 <code>mock</code> 的对象返回我们需要模拟的异常，来测试代码在这些异常情况的表现。</p></li><li><p><strong>写单元测试的过程本身就是代码重构的过程</strong></p><p>要把持续重构作为开发的一部分来执行，那写单元测试实际上就是落地执行持续重构的一个有效途径。编写单元测试就相当于对代码的一次自我 <code>Code Review</code> ，在这个过程中，我们可以发现一些设计上的问题（比如代码设计的不可测试）以及代码编写方面的问题（比如一些边界条件处理不当）等，然后针对性的进行重构。</p></li><li><p><strong>阅读单元测试能帮助你快速熟悉代码</strong></p><p>阅读代码最有效的手段，就是先了解它的业务背景和设计思路，然后再去看代码，这样代码读起来就会轻松很多。</p><p>程序员都不怎么喜欢写文档和注释，而大部分程序员写的代码又很难做到 “不言自明” 。</p><p>在没有文档和注释的情况下，单元测试就起了替代性作用。</p><p>单元测试用例实际上就是用户用例，反映了代码的功能和如何使用。借助单元测试，我们不需要深入的阅读代码，便能知道代码实现了什么功能，有哪些特殊情况需要考虑，有哪些边界条件需要处理。</p></li></ul><h1 id="3-如何编写单元测试？"><a href="#3-如何编写单元测试？" class="headerlink" title="3 如何编写单元测试？"></a>3 如何编写单元测试？</h1><p>举个栗子🌰 </p><p><code>Transaction</code> 是经过抽象简化之后的一个电商系统的交易类，用来记录每笔订单交易的情况。<br><code>Transaction</code> 类中的 <code>execute()</code> 函数负责执行转账操作，将钱从买家的钱包转到卖家的钱包中。<br>真正的转账操作是通过调用 <code>WalletRpcService RPC</code> 服务来完成的。<br>除此之外，代码中还涉及一个分布式锁 <code>DistributedLock</code> 单例类，用来避免 <code>Transaction</code> 并发执行，导致用户的钱被重复转出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Transaction</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String id;</span><br><span class="line">  <span class="keyword">private</span> Long buyerId;</span><br><span class="line">  <span class="keyword">private</span> Long sellerId;</span><br><span class="line">  <span class="keyword">private</span> Long productId;</span><br><span class="line">  <span class="keyword">private</span> String orderId;</span><br><span class="line">  <span class="keyword">private</span> Long createTimestamp;</span><br><span class="line">  <span class="keyword">private</span> Double amount;</span><br><span class="line">  <span class="keyword">private</span> STATUS status;</span><br><span class="line">  <span class="keyword">private</span> String walletTransactionId;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...get() methods...</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Transaction</span><span class="params">(String preAssignedId, Long buyerId, Long sellerId, Long productId, String orderId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (preAssignedId != <span class="keyword">null</span> &amp;&amp; !preAssignedId.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">this</span>.id = preAssignedId;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.id = IdGenerator.generateTransactionId();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.id.startWith(<span class="string">&quot;t_&quot;</span>)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.id = <span class="string">&quot;t_&quot;</span> + preAssignedId;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.buyerId = buyerId;</span><br><span class="line">    <span class="keyword">this</span>.sellerId = sellerId;</span><br><span class="line">    <span class="keyword">this</span>.productId = productId;</span><br><span class="line">    <span class="keyword">this</span>.orderId = orderId;</span><br><span class="line">    <span class="keyword">this</span>.status = STATUS.TO_BE_EXECUTD;</span><br><span class="line">    <span class="keyword">this</span>.createTimestamp = System.currentTimestamp();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> InvalidTransactionException </span>&#123;</span><br><span class="line">    <span class="comment">//TODO 2 buyerId、sellerId 为 null、amount 小于 0，返回 InvalidTransactionException。</span></span><br><span class="line">    <span class="keyword">if</span> ((buyerId == <span class="keyword">null</span> || (sellerId == <span class="keyword">null</span> || amount &lt; <span class="number">0.0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> InvalidTransactionException(...);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//TODO 4 交易已经执行了（status==EXECUTED），不再重复执行转钱逻辑，返回 true。</span></span><br><span class="line">    <span class="keyword">if</span> (status == STATUS.EXECUTED) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">boolean</span> isLocked = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      isLocked = RedisDistributedLock.getSingletonIntance().lockTransction(id);</span><br><span class="line">      <span class="keyword">if</span> (!isLocked) &#123;</span><br><span class="line">        <span class="comment">//TODO 6 交易正在执行着，不会被重复执行，函数直接返回 false。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 锁定未成功，返回false，job兜底执行</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (status == STATUS.EXECUTED) <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// double check</span></span><br><span class="line">      <span class="keyword">long</span> executionInvokedTimestamp = System.currentTimestamp();</span><br><span class="line">      <span class="keyword">if</span> (executionInvokedTimestamp - createdTimestap &gt; <span class="number">14d</span>ays) &#123;</span><br><span class="line">        <span class="keyword">this</span>.status = STATUS.EXPIRED;</span><br><span class="line">        <span class="comment">//TODO 3 交易已过期（createTimestamp 超过 14 天），交易状态设置为 EXPIRED，返回 false。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//TODO 1 mock 点</span></span><br><span class="line">      WalletRpcService walletRpcService = <span class="keyword">new</span> WalletRpcService();</span><br><span class="line">      String walletTransactionId = walletRpcService.moveMoney(id, buyerId, sellerId, amount);</span><br><span class="line">      <span class="keyword">if</span> (walletTransactionId != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.walletTransactionId = walletTransactionId;</span><br><span class="line">        <span class="keyword">this</span>.status = STATUS.EXECUTED;</span><br><span class="line">        <span class="comment">//TODO 1 正常情况下，交易执行成功，回填用于对账（交易与钱包的交易流水）用的 walletTransactionId，交易状态设置为 EXECUTED，函数返回 true。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//TODO 5 钱包（WalletRpcService）转钱失败，交易状态设置为 FAILED，函数返回 false。</span></span><br><span class="line">        <span class="keyword">this</span>.status = STATUS.FAILED;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (isLocked) &#123;</span><br><span class="line">       RedisDistributedLock.getSingletonIntance().unlockTransction(id);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对这个函数，设计了下面 <code>6</code> 个测试用例。</p><ol><li>正常情况下，交易执行成功，回填用于对账（交易与钱包的交易流水）用的 <code>walletTransactionId</code>，交易状态设置为 <code>EXECUTED</code>，函数返回 <code>true</code>。</li><li><code>buyerId</code>、<code>sellerId</code> 为 <code>null</code> 、<code>amount</code> 小于 <code>0</code>，返回 <code>InvalidTransactionException</code>。</li><li>交易已过期（<code>createTimestamp</code> 超过 14 天），交易状态设置为 <code>EXPIRED</code>，返回 <code>false</code>。</li><li>交易已经执行了（<code>status==EXECUTED</code>），不再重复执行转钱逻辑，返回 <code>true</code>。</li><li>钱包（<code>WalletRpcService</code>）转钱失败，交易状态设置为 <code>FAILED</code>，函数返回 <code>false</code>。</li><li>交易正在执行着，不会被重复执行，函数直接返回 <code>false</code>。</li></ol><p>测试用例写完了，然后就是如何写单元测试。</p><h2 id="3-1-重构代码适配单元测试例子"><a href="#3-1-重构代码适配单元测试例子" class="headerlink" title="3.1 重构代码适配单元测试例子"></a>3.1 重构代码适配单元测试例子</h2><p>先思考第一个测试用例的单元测试代码实现<br>正常情况下，上面代码我们需要依赖两个外部的服务，一个是 <code>RedisDistributedLock</code>，一个 <code>WalletRpcService</code>。</p><ul><li>如果要让这个单元测试能够运行，我们需要搭建 <code>Redis</code> 服务和 <code>Wallet RPC</code> 服务。搭建和维护的成本比较高。</li><li>我们还需要保证将伪造的 <code>transaction</code> 数据发送给 <code>Wallet RPC</code> 服务之后，能够正确返回我们期望的结果，然而 <code>Wallet RPC</code> 服务有可能是第三方（另一个团队开发维护的）的服务，并不是我们可控的。换句话说，并不是我们想让它返回什么数据就返回什么。</li><li><code>Transaction</code> 的执行跟 <code>Redis</code>、<code>RPC</code> 服务通信，需要走网络，耗时可能会比较长，对单元测试本身的执行性能也会有影响。</li><li>网络的中断、超时、<code>Redis</code>、<code>RPC</code> 服务的不可用，都会影响单元测试的执行。</li></ul><p>我们需要将被测代码与外部系统解依赖，而这种解依赖的方法就叫作 “mock” 。所谓的 <code>mock</code>  就是用一个 “假” 的服务替换真正的服务。<code>mock</code> 的服务完全在我们的控制之下，模拟输出我们想要的数据。这里展示的是手动 <code>mock</code>。</p><p>我们通过继承 <code>WalletRpcService1</code> 类，并且重写其中的 <code>moveMoney()</code> 函数的方式来实现 <code>mock</code>。具体的代码实现如下所示。通过 <code>mock</code> 的方式，我们可以让 <code>moveMoney()</code> 返回任意我们想要的数据，完全在我们的控制范围内，并且不需要真正进行网络通信。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MockWalletRpcServiceOne</span> <span class="keyword">extends</span> <span class="title">WalletRpcService</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">moveMoney</span><span class="params">(Long id, Long fromUserId, Long toUserId, Double amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;123bac&quot;</span>;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MockWalletRpcServiceTwo</span> <span class="keyword">extends</span> <span class="title">WalletRpcService</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">moveMoney</span><span class="params">(Long id, Long fromUserId, Long toUserId, Double amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运用依赖注入，将 <code>WalletRpcService</code> 对象的创建反转给上层逻辑，在外部创建好之后，再注入到 Transaction 类中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Transaction</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...省略其他代码...</span></span><br><span class="line">  <span class="comment">// 添加一个成员变量及其set方法</span></span><br><span class="line">  <span class="keyword">private</span> WalletRpcService walletRpcService;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWalletRpcService</span><span class="params">(WalletRpcService walletRpcService)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.walletRpcService = walletRpcService;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 删除下面这一行代码</span></span><br><span class="line">    <span class="comment">// WalletRpcService walletRpcService = new WalletRpcService();</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单元测试就可以这样写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testExecute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Long buyerId = <span class="number">123L</span>;</span><br><span class="line">  Long sellerId = <span class="number">234L</span>;</span><br><span class="line">  Long productId = <span class="number">345L</span>;</span><br><span class="line">  Long orderId = <span class="number">456L</span>;</span><br><span class="line">  Transction transaction = <span class="keyword">new</span> Transaction(<span class="keyword">null</span>, buyerId, sellerId, productId, orderId);</span><br><span class="line">  <span class="comment">// 使用mock对象来替代真正的RPC服务</span></span><br><span class="line">  transaction.setWalletRpcService(<span class="keyword">new</span> MockWalletRpcServiceOne()):</span><br><span class="line">  <span class="keyword">boolean</span> executedResult = transaction.execute();</span><br><span class="line">  assertTrue(executedResult);</span><br><span class="line">  assertEquals(STATUS.EXECUTED, transaction.getStatus());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>WalletRpcService</code> 问题解决了，那 <code>RedisDistributedLock</code> 它是一个单例类，单例相当于一个全局变量，我们无法 mock（无法继承和重写方法），也无法通过依赖注入的方式来替换。</p><p>如何在不改动该单例类，或者说是根本就无法改动该类的情况下，实现单元测试呢？</p><p>我们可以对 <code>transaction</code> 上锁这部分逻辑重新封装一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionLock</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> RedisDistributedLock.getSingletonIntance().lockTransction(id);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RedisDistributedLock.getSingletonIntance().unlockTransction(id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Transaction</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...省略其他代码...</span></span><br><span class="line">  <span class="keyword">private</span> TransactionLock lock;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTransactionLock</span><span class="params">(TransactionLock lock)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.lock = lock;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      isLocked = lock.lock();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (isLocked) &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们就又可以注入了~ </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testExecute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Long buyerId = <span class="number">123L</span>;</span><br><span class="line">  Long sellerId = <span class="number">234L</span>;</span><br><span class="line">  Long productId = <span class="number">345L</span>;</span><br><span class="line">  Long orderId = <span class="number">456L</span>;</span><br><span class="line">  </span><br><span class="line">  TransactionLock mockLock = <span class="keyword">new</span> TransactionLock() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  Transction transaction = <span class="keyword">new</span> Transaction(<span class="keyword">null</span>, buyerId, sellerId, productId, orderId);</span><br><span class="line">  transaction.setWalletRpcService(<span class="keyword">new</span> MockWalletRpcServiceOne());</span><br><span class="line">  transaction.setTransactionLock(mockLock);</span><br><span class="line">  <span class="keyword">boolean</span> executedResult = transaction.execute();</span><br><span class="line">  assertTrue(executedResult);</span><br><span class="line">  assertEquals(STATUS.EXECUTED, transaction.getStatus());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，测试用例 <code>1</code> 就算写好了。我们通过依赖注入和 <code>mock</code>，让单元测试代码不依赖任何不可控的外部服务。</p><p>用例 <code>2</code> 就比较简单了，用例 <code>4、5、6</code> 通过用例 <code>1</code> 的修改也方便了。 现在来看用例 <code>3</code> </p><p>用例 <code>3</code> 不就改个 <code>createdTimestap</code>  就可以测试了吗？添加一个 <code>set</code> 方法就可以~ </p><p>实际上，这样就违反了类的封装特性。在 <code>Transaction</code> 类的设计中，<code>createTimestamp</code> 是在交易生成时（也就是构造函数中）自动获取的系统时间，本来就不应该人为地轻易修改，所以，暴露 <code>createTimestamp</code> 的 <code>set</code> 方法，虽然带来了灵活性，但也带来了不可控性。因为，我们无法控制使用者是否会调用 <code>set</code> 方法重设 <code>createTimestamp</code>，而重设 <code>createTimestamp</code> 并非我们的预期行为。</p><p>这属于跟 “时间” 有关的 “未决行为” 逻辑。我们一般的处理方式是将这种未决行为逻辑重新封装。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Transaction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isExpired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> executionInvokedTimestamp = System.currentTimestamp();</span><br><span class="line">    <span class="keyword">return</span> executionInvokedTimestamp - createdTimestamp &gt; <span class="number">14L</span> * <span class="number">24</span> * <span class="number">3600</span> * <span class="number">1000</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> InvalidTransactionException </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">      <span class="keyword">if</span> (isExpired()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.status = STATUS.EXPIRED;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对用例 <code>3</code> 重构后的单元测试代码是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testExecute_with_TransactionIsExpired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Long buyerId = <span class="number">123L</span>;</span><br><span class="line">  Long sellerId = <span class="number">234L</span>;</span><br><span class="line">  Long productId = <span class="number">345L</span>;</span><br><span class="line">  Long orderId = <span class="number">456L</span>;</span><br><span class="line">  Transction transaction = <span class="keyword">new</span> Transaction(<span class="keyword">null</span>, buyerId, sellerId, productId, orderId) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isExpired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">boolean</span> actualResult = transaction.execute();</span><br><span class="line">  assertFalse(actualResult);</span><br><span class="line">  assertEquals(STATUS.EXPIRED, transaction.getStatus());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多相关：</p><ul><li><p><a href="http://blog.csdn.net/qq_17766199/article/details/78243176">Android单元测试(一)：JUnit框架的使用</a></p></li><li><p><a href="http://blog.csdn.net/qq_17766199/article/details/78450007">Android单元测试(二)：Mockito框架的使用</a></p></li><li><p><a href="http://blog.csdn.net/qq_17766199/article/details/78573390">Android单元测试(三)：PowerMock框架的使用</a></p></li><li><p><a href="http://blog.csdn.net/qq_17766199/article/details/78710177">Android单元测试(四)：Robolectric框架的使用</a></p></li><li><p><a href="http://blog.csdn.net/qq_17766199/article/details/78881992">Android单元测试(五)：网络接口测试</a> </p></li><li><p><a href="http://blog.csdn.net/qq_17766199/article/details/78989664">Android单元测试(六)：RxJava测试</a></p></li><li><p><a href="http://blog.csdn.net/qq_17766199/article/details/79183901">Android单元测试(七)：MVP与单元测试</a></p></li><li><p><a href="http://blog.csdn.net/qq_17766199/article/details/79277483">Android单元测试(八)：Dagger与单元测试</a></p></li><li><p><a href="https://blog.csdn.net/qq_17766199/article/details/80321318">Android单元测试(九)：查漏补缺篇</a></p></li><li><p><a href="https://weilu.blog.csdn.net/article/details/102992559">Android单元测试(十)：内容更新篇</a></p></li></ul><h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h1><blockquote><p><a href="https://time.geekbang.org/column/intro/250?utm_source=pinpaizhuanqu&utm_medium=geektime&utm_campaign=guanwang&utm_term=guanwang&utm_content=0511">设计模式之美</a></p><p><a href="https://github.com/simplezhli/AndroidUT">唯鹿 github</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式篇</title>
      <link href="2020/design-mode.html"/>
      <url>2020/design-mode.html</url>
      
        <content type="html"><![CDATA[<h1 id="面向对象-more"><a href="#面向对象-more" class="headerlink" title="面向对象 more"></a><a href="https://calmcenter.club/2020/oop.html">面向对象 more</a></h1><ul><li>面向对象</li><li>面向过程</li><li>面向对象编程相比面向过程有哪些优势？</li><li>抽象类和接口</li></ul><h1 id="设计原则-more"><a href="#设计原则-more" class="headerlink" title="设计原则 more"></a><a href="https://calmcenter.club/2020/design-philosophy.html">设计原则 more</a></h1><p>设计原则包括 <code>SOLID</code>、<code>KISS</code>、<code>YAGNI</code>、<code>DRY</code>、<code>LOD</code></p><ul><li><p><code>SOLID</code> 原则：</p><ul><li>单一职责原则 (Single Responsibility Principe 简称 SRP)</li><li>开闭原则 (Open-Closed Principle 简称 OCP)</li><li>里氏替换原则 (Liskov Substitution Principle 简称 LSP)</li><li>接口隔离原则 (Interface Segregation Principle 简称 ISP)</li><li>依赖反转原则 (Dependency Inversion Principe 简称 DIP)</li></ul></li><li><p><code>KISS</code> 原则</p></li><li><p><code>DRY</code> 原则</p></li><li><p>迪米特法则（Law of Demeter LOD）</p></li></ul><p><strong>设计原则和思想其实比设计模式更加重要，掌握了代码的设计原则和思想，我们甚至可以自己创造出来新的设计模式。</strong></p><h1 id="单元测试-more"><a href="#单元测试-more" class="headerlink" title="单元测试 more"></a><a href="https://calmcenter.club/2020/unit-testing.html">单元测试 more</a></h1><ul><li>什么是单元测试？</li><li>为什么要写单元测试？</li><li>如何编写单元测试？</li></ul><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p>设计模式要干的事情就是解耦，<strong>创建型</strong>设计模式主要解决 “对象的创建” 问题，将创建和使用代码解耦，<strong>结构型</strong>设计模式主要解决 “类或对象的组合或组装” 问题，将不同功能代码解耦，<strong>行为型</strong>设计模式主要解决的就是 “类或对象之间的交互” 问题，将不同的行为代码解耦。</p><ul><li><p>创建型</p><ul><li><p><a href="https://calmcenter.club/2020/design-pattern-singleton.html">单例模式 more</a></p></li><li><p><a href="https://calmcenter.club/2020/design-pattern-factory.html">工厂模式 more</a></p></li><li><p><a href="https://calmcenter.club/2020/design-pattern-builder.html">建造者模式 more</a></p></li><li><p><a href="https://calmcenter.club/2020/design-pattern-prototype.html">原型模式 more</a></p></li></ul></li><li><p>结构型</p><ul><li><p><a href="https://calmcenter.club/2020/design-pattern-proxy.html">代理模式 more</a></p><p>代理模式在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能，这是它跟装饰器模式最大的不同。</p></li><li><p><a href="https://calmcenter.club/2020/design-pattern-bridge.html">桥接模式 more</a></p><p>桥接模式的目的是将接口部分和实现部分分离，从而让它们可以较为容易、也相对独立地加以改变。</p></li><li><p><a href="https://calmcenter.club/2020/design-pattern-decorator.html">装饰器模式 more</a></p><p>装饰者模式在不改变原始类接口的情况下，对原始类功能进行增强，并且支持多个装饰器的嵌套使用。</p></li><li><p><a href="https://calmcenter.club/2020/design-pattern-adapter.html">适配器模式 more</a></p><p>适配器模式是一种事后的补救策略。适配器提供跟原始类不同的接口，而代理模式、装饰器模式提供的都是跟原始类相同的接口。</p></li><li><p><a href="https://calmcenter.club/2020/design-pattern-composite.html">组合模式 more</a></p></li><li><p><a href="https://calmcenter.club/2020/design-pattern-flyweight.html">享元模式 more</a></p></li></ul></li><li><p>行为性</p><ul><li><p><a href="https://calmcenter.club/2020/design-pattern-observer.html">观察者模式 more</a></p></li><li><p><a href="https://calmcenter.club/2020/design-pattern-template.html">模板模式 more</a></p></li><li><p><a href="https://calmcenter.club/2020/design-pattern-strategy.html">策略模式 more</a></p></li><li><p><a href="https://calmcenter.club/2020/design-pattern-chainofresponsibility.html">职责链模式 more</a></p><p>模板模式、策略模式、职责链模式，这三种模式具有相同的作用：<strong>复用</strong>和扩展，在实际的项目开发中比较常用，特别是框架开发中，我们可以利用它们来提供框架的扩展点，能够让框架的使用者在<strong>不修改框架源码的情况下，基于扩展点定制化框架的功能</strong>。</p></li><li><p><a href="https://calmcenter.club/2020/design-pattern-state.html">状态模式 more</a></p></li><li><p><a href="https://calmcenter.club/2020/design-pattern-visitor.html">访问者模式 more</a></p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式篇-面向对象</title>
      <link href="2020/oop.html"/>
      <url>2020/oop.html</url>
      
        <content type="html"><![CDATA[<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><ul><li><strong>面向对象编程<code>(Object Oriented Programming OOP)</code></strong></li></ul><p>是一种编程范式或编程风格。它以类或对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性，作为代码设计和实现的基石 。</p><p>面向对象编程中有两个非常重要、非常基础的概念，那就是类<code>（class）</code>和对象<code>（object）</code>。</p><ul><li><strong>面向对象编程语言<code>(Object Oriented Programming Language OOPL)</code></strong></li></ul><p>是支持类或对象的语法机制，并有现成的语法机制，能方便地实现面向对象编程四大特性（封装、抽象、继承、多态）的编程语言。</p><ul><li><strong>封装（Encapsulation）</strong></li></ul><p><strong>What：</strong>隐藏信息，保护数据访问。<br><strong>How：</strong>类通过暴露有限的访问接口，授权外部仅能通过类提供的方式来访问内部信息或者数据。它需要编程语言提供权限访问控制语法来支持，例如 <code>Java</code> 中的 <code>private</code>、<code>protected</code>、<code>public</code> 关键字。<br><strong>Why：</strong>保护数据不被随意修改，提高代码可维护性；降低接口复杂度，提高类的易用性。</p><ul><li><strong>抽象（Abstraction）</strong></li></ul><p><strong>What：</strong>隐藏具体实现，使用者只需关心功能，无需关心实现。<br><strong>How：</strong>通过接口类或者抽象类实现，特殊语法机制非必须。<br><strong>Why：</strong>提高代码的扩展性、维护性；降低复杂度，减少细节负担。</p><ul><li><strong>继承（Inheritance）</strong></li></ul><p><strong>What：</strong>表示 <code>is-a</code> 关系，分为单继承和多继承。<br><strong>How：</strong>需要编程语言提供特殊语法机制。例如 <code>Java</code> 的 <code>extends</code>，<code>C++</code> 的 <code>:</code> 。<br><strong>Why：</strong>解决代码复用问题。</p><ul><li><strong>多态（Polymorphism）</strong></li></ul><p><strong>What：</strong>子类替换父类，在运行时调用子类的实现。<br><strong>How：</strong>需要编程语言提供特殊的语法机制。比如继承、接口类、<code>duck-typing</code>。<br><strong>Why：</strong>提高代码扩展性和复用性。</p><h2 id="面向过程"><a href="#面向过程" class="headerlink" title="面向过程"></a>面向过程</h2><p>面向对象编程以类为组织代码的基本单元，而面向过程编程也是一种编程范式或编程风格。它以过程（可以理解为方法、函数、操作）作为组织代码的基本单元，以数据（可以理解为成员变量、属性）与方法相分离为最主要的特点。面向过程风格是一种流程化的编程风格，通过拼接一组顺序执行的方法来操作数据完成一项功能。</p><h2 id="面向对象编程相比面向过程编程有哪些优势？"><a href="#面向对象编程相比面向过程编程有哪些优势？" class="headerlink" title="面向对象编程相比面向过程编程有哪些优势？"></a>面向对象编程相比面向过程编程有哪些优势？</h2><p>为什么面向对象编程晚于面向过程编程出现，却能取而代之，成为现在主流的编程范式？面向对象编程跟面向过程编程比起来，到底有哪些优势？</p><ul><li>对于大规模复杂程序的开发，程序的处理流程并非单一的一条主线，而是错综复杂的网状结构。面向对象编程比起面向过程编程，更能应对这种复杂类型的程序开发。</li><li>面向对象编程相比面向过程编程，具有更加丰富的特性（封装、抽象、继承、多态）。利用这些特性编写出来的代码，更加易扩展、易复用、易维护。</li><li>从编程语言跟机器打交道的方式的演进规律中，我们可以总结出：面向对象编程语言比起面向过程编程语言，更加人性化、更加高级、更加智能。</li></ul><h2 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h2><ul><li><strong>定义</strong></li></ul><p>抽象类：不允许实例化，只能被继承；可包含属性和方法，包含抽象方法；子类继承抽象类必须重写抽象方法。</p><p>接口：不允许实例化，只能被实现；不包含属性和普通方法，包含抽象方法、静态方法、<code>default</code> 方法，枚举类型，接口中还可以定义接口（嵌套）；类实现接口时，必须实现抽象方法。</p><ul><li><strong>意义</strong></li></ul><p>抽象类：解决复用问题，适用于 <code>is-a</code> 的关系。</p><p>接口：表示具有某一组行为特性，是为了解决解耦问题，隔离接口和具体的实现，提高代码的扩展性，适用于 <code>has-a</code> 的关系。</p><ul><li><strong>应用</strong></li></ul><p>什么时候该用抽象类？什么时候该用接口？为了解决代码复用问题，我们就用抽象类；为了解决抽象而非代码复用问题，那我们就用接口。</p><h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h1><blockquote><p><a href="https://time.geekbang.org/column/intro/250?utm_source=pinpaizhuanqu&utm_medium=geektime&utm_campaign=guanwang&utm_term=guanwang&utm_content=0511">设计模式之美</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-设计原则篇</title>
      <link href="2020/design-philosophy.html"/>
      <url>2020/design-philosophy.html</url>
      
        <content type="html"><![CDATA[<h1 id="本文主要记载"><a href="#本文主要记载" class="headerlink" title="本文主要记载"></a>本文主要记载</h1><ul><li><strong>单一责任原则</strong><ul><li>如何理解 “单一职责原则”？</li><li>如何判断类的职责是否足够单一？</li><li>类的职责是否设计的越单一越好？</li></ul></li><li><strong>开闭原则</strong><ul><li>如何理解 “对扩展开放、修改关闭”？</li><li>如何做到 “对扩展开放、修改关闭”？</li><li>如何正在项目中灵活应用开闭原则？</li></ul></li><li><strong>里式替换原则</strong><ul><li>如何理解 “里式替换原则”？</li><li>如何做到 “里式替换原则”？</li><li>接口隔离原则和单一职责原则的区别</li></ul></li><li><strong>依赖反转原则</strong><ul><li>控制反转</li><li>依赖注入</li><li>依赖反转原则</li></ul></li><li><strong>KISS 原则</strong><ul><li>代码行数越少越 “简单” 吗？</li><li>代码逻辑复杂就违背 KISS 原则吗？</li><li>如何写出满足 KISS 原则的代码？</li><li>YANGNI 原则跟 KISS 原则说的是一回事吗？</li></ul></li><li><strong>DRY 原则</strong><ul><li>实现逻辑重复</li><li>功能语义重复</li><li>代码执行重复</li><li>怎么提高代码复用性？</li><li>思考和灵活应用</li></ul></li><li><strong>迪米特法则</strong><ul><li>何为 “高内聚，松耦合”？</li><li>不该有直接依赖关系的类之间，不要有依赖</li><li>有依赖关系的类之间，尽量只依赖必要的接口</li></ul></li></ul><hr><h1 id="🚩单一责任原则"><a href="#🚩单一责任原则" class="headerlink" title="🚩单一责任原则"></a>🚩单一责任原则</h1><p> (Single Responsibility Principle SRP)</p><h2 id="1-如何理解-“单一职责原则”-？"><a href="#1-如何理解-“单一职责原则”-？" class="headerlink" title="1 如何理解 “单一职责原则” ？"></a>1 如何理解 “单一职责原则” ？</h2><p><code>A class or module should have a single reponsibility(一个类或者模块只负责完成一个职责（或者功能）)</code></p><p>一个类只负责完成一个职责或者功能。不要设计大而全的类，要设计粒度小、功能单一的类。单一职责原则是为了实现代码高内聚、低耦合，提高代码的复用性、可读性、可维护性。</p><p><strong>就一个类而言，应该仅有一个引起变化的原因</strong>  </p><p><strong>把因为相同的原因而改变的事物聚集在一起。把那些因为不同原因而改变的东西分开。</strong></p><h2 id="2-如何判断类的职责是否足够单一？"><a href="#2-如何判断类的职责是否足够单一？" class="headerlink" title="2 如何判断类的职责是否足够单一？"></a>2 如何判断类的职责是否足够单一？</h2><p>不同的应用场景、不同阶段的需求背景、不同的业务层面，对同一个类的职责是否单一，可能会有不同的判定结果。举个栗子🌰</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> userId;</span><br><span class="line">  <span class="keyword">private</span> String username;</span><br><span class="line">  <span class="keyword">private</span> String email;</span><br><span class="line">  <span class="keyword">private</span> String telephone;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> createTime;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> lastLoginTime;</span><br><span class="line">  <span class="keyword">private</span> String avatarUrl;</span><br><span class="line">  <span class="keyword">private</span> String provinceOfAddress; <span class="comment">// 省</span></span><br><span class="line">  <span class="keyword">private</span> String cityOfAddress; <span class="comment">// 市</span></span><br><span class="line">  <span class="keyword">private</span> String regionOfAddress; <span class="comment">// 区 </span></span><br><span class="line">  <span class="keyword">private</span> String detailedAddress; <span class="comment">// 详细地址</span></span><br><span class="line">  <span class="comment">// ...省略其他属性和方法...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>UserInfo</code> 类的设计是否满足单一职责原则呢？</p><p>对于这个问题，有两种不同的观点。一种观点是，<code>UserInfo</code> 类包含的都是跟用户相关的信息，所有的属性和方法都隶属于用户这样一个业务模型，满足单一职责原则；另一种观点是，地址信息在 <code>UserInfo</code> 类中，所占的比重比较高，可以继续拆分成独立的 <code>UserAddress</code> 类，<code>UserInfo</code> 只保留除 <code>Address</code> 之外的其他信息，拆分之后的两个类的职责更加单一。</p><p>哪种观点更对呢？实际上，要从中做出选择，我们不能脱离具体的应用场景。如果在这个社交产品中，用户的地址信息跟其他信息一样，只是单纯地用来展示，那 <code>UserInfo</code> 现在的设计就是合理的。但是，如果这个社交产品发展得比较好，之后又在产品中添加了电商的模块，用户的地址信息还会用在电商物流中，那我们最好将地址信息从 <code>UserInfo</code> 中拆分出来，独立成用户物流信息（或者叫地址信息、收货信息等）。</p><p>一些侧面的判断指标更具有指导意义和可执行性，比如，出现下面这些情况就有可能说明这类的设计不满足单一职责原则：</p><ul><li>类中的代码行数、函数或者属性过多；</li><li>类依赖的其他类过多，或者依赖类的其他类过多；</li><li>私有方法过多；</li><li>比较难给类起一个合适的名字；</li><li>类中大量的方法都是集中操作类中的某几个属性；</li></ul><p>至于如何判断 <em>过多</em> ，实际上，这个问题并不好定量地回答，就像你问大厨 “放盐少许” 中的 “少许” 是多少，大厨也很难告诉你一个特别具体的量值，都是经验与感觉。</p><p>从另一个角度来看，当一个类的代码，读起来让你头大了，实现某个功能时不知道该用哪个函数了，想用哪个函数翻半天都找不到了，只用到一个小功能要引入整个类（类中包含很多无关此功能实现的函数）的时候，这就说明类的行数、函数、属性过多了。项目做多了，代码写多了，在开发中慢慢 “品尝” ，自然就知道什么是 “放盐少许” 了，这就是所谓的 “专业第六感” 。</p><h2 id="3-类的职责是否设计得越单一越好？"><a href="#3-类的职责是否设计得越单一越好？" class="headerlink" title="3 类的职责是否设计得越单一越好？"></a>3 类的职责是否设计得越单一越好？</h2><p>为了满足单一职责原则，是不是把类拆得越细就越好呢？答案是否定的。</p><p>单一职责原则通过避免设计大而全的类，避免将不相关的功能耦合在一起，来提高类的内聚性。<br>同时，类职责单一，类依赖的和被依赖的其他类也会变少，减少了代码的耦合性，以此来实现代码的高内聚、低耦合。<br>但是，如果拆分得过细，实际上会适得其反，反倒会降低内聚性，也会影响代码的可维护性。</p><p>举个栗子🌰 <code>Serialization</code> 类实现了一个 简单协议 的 序列化 和 反序列 功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Serialization</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(Map&lt;String, String&gt; object)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title">deserialize</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们想让类的职责更加单一，我们对 <code>Serialization</code> 类进一步拆分，拆分成一个只负责序列化工作的 <code>Serializer</code> 类和另一个只负责反序列化工作的 <code>Deserializer</code> 类。但是，现在如果我们修改了协议的格式，或者序列化方式从 <code>JSON</code> 改为了 <code>XML</code> ，那 <code>Serializer</code> 类和 <code>Deserializer</code> 类都需要做相应的修改，代码的内聚性显然没有原来 <code>Serialization</code> 高了。拆分之后，代码的可维护性变差了。</p><hr><h1 id="🚩开闭原则"><a href="#🚩开闭原则" class="headerlink" title="🚩开闭原则"></a>🚩开闭原则</h1><p>开闭原则 <code>(Open-Closed Principle 简称 OCP)</code> 是 <code>SOLID</code> 中最难理解、最难掌握，同时也是最有用的一条原则。</p><h2 id="1-如何理解-“对扩展开放、修改关闭”-？"><a href="#1-如何理解-“对扩展开放、修改关闭”-？" class="headerlink" title="1 如何理解 “对扩展开放、修改关闭”  ？"></a>1 如何理解 “对扩展开放、修改关闭”  ？</h2><p><code>software entities (modules, classes, functions, etc.) should be open for extension , but closed for modification(软件实体（模块、类、方法等）应该“对扩展开放、对修改关闭”。)</code></p><p>添加一个新的功能，应该是通过在已有代码基础上扩展代码（新增模块、类、方法、属性等），而非修改已有代码（修改模块、类、方法、属性等）的方式来完成。</p><ul><li>开闭原则并不是说完全杜绝修改，而是以最小的修改代码的代价来完成新功能的开发。</li><li>同样的代码改动，在粗代码粒度下，可能被认定为“修改”；在细代码粒度下，可能又被认定为“扩展”。</li></ul><h2 id="2-如何做到-“对扩展开放、修改关闭”-？"><a href="#2-如何做到-“对扩展开放、修改关闭”-？" class="headerlink" title="2 如何做到 “对扩展开放、修改关闭” ？"></a>2 如何做到 “对扩展开放、修改关闭” ？</h2><p>举个栗子🌰 一个警告通知系统，通过各种判断是否需要通知。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Alert</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> AlertRule rule;</span><br><span class="line">  <span class="keyword">private</span> Notification notification;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Alert</span><span class="params">(AlertRule rule, Notification notification)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.rule = rule;</span><br><span class="line">    <span class="keyword">this</span>.notification = notification;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(String api, <span class="keyword">long</span> requestCount, <span class="keyword">long</span> errorCount, <span class="keyword">long</span> durationOfSeconds)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> tps = requestCount / durationOfSeconds;</span><br><span class="line">    <span class="keyword">if</span> (tps &gt; rule.getMatchedRule(api).getMaxTps()) &#123;<span class="comment">//TPS 是否超过某个预先设置的最大值</span></span><br><span class="line">      notification.notify(NotificationEmergencyLevel.URGENCY, <span class="string">&quot;...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (errorCount &gt; rule.getMatchedRule(api).getMaxErrorCount()) &#123;<span class="comment">//错误数 是否超过某个预先设置的最大值</span></span><br><span class="line">      notification.notify(NotificationEmergencyLevel.SEVERE, <span class="string">&quot;...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>业务逻辑主要集中在 <code>check()</code> 函数中。现在，如果我们需要添加一个警告功能，当每秒钟接口超时请求个数，超过某个预先设置的最大阈值时，我们也要触发告警发送通知。这个时候，我们该如何改动代码呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Alert</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...省略AlertRule/Notification属性和构造函数...</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 改动一：添加参数timeoutCount</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(String api, <span class="keyword">long</span> requestCount, <span class="keyword">long</span> errorCount, <span class="keyword">long</span> timeoutCount, <span class="keyword">long</span> durationOfSeconds)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> tps = requestCount / durationOfSeconds;</span><br><span class="line">    <span class="keyword">if</span> (tps &gt; rule.getMatchedRule(api).getMaxTps()) &#123;...&#125;<span class="comment">//TPS 是否超过某个预先设置的最大值</span></span><br><span class="line">    <span class="keyword">if</span> (errorCount &gt; rule.getMatchedRule(api).getMaxErrorCount()) &#123;...&#125;<span class="comment">//错误数 是否超过某个预先设置的最大值</span></span><br><span class="line">    <span class="comment">// 改动二：添加接口超时处理逻辑</span></span><br><span class="line">    <span class="keyword">long</span> timeoutTps = timeoutCount / durationOfSeconds;</span><br><span class="line">    <span class="keyword">if</span> (timeoutTps &gt; rule.getMatchedRule(api).getMaxTimeoutTps()) &#123;</span><br><span class="line">      notification.notify(NotificationEmergencyLevel.URGENCY, <span class="string">&quot;...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的代码修改实际上存在挺多问题的。</p><ul><li>一方面，我们对接口进行了修改，这就意味着调用这个接口的代码都要做相应的修改。</li><li>另一方面，修改了 <code>check()</code> 函数，相应的单元测试都需要修改</li></ul><p>这个代码改动是基于 “修改” 的方式来实现新功能的。如果我们遵循开闭原则，也就是 “对扩展开放、对修改关闭” 。那如何通过 “扩展” 的方式，来实现同样的功能呢？</p><p>先重构一下之前的 <code>Alert</code> 代码，让它的扩展性更好一些。重构的内容主要包含两部分：</p><ul><li>第一部分是将 <code>check()</code> 函数的多个入参封装成 <code>ApiStatInfo</code> 类；</li><li>第二部分是引入 <code>handler</code> 的概念，将 if 判断逻辑分散在各个 <code>handler</code> 中。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Alert</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> List&lt;AlertHandler&gt; alertHandlers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAlertHandler</span><span class="params">(AlertHandler alertHandler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.alertHandlers.add(alertHandler);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(ApiStatInfo apiStatInfo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (AlertHandler handler : alertHandlers) &#123;</span><br><span class="line">      handler.check(apiStatInfo);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiStatInfo</span> </span>&#123;<span class="comment">//省略constructor/getter/setter方法</span></span><br><span class="line">  <span class="keyword">private</span> String api;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> requestCount;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> errorCount;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> durationOfSeconds;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AlertHandler</span> </span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> AlertRule rule;</span><br><span class="line">  <span class="keyword">protected</span> Notification notification;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">AlertHandler</span><span class="params">(AlertRule rule, Notification notification)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.rule = rule;</span><br><span class="line">    <span class="keyword">this</span>.notification = notification;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(ApiStatInfo apiStatInfo)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TpsAlertHandler</span> <span class="keyword">extends</span> <span class="title">AlertHandler</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TpsAlertHandler</span><span class="params">(AlertRule rule, Notification notification)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(rule, notification);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(ApiStatInfo apiStatInfo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> tps = apiStatInfo.getRequestCount()/ apiStatInfo.getDurationOfSeconds();</span><br><span class="line">    <span class="keyword">if</span> (tps &gt; rule.getMatchedRule(apiStatInfo.getApi()).getMaxTps()) &#123;<span class="comment">//TPS 是否超过某个预先设置的最大值</span></span><br><span class="line">      notification.notify(NotificationEmergencyLevel.URGENCY, <span class="string">&quot;...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErrorAlertHandler</span> <span class="keyword">extends</span> <span class="title">AlertHandler</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ErrorAlertHandler</span><span class="params">(AlertRule rule, Notification notification)</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(rule, notification);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(ApiStatInfo apiStatInfo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (apiStatInfo.getErrorCount() &gt; rule.getMatchedRule(apiStatInfo.getApi()).getMaxErrorCount()) &#123;<span class="comment">//错误数 是否超过某个预先设置的最大值</span></span><br><span class="line">      notification.notify(NotificationEmergencyLevel.SEVERE, <span class="string">&quot;...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再写一个单例提供配置和使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationContext</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> AlertRule alertRule;</span><br><span class="line">  <span class="keyword">private</span> Notification notification;</span><br><span class="line">  <span class="keyword">private</span> Alert alert;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initializeBeans</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    alertRule = <span class="keyword">new</span> AlertRule(<span class="comment">/*.省略参数.*/</span>); <span class="comment">//省略一些初始化代码</span></span><br><span class="line">    notification = <span class="keyword">new</span> Notification(<span class="comment">/*.省略参数.*/</span>); <span class="comment">//省略一些初始化代码</span></span><br><span class="line">    alert = <span class="keyword">new</span> Alert();<span class="comment">//添加警告方式</span></span><br><span class="line">    alert.addAlertHandler(<span class="keyword">new</span> TpsAlertHandler(alertRule, notification));</span><br><span class="line">    alert.addAlertHandler(<span class="keyword">new</span> ErrorAlertHandler(alertRule, notification));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Alert <span class="title">getAlert</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> alert; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 饿汉式单例</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ApplicationContext instance = <span class="keyword">new</span> ApplicationContext();</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">ApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    instance.initializeBeans();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ApplicationContext <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ApiStatInfo apiStatInfo = <span class="keyword">new</span> ApiStatInfo();</span><br><span class="line">    <span class="comment">// apiStatInfo.setxxx() ...省略设置apiStatInfo数据值的代码</span></span><br><span class="line">    ApplicationContext.getInstance().getAlert().check(apiStatInfo);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果再添加上面的那个新功能，每秒钟接口超时请求个数超过某个最大阈值就告警，我们又该如何改动代码呢？</p><ul><li>第一处改动是：在 <code>ApiStatInfo</code> 类中添加新的属性 <code>timeoutCount</code>。</li><li>第二处改动是：添加新的 <code>TimeoutAlertHander</code> 类。</li><li>第三处改动是：在 <code>ApplicationContext</code> 类的 <code>initializeBeans()</code> 方法中，往 alert 对象中注册新的 <code>timeoutAlertHandler</code>。</li><li>第四处改动是：在使用 <code>Alert</code> 类的时候，需要给 <code>check()</code> 函数的入参 <code>apiStatInfo</code> 对象设置 <code>timeoutCount</code> 的值。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Alert</span> </span>&#123; <span class="comment">// 代码未改动... &#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiStatInfo</span> </span>&#123;<span class="comment">//省略constructor/getter/setter方法</span></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> timeoutCount; <span class="comment">// 改动一：添加新字段</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AlertHandler</span> </span>&#123; <span class="comment">//代码未改动... &#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TpsAlertHandler</span> <span class="keyword">extends</span> <span class="title">AlertHandler</span> </span>&#123;<span class="comment">//代码未改动...&#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErrorAlertHandler</span> <span class="keyword">extends</span> <span class="title">AlertHandler</span> </span>&#123;<span class="comment">//代码未改动...&#125;</span></span><br><span class="line"><span class="comment">// 改动二：添加新的handler</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeoutAlertHandler</span> <span class="keyword">extends</span> <span class="title">AlertHandler</span> </span>&#123;<span class="comment">//省略代码...&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationContext</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initializeBeans</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    alert = <span class="keyword">new</span> Alert();</span><br><span class="line">    alert.addAlertHandler(<span class="keyword">new</span> TpsAlertHandler(alertRule, notification));</span><br><span class="line">    alert.addAlertHandler(<span class="keyword">new</span> ErrorAlertHandler(alertRule, notification));</span><br><span class="line">    <span class="comment">// 改动三：注册handler</span></span><br><span class="line">    alert.addAlertHandler(<span class="keyword">new</span> TimeoutAlertHandler(alertRule, notification));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...省略其他未改动代码...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ApiStatInfo apiStatInfo = <span class="keyword">new</span> ApiStatInfo();</span><br><span class="line">    <span class="comment">// ...省略apiStatInfo的set字段代码</span></span><br><span class="line">    apiStatInfo.setTimeoutCount(<span class="number">289</span>); <span class="comment">// 改动四：设置tiemoutCount值</span></span><br><span class="line">    ApplicationContext.getInstance().getAlert().check(apiStatInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重构之后的代码更加灵活和易扩展。如果我们要想添加新的告警逻辑，只需要基于扩展的方式创建新的 <code>handler</code> 类即可，不需要改动原来的 <code>check()</code> 函数的逻辑。而且，我们只需要为新的 handler 类添加单元测试，老的单元测试都不会失败，也不用修改。</p><h2 id="3-如何在项目中灵活应用开闭原则？"><a href="#3-如何在项目中灵活应用开闭原则？" class="headerlink" title="3 如何在项目中灵活应用开闭原则？"></a>3 如何在项目中灵活应用开闭原则？</h2><p>写出支持 “对扩展开放、对修改关闭” 的代码的关键是预留 <strong>扩展点</strong> 。那问题是如何才能识别出所有可能的扩展点呢？</p><p>要想识别出尽可能多的扩展点，就要对业务有足够的了解，能够知道当下以及未来可能要支持的业务需求。不过，有一句话说得好，“唯一不变的只有变化本身”。即便我们对业务、对系统有足够的了解，那也不可能识别出所有的扩展点，即便你能识别出所有的扩展点，为这些地方都预留扩展点，这样做的成本也是不可接受的。我们没必要为一些遥远的、不一定发生的需求去提前买单，做过度设计。</p><p>而且，开闭原则也并不是免费的。有些情况下，代码的扩展性会跟可读性相冲突。比如，我们之前举的 <code>Alert</code> 报警的例子。为了更好地支持扩展性，我们对代码进行了重构，重构之后的代码要比之前的代码复杂很多，理解起来也更加有难度。</p><p>总之，这里没有一个放之四海而皆准的参考标准，全凭实际的应用场景来决定。</p><hr><h1 id="🚩里氏替换原则"><a href="#🚩里氏替换原则" class="headerlink" title="🚩里氏替换原则"></a>🚩里氏替换原则</h1><p><code>(Liskov Substitution Principle 简称 LSP)</code></p><h2 id="1-如何理解-“里式替换原则”-？"><a href="#1-如何理解-“里式替换原则”-？" class="headerlink" title="1 如何理解 “里式替换原则” ？"></a>1 如何理解 “里式替换原则” ？</h2><p><code>If S is a subtype of T, then objects of type T may be replaced with objects of type S, without breaking the program。</code></p><p><code>Functions that use pointers of references to base classes must be able to use objects of derived classes without knowing it。</code></p><p><code>(子类对象能够替换程序中父类对象出现的任何地方，并且保证原来程序的逻辑行为不变及正确性不被破坏。)</code></p><p>里式替换原则更像是一个多态的规范。里式替换原则是用多态实现的，多态实现的子类不一定符合里式替换原则。</p><h2 id="2-如何做到-“里式替换原则”-？"><a href="#2-如何做到-“里式替换原则”-？" class="headerlink" title="2 如何做到 “里式替换原则” ？"></a>2 如何做到 “里式替换原则” ？</h2><p>举个栗子🌰 子类 <code>SecurityTransporter</code> 继承父类 <code>Transporter</code>，增加了额外的功能，支持传输 <code>appId</code> 和 <code>appToken</code> 安全认证信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Transporter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> HttpClient httpClient;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Transporter</span><span class="params">(HttpClient httpClient)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.httpClient = httpClient;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Response <span class="title">sendRequest</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...use httpClient to send request</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityTransporter</span> <span class="keyword">extends</span> <span class="title">Transporter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String appId;</span><br><span class="line">  <span class="keyword">private</span> String appToken;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SecurityTransporter</span><span class="params">(HttpClient httpClient, String appId, String appToken)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(httpClient);</span><br><span class="line">    <span class="keyword">this</span>.appId = appId;</span><br><span class="line">    <span class="keyword">this</span>.appToken = appToken;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Response <span class="title">sendRequest</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isNotBlank(appId) &amp;&amp; StringUtils.isNotBlank(appToken)) &#123;</span><br><span class="line">      request.addPayload(<span class="string">&quot;app-id&quot;</span>, appId);</span><br><span class="line">      request.addPayload(<span class="string">&quot;app-token&quot;</span>, appToken);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.sendRequest(request);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demoFunction</span><span class="params">(Transporter transporter)</span> </span>&#123;    </span><br><span class="line">    Reuqest request = <span class="keyword">new</span> Request();</span><br><span class="line">    <span class="comment">//...省略设置request中数据值的代码...</span></span><br><span class="line">    Response response = transporter.sendRequest(request);</span><br><span class="line">    <span class="comment">//...省略其他逻辑...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 里式替换原则</span></span><br><span class="line">Demo demo = <span class="keyword">new</span> Demo();</span><br><span class="line">demo.demofunction(<span class="keyword">new</span> SecurityTransporter(<span class="comment">/*省略参数*/</span>););</span><br></pre></td></tr></table></figure><p>在上面的代码中，子类 SecurityTransporter 的设计完全符合里式替换原则，可以替换父类出现的任何位置，并且原来代码的逻辑行为不变且正确性也没有被破坏。</p><p>如果我们对 <code>SecurityTransporter</code> 类中 <code>sendRequest()</code> 函数稍加改造一下。改造前，如果 <code>appId</code> 或者 <code>appToken</code> 没有设置，我们就不做校验；改造后，如果 <code>appId</code> 或者 <code>appToken</code> 没有设置，则直接抛出 <code>NoAuthorizationRuntimeException</code> 未授权异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 改造后：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityTransporter</span> <span class="keyword">extends</span> <span class="title">Transporter</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...省略其他代码..</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Response <span class="title">sendRequest</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(appId) || StringUtils.isBlank(appToken)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoAuthorizationRuntimeException(...);</span><br><span class="line">    &#125;</span><br><span class="line">    request.addPayload(<span class="string">&quot;app-id&quot;</span>, appId);</span><br><span class="line">    request.addPayload(<span class="string">&quot;app-token&quot;</span>, appToken);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.sendRequest(request);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在改造之后的代码中，如果传递进 <code>demoFunction()</code> 函数的是父类 <code>Transporter</code> 对象，那 <code>demoFunction()</code> 函数并不会有异常抛出。<br>但如果传递给 <code>demoFunction()</code> 函数的是子类 <code>SecurityTransporter</code> 对象，那 <code>demoFunction()</code> 有可能会有异常抛出。<br>子类替换父类传递进 <code>demoFunction</code> 函数之后，整个程序的逻辑行为有了改变。这样就违背了里式替换原则，但是他还是由多态实现的。</p><p>多态 和 里式替换 有点类似，但它们关注的角度是不一样的。<br>多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法。它是一种代码实现的思路。<br>而里式替换是一种设计原则，是用来指导继承关系中子类该如何设计的，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑以及不破坏原有程序的正确性。</p><h2 id="3-哪些代码明显违背了-LSP？"><a href="#3-哪些代码明显违背了-LSP？" class="headerlink" title="3 哪些代码明显违背了 LSP？"></a>3 哪些代码明显违背了 LSP？</h2><ul><li><p>子类违背父类声明要实现的功能</p><p>父类中提供的 <code>sortOrdersByAmount()</code> 订单排序函数，是按照金额从小到大来给订单排序的，而子类重写这个 <code>sortOrdersByAmount()</code> 订单排序函数之后，是按照创建日期来给订单排序的。那子类的设计就违背里式替换原则。</p></li><li><p>子类违背父类对输入、输出、异常的约定</p><p>在父类中，某个函数约定：运行出错的时候返回 <code>null</code>；获取数据为空的时候返回空集合 <code>（empty collection）</code> 。而子类重载函数之后，实现变了，运行出错返回异常 <code>（exception）</code> ，获取不到数据返回 <code>null</code> 。那子类的设计就违背里式替换原则。</p><p>在父类中，某个函数约定，输入数据可以是任意整数，但子类实现的时候，只允许输入数据是正整数，负数就抛出，也就是说，子类对输入的数据的校验比父类更加严格，那子类的设计就违背了里式替换原则。</p><p>在父类中，某个函数约定，只会抛出 <code>ArgumentNullException</code> 异常，那子类的设计实现中只允许抛出 <code>ArgumentNullException</code> 异常，任何其他异常的抛出，都会导致子类违背里式替换原则。</p></li><li><p>子类违背父类注释中所罗列的任何特殊说明</p><p>父类中定义的 <code>withdraw()</code> 提现函数的注释是这么写的：“用户的提现金额不得超过账户余额……”，而子类重写 <code>withdraw()</code> 函数之后，针对 <code>VIP</code> 账号实现了透支提现的功能，也就是提现金额可以大于账户余额，那这个子类的设计也是不符合里式替换原则的。</p></li></ul><hr><h1 id="🚩接口隔离原则"><a href="#🚩接口隔离原则" class="headerlink" title="🚩接口隔离原则"></a>🚩接口隔离原则</h1><p><code>(Interface Segregation Principle 简称 ISP)</code></p><h2 id="1-如何理解-“接口隔离原则”-？"><a href="#1-如何理解-“接口隔离原则”-？" class="headerlink" title="1 如何理解 “接口隔离原则” ？"></a>1 如何理解 “接口隔离原则” ？</h2><p><code>Clients should not be forced to depend upon interfaces that they do not use (客户端不应该被强迫依赖它不需要的接口。其中的“客户端”，可以理解为接口的调用者或者使用者)</code></p><p>在这条原则中，我们可以把“接口”理解为下面三种东西：</p><ul><li>一组 <code>API</code> 接口集合</li><li>单个 <code>API</code> 接口或函数</li><li><code>OOP</code> 中的接口概念</li></ul><h2 id="2-如何做到-“接口隔离原则”-？"><a href="#2-如何做到-“接口隔离原则”-？" class="headerlink" title="2 如何做到 “接口隔离原则” ？"></a>2 如何做到 “接口隔离原则” ？</h2><ul><li>一组 <code>API</code> 接口集合</li></ul><p>微服务用户系统提供了一组跟用户相关的 <code>API</code> 给其他系统使用，比如：注册、登录、获取用户信息等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">register</span><span class="params">(String cellphone, String password)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">login</span><span class="params">(String cellphone, String password)</span></span>;</span><br><span class="line">  <span class="function">UserInfo <span class="title">getUserInfoById</span><span class="params">(<span class="keyword">long</span> id)</span></span>;</span><br><span class="line">  <span class="function">UserInfo <span class="title">getUserInfoByCellphone</span><span class="params">(String cellphone)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们的后台管理系统要实现删除用户的功能，希望用户系统提供一个删除用户的接口。</p><p>删除用户是一个非常慎重的操作，我们只希望通过后台管理系统来执行，所以这个接口只限于给后台管理系统使用。如果我们把它放到 <code>UserService</code> 中，那所有使用到 <code>UserService</code> 的系统，都可以调用这个接口。不加限制地被其他业务系统调用，就有可能导致误删用户。</p><p>我们参照接口隔离原则，调用者不应该强迫依赖它不需要的接口，将删除接口单独放到另外一个接口 <code>RestrictedUserService</code> 中，然后将 <code>RestrictedUserService</code> 只打包提供给后台管理系统来使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RestrictedUserService</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">deleteUserByCellphone</span><span class="params">(String cellphone)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">deleteUserById</span><span class="params">(<span class="keyword">long</span> id)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span>, <span class="title">RestrictedUserService</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...省略实现代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在刚刚的这个例子中，我们把接口隔离原则中的接口，理解为一组接口集合，它可以是某个微服务的接口，也可以是某个类库的接口等等。</p><ul><li>单个 <code>API</code> 接口或函数</li></ul><p>把接口理解为单个接口或函数，那接口隔离原则就可以理解为：函数的设计要功能单一，不要将多个不同的功能逻辑在一个函数中实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Statistics</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Long max;</span><br><span class="line">  <span class="keyword">private</span> Long min;</span><br><span class="line">  <span class="keyword">private</span> Long average;</span><br><span class="line">  <span class="keyword">private</span> Long sum;</span><br><span class="line">  <span class="keyword">private</span> Long percentile99;</span><br><span class="line">  <span class="keyword">private</span> Long percentile999;</span><br><span class="line">  <span class="comment">//...省略constructor/getter/setter等方法...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Statistics <span class="title">count</span><span class="params">(Collection&lt;Long&gt; dataSet)</span> </span>&#123;</span><br><span class="line">  Statistics statistics = <span class="keyword">new</span> Statistics();</span><br><span class="line">  <span class="comment">//...省略计算逻辑 求最大值、最小值、平均值...</span></span><br><span class="line">  <span class="keyword">return</span> statistics;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照接口隔离原则，我们应该把 <code>count()</code>  函数拆成几个更小粒度的函数，每个函数负责一个独立的统计功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">max</span><span class="params">(Collection&lt;Long&gt; dataSet)</span> </span>&#123; <span class="comment">//... &#125;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">min</span><span class="params">(Collection&lt;Long&gt; dataSet)</span> </span>&#123; <span class="comment">//... &#125; </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">average</span><span class="params">(Colletion&lt;Long&gt; dataSet)</span> </span>&#123; <span class="comment">//... &#125;</span></span><br><span class="line"><span class="comment">// ...省略其他统计函数...</span></span><br></pre></td></tr></table></figure><p>在某种意义上讲，<code>count()</code> 函数也不能算是职责不够单一，毕竟它做的事情只跟统计相关。判定功能是否单一，除了很强的主观性，还需要结合具体的场景。</p><p>如果在项目中，对每个统计需求，<code>Statistics</code> 定义的那几个统计信息都有涉及，那 <code>count()</code> 函数的设计就是合理的。如果每个统计需求只涉及 <code>Statistics</code> 罗列的统计信息中一部分，就会做很多无用功，势必影响代码的性能，特别是在需要统计的数据量很大的时候。<code>count()</code> 函数的设计就有点不合理了。</p><ul><li><code>OOP</code> 中的接口概念</li></ul><p>我们还可以把“接口”理解为 <code>OOP</code> 中的接口概念，比如 <code>Java</code> 中的 <code>interface</code>。</p><p>举个栗子🌰 假设我们的项目中用到了三个外部系统：<code>Redis</code>、<code>MySQL</code>、<code>Kafka</code>。每个系统都对应一系列配置信息，比如地址、端口、访问超时时间等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ConfigSource configSource; <span class="comment">//配置中心（比如zookeeper）</span></span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> timeout;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxTotal;</span><br><span class="line">    <span class="comment">//省略其他配置: maxWaitMillis,maxIdle,minIdle...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedisConfig</span><span class="params">(ConfigSource configSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.configSource = configSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.address;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...省略其他get()、init()方法...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//从configSource加载配置到address/timeout/maxTotal...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaConfig</span> </span>&#123; <span class="comment">//...省略... &#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MysqlConfig</span> </span>&#123; <span class="comment">//...省略... &#125;</span></span><br></pre></td></tr></table></figure><p>现在，我们有一个新的功能需求，以固定时间频率（<code>periodInSeconds</code>）来调用 <code>RedisConfig</code>、<code>KafkaConfig</code> 的 <code>update()</code> 方法更新配置信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Updater</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> <span class="title">implemets</span> <span class="title">Updater</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...省略其他属性和方法...</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123; <span class="comment">//... &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaConfig</span> <span class="keyword">implements</span> <span class="title">Updater</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...省略其他属性和方法...</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123; <span class="comment">//... &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MysqlConfig</span> </span>&#123; <span class="comment">//...省略其他属性和方法... &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledUpdater</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> initialDelayInSeconds;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> periodInSeconds;</span><br><span class="line">    <span class="keyword">private</span> Updater updater;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ScheduleUpdater</span><span class="params">(Updater updater, <span class="keyword">long</span> initialDelayInSeconds, <span class="keyword">long</span> periodInSeconds)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.updater = updater;</span><br><span class="line">        <span class="keyword">this</span>.initialDelayInSeconds = initialDelayInSeconds;</span><br><span class="line">        <span class="keyword">this</span>.periodInSeconds = periodInSeconds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        executor.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                updater.update();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="keyword">this</span>.initialDelayInSeconds, <span class="keyword">this</span>.periodInSeconds, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">  ConfigSource configSource = <span class="keyword">new</span> ZookeeperConfigSource(<span class="comment">/*省略参数*/</span>);</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> RedisConfig redisConfig = <span class="keyword">new</span> RedisConfig(configSource);</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> KafkaConfig kafkaConfig = <span class="keyword">new</span> KakfaConfig(configSource);</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> MySqlConfig mysqlConfig = <span class="keyword">new</span> MysqlConfig(configSource);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ScheduledUpdater redisConfigUpdater = <span class="keyword">new</span> ScheduledUpdater(redisConfig, <span class="number">300</span>, <span class="number">300</span>);</span><br><span class="line">    redisConfigUpdater.run();</span><br><span class="line">    </span><br><span class="line">    ScheduledUpdater kafkaConfigUpdater = <span class="keyword">new</span> ScheduledUpdater(kafkaConfig, <span class="number">60</span>, <span class="number">60</span>);</span><br><span class="line">    redisConfigUpdater.run();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新的 <code>ScheduledUpdater</code> 类，只依赖 <code>Updater</code> 这个相关的接口，不需要被强迫去依赖不需要的 <code>Viewer</code> 接口，满足接口隔离原则。功能是定时调用传入的 <code>Updater</code> 的 <code>update</code>  方法。</p><p>现在，我们又有了一个新的监控功能需求。我们想暴露 <code>MySQL</code> 和 <code>Redis</code> 的配置信息，输出项目的配置信息到一个固定的 HTTP 地址。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Viewer</span> </span>&#123;</span><br><span class="line">  <span class="function">String <span class="title">outputInPlainText</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">Map&lt;String, String&gt; <span class="title">output</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> <span class="title">implemets</span> <span class="title">Updater</span>, <span class="title">Viewer</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...省略其他属性和方法...</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123; <span class="comment">//... &#125;</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">outputInPlainText</span><span class="params">()</span> </span>&#123; <span class="comment">//... &#125;</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title">output</span><span class="params">()</span> </span>&#123; <span class="comment">//...&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaConfig</span> <span class="keyword">implements</span> <span class="title">Updater</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...省略其他属性和方法...</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123; <span class="comment">//... &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MysqlConfig</span> <span class="keyword">implements</span> <span class="title">Viewer</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...省略其他属性和方法...</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">outputInPlainText</span><span class="params">()</span> </span>&#123; <span class="comment">//... &#125;</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title">output</span><span class="params">()</span> </span>&#123; <span class="comment">//...&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleHttpServer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String host;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line">  <span class="keyword">private</span> Map&lt;String, List&lt;Viewer&gt;&gt; viewers = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SimpleHttpServer</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;<span class="comment">//...&#125;</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addViewers</span><span class="params">(String urlDirectory, Viewer viewer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!viewers.containsKey(urlDirectory)) &#123;</span><br><span class="line">      viewers.put(urlDirectory, <span class="keyword">new</span> ArrayList&lt;Viewer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.viewers.get(urlDirectory).add(viewer);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="comment">//... &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    ConfigSource configSource = <span class="keyword">new</span> ZookeeperConfigSource();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> RedisConfig redisConfig = <span class="keyword">new</span> RedisConfig(configSource);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> KafkaConfig kafkaConfig = <span class="keyword">new</span> KakfaConfig(configSource);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> MySqlConfig mysqlConfig = <span class="keyword">new</span> MySqlConfig(configSource);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ScheduledUpdater redisConfigUpdater =<span class="keyword">new</span> ScheduledUpdater(redisConfig, <span class="number">300</span>, <span class="number">300</span>);</span><br><span class="line">        redisConfigUpdater.run();</span><br><span class="line">        </span><br><span class="line">        ScheduledUpdater kafkaConfigUpdater =<span class="keyword">new</span> ScheduledUpdater(kafkaConfig, <span class="number">60</span>, <span class="number">60</span>);</span><br><span class="line">        kafkaConfigUpdater.run();</span><br><span class="line">        </span><br><span class="line">        SimpleHttpServer simpleHttpServer = <span class="keyword">new</span> SimpleHttpServer(“<span class="number">127.0</span>.<span class="number">0.1</span>”, <span class="number">2389</span>);</span><br><span class="line">        simpleHttpServer.addViewer(<span class="string">&quot;/config&quot;</span>, redisConfig);</span><br><span class="line">        simpleHttpServer.addViewer(<span class="string">&quot;/config&quot;</span>, mysqlConfig);</span><br><span class="line">        simpleHttpServer.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SimpleHttpServer</code> 只依赖跟查看信息相关的 <code>Viewer</code> 接口，不依赖不需要的 <code>Updater</code> 接口，也满足接口隔离原则。</p><p>这种方式比普通大而全的 <code>Config</code> 接口更加灵活、易扩展、易复用，因为 <code>Updater</code>、<code>Viewer</code> 职责更加单一，添加新需求也容易应对。同时也防止了重写无用的接口，可读性更高。</p><h2 id="3-接口隔离原则与单一职责原则的区别"><a href="#3-接口隔离原则与单一职责原则的区别" class="headerlink" title="3 接口隔离原则与单一职责原则的区别"></a>3 接口隔离原则与单一职责原则的区别</h2><p>单一职责原则针对的是模块、类、接口的设计。</p><p>接口隔离原则相对于单一职责原则，一方面更侧重于接口的设计，另一方面它的思考角度也是不同的。</p><p>接口隔离原则提供了一种判断接口的职责是否单一的标准：通过调用者如何使用接口来间接地判定。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。</p><hr><h1 id="🚩依赖反转原则"><a href="#🚩依赖反转原则" class="headerlink" title="🚩依赖反转原则"></a>🚩依赖反转原则</h1><p>在讲 “依赖反转原则 <code>(Dependency Inversion Principe 简称 DIP)</code>” 之前，我们先讲一讲基础知识。</p><h2 id="1-控制反转"><a href="#1-控制反转" class="headerlink" title="1 控制反转"></a>1 控制反转</h2><p><code>（ Inversion Of Control IOC）</code></p><p>这里的 ”控制” 指的是对程序执行流程的控制，而 “反转” 指的是在没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流程可以通过框架来控制。流程的控制权从程序员 “反转” 到了框架。</p><p>举个栗子🌰 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">doTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;<span class="comment">//这部分逻辑可以放到框架中</span></span><br><span class="line">    <span class="keyword">if</span> (doTest()) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Test succeed.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Test failed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，所有的流程都由程序员来控制。我们再来看，如何利用 ”控制反转“ 来实现同样的功能。</p><p>首先是框架代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCase</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (doTest()) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Test succeed.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Test failed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">doTest</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JunitApplication</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;TestCase&gt; testCases = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(TestCase testCase)</span> </span>&#123;</span><br><span class="line">    testCases.add(testCase);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (TestCase <span class="keyword">case</span>: testCases) &#123;</span><br><span class="line">      <span class="keyword">case</span>.run();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>我们只需要在框架预留的扩展点，也就是 <code>TestCase</code> 类中的 <code>doTest()</code> 抽象函数中，填充具体的测试代码就可以实现之前的功能了，完全不需要写负责执行流程的 <code>main()</code> 函数了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceTest</span> <span class="keyword">extends</span> <span class="title">TestCase</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">doTest</span><span class="params">()</span> </span>&#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册操作还可以通过配置的方式来实现，不需要程序员显示调用register()</span></span><br><span class="line">JunitApplication.register(<span class="keyword">new</span> UserServiceTest();</span><br></pre></td></tr></table></figure><p>这就是典型的通过框架来实现 “控制反转” 的例子。</p><p>框架提供了一个可扩展的代码骨架，用来组装对象、管理整个执行流程。<br>程序员利用框架进行开发的时候，只需要往预留的扩展点上，添加跟自己业务相关的代码，就可以利用框架来驱动整个程序流程的执行。</p><p>控制反转并不是一种具体的实现技巧，而是一个比较笼统的设计思想，一般用来指导框架层面的设计。</p><h2 id="2-依赖注入"><a href="#2-依赖注入" class="headerlink" title="2 依赖注入"></a>2 依赖注入</h2><p><code>（Dependency Injection DI）</code></p><p>有一个非常形象的说法，那就是：依赖注入是一个标价 <code>25</code> 美元，实际上只值 <code>5</code> 美分的概念。也就是说，这个概念听起来很 “高大上” ，实际上，理解、应用起来非常简单。</p><p>那到底什么是依赖注入呢？<br>我们用一句话来概括就是：不通过 <code>new()</code> 的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类使用。</p><p>举个栗子🌰 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Notification</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> MessageSender messageSender;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 通过构造函数将messageSender传递进来</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Notification</span><span class="params">(MessageSender messageSender)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.messageSender = messageSender;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String cellphone, String message)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...省略校验逻辑等...</span></span><br><span class="line">    <span class="keyword">this</span>.messageSender.send(cellphone, message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用Notification</span></span><br><span class="line">MessageSender messageSender = <span class="keyword">new</span> MessageSender();</span><br><span class="line">Notification notification = <span class="keyword">new</span> Notification(messageSender);</span><br></pre></td></tr></table></figure><p>通过依赖注入的方式来将依赖的类对象传递进来，这样就提高了代码的扩展性，我们可以灵活地替换依赖的类。</p><p>这一点在我们之前讲 “开闭原则” 的时候也提到过。</p><p>上面代码还有继续优化的空间，我们还可以把 MessageSender 定义成接口，<strong>基于接口而非实现编程</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Notification</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> MessageSender messageSender;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Notification</span><span class="params">(MessageSender messageSender)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.messageSender = messageSender;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String cellphone, String message)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.messageSender.send(cellphone, message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MessageSender</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(String cellphone, String message)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 短信发送类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsSender</span> <span class="keyword">implements</span> <span class="title">MessageSender</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String cellphone, String message)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 站内信发送类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InboxSender</span> <span class="keyword">implements</span> <span class="title">MessageSender</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String cellphone, String message)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用Notification</span></span><br><span class="line">MessageSender messageSender = <span class="keyword">new</span> SmsSender();</span><br><span class="line">Notification notification = <span class="keyword">new</span> Notification(messageSender);</span><br></pre></td></tr></table></figure><p>依赖注入非常简单，但却非常有用！！它是编写可测试性代码最有效的手段。</p><p><strong>“基于接口而非实现编程” 跟 “依赖注入” ，看起来非常类似，那它俩有什么区别和联系呢？</strong></p><p>二者都是从外部传入依赖对象而不是在内部去 <code>new</code> 一个出来。</p><p>区别是 “基于接口而非实现编程” 强调的是 “接口” ，强调依赖的对象是接口，而不是具体的实现类；而 “依赖注入” 不强调这个，类或接口都可以，只要是从外部传入不是在内部 <code>new</code> 出来都可以称为依赖注入。</p><h2 id="3-依赖反转原则"><a href="#3-依赖反转原则" class="headerlink" title="3 依赖反转原则"></a>3 依赖反转原则</h2><p><code>（Dependency Inversion Principle DIP）</code></p><p><code>High-level modules shouldn’t depend on low-level modules. Both modules should depend on abstractions. In addition, abstractions shouldn’t depend on details. Details depend on abstractions. (高层模块（high-level modules）不要依赖低层模块（low-level）。高层模块和低层模块应该通过抽象（abstractions）来互相依赖。除此之外，抽象（abstractions）不要依赖具体实现细节（details），具体实现细节（details）依赖抽象（abstractions）。)</code></p><p>所谓高层模块和低层模块的划分，简单来说就是，在调用链上，<strong>调用者</strong> 属于高层，<strong>被调用者</strong> 属于低层。</p><p>依赖反转原则也叫作依赖倒置原则。这条原则跟控制反转有点类似，主要用来指导框架层面的设计。</p><p>举个栗子🌰 </p><p><code>Tomcat</code> 是运行 <code>Java Web</code> 应用程序的容器。<br>我们编写的 <code>Web</code> 应用程序代码只需要部署在 <code>Tomcat</code> 容器下，便可以被 <code>Tomcat</code> 容器调用执行。按照之前的划分原则，<code>Tomcat</code> 就是高层模块，我们编写的 <code>Web</code> 应用程序代码就是低层模块。<code>Tomcat</code> 和应用程序代码之间并没有直接的依赖关系，两者都依赖同一个 “抽象” ，也就是 <code>Servlet</code> 规范。<code>Servlet</code> 规范不依赖具体的 <code>Tomcat</code> 容器和应用程序的实现细节，而 <code>Tomcat</code> 容器和应用程序依赖 <code>Servlet</code> 规范。</p><hr><h1 id="🚩KISS-原则"><a href="#🚩KISS-原则" class="headerlink" title="🚩KISS 原则"></a>🚩KISS 原则</h1><p><code>Keep It Simple and Stupid.</code>  </p><p><code>Keep It Short and Simple.</code>   </p><p><code>Keep It Simple and Straightforward.</code> </p><p><code>(尽量保持简单。)</code></p><p>代码的可读性和可维护性是衡量代码质量非常重要的两个标准。而 <code>KISS</code> 原则就是保持代码可读和可维护的重要手段。代码足够简单，也就意味着很容易读懂，<code>bug</code> 比较难隐藏。即便出现 <code>bug</code>，修复起来也比较简单。</p><h2 id="1-代码行数越少就越“简单”吗？"><a href="#1-代码行数越少就越“简单”吗？" class="headerlink" title="1 代码行数越少就越“简单”吗？"></a>1 代码行数越少就越“简单”吗？</h2><p>举几个栗子🌰 对比一下。 检查输入的字符串 <code>ipAddress</code> 是否是合法的 IP 地址。一个合法的 <code>IP</code> 地址由四个数字组成，并且通过 “.” 来进行分割。每组数字的取值范围是 <code>0~255</code>。第一组数字比较特殊，不允许为 <code>0</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种实现方式: 使用正则表达式</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidIpAddressV1</span><span class="params">(String ipAddress)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (StringUtils.isBlank(ipAddress)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  String regex = <span class="string">&quot;^(1\\d&#123;2&#125;|2[0-4]\\d|25[0-5]|[1-9]\\d|[1-9])\\.&quot;</span></span><br><span class="line">          + <span class="string">&quot;(1\\d&#123;2&#125;|2[0-4]\\d|25[0-5]|[1-9]\\d|\\d)\\.&quot;</span></span><br><span class="line">          + <span class="string">&quot;(1\\d&#123;2&#125;|2[0-4]\\d|25[0-5]|[1-9]\\d|\\d)\\.&quot;</span></span><br><span class="line">          + <span class="string">&quot;(1\\d&#123;2&#125;|2[0-4]\\d|25[0-5]|[1-9]\\d|\\d)$&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> ipAddress.matches(regex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种实现方式: 使用现成的工具类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidIpAddressV2</span><span class="params">(String ipAddress)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (StringUtils.isBlank(ipAddress)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  String[] ipUnits = StringUtils.split(ipAddress, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (ipUnits.length != <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> ipUnitIntValue;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      ipUnitIntValue = Integer.parseInt(ipUnits[i]);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ipUnitIntValue &lt; <span class="number">0</span> || ipUnitIntValue &gt; <span class="number">255</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; ipUnitIntValue == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三种实现方式: 不使用任何工具类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidIpAddressV3</span><span class="params">(String ipAddress)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span>[] ipChars = ipAddress.toCharArray();</span><br><span class="line">  <span class="keyword">int</span> length = ipChars.length;</span><br><span class="line">  <span class="keyword">int</span> ipUnitIntValue = -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">boolean</span> isFirstUnit = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">int</span> unitsCount = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">    <span class="keyword">char</span> c = ipChars[i];</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (ipUnitIntValue &lt; <span class="number">0</span> || ipUnitIntValue &gt; <span class="number">255</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (isFirstUnit &amp;&amp; ipUnitIntValue == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (isFirstUnit) isFirstUnit = <span class="keyword">false</span>;</span><br><span class="line">      ipUnitIntValue = -<span class="number">1</span>;</span><br><span class="line">      unitsCount++;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ipUnitIntValue == -<span class="number">1</span>) ipUnitIntValue = <span class="number">0</span>;</span><br><span class="line">    ipUnitIntValue = ipUnitIntValue * <span class="number">10</span> + (c - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (ipUnitIntValue &lt; <span class="number">0</span> || ipUnitIntValue &gt; <span class="number">255</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (unitsCount != <span class="number">3</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>第一种实现方式利用的是正则表达式<br>只用三行代码就把这个问题搞定了。它的代码行数最少，那是不是就最符合 KISS 原则呢？答案是否定的。虽然代码行数最少，看似最简单，实际上却很复杂。这正是因为它使用了正则表达式。</p><p>一方面，正则表达式本身是比较复杂的，写出完全没有 <code>bug</code> 的正则表达本身就比较有挑战；另一方面，并不是每个程序员都精通正则表达式。这种实现方式会导致代码的可读性和可维护性变差，所以，从 <code>KISS</code> 原则的设计初衷上来讲，这种实现方式并不符合 <code>KISS</code> 原则。</p></li><li><p>第二种实现方式使用了 <code>StringUtils</code> 类、<code>Integer</code> 类提供的一些现成的工具函数处理 <code>IP</code> 地址字符串。</p></li><li><p>第三种实现方式，不使用任何工具函数，而是通过逐一处理 <code>IP</code> 地址中的字符，来判断是否合法。</p><p>第三种实现方式完全是自己操作底层字符，只针对 <code>IP</code> 地址这一种格式的数据输入来做处理，没有太多多余的函数调用和其他不必要的处理逻辑，所以，在执行效率上，这种类似定制化的处理代码方式肯定比通用的工具类要高些。</p><p>从性能上来说，尽管第三种实现方式性能更高些，但还是更倾向于选择第二种实现方法。那是因为第三种实现方式实际上是一种过度优化。除非 <code>isValidIpAddress()</code> 函数是影响系统性能的瓶颈代码，否则，这样优化的投入产出比并不高，增加了代码实现的难度、牺牲了代码的可读性，性能上的提升却并不明显。</p><p>从代码行数上来说，这两种方式差不多。但是，第三种要比第二种更加有难度，更容易写出 <code>bug</code>。</p><p>从可读性上来说，第二种实现方式的代码逻辑更清晰、更好理解。</p><p>所以，在这两种实现方式中，第二种实现方式更加 “简单” ，更加符合 <code>KISS</code> 原则。</p></li></ul><h2 id="2-代码逻辑复杂就违背-KISS-原则吗？"><a href="#2-代码逻辑复杂就违背-KISS-原则吗？" class="headerlink" title="2 代码逻辑复杂就违背 KISS 原则吗？"></a>2 代码逻辑复杂就违背 KISS 原则吗？</h2><p>刚刚我们提到，并不是代码行数越少就越“简单”，还要考虑逻辑复杂度、实现难度、代码的可读性等。那如果一段代码的逻辑复杂、实现难度大、可读性也不太好，是不是就一定违背 <code>KISS</code> 原则呢？其实这也是由业务场景决定的。举个栗子🌰 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// KMP algorithm: a, b分别是主串和模式串；n, m分别是主串和模式串的长度。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kmp</span><span class="params">(<span class="keyword">char</span>[] a, <span class="keyword">int</span> n, <span class="keyword">char</span>[] b, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[] next = getNexts(b, m);</span><br><span class="line">  <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; a[i] != b[j]) &#123; <span class="comment">// 一直找到a[i]和b[j]</span></span><br><span class="line">      j = next[j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a[i] == b[j]) &#123;</span><br><span class="line">      ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j == m) &#123; <span class="comment">// 找到匹配模式串的了</span></span><br><span class="line">      <span class="keyword">return</span> i - m + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b表示模式串，m表示模式串的长度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getNexts(<span class="keyword">char</span>[] b, <span class="keyword">int</span> m) &#123;</span><br><span class="line">  <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">  next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> k = -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">    <span class="keyword">while</span> (k != -<span class="number">1</span> &amp;&amp; b[k + <span class="number">1</span>] != b[i]) &#123;</span><br><span class="line">      k = next[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (b[k + <span class="number">1</span>] == b[i]) &#123;</span><br><span class="line">      ++k;</span><br><span class="line">    &#125;</span><br><span class="line">    next[i] = k;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一段 <code>KMP</code> 字符串匹配算法，它以快速高效著称。<code>KMP</code> 字符串匹配算法完全符合我们刚提到的逻辑复杂、实现难度大、可读性差的特点，但当我们需要处理长文本字符串匹配问题（几百 <code>MB</code> 大小文本内容的匹配），或者字符串匹配是某个产品的核心功能（比如 <code>Vim</code>、<code>Word</code> 等文本编辑器），又或者字符串匹配算法是系统性能瓶颈的时候，这时它并不违反 <code>KISS</code> 原则。</p><p>本身就复杂的问题，用复杂的方法解决，并不违背 <code>KISS</code> 原则。</p><p>不过，平时的项目开发中涉及的字符串匹配问题，大部分都是针对比较小的文本。在这种情况下，直接调用编程语言提供的现成的字符串匹配函数就足够了。如果非得用 <code>KMP</code> 算法、BM 算法来实现字符串匹配，那就真的违背 <code>KISS</code> 原则了。</p><p>也就是说，同样的代码，在某个业务场景下满足 <code>KISS</code> 原则，换一个应用场景可能就不满足了。</p><h2 id="3-如何写出满足-KISS-原则的代码？"><a href="#3-如何写出满足-KISS-原则的代码？" class="headerlink" title="3 如何写出满足 KISS 原则的代码？"></a>3 如何写出满足 KISS 原则的代码？</h2><ul><li>不要使用同事可能不懂的技术来实现代码。比如前面例子中的正则表达式，还有一些编程语言中过于高级的语法等。</li><li>不要重复造轮子，要善于使用已经有的工具类库。经验证明，自己去实现这些类库，出 <code>bug</code> 的概率会更高，维护的成本也比较高。</li><li>不要过度优化。不要过度使用一些奇技淫巧（比如，位运算代替算术运算、复杂的条件语句代替 <code>if-else</code>、使用一些过于底层的函数等）来优化代码，牺牲代码的可读性。</li></ul><p>评判代码是否简单，有一个很有效的间接方法，那就是 <code>code review</code>。如果在 <code>code review</code> 的时候，同事对你的代码有很多疑问，那就说明你的代码有可能不够 “简单” ，需要优化啦。</p><p>我们在做开发的时候，一定不要过度设计，不要觉得简单的东西就没有技术含量。实际上，越是能用简单的方法解决复杂的问题，越能体现一个人的能力。</p><h2 id="4-YAGNI-原则跟-KISS-原则说的是一回事吗？"><a href="#4-YAGNI-原则跟-KISS-原则说的是一回事吗？" class="headerlink" title="4 YAGNI 原则跟 KISS 原则说的是一回事吗？"></a>4 YAGNI 原则跟 KISS 原则说的是一回事吗？</h2><p><code>You Ain’t Gonna Need It(你不会需要它)</code> </p><p>不要去设计当前用不到的功能；不要去编写当前用不到的代码。实际上，这条原则的核心思想就是：不要做过度设计。</p><p>对于 <code>Java</code> 程序员来说，我们经常使用 <code>Maven</code> 或者 <code>Gradle</code> 来管理依赖的类库（<code>library</code>），有些同事为了避免开发中 <code>library</code> 包缺失而频繁地修改 <code>Maven</code> 或者 <code>Gradle</code> 配置文件，提前往项目里引入大量常用的 <code>library</code> 包。实际上，这样的做法也是违背 YAGNI 原则的。</p><p><code>KISS</code> 原则讲的是 “如何做” 的问题（尽量保持简单），而 <code>YAGNI</code> 原则说的是 “要不要做” 的问题（当前不需要的就不要做）。</p><hr><h1 id="🚩DRY-原则"><a href="#🚩DRY-原则" class="headerlink" title="🚩DRY 原则"></a>🚩DRY 原则</h1><p><code>Don’t Repeat Yourself(不要重复自己)</code> </p><p>可以理解为：不要写重复的代码。</p><p>你可能会觉得，这条原则非常简单、非常容易应用。只要两段代码长得一样，那就是违反 <code>DRY</code> 原则了。真的是这样吗？<br>答案是否定的。这是很多人对这条原则存在的误解。实际上，重复的代码不一定违反 <code>DRY</code> 原则，而且有些看似不重复的代码也有可能违反 <code>DRY</code> 原则。</p><h2 id="1-实现逻辑重复"><a href="#1-实现逻辑重复" class="headerlink" title="1 实现逻辑重复"></a>1 实现逻辑重复</h2><p>举个栗子🌰 有两处非常明显的重复的代码片段：<code>isValidUserName()</code> 函数和 <code>isValidPassword()</code> 函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserAuthenticator</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">authenticate</span><span class="params">(String username, String password)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isValidUsername(username)) &#123;</span><br><span class="line">      <span class="comment">// ...throw InvalidUsernameException...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isValidPassword(password)) &#123;</span><br><span class="line">      <span class="comment">// ...throw InvalidPasswordException...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...省略其他代码...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValidUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// check not null, not empty</span></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(username)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// check length: 4~64</span></span><br><span class="line">    <span class="keyword">int</span> length = username.length();</span><br><span class="line">    <span class="keyword">if</span> (length &lt; <span class="number">4</span> || length &gt; <span class="number">64</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// contains only lowcase characters</span></span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.isAllLowerCase(username)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// contains only a~z,0~9,dot</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">      <span class="keyword">char</span> c = username.charAt(i);</span><br><span class="line">      <span class="keyword">if</span> (!(c &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;z&#x27;</span>) || (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) || c == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValidPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// check not null, not empty</span></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(password)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// check length: 4~64</span></span><br><span class="line">    <span class="keyword">int</span> length = password.length();</span><br><span class="line">    <span class="keyword">if</span> (length &lt; <span class="number">4</span> || length &gt; <span class="number">64</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// contains only lowcase characters</span></span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.isAllLowerCase(password)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// contains only a~z,0~9,dot</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">      <span class="keyword">char</span> c = password.charAt(i);</span><br><span class="line">      <span class="keyword">if</span> (!(c &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;z&#x27;</span>) || (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) || c == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重复的代码被敲了两遍，或者简单 <code>copy-paste</code> 了一下，看起来明显违反 <code>DRY</code> 原则。为了移除重复的代码，我们对上面的代码做下重构，将 <code>isValidUserName()</code> 函数和 <code>isValidPassword()</code> 函数，合并为一个更通用的函数 <code>isValidUserNameOrPassword()</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserAuthenticatorV2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">authenticate</span><span class="params">(String userName, String password)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isValidUsernameOrPassword(userName)) &#123;</span><br><span class="line">      <span class="comment">// ...throw InvalidUsernameException...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isValidUsernameOrPassword(password)) &#123;</span><br><span class="line">      <span class="comment">// ...throw InvalidPasswordException...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValidUsernameOrPassword</span><span class="params">(String usernameOrPassword)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//省略实现逻辑</span></span><br><span class="line">    <span class="comment">//跟原来的isValidUsername()或isValidPassword()的实现逻辑一样...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过重构之后，代码行数减少了，也没有重复的代码了，是不是更好了呢？答案是否定的！！</p><p>合并之后的 <code>isValidUserNameOrPassword()</code> 函数，负责两件事情：验证用户名和验证密码，违反了 “单一职责原则” 和 “接口隔离原则” 。</p><p>从代码实现逻辑上看起来是重复的，但是从语义上并不重复。所谓 “语义不重复” 指的是：从功能上来看，这两个函数干的是完全不重复的两件事情，一个是校验用户名，另一个是校验密码。<br>经过重构之后，在未来的某一天，如果我们修改了密码的校验逻辑，我们就要把合并后的函数，重新拆成合并前的那两个函数。</p><p>尽管代码的实现逻辑是相同的，但语义不同，我们判定它并不违反 <code>DRY</code> 原则。对于包含重复代码的问题，我们可以通过抽象成更细粒度函数的方式来解决。</p><h2 id="2-功能语义重复"><a href="#2-功能语义重复" class="headerlink" title="2 功能语义重复"></a>2 功能语义重复</h2><p>在同一个项目代码中有下面两个函数：<code>isValidIp()</code> 和 <code>checkIfIpValid()</code>。尽管两个函数的命名不同，实现逻辑不同，但功能是相同的，都是用来判定 <code>IP</code>地址是否合法的。</p><p>之所以在同一个项目中会有两个功能相同的函数，那是因为这两个函数是由两个不同的同事开发的，这时经常遇到的，其中一个同事在不知道已经存在相同功能的情况下又写了一个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidIp</span><span class="params">(String ipAddress)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (StringUtils.isBlank(ipAddress)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  String regex = <span class="string">&quot;^(1\\d&#123;2&#125;|2[0-4]\\d|25[0-5]|[1-9]\\d|[1-9])\\.&quot;</span></span><br><span class="line">          + <span class="string">&quot;(1\\d&#123;2&#125;|2[0-4]\\d|25[0-5]|[1-9]\\d|\\d)\\.&quot;</span></span><br><span class="line">          + <span class="string">&quot;(1\\d&#123;2&#125;|2[0-4]\\d|25[0-5]|[1-9]\\d|\\d)\\.&quot;</span></span><br><span class="line">          + <span class="string">&quot;(1\\d&#123;2&#125;|2[0-4]\\d|25[0-5]|[1-9]\\d|\\d)$&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> ipAddress.matches(regex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkIfIpValid</span><span class="params">(String ipAddress)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (StringUtils.isBlank(ipAddress)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  String[] ipUnits = StringUtils.split(ipAddress, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (ipUnits.length != <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> ipUnitIntValue;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      ipUnitIntValue = Integer.parseInt(ipUnits[i]);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ipUnitIntValue &lt; <span class="number">0</span> || ipUnitIntValue &gt; <span class="number">255</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; ipUnitIntValue == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，尽管两段代码的实现逻辑不重复，但语义重复，也就是功能重复，我们认为它违反了 DRY 原则。我们应该在项目中，统一一种实现思路，所有用到判断 <code>IP</code> 地址是否合法的地方，都统一调用同一个函数。</p><p>假设我们不统一实现思路，给不熟悉这部分代码的同事增加了阅读的难度。同事有可能研究了半天，觉得功能是一样的，但又有点疑惑，觉得是不是有更高深的考量，才定义了两个功能类似的函数，最终发现居然是代码设计的问题。</p><p>除此之外，如果哪天项目中 <code>IP</code> 地址是否合法的判定规则改变了，相应地，我们对 <code>isValidIp()</code> 的实现逻辑做了相应的修改，但却忘记了修改 <code>checkIfIpValid()</code> 函数。又或者，我们压根就不知道还存在一个功能相同的 <code>checkIfIpValid()</code> 函数，这样就会导致有些代码仍然使用老的 <code>IP</code> 地址判断逻辑，导致出现一些莫名其妙的 <code>bug</code>。</p><h2 id="3-代码执行重复"><a href="#3-代码执行重复" class="headerlink" title="3 代码执行重复"></a>3 代码执行重复</h2><p>第三个栗子🌰 <code>UserService</code> 中 <code>login()</code> 函数用来校验用户登录是否成功。如果失败，就返回异常；如果成功，就返回用户信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> UserRepo userRepo;<span class="comment">//通过依赖注入或者IOC框架注入</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> User <span class="title">login</span><span class="params">(String email, String password)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> existed = userRepo.checkIfUserExisted(email, password);</span><br><span class="line">    <span class="keyword">if</span> (!existed) &#123;<span class="comment">/*...throw AuthenticationFailureException...*/</span>&#125;</span><br><span class="line">    User user = userRepo.getUserByEmail(email);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRepo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkIfUserExisted</span><span class="params">(String email, String password)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!EmailValidation.validate(email)) &#123;<span class="comment">/*...throw InvalidEmailException...*/</span>&#125;</span><br><span class="line">    <span class="keyword">if</span> (!PasswordValidation.validate(password)) &#123;<span class="comment">/*...throw InvalidPasswordException...*/</span>&#125;</span><br><span class="line">    <span class="comment">//...query db to check if email&amp;password exists...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> User <span class="title">getUserByEmail</span><span class="params">(String email)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!EmailValidation.validate(email)) &#123;<span class="comment">/*...throw InvalidEmailException...*/</span>&#125;</span><br><span class="line">    <span class="comment">//...query db to get user by email...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码，既没有逻辑重复，也没有语义重复，但仍然违反了 <code>DRY</code> 原则。这是因为代码中存在 “执行重复” 。</p><p><code>email</code> 的校验逻辑被执行了两次。一次是在调用 <code>checkIfUserExisted()</code> 函数的时候，另一次是调用 <code>getUserByEmail()</code> 函数的时候。我们只需要将校验逻辑从 <code>UserRepo</code> 中移除，统一放到 <code>UserService</code> 中就可以了。</p><p>代码中还有一处比较隐蔽的执行重复，<code>login()</code> 函数并不需要调用 <code>checkIfUserExisted()</code> 函数，只需要调用一次 <code>getUserByEmail()</code> 函数，从数据库中获取到用户的 <code>email</code>、<code>password</code> 等信息，然后跟用户输入的 <code>email</code>、<code>password</code> 信息做对比，依次判断是否登录成功。</p><p>这样的优化是很有必要的。因为 <code>checkIfUserExisted()</code> 函数和 <code>getUserByEmail()</code> 函数都需要查询数据库，而数据库这类的 <code>I/O</code> 操作是比较耗时的。我们在写代码的时候，应当尽量减少这类 <code>I/O</code> 操作。</p><p>按照刚刚的修改思路，我们把代码重构一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> UserRepo userRepo;<span class="comment">//通过依赖注入或者IOC框架注入</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> User <span class="title">login</span><span class="params">(String email, String password)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!EmailValidation.validate(email)) &#123;<span class="comment">/*...throw InvalidEmailException...*/</span>&#125;</span><br><span class="line">    <span class="keyword">if</span> (!PasswordValidation.validate(password)) &#123;<span class="comment">/*...throw InvalidPasswordException...*/</span>&#125;</span><br><span class="line"></span><br><span class="line">    User user = userRepo.getUserByEmail(email);</span><br><span class="line">    <span class="keyword">if</span> (user == <span class="keyword">null</span> || !password.equals(user.getPassword())  &#123;<span class="comment">/*...throw AuthenticationFailureException...*/</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRepo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> User <span class="title">getUserByEmail</span><span class="params">(String email)</span> </span>&#123;<span class="comment">/*...query db to get user by email...*/</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-怎么提高代码复用性？"><a href="#4-怎么提高代码复用性？" class="headerlink" title="4 怎么提高代码复用性？"></a>4 怎么提高代码复用性？</h2><ul><li><p>减少代码耦合</p><p>对于高度耦合的代码，当我们希望复用其中的一个功能，想把这个功能的代码抽取出来成为一个独立的模块、类或者函数的时候，往往会发现牵一发而动全身。移动一点代码，就要牵连到很多其他相关的代码。所以，高度耦合的代码会影响到代码的复用性，我们要尽量减少代码耦合。</p></li><li><p>满足单一职责原则</p><p>如果职责不够单一，模块、类设计得大而全，那依赖它的代码或者它依赖的代码就会比较多，进而增加了代码的耦合。根据上一点，也就会影响到代码的复用性。相反，越细粒度的代码，代码的通用性会越好，越容易被复用。</p></li><li><p>模块化</p><p>这里的 “模块” ，不单单指一组类构成的模块，还可以理解为单个类、函数。我们要善于将功能独立的代码，封装成模块。独立的模块就像一块一块的积木，更加容易复用，可以直接拿来搭建更加复杂的系统。</p></li><li><p>业务与非业务逻辑分离</p><p>越是跟业务无关的代码越是容易复用，越是针对特定业务的代码越难复用。所以，为了复用跟业务无关的代码，我们将业务和非业务逻辑代码分离，抽取成一些通用的框架、类库、组件等。</p></li><li><p>通用代码下沉</p><p>从分层的角度来看，越底层的代码越通用、会被越多的模块调用，越应该设计得足够可复用。一般情况下，在代码分层之后，为了避免交叉调用导致调用关系混乱，我们只允许上层代码调用下层代码及同层代码之间的调用，杜绝下层代码调用上层代码。所以，通用的代码我们尽量下沉到更下层。</p></li><li><p>继承、多态、抽象、封装</p><p>利用继承，可以将公共的代码抽取到父类，子类复用父类的属性和方法。利用多态，我们可以动态地替换一段代码的部分逻辑，让这段代码可复用。除此之外，抽象和封装，从更加广义的层面、而非狭义的面向对象特性的层面来理解的话，越抽象、越不依赖具体的实现，越容易复用。代码封装成模块，隐藏可变的细节、暴露不变的接口，就越容易复用。</p></li><li><p>应用模板等设计模式</p><p>一些设计模式，也能提高代码的复用性。比如，模板模式利用了多态来实现，可以灵活地替换其中的部分代码，整个流程模板代码可复用。</p></li></ul><h2 id="5-辩证思考和灵活应用"><a href="#5-辩证思考和灵活应用" class="headerlink" title="5 辩证思考和灵活应用"></a>5 辩证思考和灵活应用</h2><p>实际上，编写可复用的代码并不简单。<br>除非有非常明确的复用需求，否则，为了暂时用不到的复用需求，花费太多的时间、精力，投入太多的开发成本，并不是一个值得推荐的做法。这也违反我们之前讲到的 <code>YAGNI</code> 原则。</p><p>有一个著名的原则，叫作 <code>“Rule of Three”</code> 。这条原则可以用在很多行业和场景中，我们在第一次写代码的时候，如果当下没有复用的需求，而未来的复用需求也不是特别明确，并且开发可复用代码的成本比较高，那我们就不需要考虑代码的复用性。<br>在之后我们开发新的功能的时候，发现可以复用之前写的这段代码，那我们就重构这段代码，让其变得更加可复用。</p><p>也就是说，第一次编写代码的时候，我们不考虑复用性；第二次遇到复用场景的时候，再进行重构使其复用。需要注意的是，<code>“Rule of Three”</code> 中的 <code>“Three”</code> 并不是真的就指确切的 <code>“三”</code> 。</p><hr><h1 id="🚩迪米特法则"><a href="#🚩迪米特法则" class="headerlink" title="🚩迪米特法则"></a>🚩迪米特法则</h1><p><code>Law of Demeter LOD</code></p><p><code>Each unit should have only limited knowledge about other units: only units “closely” related to the current unit. Or: Each unit should only talk to its friends; Don’t talk to strangers.(每个模块（unit）只应该了解那些与它关系密切的模块（units: only units “closely” related to the current unit）的有限知识（knowledge）。或者说，每个模块只和自己的朋友“说话”（talk），不和陌生人“说话”（talk）。)</code></p><p><code>不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口（也就是定义中的“有限知识”）。</code></p><p>迪米特法则。尽管它不像 <code>SOLID</code>、<code>KISS</code>、<code>DRY</code> 原则那样，人尽皆知，但它却非常实用。利用这个原则，能够帮我们实现代码的 “高内聚、松耦合” 。</p><h2 id="1-何为-“高内聚、松耦合”-？"><a href="#1-何为-“高内聚、松耦合”-？" class="headerlink" title="1 何为 “高内聚、松耦合” ？"></a>1 何为 “高内聚、松耦合” ？</h2><p>在这个设计思想中，“高内聚” 用来指导类本身的设计，“松耦合” 用来指导类与类之间依赖关系的设计。不过，这两者并非完全独立不相干。高内聚有助于松耦合，松耦合又需要高内聚的支持。</p><ul><li><p>所谓高内聚，就是指相近的功能应该放到同一个类中，不相近的功能不要放到同一个类中。</p><p>相近的功能往往会被同时修改，放到同一个类中，修改会比较集中，代码容易维护。实际上，单一职责原则是实现代码高内聚非常有效的设计原则。</p></li><li><p>所谓松耦合是说，在代码中，类与类之间的依赖关系简单清晰。</p><p>即使两个类有依赖关系，一个类的代码改动不会或者很少导致依赖类的代码改动。实际上，我们前面讲的依赖注入、接口隔离、基于接口而非实现编程，以及迪米特法则，都是为了实现代码的松耦合。</p></li></ul><p>##2 不该有直接依赖关系的类之间，不要有依赖</p><p>迪米特法则的前半部分，</p><h2 id="2-不该有直接依赖关系的类之间，不要有依赖"><a href="#2-不该有直接依赖关系的类之间，不要有依赖" class="headerlink" title="2 不该有直接依赖关系的类之间，不要有依赖"></a>2 不该有直接依赖关系的类之间，不要有依赖</h2><p>举个栗子🌰 代码中包含三个主要的类。其中，<code>NetworkTransporter</code> 类负责底层网络通信，根据请求获取数据；<code>HtmlDownloader</code> 类用来通过 <code>URL</code> 获取网页；<code>Document</code> 表示网页文档，后续的网页内容抽取、分词、索引都是以此为处理对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NetworkTransporter</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略属性和其他方法...</span></span><br><span class="line">    <span class="keyword">public</span> Byte[] send(HtmlRequest htmlRequest) &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HtmlDownloader</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> NetworkTransporter transporter;<span class="comment">//通过构造函数或IOC注入</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Html <span class="title">downloadHtml</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">    Byte[] rawHtml = transporter.send(<span class="keyword">new</span> HtmlRequest(url));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Html(rawHtml);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Document</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Html html;</span><br><span class="line">  <span class="keyword">private</span> String url;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Document</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.url = url;</span><br><span class="line">    HtmlDownloader downloader = <span class="keyword">new</span> HtmlDownloader();</span><br><span class="line">    <span class="keyword">this</span>.html = downloader.downloadHtml(url);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>首先看 <code>NetworkTransporter</code> 类</strong></p><p>作为一个底层网络通信类，我们希望它的功能尽可能通用，而不只是服务于下载 <code>HTML</code>，所有这里的参数 <code>HtmlRequest</code> 就限制了这个功能，我们不应该直接依赖太具体的发送对象 <code>HtmlRequest</code>。从这一点上讲，<code>NetworkTransporter</code> 类的设计违背迪米特法则，依赖了不该有直接依赖关系的 <code>HtmlRequest</code> 类。</p><p>有一个很形象的比喻。假如你现在要去商店买东西，你肯定不会直接把钱包给收银员，让收银员自己从里面拿钱，而是你从钱包里把钱拿出来交给收银员。这里的 <code>HtmlRequest</code> 对象就相当于钱包，<code>HtmlRequest</code> 里的 <code>address</code> 和 <code>content</code> 对象就相当于钱。我们应该把 <code>address</code> 和 <code>content</code> 交给 <code>NetworkTransporter</code>，而非是直接把 <code>HtmlRequest</code> 交给 <code>NetworkTransporter</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NetworkTransporter</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略属性和其他方法...</span></span><br><span class="line">    <span class="keyword">public</span> Byte[] send(String address, Byte[] data) &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>再来看 <code>HtmlDownloader</code> 类</strong></p><p>根据 <code>NetworkTransporter</code> 的修改 <code>HtmlDownloader</code> 也得做相应的修改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HtmlDownloader</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> NetworkTransporter transporter;<span class="comment">//通过构造函数或IOC注入</span></span><br><span class="line">  <span class="comment">// HtmlDownloader这里也要有相应的修改</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Html <span class="title">downloadHtml</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">    HtmlRequest htmlRequest = <span class="keyword">new</span> HtmlRequest(url);</span><br><span class="line">    Byte[] rawHtml = transporter.send(</span><br><span class="line">      htmlRequest.getAddress(), htmlRequest.getContent().getBytes());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Html(rawHtml);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>最后是 <code>Document</code> 类</strong></p><p>主要有三点。<br>第一，构造函数中的 <code>downloader.downloadHtml()</code> 逻辑复杂，耗时长，不应该放到构造函数中，会影响代码的可测试性<br>第二，<code>HtmlDownloader</code> 对象在构造函数中通过 <code>new</code> 来创建，违反了基于接口而非实现编程的设计思想，也会影响到代码的可测试性<br>第三，从业务含义上来讲，<code>Document</code> 网页文档没必要依赖 HtmlDownloader 类，违背了迪米特法则。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Document</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Html html;</span><br><span class="line">  <span class="keyword">private</span> String url;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Document</span><span class="params">(String url, Html html)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.html = html;</span><br><span class="line">    <span class="keyword">this</span>.url = url;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过一个工厂方法来创建Document</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DocumentFactory</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> HtmlDownloader downloader;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DocumentFactory</span><span class="params">(HtmlDownloader downloader)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.downloader = downloader;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Document <span class="title">createDocument</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">    Html html = downloader.downloadHtml(url);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Document(url, html);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就很好的解决了三个问题。</p></li></ul><h2 id="3-有依赖关系的类之间，尽量只依赖必要的接口"><a href="#3-有依赖关系的类之间，尽量只依赖必要的接口" class="headerlink" title="3 有依赖关系的类之间，尽量只依赖必要的接口"></a>3 有依赖关系的类之间，尽量只依赖必要的接口</h2><p>举个之前的栗子🌰  <code>Serialization</code> 类负责对象的序列化和反序列化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Serialization</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">    String serializedResult = ...;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> serializedResult;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">deserialize</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    Object deserializedResult = ...;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> deserializedResult;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单看这个类的设计，没有一点问题。<br>假设在我们的项目中，有些类只用到了序列化操作，而另一些类只用到反序列化操作。那基于迪米特法则后半部分 “有依赖关系的类之间，尽量只依赖必要的接口” ，只用到序列化操作的那部分类不应该依赖反序列化接口。同理，只用到反序列化操作的那部分类不应该依赖序列化接口。<br>那我们是不是又得把这个类拆开成两个类？那不就和之前在单一职责中说的冲突了吗？之前我们就说拆分后代码的内聚性显然没有原来 <code>Serialization</code> 高了。那有没有既不违背高内聚的设计思想，也不违背迪米特法则的方法呢？🤔🤔<br>既然在这说了，肯定是有的😁<br>我们可以利用 “接口隔离原则” 来解决这个问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  <span class="function">String <span class="title">serialize</span><span class="params">(Object object)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Deserializable</span> </span>&#123;</span><br><span class="line">  <span class="function">Object <span class="title">deserialize</span><span class="params">(String text)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Serialization</span> <span class="keyword">implements</span> <span class="title">Serializable</span>, <span class="title">Deserializable</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">    String serializedResult = ...;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> serializedResult;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">deserialize</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    Object deserializedResult = ...;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> deserializedResult;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoClass_1</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Serializable serializer;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Demo</span><span class="params">(Serializable serializer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.serializer = serializer;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoClass_2</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Deserializable deserializer;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Demo</span><span class="params">(Deserializable deserializer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.deserializer = deserializer;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管我们还是要往 <code>DemoClass_1</code> 的构造函数中，传入包含序列化和反序列化的 <code>Serialization</code> 实现类，但是，我们依赖的 <code>Serializable</code> 接口只包含序列化操作，<code>DemoClass_1</code> 无法使用 <code>Serialization</code> 类中的反序列化接口，对反序列化操作无感知，这也就符合了迪米特法则后半部分所说的 “依赖有限接口”的要求 。</p><p>上面的代码实现思路，也体现了 “基于接口而非实现编程” 的设计原则，结合迪米特法则，我们可以总结出一条新的设计原则，那就是 “基于最小接口而非最大实现编程”。</p><p>新的设计模式和设计原则是怎么创造出来的，实际上，就是在大量的实践中，针对开发痛点总结归纳出来的套路。</p><h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h1><blockquote><p><a href="https://time.geekbang.org/column/intro/250?utm_source=pinpaizhuanqu&utm_medium=geektime&utm_campaign=guanwang&utm_term=guanwang&utm_content=0511">设计模式之美</a></p><p><a href="https://juejin.im/post/5d669bfc6fb9a06b1b19d25e">通过代码示例来学习面向对象六大原则</a></p><p><a href="https://blog.cleancoder.com/">The Clean Code Blog</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>稳定性优化</title>
      <link href="2020/stability-optimization.html"/>
      <url>2020/stability-optimization.html</url>
      
        <content type="html"><![CDATA[<h1 id="本文主要记载"><a href="#本文主要记载" class="headerlink" title="本文主要记载"></a>本文主要记载</h1><hr><p><code>Android</code> 稳定性优化主要注意一下几点：</p><ul><li><p><strong>执行超时 <code>(Timeout)</code></strong></p><p>长时间无法执行完成。对于 <code>Android</code> 系统来说,比较常见的便是 <code>Service</code> 、<code>Broadcast</code>、<code>provider</code> 以及 <code>input</code> , 当普通 <code>app</code> 进程超过一定时间没有执行完, 则会弹出应用无响应 <code>(Application Not Responding, ANR)</code> 的对话框。如果该 <code>app</code> 运行在 <code>system</code> 进程，更准确的来说,应该是 <code>(System Not Responding, SNR)</code> 。 虽然有 <code>ANR</code> 和 <code>SNR</code> 之分, 但习惯上大家都统称为 <code>ANR</code> 问题。</p><ul><li><strong>Service Timeout：</strong>比如前台服务在 <code>20s</code> 内未执行完成。</li><li><strong>broadcast Timeout：</strong>比如前台广播在 <code>10s</code> 内未执行完成。</li><li><strong>ContentProvider Timeout：</strong>内容提供者执行超时。</li><li><strong>InputDispatching Timeout：</strong>输入事件分发超时 <code>5s</code> ，包括按键和触摸事件。</li></ul></li><li><p>*<em>异常崩溃 <code>(Crash)</code> *</em></p><p>异常崩溃 <code>(Crash)</code> 的问题, 毫无疑问这不是时间上能解决的问题, 而是出现了未知的异常. 一旦触发崩溃会出现相应的调用栈, 但不糊输出各个进程的<code>traces</code>。</p><ul><li><p><strong><code>Java</code> 崩溃</strong> </p><p><a href="http://gityuan.com/2016/06/24/app-crash/"> 理解Java Crash处理流程</a> </p><p>往往是抛出了一个未捕获的异常 <code>uncaughtException</code> 而导致的崩溃. 那是不是把所有的异常都 <code>catch</code> 住系统就没有问题呢？这个是要分情况的，有时候的异常强制崩溃可能会留下更大的问题，有些异常的抛出是需要深入分析 <code>Root Cause</code> ，从根源来解决问题, 而非简单粗糙的捕获住所有的异常.</p></li><li><p><strong><code>Native</code> 崩溃</strong></p><p><a href="http://gityuan.com/2016/06/25/android-native-crash/">理解Native Crash处理流程</a> </p><p>由于进程收到 <code>signal</code>信号而引发的崩溃。当进程收到信号，并会触发信号处理函数，通过 <code>socket</code> 发送信息到 <code>debuggerd</code> 进程，<code>debuggerd</code> 进程收到事件后通过 <code>ptrace attach</code> 到目标进程, 获取 <code>cpu/memory/traces</code> 等关键信息后 <code>dettach</code> 。<code>Native crash</code> 情况比较多, 其中最为场景便是<code>SIGSEGV</code> 段错误异常，往往是内存出现异常，比如访问了权限不足的内存地址等。</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>App 刷脂</title>
      <link href="2020/package-optimization.html"/>
      <url>2020/package-optimization.html</url>
      
        <content type="html"><![CDATA[<h1 id="本文主要记载"><a href="#本文主要记载" class="headerlink" title="本文主要记载"></a>本文主要记载</h1><ul><li><strong>1 为什么要优化包体积？</strong></li><li><strong>2 包体积与应用性能有关系吗？</strong></li><li><strong>3 根据 APK 组成分析优化</strong><ul><li>3.1 代码相关<ul><li>3.1.1 Dex 探秘</li><li>3.1.2 Proguard</li><li>3.1.3 D8 与 R8 优化</li><li>3.1.4 去除 debug 信息与行号信息</li><li>3.1.5 Dex 分包<ul><li>Redex Ubuntu 具体实践</li></ul></li><li>3.1.6 使用 XZ Utils 进行 Dex 压缩</li><li>3.1.7 其他</li></ul></li><li>3.2 资源相关<ul><li>3.2.1 使用 Lint 的 Remove Unused Resource</li><li>3.2.2 shrinkResources</li><li>3.2.3 AndResGuard 工具<ul><li>实践</li></ul></li></ul></li><li>3.3 Native Library 相关<ul><li>3.3.1 Library 压缩</li><li>3.3.2 Library 合并与裁剪</li></ul></li></ul></li></ul><hr><h1 id="1-为什么要优化包体积？"><a href="#1-为什么要优化包体积？" class="headerlink" title="1 为什么要优化包体积？"></a>1 为什么要优化包体积？</h1><ol><li><p><strong>下载转化率。</strong> </p><p><code>APK</code> 刷脂在 <strong>初创项目</strong> 中优先级是比较低的，相对于 <strong>启动优化、卡顿优化</strong> 它的好处不是那么明显，包体积优化最主要的好处是对应用 <strong>下载转化率</strong> 的影响，它是 <code>App</code> 业务运营的重要指标之一，在项目精细化运营的阶段是非常重要的。在 <code>2018</code> 年的 <code>Google I/O</code>，<code>Google</code> 透露了 <code>Google Play</code> 上安装包体积与下载转化率的关系图。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/f8a5e264dee4ee6879cd6c30d4bbf368.png" alt="图片来源于 Android 开发高手课"></p><p>从这张图上看，大体来说，安装包越小，转化率越高这个结论成立。包体积越小，用户下载等待的时间也会越短，所以下载转换成功率也就越高，一个 <code>100MB</code> 的应用，用户即使点了下载，也可能因为网络速度慢、突然反悔下载失败。对于一个 <code>10MB</code> 的应用，用户点了下载之后，在犹豫要不要下的时候已经下载完了。但是正如上图的数据，安装包大小与转化率的关系是非常微妙的。<code>10MB</code> 跟 <code>15MB</code> 可能差距不大，但是 <code>10MB</code> 跟 <code>40MB</code> 的差距还是非常明显的。</p><p>而且，现在很多大型的 <code>App</code> 一般都会有一个极速版本的 <code>App</code>，这个也是出于下载转化率方面的考虑。</p></li><li><p><strong>推广成本。</strong>一般来说，包体积对渠道推广和厂商预装的单价会有非常大的影响。特别是厂商预装，这主要是因为厂商留给预装应用的总空间是有限的。如果你的包体积非常大，那就会影响厂商预装其他应用。</p></li><li><p><strong>应用市场。</strong> <code>Google Play</code> 要求超过 <code>100MB</code> 的应用只能使用 <a href="https://developer.android.google.cn/google/play/expansion-files">APK 扩展文件方式</a> 上传，由此可见应用包体积对应用市场的服务器带宽成本还是会有一点压力的。如果想避免使用扩展文件，并且想要应用程序的下载大小大于 <code>100 MB</code>，则应该使用 <code>Android App Bundles</code> 上传应用程序。</p><p><a href="https://www.jianshu.com/p/3754d4e7f4e5">Android App Bundle</a> </p></li></ol><hr><h1 id="2-包体积与应用性能有关系吗？"><a href="#2-包体积与应用性能有关系吗？" class="headerlink" title="2 包体积与应用性能有关系吗？"></a>2 包体积与应用性能有关系吗？</h1><p>包体积除了转化率的影响，主要还会对 <code>App</code> 三个方面 的性能有一定的影响</p><ul><li><strong>安装时间：</strong>文件拷贝、<code>Library</code> 解压，并且，在编译 <code>ODEX</code> 的时候，特别是对于 <code>Android 5.0</code> 和 <code>6.0</code> 系统来说，耗费的时间比较久，而 <code>Android 7.0</code> 之后有了 混合编译，所以还可以接受。最后，<code>App</code> 变大后，其签名校验的时间也会变长。微信 <code>13</code> 个 <code>Dex</code> 光是编译 <code>ODEX</code> 的时间可能就要 <code>5</code> 分钟。</li><li><strong>运行内存：</strong>在内存优化的时候我们就说过，<code>Resource</code> 资源、<code>Library</code> 以及 <code>Dex</code> 类加载这些都会占用不少的内存。</li><li><strong>ROM 空间：</strong>如果应用的安装包大小为 <code>50MB</code>，那么启动解压之后很可能就已经超过 <code>100MB</code> 了。并且，如果 闪存空间不足，很可能出现 “写入放大” 的情况。具体情况将在 <code>I/O 优化</code> 中讲解。</li></ul><hr><h1 id="3-根据-APK-组成分析优化"><a href="#3-根据-APK-组成分析优化" class="headerlink" title="3 根据 APK 组成分析优化"></a>3 根据 APK 组成分析优化</h1><p>我们都知道，<code>Android</code> 项目最终会编译成一个 <code>.apk</code> 后缀的文件，实际上它就是一个 压缩包。因此，它内部还有很多不同类型的文件，这些文件，按照大小，共分为 代码优化、资源优化、<code>So</code> 优化。</p><h2 id="3-1-代码相关"><a href="#3-1-代码相关" class="headerlink" title="3.1 代码相关"></a>3.1 代码相关</h2><p><code>classes.dex</code>，我们在项目中所编写的 <code>java</code> 文件，经过编译之后会生成一个 <code>.class</code> 文件，而这些所有的 <code>.class</code> 文件呢，它最终会经过 <code>dx</code> 工具编译生成一个 <code>classes.dex</code>。</p><p>对于大部分应用来说，<code>Dex</code> 都是包体积中的大头。日常开发中 <code>Dex</code> 数量从 1 个增长到 10 多个，我们的代码量真的增长了那么多倍吗？而且 Dex 的数量对用户安装时间也是一个非常大的挑战，在不砍功能的前提下，我们看看有哪些方法可以减少这部分空间。</p><p>与传统 <code>jar</code> 文件相比，<code>Dex</code> 文件的大小能够缩减 <code>50%</code> 左右。关于 <code>Class</code> 文件与 <code>Dex</code> 文件的结果对比图如下所示：</p><h3 id="3-1-1-Dex-探秘"><a href="#3-1-1-Dex-探秘" class="headerlink" title="3.1.1 Dex 探秘"></a>3.1.1 Dex 探秘</h3><p><code>Dex</code> 是 <code>Android</code> 系统的可执行文件，包含 应用程序的全部操作指令以及运行时数据。因为 <code>Dalvik</code> 是一种针对嵌入式设备而特殊设计的 <code>Java</code> 虚拟机，所以 <code>Dex</code> 文件与标准的 <code>Class</code> 文件在结构设计上有着本质的区别。</p><p>当 <code>Java</code> 程序被编译成 <code>class</code> 文件之后，还需要使用 <code>dx</code> 工具将所有的 class 文件整合到一个 <code>dex</code> 文件中，这样 <code>dex</code> 文件就将原来每个 <code>class</code> 文件中都有的共有信息合成了一体，这样做的目的是 保证其中的每个类都能够共享数据，这在一定程度上降低了信息冗余，同时也使得文件结构更加紧凑。</p><p><a href="https://www.jianshu.com/p/f7f0a712ddfe">Dex文件格式详解</a> </p><p><code>Dex</code> 一般在应用包体积中占据了不少比重，并且 <code>Dex</code> 数量越多，<code>App</code> 的安装时间也会越长。所以，优化它们可以说是重中之重。下面就来看看有哪些方式可以优化 <code>Dex</code> 这部分的体积。</p><hr><h3 id="3-1-2-ProGuard"><a href="#3-1-2-ProGuard" class="headerlink" title="3.1.2 ProGuard"></a>3.1.2 ProGuard</h3><ol><li><p><strong>代码混淆的形式</strong></p><p>目前，代码混淆的形式主要有三种，如下所示：</p><ul><li>将代码中的各个元素，比如类、函数、变量的名字改变成无意义的名字。例如将 <code>hasValue</code> 转换成单个的字母 <code>a</code>。这样，反编译阅读的人就无法通过名字来猜测用途。</li><li>重写代码中的部分逻辑，将它变成功能上等价，但是又难以理解的形式。比如它会改变循环的指令、结构体。</li><li>打乱代码的格式，比如多加一些空格或删除空格，或者将一行代码写成多行，将多行代码改成一行。</li></ul></li><li><p><strong><code>Proguard</code> 的作用</strong></p><p>在 <code>Android SDK</code> 里面集成了一个工具 — <code>Proguard</code>，它是一个免费的 <code>Java</code> 类文件压缩、优化、混淆、预先校验的工具。它的主要作用大概可以概括为两点，如下所示：</p><ul><li><p><strong>瘦身</strong>：它可以检测并移除未使用到的类、方法、字段以及指令、冗余代码，并能够对字节码进行深度优化。最后，它还会将类中的字段、方法、类的名称改成简短无意义的名字。</p><ul><li><p><strong>压缩：</strong>默认开启，以减小应用体积，移除未被使用的类和成员，并且会在优化动作执行之后再次执行，因为优化后可能会再次暴露一些未被使用的类和成员。我们可以使用如下规则来关闭压缩：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭压缩</span></span><br><span class="line"><span class="attr">-dontshrink</span></span><br></pre></td></tr></table></figure></li><li><p><strong>优化：</strong>默认开启，在字节码级别执行优化，让应用运行的更快。使用如下规则可进行优化相关操作：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭优化</span></span><br><span class="line"><span class="attr">-dontoptimize</span></span><br><span class="line"><span class="comment"># 表示proguard对代码进行迭代优化的次数，Android一般为5</span></span><br><span class="line"><span class="meta">-optimizationpasses</span> <span class="string">5</span></span><br></pre></td></tr></table></figure><p><strong>优化细节包括：</strong>内联、修饰符、合并类、方法、 <code>Gson</code> 库的使用、把类都标记为 <code>final</code>、把枚举类型简化为常量、把一些类都垂直合并进当前类的结构中、把一些类都水平合并进当前类的结构中、移除 <code>write-only</code> 字段、把类标记为私有的、把字段的值跨方法地进行传递、把一些方法标记为私有、静态或 <code>final</code>、解除方法的 <code>synchronized</code> 标记、移除没有使用的方法参数等 30 多种优化项</p></li></ul></li><li><p><strong>安全：</strong>增加代码被反编译的难度，一定程度上保证代码的安全。</p><ul><li><p><strong>混淆：</strong>默认开启，增大反编译难度，类和类成员会被随机命名，除非用 优化字节码 等规则进行保护。使用如下规则可以关闭混淆：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭混淆</span></span><br><span class="line"><span class="attr">-dontobfuscate</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><p>所以说，混淆不仅是保障 <strong>Android 程序源码安全</strong> 的 <strong>第一道门槛</strong>，还可以优化字节码的大小</p></li><li><p><code>Proguard</code> 的配置</p><p>混淆之后，默认会在工程目录 <code>app/build/outputs/mapping/release</code> 下生成一个 <code>mapping.txt</code> 文件，这就是混淆规则，所以我们可以根据这个文件把混淆后的代码反推回原本的代码。要使用混淆，我们只需配置如下代码即可：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">buildTypes &#123;</span><br><span class="line">    release &#123;</span><br><span class="line">        <span class="comment">// 1、是否进行混淆</span></span><br><span class="line">        minifyEnabled <span class="literal">true</span></span><br><span class="line">        <span class="comment">// 2、开启zipAlign可以让安装包中的资源按4字节对齐，这样可以减少应用在运行时的内存消耗</span></span><br><span class="line">        zipAlignEnabled <span class="literal">true</span></span><br><span class="line">        <span class="comment">// 3、移除无用的resource文件：当ProGuard 把部分无用代码移除的时候，</span></span><br><span class="line">        <span class="comment">// 这些代码所引用的资源也会被标记为无用资源，然后</span></span><br><span class="line">        <span class="comment">// 系统通过资源压缩功能将它们移除。</span></span><br><span class="line">        <span class="comment">// 需要注意的是目前资源压缩器目前不会移除values/文件夹中</span></span><br><span class="line">        <span class="comment">// 定义的资源（例如字符串、尺寸、样式和颜色）</span></span><br><span class="line">        <span class="comment">// 开启后，Android构建工具会通过ResourceUsageAnalyzer来检查</span></span><br><span class="line">        <span class="comment">// 哪些资源是无用的，当检查到无用的资源时会把该资源替换</span></span><br><span class="line">        <span class="comment">// 成预定义的版本。主要是针对.png、.9.png、.xml提供了</span></span><br><span class="line">        <span class="comment">// TINY_PNG、TINY_9PNG、TINY_XML这3个byte数组的预定义版本。</span></span><br><span class="line">        <span class="comment">// 资源压缩工具默认是采用安全压缩模式来运行，可以通过开启严格压缩模式来达到更好的瘦身效果。</span></span><br><span class="line">        shrinkResources <span class="literal">true</span></span><br><span class="line">        <span class="comment">// 4、混淆文件的位置，其中 proguard-android.txt 为sdk默认的混淆配置，</span></span><br><span class="line">        <span class="comment">// 它的位置位于android-sdk/tools/proguard/proguard-android.txt，</span></span><br><span class="line">        <span class="comment">// 此外，proguard-android-optimize.txt 也为sdk默认的混淆配置，</span></span><br><span class="line">        <span class="comment">// 但是它默认打开了优化开关。并且，我们可在配置混淆文件将android.util.Log置为无效代码，</span></span><br><span class="line">        <span class="comment">// 以去除apk中打印日志的代码。而 proguard-rules.pro 是该模块下的混淆配置。</span></span><br><span class="line">      <span class="comment">// 如果想让各个 library 的 proguard-rules 也生效使用  consumerProguardFiles &#x27;proguard-rules.pro&#x27;</span></span><br><span class="line">        proguardFiles getDefaultProguardFile(<span class="string">&#x27;proguard-android-optimize.txt&#x27;</span>), <span class="string">&#x27;proguard-rules.pro&#x27;</span></span><br><span class="line">        signingConfig signingConfigs.release</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在执行完 <code>ProGuard</code> 之后，<code>ProGuard</code> 都会在 <code>$&#123;project.buildDir&#125;/outputs/mapping/$&#123;flavorDir&#125;/</code> 生成以下文件：</p><table><thead><tr><th><strong>文件名</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>dump.txt</td><td>APK 中所有类文件的内部结构</td></tr><tr><td>mapping.txt</td><td>提供原始与混淆过的类、方法和字段名称之间的转换，<br />可以通过 proguard.obfuscate.MappingReader 来解析</td></tr><tr><td>seeds.txt</td><td>列出未进行混淆的类和成员</td></tr><tr><td>usage.txt</td><td>列出从 APK 移除的代码</td></tr></tbody></table></li></ol><ol start="4"><li><p><strong>混淆的基本规则</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># * 表示仅保持该包下的类名，而子包下的类名还是会被混淆</span></span><br><span class="line"><span class="meta">-keep</span> <span class="string">class com.json.chao.wanandroid.*</span></span><br><span class="line"><span class="comment"># ** 表示把本包和所含子包下的类名都保持</span></span><br><span class="line"><span class="meta">-keep</span> <span class="string">class com.json.chao.wanandroid.**</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 既保持类名，又保持里面的内容不被混淆</span></span><br><span class="line"><span class="meta">-keep</span> <span class="string">class com.json.chao.wanandroid.* &#123;*;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以使用Java的基本规则来保护特定类不被混淆，比如extend，implement等这些Java规则</span></span><br><span class="line"><span class="meta">-keep</span> <span class="string">public class * extends android.app.Activity</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 保留MainPagerFragment内部类JavaScriptInterface中的所有public内容不被混淆</span></span><br><span class="line"><span class="meta">-keepclassmembers</span> <span class="string">class com.json.chao.wanandroid.ui.fragment.MainPagerFragment$JavaScriptInterface &#123;</span></span><br><span class="line">    <span class="attr">public</span> <span class="string">*;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 仅希望保护类下的特定内容时需使用匹配符</span></span><br><span class="line"><span class="meta">&lt;init&gt;;</span>     <span class="string">//匹配所有构造器</span></span><br><span class="line"><span class="meta">&lt;fields&gt;;</span>   <span class="string">//匹配所有字段</span></span><br><span class="line"><span class="meta">&lt;methods&gt;;</span>  <span class="string">//匹配所有方法</span></span><br><span class="line"><span class="comment"># 还可以在上述匹配符前面加上private 、public、native等来进一步指定不被混淆的内 容</span></span><br><span class="line"><span class="meta">-keep</span> <span class="string">class com.json.chao.wanandroid.app.WanAndroidApp &#123;</span></span><br><span class="line">    <span class="attr">public</span> <span class="string">&lt;fields&gt;;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"><span class="comment"># 也可以加入参数，以下表示用java.lang.String作为入参的构造函数不会被混淆</span></span><br><span class="line"><span class="meta">-keep</span> <span class="string">class com.json.chao.wanandroid.app.WanAndroidApp &#123;</span></span><br><span class="line">    <span class="attr">public</span> <span class="string">&lt;init&gt;(java.lang.String);</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不需要保持类名，仅需要把该类下的特定成员保持不被混淆时使用keepclassmembers</span></span><br><span class="line"><span class="comment"># 如果拥有某成员，要保留类和类成员使用-keepclasseswithmembers</span></span><br></pre></td></tr></table></figure><p>添加在 <code>AndroidMainfest</code> 中的类默认不会被混淆，所以四大组件和 <code>Application</code> 的子类和 <code>Framework</code> 层下所有的类默认不会进行混淆，自定义的 <code>View</code> 默认也不会被混淆。所以下面代码加不加都可以</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">-keep</span> <span class="string">public class * extends android.app.Activity</span></span><br><span class="line"><span class="meta">-keep</span> <span class="string">public class * extends android.app.Application</span></span><br><span class="line"><span class="meta">-keep</span> <span class="string">public class * extends android.app.Service</span></span><br><span class="line"><span class="meta">-keep</span> <span class="string">public class * extends android.content.BroadcastReceiver</span></span><br><span class="line"><span class="meta">-keep</span> <span class="string">public class * extends android.content.ContentProvider</span></span><br><span class="line"><span class="meta">-keep</span> <span class="string">public class * extends android.view.View</span></span><br></pre></td></tr></table></figure><p>“十个 <code>ProGuard</code> 配置九个坑”，特别是各种第三方 <code>SDK</code>。我们需要仔细检查最终合并的 <code>ProGuard</code> 配置文件，是不是存在过度 <code>keep</code> 的现象。</p><p>可以通过下面的方法输出 <code>ProGuard</code> 的最终配置，尤其需要注意各种的 <code>keep *</code>，很多情况下我们只需要 <code>keep</code> 其中的某个包、某个方法，或者是类名就可以了。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">-printconfiguration</span>  <span class="string">configuration.txt</span></span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="3-1-3-D8-与-R8-优化"><a href="#3-1-3-D8-与-R8-优化" class="headerlink" title="3.1.3 D8 与 R8 优化"></a>3.1.3 D8 与 R8 优化</h3><ul><li><p><strong>D8 优化</strong></p><p>1, <code>Dex</code>编译时间更短</p><p>2, <code>.dex</code> 文件大小更小</p><p>3, <code>D8</code> 编译的 <code>.dex</code> 文件将拥有相同或者是更好的运行时性能</p><p>4, 包含 <code>Java 8</code> 语言支持的处理</p></li></ul><p>在 <code>gradle.properties</code> 文件中新增如下代码。<code>Android Studio 3.1</code> 或之后的版本 <code>D8</code> 将会被作为默认的 <code>Dex</code> 编译器。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android.enableD8 = <span class="literal">true</span></span><br></pre></td></tr></table></figure><ul><li><strong>R8 优化</strong></li></ul><p>如果我们当前使用的是 <code>Android Studio 3.4</code> 或 <code>Android Gradle</code> 插件 <code>3.4.0</code> 及其更高版本， <a href="https://www.guardsquare.com/en/blog/proguard-and-r8">R8</a>  会作为默认编译器。否则，我们必须要在 <code>gradle.properties</code> 中配置如下代码让 <code>App</code> 的混淆去支持 <code>R8</code>，如下所示：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">android.enableR8</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">android.enableR8.libraries</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure><ul><li><strong>R8 与混淆相比优势在哪里呢</strong></li></ul><p><code>ProGuard</code> 和 <code>R8</code> 都应用了基本名称混淆：它们都使用简短，无意义的名称重命名类，字段和方法。他们还可以删除调试属性。但是，<code>R8</code> 在 <code>inline</code> 内联容器类中更有效，并且在删除未使用的类，字段和方法上则更具侵略性。例如，<code>R8</code> 本身集成在 <code>ProGuard V6.1.1</code> 版本中，在压缩 <code>apk</code> 的大小方面，与 <code>ProGuard</code> 的 <code>8.5％</code> 相比，使用 <code>R8 apk</code> 尺寸减小了约 <code>10％</code>。并且，随着 <code>Kotlin</code> 现在成为 <code>Android</code> 的第一语言，<code>R8</code> 进行了 <code>ProGuard</code> 尚未提供的一些 <code>Kotlin</code> 的特定的优化。</p><p>想对 <code>D8</code> 与 <code>R8</code> 的实现细节有更多地了解前往 <a href="https://jakewharton.com/">Jake Wharton 个人博客</a>。</p><hr><h3 id="3-1-4-去除-debug-信息与行号信息"><a href="#3-1-4-去除-debug-信息与行号信息" class="headerlink" title="3.1.4 去除 debug 信息与行号信息"></a>3.1.4 去除 debug 信息与行号信息</h3><p>在讲解什么是 <code>deubg</code> 信息与行号信息之前，我们需要先了解 <code>Dex</code> 的一些知识。</p><p>我们都知道，<code>JVM</code> 运行时加载的是 <code>.class</code> 文件，而 <code>Android</code> 为了使包大小更加紧凑、运行时更加高效就发明了 <code>Dalvik</code> 和 <code>ART</code> 虚拟机，两种虚拟机运行的都是 <code>.dex</code> 文件，当然 <code>ART</code> 虚拟机还可以同时运行 <code>oat</code> 文件。</p><p>所以 <code>Dex</code> 文件里的信息内容和 <code>Class</code> 文件包含的信息是一样的，不同的是 <code>Dex</code> 文件对 <code>Class</code> 中的信息做了去重，一个 <code>Dex</code> 包含了很多的 <code>Class</code> 文件，并且在结构上有比较大的差异，<code>Class</code> 是流式的结构，<code>Dex</code>  是分区结构，<code>Dex</code> 内部的各个区块间通过 <code>offset</code> 来进行索引。</p><p>某个应用通过相同的 <code>ProGuard</code> 规则生成一个 <code>Debug</code> 包和 <code>Release</code> 包，其中 <code>Debug</code> 包的大小是 <code>4MB</code>，<code>Release</code> 包只有 <code>3.5MB</code>。</p><p>既然它们 <code>ProGuard</code> 的混淆与优化的规则是一样的，那它们之间的差异在哪里呢？那就是 <code>DebugItem</code>。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/69ec4986053903876d55fbd37d47a710.webp" alt="图片来源于 Android 开发高手课"></p><p>从图中可以看到，<code>Dex</code> 文件的结构主要分为四大块：<code>header</code> 区，索引区，<code>data</code> 区，<code>map</code> 区。而我们的 <code>debug</code> 与行号信息就保存在 <code>data</code> 区中的 <code>DebugItems</code> 区域。</p><p><code>DebugItem</code> 里面主要包含两种信息：</p><ul><li><strong>调试的信息。</strong>函数的参数变量和所有的局部变量。</li><li><strong>排查问题的信息。</strong>所有的指令集行号和源文件行号的对应关系。</li></ul><p>为了在应用出现问题时，我们能在调试的时候去显示相应的调试信息或者上报 <code>crash</code> 或者主动获取调用堆栈的时候能通过 <code>debugItem</code> 来获取对应的行号，我们都会在混淆配置中加上下面的规则：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">-keepattributes</span> <span class="string">SourceFile, LineNumberTable</span></span><br></pre></td></tr></table></figure><p>对于去除 <code>debuginfo</code> 以及行号信息更详细的分析，看一下支付宝的一篇文章<a href="https://mp.weixin.qq.com/s/_gnT2kjqpfMFs0kqAg4Qig">《Android 包大小极致压缩》</a> 。通过这个方法，我们可以实现既保留行号，但是又可以减少大约 <code>5%</code> 的 <code>Dex</code> 体积。</p><p>事实上，支付宝参考的是 <code>Facebook</code> 的一个开源编译工具 <a href="https://github.com/facebook/redex">ReDex</a> 。<code>ReDex</code> 除了没有文档之外，绝对是客户端领域非常硬核的一个开源库，非常值得去认真研究。<code>ReDex</code> 这个库去除 <code>Debug</code> 信息是通过 <code>StripDebugInfoPass</code> 完成。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;redex&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;passes&quot;</span> : [</span><br><span class="line">      <span class="string">&quot;StripDebugInfoPass&quot;</span>,</span><br><span class="line">      <span class="string">&quot;RegAllocPass&quot;</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;StripDebugInfoPass&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;drop_all_dbg_info&quot;</span> : <span class="literal">false</span>,     <span class="comment">// 去除所有的debug信息，0表示不去除</span></span><br><span class="line">    <span class="attr">&quot;drop_local_variables&quot;</span> : <span class="literal">true</span>,  <span class="comment">// 去除所有局部变量，1表示去除</span></span><br><span class="line">    <span class="attr">&quot;drop_line_numbers&quot;</span> : <span class="literal">false</span>,     <span class="comment">// 去除行号，0表示不去除</span></span><br><span class="line">    <span class="attr">&quot;drop_src_files&quot;</span> : <span class="literal">false</span>,        </span><br><span class="line">    <span class="attr">&quot;use_whitelist&quot;</span> : <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;drop_prologue_end&quot;</span> : <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;drop_epilogue_begin&quot;</span> : <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;drop_all_dbg_info_if_empty&quot;</span> : <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;RegAllocPass&quot;</span> : &#123;</span><br><span class="line">  <span class="attr">&quot;live_range_splitting&quot;</span>: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="3-1-5-Dex-分包"><a href="#3-1-5-Dex-分包" class="headerlink" title="3.1.5 Dex 分包"></a>3.1.5 Dex 分包</h3><p>当我们的 <code>APK</code> 过大时，<code>Dex</code> 的方法数就会超过 <code>65536</code> 个，因此，必须采用 <code>mutildex</code> 进行分包，但是此时每一个 <code>Dex</code> 可能会调用到其它 <code>Dex</code> 中的方法，这种跨 <code>Dex</code> 调用的方式会造成许多冗余信息，</p><p>简单来说，如下图所示如果将 <code>Class A</code> 与 <code>Class B</code> 分别编译到不同的 <code>Dex</code> 中，由于 <code>method a</code> 调用了 <code>method b</code>，所以在 <code>classes2.dex</code> 中也需要加上 <code>method b</code> 的 <code>id</code>。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/96d08f01c5fe27c74bfcd5ac529232d5.webp" alt="图片来源于 Android 开发高手课"></p><p>因为跨 <code>Dex</code> 调用造成的这些冗余信息，它对我们 <code>Dex</code> 的大小会造成下如下两点：</p><ul><li><strong>method id 爆表：</strong>每个 <code>Dex</code> 的 <code>method id</code> 需要小于 <code>65536</code>，因为 <code>method id</code> 的大量冗余导致每个 <code>Dex</code> 真正可以放的 <code>Class</code> 变少，这是造成最终编译的 <code>Dex</code> 数量增多。</li><li><strong>信息冗余：</strong>因为需要记录跨 <code>Dex</code> 调用的方法的详细信息，所以在 <code>classes2.dex</code> 我们还需要记录 <code>Class B</code> 以及 <code>method b</code> 的定义，造成 <code>string_ids</code>、<code>type_ids</code>、<code>proto_ids</code> 这几部分信息的冗余。</li></ul><p>为了进一步减少 <code>Dex</code> 的数量，我们希望每个 <code>Dex</code> 的方法数都是满的，即分配了 <code>65536</code> 个方法。最好保证 Dex 有效率应该在 80% 以上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Dex信息有效率 &#x3D; define methods数量&#x2F;reference methods数量</span><br></pre></td></tr></table></figure><p><code>define methods</code> 与 <code>reference methods</code> 可以通过 <code>Android Studio</code> 查看 <code>APK</code> 选择一个 <code>dex</code> 文件查看。<code>define classes and methods</code> 是指真正在这个 <code>Dex</code> 中定义的类以及它们的方法。而 <code>reference methods</code> 指的是 <code>define methods</code> 以及 <code>define methods</code> 引用到的方法。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/fbd2ebe2b0ffc43447e414994c56d6c4.webp" alt="图片来源于 Android 开发高手课"></p><p>关于 Dex 的格式以及各个字段的定义，可以参考 <a href="https://www.jianshu.com/p/f7f0a712ddfe">Dex文件格式详解</a></p><p><strong>那如何实现 Dex 信息有效率提升呢？</strong></p><p>关键在于我们需要将有调用关系的类和方法分配到同一个 <code>Dex</code> 中，即减少跨 <code>Dex</code> 的调用的情况。但是由于类的调用关系非常复杂，我们不太可能可以计算出最优解，只能得到局部的最优解。</p><p>所幸的是，<code>ReDex</code> 的 <a href="https://github.com/facebook/redex/blob/master/opt/interdex/CrossDexRefMinimizer.cpp">CrossDexDefMinimizer</a> 类分析了类之间的调用关系，并使用了贪心算法去计算局部的最优解（编译效果和 <code>dex</code> 优化效果之间的某一个平衡点）。使用 <code>InterDexPass</code> 配置项可以把互相引用的类尽量放在同个 <code>Dex</code>，增加类的 <code>pre-verify</code>，以此提升应用的冷启动速度。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;redex&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;passes&quot;</span> : [</span><br><span class="line">      <span class="string">&quot;InterDexPass&quot;</span>,</span><br><span class="line">      <span class="string">&quot;RegAllocPass&quot;</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;InterDexPass&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;minimize_cross_dex_refs&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;minimize_cross_dex_refs_method_ref_weight&quot;</span>: <span class="number">100</span>,</span><br><span class="line">    <span class="attr">&quot;minimize_cross_dex_refs_field_ref_weight&quot;</span>: <span class="number">90</span>,</span><br><span class="line">    <span class="attr">&quot;minimize_cross_dex_refs_type_ref_weight&quot;</span>: <span class="number">100</span>,</span><br><span class="line">    <span class="attr">&quot;minimize_cross_dex_refs_string_ref_weight&quot;</span>: <span class="number">90</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;RegAllocPass&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;live_range_splitting&quot;</span>: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Redex-Ubuntu-具体实践"><a href="#Redex-Ubuntu-具体实践" class="headerlink" title="Redex Ubuntu 具体实践"></a>Redex Ubuntu 具体实践</h4><p><a href="http://mirrors.aliyun.com/ubuntu-releases/">ubuntu 下载</a> 我试过 16、18、20 的 <code>Ubuntu</code> 最终 <code>20</code> 的编译成功了。</p><p><a href="https://fbredex.com/docs/installation">Redex 文档</a></p><ol><li><p>首先我们安装必要东西</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install \</span><br><span class="line">    g++ \</span><br><span class="line">    automake \</span><br><span class="line">    autoconf \</span><br><span class="line">    autoconf-archive \</span><br><span class="line">    libtool \</span><br><span class="line">    liblz4-dev \</span><br><span class="line">    liblzma-dev \</span><br><span class="line">    make \</span><br><span class="line">    zlib1g-dev \</span><br><span class="line">    binutils-dev \</span><br><span class="line">    libjemalloc-dev \</span><br><span class="line">    libiberty-dev \</span><br><span class="line">    libjsoncpp-dev</span><br></pre></td></tr></table></figure></li><li><p>然后拉取代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;facebook&#x2F;redex.git</span><br><span class="line">cd redex</span><br></pre></td></tr></table></figure></li><li><p>一般情况下都需要升级 <code>boost</code> ，可以先执行以下编译试试~ </p><p>   <code>-j4</code> 表示使用 <code>4</code> 个线程编译。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># if you&#39;re using gcc, please use gcc-5</span><br><span class="line">autoreconf -ivf &amp;&amp; .&#x2F;configure &amp;&amp; make -j4</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure></li><li><p>如果提示 <code>error boost</code> 版本的问题，升级 <code>boost</code> ，在 <code>redex</code> 目录内输入如下命令，然后重新执行第三步</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo .&#x2F;get_boost.sh</span><br></pre></td></tr></table></figure><pre><code>在第三步编译过程中 18 版本的 `Ubuntu` 一直报错，各种办法未解决，`16` 版本 `boost` 升级配置不上。</code></pre></li><li><p><code>config</code> 配置</p><p>在 <code>Redex</code> 在运行的时候，它是根据 <code>redex/config/default.config</code> 这个配置文件中的通道 <code>passes</code> 中添加不同的优化项来对 <code>APK</code> 的 <code>Dex</code> 进行处理的，我们可以参考 <code>redex/config/default.config</code> 这个默认的配置，里面的 <code>passes</code> 中不同的配置项都有特定的优化。为了优化 <code>App</code> 的包体积，我们再加上 <code>interdex_stripdebuginfo.config</code> 中的配置项去删除 <code>debugInfo</code> 和减少跨 <code>Dex</code> 调用的情况，最终的 <code>interdex_stripdebuginfo.config</code> 配置代码 如下所示：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;redex&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;passes&quot;</span> : [</span><br><span class="line">            <span class="string">&quot;StripDebugInfoPass&quot;</span>,</span><br><span class="line">            <span class="string">&quot;InterDexPass&quot;</span>,</span><br><span class="line">            <span class="string">&quot;RegAllocPass&quot;</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;StripDebugInfoPass&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;drop_all_dbg_info&quot;</span> : <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">&quot;drop_local_variables&quot;</span> : <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">&quot;drop_line_numbers&quot;</span> : <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">&quot;drop_src_files&quot;</span> : <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">&quot;use_whitelist&quot;</span> : <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">&quot;cls_whitelist&quot;</span> : [],</span><br><span class="line">        <span class="attr">&quot;method_whitelist&quot;</span> : [],</span><br><span class="line">        <span class="attr">&quot;drop_prologue_end&quot;</span> : <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">&quot;drop_epilogue_begin&quot;</span> : <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">&quot;drop_all_dbg_info_if_empty&quot;</span> : <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;InterDexPass&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;minimize_cross_dex_refs&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">&quot;minimize_cross_dex_refs_method_ref_weight&quot;</span>: <span class="number">100</span>,</span><br><span class="line">        <span class="attr">&quot;minimize_cross_dex_refs_field_ref_weight&quot;</span>: <span class="number">90</span>,</span><br><span class="line">        <span class="attr">&quot;minimize_cross_dex_refs_type_ref_weight&quot;</span>: <span class="number">100</span>,</span><br><span class="line">        <span class="attr">&quot;minimize_cross_dex_refs_string_ref_weight&quot;</span>: <span class="number">90</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;RegAllocPass&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;live_range_splitting&quot;</span>: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;string_sort_mode&quot;</span> : <span class="string">&quot;class_order&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;bytecode_sort_mode&quot;</span> : <span class="string">&quot;class_order&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>最后，执行相应的 <code>redex</code> 优化命令</strong></p><p>它使用了贪心这种局部最优解的方式去减少跨 <code>Dex</code> 调用造成的信息冗余，命令如下所示（注意，在 <code>redex</code> 的前面可能需要加上 <code>Android sdk</code> 的路径，因为 <code>redex</code> 中使用到了 <code>sdk</code> 下的 <code>zipalign</code> 工具）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ANDROID_SDK&#x3D;&#x2F;usr&#x2F;lib&#x2F;android-sdk redex --sign -s &lt;xxx&gt;.jks -a &lt;alias&gt; -p 123456 -c redex&#x2F;config&#x2F;interdex_stripdebuginfo.config -P proguard-rules.pro &lt;youapk&gt;.apk -o redexSign.apk</span><br></pre></td></tr></table></figure><p>上述 <code>redex</code> 命令的 <code>关键参数含义</code> 如下所示：</p><ul><li><strong>–sign：</strong> 对生成的 <code>apk</code> 进行签名。</li><li><strong>-s：</strong> 配置应用的签名文件。</li><li><strong>-a：</strong> 配置应用签名的 <code>key_alias</code>。</li><li><strong>-p：</strong> 配置应用签名的 <code>key_password</code>。</li><li><strong>-c：</strong> 指定 <code>redex</code> 进行 <code>Dex</code> 处理时需要依据的 <code>CONFIG</code> 配置文件。</li><li><strong>-o：</strong> 指定生成 <code>APK</code> 的全路径。</li><li><strong>-P：</strong> 是混淆文件</li></ul></li><li><p>补充：</p><ul><li><code>Linux</code> 中下载 <code>android-sdk</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update &amp;&amp; sudo apt install android-sdk</span><br></pre></td></tr></table></figure></li></ul><p>我最后在 <code>/usr/lib/android-sdk</code> 中找到</p><ul><li><p>运行 test 需要在 <code>redex</code> 目录下执行 <code>./test/setup.sh</code> 文件中有个 <code>pushd test</code> ，还需要安装 <code>curl</code> 和 <code>unzip</code></p></li><li><p>如果报错 <code>fatal error:Killed signal terminated program cc1plus</code> 是内存不足了，请分配足够大的内存，还有可能 <code>cpu</code> 太高，请适当减少运行线程，<code>autoreconf -ivf &amp;&amp; ./configure &amp;&amp; make -j4</code> 这句话中 <code>-j4</code> 表示开启 <code>4</code> 个线程，如果不是多核的开线程没有用。我最后用 <code>make -j2</code> 给了 <code>4G</code> 内存执行成功。</p></li></ul></li></ol><p>经过三天努力，终于编译成功，但是在 <code>release</code> 包下 体积并没有减少， <code>debug</code> 有变少。</p><p>通过搜索，可能是没有做到压缩，只做了 <code>dex</code> 重排加速了启动，所以体积可能不小反而变大一点点。</p><p>也有可能项目太小发挥不了作用。</p><p>还会再继续探究 ~</p><hr><h3 id="3-1-6-使用-XZ-Utils-进行-Dex-压缩"><a href="#3-1-6-使用-XZ-Utils-进行-Dex-压缩" class="headerlink" title="3.1.6 使用 XZ Utils 进行 Dex 压缩"></a>3.1.6 使用 XZ Utils 进行 Dex 压缩</h3><p><a href="https://tukaani.org/xz/">XZ Utils</a> 和 <code>7-Zip</code> 一样，内部使用的都是 <code>LZMA</code> 算法。<code>LZMA</code> 提供了高压缩比和快速解压缩，因此非常适合嵌入式应用。对于 <code>Dex</code> 格式来说，<code>XZ</code> 的压缩率可以比 <code>Zip</code> 高 <code>30%</code> 左右。</p><p>在 <code>FaceBook</code> 的 <code>App</code> 中就使用了 <code>Dex 压缩</code> 的方式，而且它将 <code>Dex</code> 压缩后的文件都放在了 <code>assets</code> 目录中</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/008dc38d277aab4eabfb580ccac7aef7.webp" alt="图片来源于 Android 开发高手课"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/66abe10ca8e67e86ced07087555b8f22.webp" alt="图片来源于 Android 开发高手课"></p><p>我们先看到上图中的 <code>classes.dex</code>，其中仅包含了启动时要用到的类，这样可以为 <code>Dex</code> 压缩文件 <code>secondary.dex.jar.xzs</code> 的解压争取时间。</p><p>但是，这套方案还存在一些问题：</p><ul><li><strong>首次启动解压</strong>：应用首次启动的时候，需要将 <code>secondary.dex.jar.xzs</code> 解压缩，<code>Facebook</code> 使用多线程解压的方式，这个耗时在高端机是几百毫秒左右，在低端机可能需要 3～5 秒。</li><li><strong>ODEX 文件生成</strong>：当 <code>Dex</code> 非常多的时候会增加应用的安装时间，如果还使用了压缩 <code>Dex</code> 的方式，那么首次生成 <code>ODEX</code> 的时间可能就会超过 1 分钟。<code>Facebook</code> 为了解决这个问题，使用了 <code>ReDex</code> 另外一个超级硬核的方法，那就是 <a href="https://github.com/facebook/redex/tree/master/tools/oatmeal">oatmeal</a> 。<ul><li>对于正常的流程，我们需要 <code>fork</code> 进程来生成 <code>dex2oat</code>，这个耗时一般都比较大。通过 <code>oatmeal</code>，我们直接在本进程生成 <code>ODEX</code> 文件。一个 <code>10MB</code> 的 <code>Dex</code>，如果在 <code>Android 5.0</code> 生成一个 <code>ODEX</code> 的耗时大约在 <code>10</code> 秒以上，在 <code>Android 8.0</code> 使用 <code>speed</code> 模式大约在 1 秒左右，而通过 <code>oatmeal</code> 这个耗时大约在 <code>100</code> 毫秒左右。</li></ul></li></ul><p><code>ReDex</code> 提供的功能：</p><ol><li><strong>Interdex：</strong>类重排和文件重排、<code>Dex</code> 分包优化。</li><li><strong>Oatmeal：</strong> 直接生成 <code>Odex</code> 文件。</li><li><strong>StripDebugInfo：</strong> 去除 <code>Dex</code> 中的 <code>Debug</code> 信息。</li><li><strong>源码中 access-marking 模块：</strong> 删除 <code>Java access</code> 方法 。</li><li><strong>源码中 type-erasure 模块：</strong>类型擦除。</li></ol><hr><h3 id="3-1-7-其他"><a href="#3-1-7-其他" class="headerlink" title="3.1.7 其他"></a>3.1.7 其他</h3><ul><li><p><strong>使用 Lint 检测无效代码</strong></p><p><code>步骤：点击菜单栏 Analyze -&gt; Run Inspection by Name -&gt; unused declaration -&gt; Moudule ‘app’ -&gt; OK</code></p></li><li><p><strong>避免产生 access 方法的方式</strong></p><p><a href="https://mp.weixin.qq.com/s/ZHisCVjO_ZrtvvEWBYUQFQ">西瓜视频 apk 瘦身之 Java access 方法删除</a> </p><p>编译阶段去除 <code>access</code> 方法</p><p><a href="https://github.com/bytedance/ByteX"> 抖音 Android 团队 ByteX</a> </p><p>已集成的插件</p><ul><li><a href="https://github.com/bytedance/ByteX/blob/master/access-inline-plugin/README-zh.md">access-inline-plugin</a>（<code>access</code> 方法内联）</li><li><a href="https://github.com/bytedance/ByteX/blob/master/shrink-r-plugin/README-zh.md">shrink-r-plugin</a>（<code>R</code> 文件瘦身和无用资源检查）</li><li><a href="https://github.com/bytedance/ByteX/blob/master/closeable-check-plugin/README-zh.md">closeable-check-plugin</a>（文件流的 <code>close</code> 检查）</li><li><a href="https://github.com/bytedance/ByteX/blob/master/const-inline-plugin/README-zh.md">const-inline-plugin</a>（常量内联）</li><li><a href="https://github.com/bytedance/ByteX/blob/master/field-assign-opt-plugin/README-zh.md">field-assign-opt-plugin</a>（优化多余赋值指令）</li><li><a href="https://github.com/bytedance/ByteX/blob/master/getter-setter-inline-plugin/README-zh.md">getter-setter-inline-plugin</a> （<code>getter</code> 和 <code>setter</code> 方法内联）</li><li><a href="https://github.com/bytedance/ByteX/blob/master/method-call-opt-plugin/README-zh.md">method-call-opt-plugin</a>（干净地删除某些方法调用，如 <code>Log.d</code>）</li><li><a href="https://github.com/bytedance/ByteX/blob/master/coverage/README-zh.md">coverage-plugin</a>（线上代码覆盖率）</li><li><a href="https://github.com/bytedance/ByteX/blob/master/refer-check-plugin/README-zh.md">refer-check-plugin</a>（检查是否有调用不存在的方法和引用不存在的字段）</li><li><a href="https://github.com/bytedance/ByteX/blob/master/serialization-check-plugin/README-zh.md">serialization-check-plugin</a>（序列化检查）</li><li><a href="https://github.com/bytedance/ByteX/blob/master/SourceFileKiller/README-zh.md">SourceFileKiller</a>（删除 <code>SourceFile</code> 和行号属性，作为示例）</li><li><a href="https://github.com/bytedance/ByteX/blob/master/butterknife-check-plugin/README-zh.md">ButterKnifeChecker</a>（检测跨 <code>module</code> 使用 <code>ButterKnife</code> 可能导致的问题）</li><li><a href="https://github.com/bytedance/ByteX/blob/master/shrink-r-plugin/RFileKnife-README-zh.md">RFileKnife</a>（修复 <code>R.java</code> 太大编译报 <code>code too large</code> 的问题）</li></ul></li></ul><hr><h2 id="3-2-资源相关"><a href="#3-2-资源相关" class="headerlink" title="3.2 资源相关"></a>3.2 资源相关</h2><p><code>res</code>、<code>assets</code>、编译后的二进制资源文件 <code>resources.arsc</code> 和 清单文件 等等。<code>res</code> 和 <code>assets</code> 的不同在于 <code>res</code> 目录下的文件会在 <code>.R</code> 文件中生成对应的资源 <code>ID</code>，而 <code>assets</code> 不会自动生成对应的 <code>ID</code>，而是通过 <code>AssetManager</code> 类的接口来获取。此外，每当在 <code>res</code> 文件夹下放一个文件时，<code>aapt</code> 就会自动生成对应 <code>id</code> 并保存在 <code>.R</code> 文件中，但 <code>.R</code> 文件仅仅只是保证编译程序不会报错，实际上在应用运行时，系统会根据 <code>ID</code> 寻找对应的资源路径，而 <code>resources.arsc</code> 文件就是用来记录这些 <code>ID</code> 和 资源文件位置对应关系 的文件。</p><h3 id="3-2-1-使用-Lint-的-Remove-Unused-Resource"><a href="#3-2-1-使用-Lint-的-Remove-Unused-Resource" class="headerlink" title="3.2.1 使用 Lint 的 Remove Unused Resource"></a>3.2.1 使用 Lint 的 Remove Unused Resource</h3><p><code>Refactor -&gt; Remove Unused Resource -&gt; preview</code> 可以预览找到的无用资源</p><p>需要注意的，<code>Android Lint</code> 不会分析 <code>assets</code> 文件夹下的资源，因为 <code>assets</code> 文件可以通过文件名直接访问，不需要通过具体的引用，<code>Lint</code> 无法判断资源是否被用到。</p><h3 id="3-2-2-shrinkResources"><a href="#3-2-2-shrinkResources" class="headerlink" title="3.2.2 shrinkResources"></a>3.2.2 shrinkResources</h3><p>Android <code>shrinkResources</code> 资源压缩功能，它需要配合 <code>ProGurad</code> 的 <code>minifyEnabled</code> 功能同时使用。如果 <code>ProGuard</code> 把部分无用代码移除，这些代码所引用的资源也会被标记为无用资源，然后通过资源压缩功能将它们移除。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            shrinkResources <span class="literal">true</span></span><br><span class="line">            minifyEnabled <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是看起来很完美，但是目前的 <code>shrinkResources</code> 实现起来还有几个缺陷。</p><ul><li><strong>没有处理 resources.arsc 文件。</strong> 这样导致大量无用的 <code>String</code>、<code>ID</code>、<code>Attr</code>、<code>Dimen</code> 等资源并没有被删除。</li><li><strong>没有真正删除资源文件。</strong> 对于 <code>Drawable</code>、<code>Layout</code> 这些无用资源，<code>shrinkResources</code> 也没有真正把它们删掉，而是仅仅替换为一个空文件。为什么不能删除呢？主要还是因为 <code>resources.arsc</code> 里面还有这些文件的路径，具体你可以查看这个 <a href="https://issuetracker.google.com/issues/37010152">issues</a> 。</li></ul><p>如果想解答系统为什么不能直接把这些资源删除，我们需要先回过头来重温一下 <code>Android</code> 的编译流程。</p><ul><li>由于 <code>Java</code> 代码需要用到资源的 <code>R.java</code> 文件，所以我们就需要把 <code>R.java</code> 提前准备好。</li><li>在编译 <code>Java</code> 代码过程，已经根据 <code>R.java</code> 文件，直接将代码中资源的引用替换为常量，例如将 <code>R.String.sample</code> 替换为 <code>0x7f0c0003</code>。</li><li><code>.ap_</code> 资源文件的同步编译，例如 <code>resources.arsc</code>、XML 文件的处理等。</li></ul><p>如果我们在这个过程强行把无用资源文件删除，<code>resources.arsc</code> 和 <code>R.java</code> 文件的资源 <code>ID</code> 都会改变（因为默认都是连续的），这个时候代码中已经替换过的 <code>0x7f0c0003</code> 就会出现资源错乱或者找不到的情况。</p><p>因此系统为了避免发生这种情况，采用了折中的方法，并没有二次处理 <code>resources.arsc</code> 文件，只是仅仅把无用的 <code>Drawable</code> 和 <code>Layout</code> 文件替换为空文件。</p><p>那怎么样才能真正实现无用资源的删除功能呢？我们可以利用 <code>resources.arsc</code> 中 <code>Public ID</code> 的机制，实现非连续的资源 ID。</p><p>简单来说，就是 <code>keep</code> 住保留资源的 <code>ID</code>，保证已经编译完的代码可以正常找到对应的资源。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/20200531194630.webp" alt="图片来源于 Android 开发高手课"></p><p>但是重写 <code>resources.arsc</code> 的方法会比资源混淆更加复杂，我们既要从这个文件中抹去所有的无用资源相关信息，还要 <code>keep</code> 住所有保留资源的 <code>ID</code>，相当于把整个文件都重写了。</p><p>正因为异常复杂，所以目前 <code>Android</code> 还没有提供这套方案的完整实现。</p><p><a href="https://juejin.im/post/5e7ad1c0e51d450edc0cf053#heading-68">深入探索 Android 包体积优化 优化 shrinkResources 流程真正去除无用资源</a>  一文中给出一个方法。</p><p><code>matrix</code> 也实现了相关内容 <a href="https://github.com/Tencent/matrix/blob/master/matrix/matrix-android/matrix-apk-canary/src/main/java/com/tencent/matrix/apk/model/task/UnusedAssetsTask.java">UnusedAssetsTask</a> </p><h3 id="3-2-3-AndResGuard-工具"><a href="#3-2-3-AndResGuard-工具" class="headerlink" title="3.2.3 AndResGuard 工具"></a>3.2.3 AndResGuard 工具</h3><p>在我们的安装包中，资源相关的文件具体有下面这几个，它们都是我们需要优化的目标文件。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/dd5c7efb6074ff0f2bd18296f9ecf1b7.webp" alt="图片来源于 Android 开发高手课"></p><p><a href="https://github.com/shwenzhang/AndResGuard">AndResGuard</a> 工具它主要有两个功能，一个是资源混淆，一个是资源的极限压缩。</p><ol><li><p><strong>资源混淆</strong></p><p>资源混淆的思路其实非常简单，就是把资源和文件的名字混淆成短路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Proguard          -&gt; Resource Proguard</span><br><span class="line">R.string.name     -&gt; R.string.a   </span><br><span class="line">res&#x2F;drawable&#x2F;icon -&gt; res&#x2F;s&#x2F;a</span><br></pre></td></tr></table></figure><p>那么这样的实现究竟对哪些资源文件有优化作用呢？</p><ul><li><strong>resources.arsc。</strong>因为资源索引文件 <code>resources.arsc</code> 需要记录资源文件的名称与路径，使用混淆后的短路径 <code>res/s/a</code>，可以减少整个文件的大小。</li><li><strong>metadata 签名文件。</strong><a href="https://cloud.tencent.com/developer/article/1354380">签名文件 MF 与 SF</a> 都需要记录所有文件的路径以及它们的哈希值，使用短路径可以减少这两个文件的大小。</li><li><strong>ZIP 文件索引。</strong> <code>ZIP</code> 文件格式里面也需要记录每个文件 <code>Entry</code> 的路径、压缩算法、<code>CRC</code>、文件大小等信息。使用短路径，本身就可以减少记录文件路径的字符串大小。</li></ul></li><li><p><strong>极限压缩</strong></p><p><code>AndResGuard</code> 的另外一个优化就是极限压缩，它的极限压缩功能体现在两个方面：</p><ul><li><p><strong>更高的压缩率。</strong>虽然我们使用的还是 <code>Zip</code> 算法，但是利用了 <code>7-Zip</code> 的大字典优化，<code>APK</code> 的整体压缩率可以提升 <code>3%</code> 左右。</p></li><li><p><strong>压缩更多的文件。</strong> <code>Android</code> 编译过程中，下面这些格式的文件会指定不压缩；在 <code>AndResGuard</code> 中，我们支持针对 <code>resources.arsc</code>、<code>PNG</code>、<code>JPG</code> 以及 <code>GIF</code> 等文件的强制压缩。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* these formats are already compressed, or don&#39;t compress well *&#x2F;</span><br><span class="line">static const char* kNoCompressExt[] &#x3D; &#123;</span><br><span class="line">    &quot;.jpg&quot;, &quot;.jpeg&quot;, &quot;.png&quot;, &quot;.gif&quot;,</span><br><span class="line">    &quot;.wav&quot;, &quot;.mp2&quot;, &quot;.mp3&quot;, &quot;.ogg&quot;, &quot;.aac&quot;,</span><br><span class="line">    &quot;.mpg&quot;, &quot;.mpeg&quot;, &quot;.mid&quot;, &quot;.midi&quot;, &quot;.smf&quot;, &quot;.jet&quot;,</span><br><span class="line">    &quot;.rtttl&quot;, &quot;.imy&quot;, &quot;.xmf&quot;, &quot;.mp4&quot;, &quot;.m4a&quot;,</span><br><span class="line">    &quot;.m4v&quot;, &quot;.3gp&quot;, &quot;.3gpp&quot;, &quot;.3g2&quot;, &quot;.3gpp2&quot;,</span><br><span class="line">    &quot;.amr&quot;, &quot;.awb&quot;, &quot;.wma&quot;, &quot;.wmv&quot;, &quot;.webm&quot;, &quot;.mkv&quot;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>为什么 <code>Android</code> 系统会专门选择不去压缩这些文件呢？</p><ul><li><strong>压缩效果并不明显。</strong>这些格式的文件大部分本身已经压缩过，重新做 <code>Zip</code> 压缩效果并不明显。例如 <code>PNG</code> 和 <code>JPG</code> 格式，重新压缩只有 <code>3%～5%</code> 的收益，并不是十分明显。</li><li><strong>读取时间与内存的考虑。</strong>如果文件是没有压缩的，系统可以利用 <code>mmap</code> 的方式直接读取，而不需要一次性解压并放在内存中。</li></ul></li></ol><h4 id="AndResGuard-实践"><a href="#AndResGuard-实践" class="headerlink" title="AndResGuard 实践"></a>AndResGuard 实践</h4><p>配置根据 <a href="https://github.com/shwenzhang/AndResGuard">AndResGuard</a> 走就可以</p><p>编译在 <code>Gradle -&gt; app -&gt; Tasks -&gt; andresguard-&gt; resguardRelease</code> 可以进行编译打包，结果生成在 <code>app -&gt; build -&gt; outputs -&gt; apk -&gt; release -&gt; AndResGuard_xxx</code> 下。</p><p>此外，抖音 <code>Android</code> 团队还开源了针对于海外市场 <code>App Bundle APK</code> 的 <a href="https://github.com/bytedance/AabResGuard/blob/develop/wiki/zh-cn/README.md">AabResGuard 资源混淆工具</a> </p><p>在美团的一篇文章<a href="https://tech.meituan.com/2017/04/07/android-shrink-overall-solution.html">《Android App 包瘦身优化实践》</a> 中，也讲到了很多资源优化相关的方法，例如 <code>WebP</code> 和 <code>SVG</code>、<code>R</code> 文件、无用资源、资源混淆以及语言压缩等。</p><h2 id="3-3-Native-Library-相关"><a href="#3-3-Native-Library-相关" class="headerlink" title="3.3 Native Library 相关"></a>3.3 Native Library 相关</h2><p>对于 Native Library，传统的优化方法可能就是去除 Debug 信息、使用 c++_shared 这些。那我们还有没有更好的优化方法呢？</p><h3 id="3-3-1-Library-压缩"><a href="#3-3-1-Library-压缩" class="headerlink" title="3.3.1 Library 压缩"></a>3.3.1 Library 压缩</h3><p>跟 <code>Dex</code> 压缩一样，Library 优化最有效果的方法也是使用 <code>XZ</code> 或者 <code>7-Zip</code> 压缩。</p><p>在默认的 <code>lib</code> 目录，我们只需要加载少数启动过程相关的 <code>Library</code>，其他的 <code>Library</code> 我们都在首次启动时解压。对于 <code>Library</code> 格式来说，压缩率同样可以比 <code>Zip</code> 高 <code>30%</code> 左右，效果十分惊人。</p><p><code>Facebook</code> 有一个 <code>So</code> 加载的开源库 <a href="https://github.com/facebook/SoLoader">SoLoader</a> ，它可以跟这套方案配合使用。和 <code>Dex</code> 压缩一样，压缩方案的主要缺点在于首次启动的时间，毕竟对于低端机来说，多线程的意义并不大，因此我们要在包体积和用户体验之间做好平衡。</p><h3 id="3-3-2-Library-合并与裁剪"><a href="#3-3-2-Library-合并与裁剪" class="headerlink" title="3.3.2 Library 合并与裁剪"></a>3.3.2 Library 合并与裁剪</h3><p>对于 <code>Native Library</code>，<code>Facebook</code> 中的编译构建工具 <a href="https://buck.build/">Buck</a> 也有两个比较硬核的高科技。当然在官方文档中是完全找不到的，它们都隐藏在 <a href="https://github.com/facebook/buck">源码</a> 中。</p><ul><li><strong>Library 合并。</strong>在 <code>Android 4.3</code> 之前，进程加载的 <code>Library</code> 数量是有限制的。在编译过程，我们可以自动将部分 <code>Library</code> 合并成一个。具体思路可以参考文章<a href="https://engineering.fb.com/android/android-native-library-merging/">《Android native library merging》</a> 以及 <a href="https://github.com/fbsamples/android-native-library-merging-demo">Demo</a> 。</li><li><strong>Library 裁剪。</strong> <code>Buck</code> 里面有一个 <a href="https://github.com/facebook/buck/blob/master/src/com/facebook/buck/android/relinker/NativeRelinker.java">relinker</a> 的功能，原理就是分析代码中 <code>JNI</code> 方法以及不同 <code>Library</code> 的方法调用，找到没有无用的导出 <code>symbol</code>，将它们删掉。这样 <code>linker</code> 在编译的时候也会把对应的无用代码同时删掉，这个方法相当于实现了 <code>Library</code> 的 <code>ProGuard Shrinking</code> 功能。</li></ul><h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h1><blockquote><p><a href="https://time.geekbang.org/column/article/74044">极客时间 Android开发高手课</a>  </p><p><a href="https://juejin.im/post/5e7ad1c0e51d450edc0cf053">深入探索 Android 包体积优化</a> </p><p><a href="https://blog.dreamtobe.cn/android_d8_r8/">Android新Dex编译器D8与新混淆工具R8</a> </p><p>以及上文中的链接</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>App 网络优化🌞</title>
      <link href="2020/network-optimization.html"/>
      <url>2020/network-optimization.html</url>
      
        <content type="html"><![CDATA[<p>在 <code>PC</code> 互联网时代，网络优化已经是一项非常复杂的工作。对于移动网络来说，弱网络、网络切换、网络劫持这些问题更加突出，网络优化这项工作也变得更加艰巨。</p><h1 id="本文主要记载"><a href="#本文主要记载" class="headerlink" title="本文主要记载"></a>本文主要记载</h1><ul><li><strong>1 网络库实现哪家强？</strong></li><li><strong>2 网络需要优化哪些？</strong><ul><li>2.1 HTTPDNS</li><li>2.2 链接复用</li><li>2.3 压缩与加密</li><li>2.4 其他优化</li></ul></li><li><strong>3 如何监控网络</strong></li><li><strong>4 PLT HOOK Demo 练习</strong></li></ul><hr><h1 id="1-网络库实现哪家强？"><a href="#1-网络库实现哪家强？" class="headerlink" title="1 网络库实现哪家强？"></a>1 网络库实现哪家强？</h1><p>在实际的开发工作中，我们很少会像《UNIX 网络编程》那样直接去操作底层的网络接口，一般都会使用网络库。<code>Square</code> 出品的 <a href="https://github.com/square/okhttp">OkHttp</a> 是目前最流行的 <code>Android</code> 网络库，它还被 <code>Google</code> 加入到 <code>Android</code> 系统内部，为广大开发者提供网络服务。</p><p>网络库的作用是屏蔽了下层复杂的网络接口，让我们可以更高效地使用网络请求。主要有以下三点：</p><ul><li><strong>统一编程接口：</strong>无论是同步还是异步请求，接口都非常简单易用。同时我们可以统一做策略管理，统一进行流解析（<code>JSON</code>、<code>XML</code>、<code>Protocol Buffers</code>）等。</li><li><strong>全局网络控制：</strong>在网络库内部我们可以做统一的网络调度、流量监控以及容灾管理等工作。</li><li><strong>高性能：</strong>既然我们把所有的网络请求都交给了网络库，那网络库是否实现高性能就至关重要。既然要实现高性能，那我会非常关注速度，<code>CPU</code>、内存、<code>I/O</code> 的使用，以及失败率、崩溃率、协议的兼容性等方面。</li></ul><p>接下来对比 <code>OkHttp</code>、<code>Chromium</code> 的 <a href="https://chromium.googlesource.com/chromium/src/+/master/components/cronet/">Cronet</a> 以及微信 <a href="https://github.com/Tencent/mars">Mars</a> 这三个网络库的内部实现。</p><p><a href="https://www.infoq.cn/article/mogujie-app-chromium-network-layer?useSponsorshipSuggestions=true%2F">蘑菇街</a> 、头条、<code>UC</code> 浏览器、微信 <code>Mars</code> 都在 <code>Chromium</code> 网络库上做了二次开发，而微信 <code>Mars</code> 在弱网络方面做了大量优化，拼多多、虎牙、链家、美丽说这些应用都在使用 <code>Mars</code>。</p><p>为什么那么多大厂都在用<code>Chromium</code> 的 <a href="https://chromium.googlesource.com/chromium/src/+/master/components/cronet/">Cronet</a> 做二次开发，而不用 <code>OkHTTP</code> 呢？主要因为它并不支持跨平台，对于大型应用来说跨平台是非常重要的。我们不希望所有的优化 <code>Android</code> 和 <code>iOS</code> 都要各自去实现一套，不仅浪费人力而且还容易出问题。对于 <a href="https://github.com/Tencent/mars">Mars</a> 来说，它是一个跨平台的 <code>Socket</code> 层解决方案，并不支持完整的 <code>HTTP</code> 协议，所以 Mars 从严格意义上来讲并不是一个完整的网络库。但是它在弱网络和连接上做了大量的优化，并且支持长连接。</p><p><code>Chromium</code> 网络库作为标准的网络库，基本上可以说是找不到太大的缺点。而且我们可以享受 <code>Google</code> 后续网络优化的成果，类似 <code>TLS 1.3</code>、<code>QUIC</code> 支持等。但是它针对弱网络场景没有做太多定制的优化，也不支持长连接。</p><h1 id="2-网络需要优化哪些？"><a href="#2-网络需要优化哪些？" class="headerlink" title="2 网络需要优化哪些？"></a>2 网络需要优化哪些？</h1><p>在讲怎么去优化网络之前，先明确一下所谓的网络优化，究竟指的是什么？</p><ul><li><strong>速度：</strong>在网络正常或者良好的时候，怎样更好地利用带宽，进一步提升网络请求速度。</li><li><strong>弱网络：</strong>移动端网络复杂多变，在出现网络连接不稳定的时候，怎样最大程度保证网络的连通性。</li><li><strong>安全：</strong>网络安全不容忽视，怎样有效防止被第三方劫持、窃听甚至篡改。</li></ul><p><strong>网络请求的整个过程</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/8d6e833f2a6c6d1e8beeb92d4579c38b.png" alt="图片来源于 Android 开发高手课"></p><ul><li><strong>DNS 解析：</strong>通过 <code>DNS</code> 服务器，拿到对应域名的 <code>IP</code> 地址。在这个步骤，我们比较关注 <code>DNS</code> 解析耗时情况、运营商 <code>LocalDNS</code> 的劫持、<code>DNS</code> 调度这些问题。</li><li><strong>创建连接：</strong>跟服务器建立连接，这里包括 <code>TCP</code> 三次握手、<code>TLS</code> 密钥协商等工作。多个 <code>IP/</code> 端口该如何选择、是否要使用 <code>HTTPS</code>、能否可以减少甚至省下创建连接的时间，这些问题都是我们优化的关键。</li><li><strong>发送 / 接收数据：</strong>在成功建立连接之后，就可以愉快地跟服务器交互，进行组装数据、发送数据、接收数据、解析数据。我们关注的是，如何根据网络状况将带宽利用好，怎么样快速地侦测到网络延时，在弱网络下如何调整包大小等问题。</li><li><strong>关闭连接：</strong>连接的关闭看起来非常简单，其实这里的水也很深。这里主要关注主动关闭和被动关闭两种情况，一般我们都希望客户端可以主动关闭连接。</li></ul><p>🔥🔥 <strong>所谓的网络优化，就是围绕速度、弱网络、安全这三个核心内容，减少每一个步骤的耗时，打造快速、稳定且安全的高质量网络。</strong></p><h2 id="2-1-HTTPDNS"><a href="#2-1-HTTPDNS" class="headerlink" title="2.1 HTTPDNS"></a>2.1 HTTPDNS</h2><p><code>DNS</code> 的解析是网络请求的第一项工作，默认使用运营商的 <code>LocalDNS</code> 服务。这块耗时在 <code>3G</code> 网络下可能是 <code>200～300ms</code>，<code>4G</code> 网络也需要 <code>100ms</code>。</p><p>解析慢并不是默认 <code>LocalDNS</code> 最大的 “原罪” ，它还存在一些其他问题：</p><ul><li><strong>稳定性：</strong><code>UDP</code> 协议，无状态，容易域名劫持（难复现、难定位、难解决），每天至少几百万个域名被劫持，一年至少十次大规模事件。</li><li><strong>准确性：</strong><code>LocalDNS</code> 调度经常出现不准确，比如北京的用户调度到广东 <code>IP</code>，移动的运营商调度到电信的 <code>IP</code>，跨运营商调度会导致访问慢，甚至访问不了。</li><li><strong>及时性：</strong>运营商可能会修改 <code>DNS</code> 的 <code>TTL</code>，导致 <code>DNS</code> 修改生效延迟。不同运营商的服务实现不一致，我们也很难保证 <code>DNS</code> 解析的耗时。</li></ul><p>为了解决这些问题，就有了 <code>HTTPDNS</code>。简单来说自己做域名解析的工作，通过 <code>HTTP</code> 请求后台去拿到域名对应的 <code>IP</code> 地址，直接解决上述所有问题。</p><p><a href="https://mp.weixin.qq.com/s/iaPtSF-twWz-AN66UJUBDg">《百度App网络深度优化系列《一》DNS优化》</a> </p><p><a href="https://github.com/aliyun/alicloud-android-demo/tree/master/httpdns_android_demo">阿里 HTTPDNS</a></p><p><a href="https://github.com/CNSRE/HTTPDNSLib">新浪 HTTPDNS库</a>  |  <a href="https://www.jianshu.com/p/a7c750f27e53">Android端HttpDNS优化方案</a>  |  <a href="https://blog.csdn.net/sbsujjbcy/article/details/51612832">Android OkHttp实现HttpDns的最佳实践（非拦截器）</a> </p><h2 id="2-2-连接复用"><a href="#2-2-连接复用" class="headerlink" title="2.2 连接复用"></a>2.2 连接复用</h2><p>利用 <code>HTTP</code> 协议里的 <code>keep-alive</code>，而 <code>HTTP/2.0</code> 的多路复用则可以进一步的提升连接复用率。它复用的这条连接支持同时处理多条请求，所有请求都可以并发在这条连接上进行。</p><p>虽然 <code>H2</code> 十分强大，不过这里还有两个问题需要解决。</p><ul><li>一个是同一条 <code>H2</code> 连接只支持同一个域名</li><li>一个是后端支持 <code>HTTP/2.0</code> 需要额外的改造</li></ul><p>这个时候我们只需要在统一接入层（传说中的中台？）做改造，接入层将数据转换到 <code>HTTP/1.1</code> 再转发到对应域名的服务器。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/d7dc96541811392f2a669232582c0bc9.png" alt="图片来源于 Android 开发高手课"></p><p>这样所有的服务都不用做任何改造就可以享受 <code>HTTP/2.0</code> 的所有优化，不过这里需要注意的是 <code>H2</code> 的多路复用在本质上依然是同一条 <code>TCP</code>连接，如果所有的域名的请求都集中在某一条连接中，在网络拥塞的时候容易出现 <code>TCP</code> 队首阻塞问题。</p><h2 id="2-3-压缩与加密"><a href="#2-3-压缩与加密" class="headerlink" title="2.3 压缩与加密"></a>2.3 压缩与加密</h2><h3 id="2-3-1-压缩"><a href="#2-3-1-压缩" class="headerlink" title="2.3.1 压缩"></a>2.3.1 压缩</h3><p>首先对于 <code>HTTP</code> 请求来说，数据主要包括三个部分：请求 <code>URL</code>、请求 <code>header</code>、请求 <code>body</code>。</p><p>对于请求 <code>body</code> 来说，一方面是数据通信协议的选择，在网络传输中目前最流行的两种数据序列化方式是 <code>JSON</code> 和 <code>Protocol Buffers</code>。<code>Protocol Buffers</code> 使用起来更加复杂一些，但在数据压缩率、序列化与反序列化速度上面都有很大的优势。</p><p>另外一方面是压缩算法的选择，通用的压缩算法主要是如 <code>gzip</code>，<code>Google</code> 的 <a href="https://github.com/google/brotli">Brotli</a> 或者 <code>Facebook</code> 的 <a href="https://github.com/facebook/zstd">Z-standard</a> 等算法，用来减少流量消耗和传输时间。</p><p>针对图片我们可以使用 <code>webp</code>、<code>hevc</code>、<code>SharpP</code> 等压缩率更高的格式。</p><p><a href="http://i.lckiss.com/?p=4606">关于Android okHttp Gzip的简单处理</a> </p><p><a href="https://www.jianshu.com/p/a9d861732445">OkHttp使用gzip时的坑</a>   <a href="https://stackoverflow.com/questions/26360858/okhttp-gzip-post-body">Gzip 手动解压</a> </p><p>还有就是 <code>gzip</code> 拦截器要添加到签名等操作拦截器之后，我们网络库在上传前需要使用 <code>body</code> 生成签名，如果在生成签名之前先使用 <code>gzip</code> 压缩了 <code>body</code> 体会什么也拿不到。</p><h3 id="2-3-2-安全"><a href="#2-3-2-安全" class="headerlink" title="2.3.2 安全"></a>2.3.2 安全</h3><p>数据安全也是网络重中之重的一个环节，在大网络平台中我们都是基于 <code>HTTPS</code> 的 <code>HTTP/2</code> 通道，已经有了 <code>TLS</code> 加密。</p><p><a href="https://blog.helong.info/blog/2015/09/07/tls-protocol-analysis-and-crypto-protocol-design/">《TLS 协议分析》</a> </p><p>但是 <code>HTTPS</code> 带来的代价也是不小的，它需要 <code>2-RTT</code> 的协商成本，在弱网络下时延不可接受。同时后台服务解密的成本也十分高昂，在大型企业中需要单独的集群来做这个事情。</p><p><code>HTTPS</code> 的优化有下面几个思路：</p><ul><li><strong>连接复用率。</strong>通过多个域名共用同一个 HTTP/2 连接、长连接等方式提升连接复用率。</li><li><strong>减少握手次数。</strong> <a href="https://zhuanlan.zhihu.com/p/44980381">TLS 1.3</a> 可以实现 <code>0-RTT</code> 协商，事实上在 <code>TLS 1.3 release</code> 之前，微信的 <a href="https://mp.weixin.qq.com/s/tvngTp6NoTZ15Yc206v8fQ">mmtls</a>、<code>Facebook</code> 的<a href="https://mp.weixin.qq.com/s?__biz=MzI4MTY5NTk4Ng==&mid=2247489465&idx=1&sn=a54e3fe78fc559458fa47104845e764b&source=41#wechat_redirect">fizz</a>、阿里的 <code>SlightSSL</code> 都已在企业内部大规模部署。</li><li><strong>性能提升。</strong>使用 <code>ecc</code> 证书代替 <code>RSA</code>，服务端签名的性能可以提升 <code>4～10</code> 倍，但是客户端校验性能降低了约 <code>20</code> 倍，从 <code>10</code> 微秒级降低到 <code>100</code> 微秒级。另外一方面可以通过 <code>Session Ticket</code> 会话复用，节省一个 <code>RTT</code> 耗时。</li></ul><p>使用 <code>HTTPS</code> 之后，整个通道是不是就一定高枕无忧呢？如果客户端设置了代理，<code>TLS</code> 加密的数据可以被解开并可能被利用 。这个时候我们可以在客户端将 <a href="https://sec.xiaomi.com/article/48">证书锁定</a>（Certificate Pinning），为了老版本兼容和证书替换的灵活性，建议锁定根证书。</p><p>我们也可以对传输内容做二次加密，这块在统一接入层实现，业务服务器也同样无需关心这个流程。需要注意的是二次加密会增加客户端与服务器的处理耗时，我们需要在安全性与性能之间做一个取舍。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/20200524180753.png" alt="图片来源于 Android 开发高手课"></p><h2 id="2-4-其他优化"><a href="#2-4-其他优化" class="headerlink" title="2.4 其他优化"></a>2.4 其他优化</h2><ul><li><a href="https://toutiao.io/posts/6gb8ih/preview">CDN 服务</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI4MTY5NTk4Ng==&mid=2247489182&idx=1&sn=e892855fd315ed2f1395f05b765f9c4e&source=41#wechat_redirect">P2P 技术</a></li></ul><p>这个两个在直播场景经常使用</p><p>关于网络优化的手段还有很多，一些方案可能是需要用钱堆出来的，比如部署跨国的专线、加速点，多 <code>IDC</code> 就近接入等。</p><ul><li><p>QUIC </p><p><code>QUIC</code> 协议由 Google 在 2013 年实现，在 <code>2018</code> 年基于 <code>QUIC</code> 协议的 <code>HTTP</code> 更被确认为 <a href="https://zh.wikipedia.org/wiki/HTTP/3">HTTP/3</a> 。在连接复用中说过 <code>HTTP/2 + TCP</code> 会存在队首阻塞的问题，基于 <code>UDP</code> 的 <code>QUIC</code> 才是终极解决方案。</p><p><code>QUIC</code> 简单理解为 <code>HTTP/2.0 + TLS 1.3 + UDP</code></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/20200524184937.png" alt="图片来源于 Android 开发高手课"></p></li></ul><h1 id="3-如何监控网络？"><a href="#3-如何监控网络？" class="headerlink" title="3 如何监控网络？"></a>3 如何监控网络？</h1><h2 id="3-1-NetWork-Profiler"><a href="#3-1-NetWork-Profiler" class="headerlink" title="3.1 NetWork Profiler"></a>3.1 NetWork Profiler</h2><p><a href="https://developer.android.google.cn/studio/profile/network-profiler">利用网络性能剖析器检查网络流量</a>  </p><p><a href="https://juejin.im/post/5dea1efbe51d4557fe5941e7">涨姿势：利用AndroidStudio自带的Network Profiler来查看网络请求的相关数据</a> </p><h2 id="3-2-Charles"><a href="#3-2-Charles" class="headerlink" title="3.2 Charles"></a>3.2 Charles</h2><p><a href="https://www.cnblogs.com/jiayuchn-test/p/8875105.html">抓包工具Charles的使用教程</a> </p><p><a href="https://www.axihe.com/tools/charles/charles/tutorial.html">Charles 使用教程</a></p><h2 id="3-3-插桩"><a href="#3-3-插桩" class="headerlink" title="3.3 插桩"></a>3.3 插桩</h2><p><code>360</code> 开源的性能监控工具  <a href="https://github.com/Qihoo360/ArgusAPM">ArgusAPM</a> 就是利用 <code>Aspect</code> 切换插桩，实现监控系统和 <code>OkHttp</code> 网络库的请求。</p><p>系统网络库的插桩实现可以参考 <a href="https://github.com/Qihoo360/ArgusAPM/blob/bc03d63c65019cd3ffe2cbef9533c9228b3f2381/argus-apm/argus-apm-aop/src/main/java/com/argusapm/android/aop/TraceNetTrafficMonitor.java">TraceNetTrafficMonitor</a>，主要利用 <a href="http://www.shouce.ren/api/spring2.5/ch06s02.html">Aspect</a> 的切面功能。<code>OkHttp</code> 的拦截可以参考<a href="https://github.com/Qihoo360/ArgusAPM/blob/bc03d63c65019cd3ffe2cbef9533c9228b3f2381/argus-apm/argus-apm-okhttp/src/main/java/com/argusapm/android/okhttp3/OkHttp3Aspect.java">OkHttp3Aspect</a>，它会更加简单一些，因为 <code>OkHttp</code> 本身就有代理机制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut(&quot;call(public okhttp3.OkHttpClient build())&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Around(&quot;build()&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">aroundBuild</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    Object target = joinPoint.getTarget();</span><br><span class="line">    <span class="keyword">if</span> (target <span class="keyword">instanceof</span> OkHttpClient.Builder &amp;&amp;    Client.isTaskRunning(ApmTask.TASK_NET)) &#123;</span><br><span class="line">        OkHttpClient.Builder builder = (OkHttpClient.Builder) target;</span><br><span class="line">        builder.addInterceptor(<span class="keyword">new</span> NetWorkInterceptor());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> joinPoint.proceed();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-4-Native-Hook"><a href="#3-4-Native-Hook" class="headerlink" title="3.4 Native Hook"></a>3.4 Native Hook</h2><p>网络相关的一般会 Hook 下面几个方法 ：</p><ul><li>连接相关：<code>connect</code>。</li><li>发送数据相关：<code>send</code> 和 <code>sendto</code>。</li><li>接收数据相关：<code>recv</code> 和 <code>recvfrom</code>。</li></ul><p>具体 <code>Demo</code> 见 <code>4 PLT HOOK Demo 练习</code></p><h1 id="4-PLT-HOOK-Demo-练习"><a href="#4-PLT-HOOK-Demo-练习" class="headerlink" title="4 PLT HOOK Demo 练习"></a>4 PLT HOOK Demo 练习</h1><p><a href="https://github.com/facebookincubator/profilo/tree/master/deps/plthooks">face book plthooks</a></p><p><a href="https://github.com/AndroidAdvanceWithGeektime/Chapter17">Chapter17</a>  </p><p>它的作用是不仅仅 <code>hook</code> 某个 <code>so</code> ，而是 <code>hook</code> 内存中的所有 <code>so</code> 。但是要排除掉方法本身定义的 <code>so</code> ，不然运行期间会出问题。</p><p><code>Demo</code> 中比较疑惑的点 ，<code>hook_plt_method_all_lib</code> 的第一个参数是要排除掉的 <code>so</code> 库。还在研究中。。。</p><p>通过 <code>connect</code> 函数的 <code>hook</code> ，我们可以做的东西很多，例如：</p><ul><li>禁用应用网络访问</li><li>过滤广告 <code>ip</code> </li><li>禁用定位功能</li></ul><h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h1><blockquote><p><a href="https://time.geekbang.org/column/article/74044">极客时间 Android开发高手课</a>  </p><p>以及上文中的链接</p><p>更多理论和基础知识</p><p><a href="https://juejin.im/post/5ecf149af265da76ce577fbc">深入探索 Android 网络优化（二、网络优化基础篇）上</a></p><p><a href="https://juejin.im/post/5ecda2b6f265da77084772a1">深入探索 Android 网络优化（二、网络优化基础篇）下</a></p><p><a href="https://juejin.im/post/5edc594ef265da76ea2e988c">深入探索 Android 网络优化（三、网络优化篇）上</a></p><p><a href="https://juejin.im/post/5ee1f2936fb9a04801706b77">深入探索 Android 网络优化（三、网络优化篇）下</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>App 存储优化💦</title>
      <link href="2020/storage-optimization.html"/>
      <url>2020/storage-optimization.html</url>
      
        <content type="html"><![CDATA[<p>本文记录开发过程中常见存储方法的优缺点，希望可以在日常工作中如何做出更好的选择。</p><p><strong>注意：如果出现图片不显示问题请移步</strong> <a href="https://calmcenter.club/2019/PicNotShow.html">图片不显示问题</a></p><h1 id="本文主要记载"><a href="#本文主要记载" class="headerlink" title="本文主要记载"></a>本文主要记载</h1><ul><li><strong>1 如何选择持久化存储方案？</strong><ul><li>1.1 考察存储关键要素</li><li>1.2 SharedPreferences</li><li>1.3 ContentProvider</li><li>1.4 SQLite 优化那些事儿<ul><li>1.4.1 OCR</li><li>1.4.2 并发</li><li>1.4.3 索引查询优化</li><li>1.4.4 页大小与缓存大小</li><li>1.4.5 其他优化</li></ul></li><li>1.5 SQLite 的其他特征<ul><li>1.5.1 损坏与恢复</li><li>1.5.2 加密与安全</li></ul></li></ul></li><li><strong>2 如何优化数据存储？</strong><ul><li>2.1 对象的序列化<ul><li>2.1.1 Serializable<ul><li>Serializable 的原理</li><li>Serializable 的进阶</li><li>Serializable 的注意事项</li></ul></li><li>2.1.2 Parcelable<ul><li>Parcelable 的永久存储</li><li>Parcelable 的注意事项</li></ul></li><li>2.1.3 Serial</li></ul></li><li>2.2 数据的序列化<ul><li>2.2.1 Json</li><li>2.2.2 Protocol Buffers</li></ul></li></ul></li><li><strong>3 Demo 相关练习</strong><ul><li>3.1 重写 SharedPreferencesImpl</li></ul></li></ul><hr><h1 id="1-如何选择持久化存储方案？"><a href="#1-如何选择持久化存储方案？" class="headerlink" title="1 如何选择持久化存储方案？"></a>1 如何选择持久化存储方案？</h1><h2 id="1-1-考察存储关键要素"><a href="#1-1-考察存储关键要素" class="headerlink" title="1.1 考察存储关键要素"></a>1.1 考察存储关键要素</h2><ol><li><p><strong>正确性：</strong> 选择存储方案的时候，第一个需要判断它<strong>是否靠谱</strong>。这套存储方案<strong>设计是否完备</strong>，有没有支持<strong>多线程</strong>或者<strong>多进程</strong>操作。内部<strong>是否健壮</strong>，有没有考虑<strong>异常情况下数据的校验和恢复</strong>，比如采取双写或者备份文件策略，即使主文件因为系统底层导致损坏，也可以一定程度恢复大部分数据。</p></li><li><p><strong>时间开销：</strong>这里说的时间开销包括了 <code>CPU</code> 时间和 <code>I/O</code> 时间，在 <code>I/O</code> 优化中我就多次提到相比 <code>CPU</code> 和内存，<code>I/O</code> 存储的速度是非常慢的。但是如果存储方法中比如编解码或者加密/解密等设计的比较复杂，整个数据存储过程也会出现 <code>CPU</code> 时间变的更长的情况。</p></li><li><p><strong>控件开销：</strong>即使相同的数据如果使用不同的编码方式，最后占用的存储空间也会有所不同。举一个简单的例子，相同的数据所占的空间大小是 <code>XML&gt;JSON&gt;Protocol Buffer</code>。除了编码方式的差异，在一些场景我们可能还需要引入压缩策略来进一步减少存储空间，例如<code>zip</code>、<code>Izma</code> 等。数据存储的空间开销还需要考虑内存空间的占用量，整个存储过程会不会导致应用出现大量 <code>GC</code> 、<code>OOM</code> 等</p></li><li><p><strong>安全：</strong>应用中可能会有一些非常敏感的数据，即使它们存储在 <code>/data/data</code> 中，我们依然必须将它们加密。例如微信的聊天数据是存储在加密的数据库中，一些账号相关的数据我们也要单独做加密落地。根据加密强度的不同，可以选择 <code>RSA</code> 、<code>AES</code>、<code>chacha20</code>、<code>TEA</code>这些常用的加密算法</p></li><li><p><strong>开发成本：</strong>有些存储方案看起来非常高大上，但是需要业务做很大改造才能接入。这里我们当然希望能无缝的接入到业务中，在整个开发过程越简单越好</p></li><li><p><strong>兼容性：</strong>业务不停地向前演进，我们的存储字段或者格式有时候也会不得不有所变化。兼容性首先要考虑的是向前、向后的兼容性，老的数据在升级时能否迁移过来，新的数据在老版本能否降级使用。兼容性另外一个需要考虑的可能是多语言的问题，不同的语言是否支持转换</p></li></ol><p>数据存储方法不能脱离场景来考虑，我们不可能把这六个要素都做成最完美。如果首要考虑的是<strong>正确性</strong>，那我们可能需要采用冗余、双写等方案，那就要容忍对<strong>时间开销</strong>产生的额外影响。同样如果非常在意<strong>安全</strong>，加解密环节的<strong>开销</strong>也必不可小。如果想针对启动场景，我们希望选择在初始化时间和读取时间更有优势的方案。</p><hr><h2 id="1-2-SharedPreferences"><a href="#1-2-SharedPreferences" class="headerlink" title="1.2 SharedPreferences"></a>1.2 SharedPreferences</h2><p><code>SharedPreferences</code> 使用非常简便，但也是诟病比较多的存储方法。</p><ol><li><strong>跨进程不安全：</strong>由于没有使用跨进程的锁，就算使用 <code>MODE_MULTI_PROCESS</code>，<code>SharedPreferences</code> 在跨进程频繁读写有可能导致数据全部丢失。根据线上统计，<code>SP</code> 大约会有万分之一的损坏率。</li><li><strong>加载缓慢：</strong><code>SharedPreferences</code> 文件的加载使用了异步线程，而且加载线程并没有设置线程优先级，如果这个时候主线程读取数据就需要等待文件加载线程的结束。这就导致出现主线程等待低优先级线程锁的问题，比如一个 <code>100KB</code> 的 <code>SP</code> 文件读取等待时间大约需要 <code>50~100ms</code>，我建议提前用异步线程预加载启动过程用到的 SP 文件。</li><li><strong>全量写入：</strong>无论是调用 <code>commit()</code> 还是 <code>apply()</code>，即使我们只改动其中的一个条目，都会把整个内容全部写到文件。而且即使我们多次写入同一个文件，<code>SP</code> 也没有将多次修改合并为一次，这也是性能差的重要原因之一。</li><li><strong>卡顿：</strong>由于提供了异步落盘的 <code>apply</code> 机制，在崩溃或者其他一些异常情况可能会导致数据丢失。所以当应用收到系统广播，或者被调用 <code>onPause</code> 等一些时机，系统会强制把所有的 <code>SharedPreferences</code> 对象数据落地到磁盘。如果没有落地完成，这时候主线程会被一直阻塞。这样非常容易造成卡顿，甚至是 <code>ANR</code>，从线上数据来看 <code>SP</code> 卡顿占比一般会超过 <code>5%</code>。</li></ol><p>更多机制 <a href="https://juejin.im/entry/597446ed6fb9a06bac5bc630">彻底搞懂 SharedPreferences</a></p><p>更好的替代 <code>SharedPreferences</code> 的存储方案微信的 <a href="https://github.com/Tencent/MMKV">MMKV</a></p><hr><h2 id="1-3-ContentProvider"><a href="#1-3-ContentProvider" class="headerlink" title="1.3 ContentProvider"></a>1.3 ContentProvider</h2><p><code>ContentProvider</code> 作为 <code>Android</code> 四大组件中的一种，为我们提供了不同进程甚至是不同应用程序之间共享数据的机制。</p><p>为什么 <code>Android</code> 系统不把 <code>SharedPreferences</code> 设计成跨进程安全的呢？那是因为 <code>Android</code> 系统更希望我们在这个场景选择使用 <code>ContentProvider</code> 作为存储方式。</p><p><code>Android</code> 系统中比如相册、日历、音频、视频、通讯录等模块都提供了 <code>ContentProvider</code> 的访问支持。具体使用你可以参考其他文章。</p><p><code>ContentProvider</code> 的一些注意事项：</p><ol><li><p><strong>启动性能：</strong><code>ContentProvider</code> 的生命周期默认在 <code>Application onCreate()</code> 之前，而且都是在主线程创建的。我们自定义的 <code>ContentProvider</code> 类的构造函数、静态代码块、<code>onCreate</code> 函数都尽量不要做耗时的操作，会拖慢启动速度。</p></li><li><p><strong>稳定性：</strong><code>ContentProvider</code> 在进行跨进程数据传递时，利用了 <code>Android</code> 的 <code>Binder</code> 和匿名共享内存机制。就是通过 <code>Binder</code> 传递 <code>CursorWindow</code> 对象内部的匿名共享内存的文件描述符。这样在跨进程传输中，结果数据并不需要跨进程传输，而是在不同进程中通过传输的匿名共享内存文件描述符来操作同一块匿名内存，这样来实现不同进程访问相同数据的目的。</p><p>基于 <code>mmap</code> 的匿名共享内存机制也是有代价的。当传输的数据量非常小的时候，可能不一定划算。所以 <code>ContentProvider</code> 提供了一种 <code>call</code> 函数，它会直接通过 <code>Binder</code> 来传输数据。<code>Android</code> 的 <code>Binder</code> 传输是有大小限制的，一般来说限制是 <code>1~2MB</code>。<code>ContentProvider</code> 的接口调用参数和 call 函数调用并没有使用匿名共享机制，比如要批量插入很多数据，那么就会出现一个插入数据的数组，如果这个数组太大了，那么这个操作就可能会出现数据超大异常。</p></li><li><p><strong>安全性：</strong>虽然 <code>ContentProvider</code> 为应用程序之间的数据共享提供了很好的安全机制，但是如果 <code>ContentProvider</code> 是 <code>exported（是否可以被其他应用调用）</code>，当支持执行 <code>SQL</code> 语句时就需要注意 <code>SQL 注入</code> 的问题。另外如果我们传入的参数是一个文件路径，然后返回文件的内容，这个时候也要校验合法性，不然整个应用的私有数据都有可能被别人拿到，在 <code>intent</code>传递参数的时候可能经常会犯这个错误。</p></li></ol><p>总的来说，<code>ContentProvider</code> 这套方案实现相对比较笨重，适合传输大的数据。</p><hr><h2 id="1-4-SQLite-优化那些事儿"><a href="#1-4-SQLite-优化那些事儿" class="headerlink" title="1.4 SQLite 优化那些事儿"></a>1.4 SQLite 优化那些事儿</h2><h3 id="1-4-1-OCR"><a href="#1-4-1-OCR" class="headerlink" title="1.4.1 OCR"></a>1.4.1 OCR</h3><p>说到 <code>SQLite</code> Android 中最常用的开源库有 <a href="https://github.com/greenrobot/greenDAO">greenDAO</a> 和 Google 官方的 <a href="https://developer.android.google.cn/topic/libraries/architecture/room">Room</a> ，它们都是 <code>ORM 框架</code></p><p><code>ORM（Object Relational Mapping）</code>也就是对象关系映射，用面向对象的概念把数据库中表和对象关联起来，可以让我们不用关心数据库底层的实现。</p><p><code>ORM</code> 框架会带来什么问题?</p><p>使用 <code>ORM</code> 框架真的非常简单，但是简易性是需要牺牲部分执行效率为代价的，具体的损耗跟 <code>ORM</code> 框架写得好不好很有关系。但可能更大的问题是思维固化，最后可能连简单的 <code>SQL</code> 语句都不会写了。</p><p>这里推荐微信的 <a href="https://github.com/Tencent/wcdb/wiki">WCDB</a> </p><p><code>SQLite</code> 优化：</p><h3 id="1-4-2-并发"><a href="#1-4-2-并发" class="headerlink" title="1.4.2 并发"></a>1.4.2 并发</h3><p><a href="http://huili.github.io/lockandimplement/machining.html">SQLite 锁机制简介</a> <a href="https://www.cnblogs.com/cchust/p/4761814.html">SQLite 封锁机制</a></p><p>为了进一步提高并发性能，我们还可以打开 <a href="https://www.sqlite.org/wal.html">WAL</a>（Write-Ahead Logging）模式。<code>WAL</code> 模式会将修改的数据单独写到一个 <code>WAL</code> 文件中，同时也会引入了 <code>WAL</code> 日志文件锁。通过 <code>WAL</code> 模式读和写可以完全地并发执行，不会互相阻塞。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mSQLiteDataBase.rawExecSQL(&quot;PRAGMA schema.journal_mode &#x3D; WAL;&quot;)</span><br></pre></td></tr></table></figure><p>通过 <code>连接池</code> 与 <code>WAL</code> 模式，我们可以很大程度上增加 <code>SQLite</code> 的读写并发，大大减少由于并发导致的等待耗时。</p><h3 id="1-4-3-索引查询优化"><a href="#1-4-3-索引查询优化" class="headerlink" title="1.4.3 索引查询优化"></a>1.4.3 索引查询优化</h3><p><a href="https://www.cnblogs.com/huahuahu/p/sqlite-suo-yin-de-yuan-li-ji-ying-yong.html">SQLite 索引的原理</a> <a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">MySQL 索引背后的数据结构及算法原理</a> <a href="https://www.sqlite.org/queryplanner.html#searching">官方文档 Query Planning</a></p><p>这里的关键在于如何正确的建立索引，很多时候我们以为已经建立了索引，但事实上并没有真正生效。例如使用了 <code>BETWEEN</code>、<code>LIKE</code>、<code>OR</code> 这些操作符、使用表达式或者 <code>case when</code> 等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># BETWEEN：myfiedl索引无法生效</span><br><span class="line">SELECT * FROM mytable WHERE myfield BETWEEN 10 and 20;</span><br><span class="line"># 转换成：myfiedl索引可以生效</span><br><span class="line">SELECT * FROM mytable WHERE myfield &gt;&#x3D; 10 AND myfield &lt;&#x3D; 20;</span><br></pre></td></tr></table></figure><p>建立索引是有代价的，需要一直维护索引表的更新。比如对于一个很小的表来说就没必要建索引；如果一个表经常是执行插入更新操作，那么也需要节制的建立索引。总的来说有几个原则：</p><ul><li>建立正确的索引。这里不仅需要确保索引在查询中真正生效，我们还希望可以选择最高效的索引。如果一个表建立太多的索引，那么在查询的时候 <code>SQLite</code> 可能不会选择最好的来执行。</li><li>单列索引、多列索引与复合索引的选择。索引要综合数据表中不同的查询与排序语句一起考虑，如果查询结果集过大，还是希望可以通过复合索引直接在索引表返回查询结果。</li><li>索引字段的选择。整型类型索引效率会远高于字符串索引，而对于主键 <code>SQLite</code> 会默认帮我们建立索引，所以主键尽量不要用复杂字段。</li></ul><p>总的来说索引优化是 <code>SQLite</code> 优化中最简单同时也是最有效的，但是它并不是简单的建一个索引就可以了，有的时候我们需要进一步调整查询语句甚至是表的结构，这样才能达到最好的效果。</p><h3 id="1-4-4-页大小与缓存大小"><a href="#1-4-4-页大小与缓存大小" class="headerlink" title="1.4.4 页大小与缓存大小"></a>1.4.4 页大小与缓存大小</h3><p>在 <code>I/O</code> 文件系统中，数据库就像一个小文件系统一样，事实上它内部也有页和缓存的概念。</p><p>跟文件系统的页缓存（Page Cache）一样，<code>SQLite</code> 会将读过的页缓存起来，用来加快下一次读取速度。页大小默认是 <code>1024Byte</code>，缓存大小默认是 <code>1000</code> 页。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mSQLiteDataBase.rawExecSQL(<span class="string">&quot;PRAGMA page_size = 1024;&quot;</span>)</span><br><span class="line">mSQLiteDataBase.rawExecSQL(<span class="string">&quot;PRAGMA cache_size = 1000;&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/f232cbaff34236a1933182a02c685a1c.png" alt="图片来源于 Android 开发高手课"></p><p><strong>注意：</strong>在微信的内部测试中，如果使用 <code>4KB</code> 的 <code>page size</code> 性能提升可以在 <code>5%～10%</code>。但是考虑到历史数据的迁移成本，最终还是使用 <code>1024Byte</code>。所以这里建议大家在新建数据库的时候，就提前选择 <code>4KB</code> 作为默认的 <code>page size</code> 以获得更好的性能。</p><h3 id="1-4-5-其他优化"><a href="#1-4-5-其他优化" class="headerlink" title="1.4.5 其他优化"></a>1.4.5 其他优化</h3><ul><li>慎用 <code>select*</code>，需要使用多少列，就选取多少列。</li><li>正确地使用事务。</li><li>预编译与参数绑定，缓存被编译后的 <code>SQL</code> 语句。</li><li>定期整理或者清理无用或可删除的数据，例如朋友圈数据库会删除比较久远的数据，如果用户访问到这部分数据，重新从网络拉取即可。</li></ul><p><strong>总结：通过引进 <code>ORM</code>，可以大大的提升我们的开发效率。通过正确的建立索引，可以提升 <code>SQLite</code> 的查询速度。通过 <code>WAL</code> 模式和连接池，可以提高 <code>SQLite</code> 的并发性能。通过调整默认的页大小和缓存大小，可以提升 <code>SQLite</code> 的整体性能。</strong></p><hr><h2 id="1-5-SQLite-的其他特征"><a href="#1-5-SQLite-的其他特征" class="headerlink" title="1.5 SQLite 的其他特征"></a>1.5 SQLite 的其他特征</h2><p>除了 <code>SQLite</code> 的优化经验，还有一些其他的</p><h3 id="1-5-1-损坏与恢复"><a href="#1-5-1-损坏与恢复" class="headerlink" title="1.5.1 损坏与恢复"></a>1.5.1 损坏与恢复</h3><p><a href="https://mp.weixin.qq.com/s/N1tuHTyg3xVfbaSd4du-tw">微信 SQLite 数据库修复实践</a></p><p><a href="https://mp.weixin.qq.com/s/Ln7kNOn3zx589ACmn5ESQA">微信移动端数据库组件WCDB系列（二） — 数据库修复三板斧</a></p><p><a href="https://github.com/Tencent/wcdb/wiki/Android数据库修复">WCDB Android 数据库修复</a></p><h3 id="1-5-2-加密与安全"><a href="#1-5-2-加密与安全" class="headerlink" title="1.5.2 加密与安全"></a>1.5.2 加密与安全</h3><p>数据库的安全主要有两个方面，一个是防注入，一个是加密。防注入可以通过静态安全扫描的方式，而加密一般会使用 <code>SQLCipher</code> 支持。</p><p><code>SQLite</code> 的加解密都是以页为单位，默认会使用 <code>AES</code> 算法加密，加 / 解密的耗时跟选用的密钥长度有关。</p><p><a href="https://mp.weixin.qq.com/s/NFnYEXSxAaHBqpi7WofSPQ">WCDB 加解密的使用</a></p><h3 id="1-5-3-全文搜索"><a href="#1-5-3-全文搜索" class="headerlink" title="1.5.3 全文搜索"></a>1.5.3 全文搜索</h3><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/d2a09d040d0d915e78d7598457d6d1d9.png" alt="图片来源于 Android 开发高手课"></p><p><a href="https://mp.weixin.qq.com/s/AhYECT3HVyn1ikB0YQ-UVg">微信全文搜索优化之路</a></p><p><a href="https://mp.weixin.qq.com/s/GCznwCtjJ2XUszyMcbNz8Q">移动客户端多音字搜索</a> </p><p><strong>总结：</strong>关于 <code>SQLite</code>的这些特性，我们需要根据自己的项目情况综合考虑。假如某个数据库存储的数据并不重要，这个时候万分之一的数据损坏率我们并不会关心。同样是否需要使用数据库加密，也要根据存储的数据是不是敏感内容。</p><p><a href="http://huili.github.io/sqlite/sqliteintro.html">SQLite 源码分析</a></p><p><a href="https://github.com/AndroidAdvanceWithGeektime/Chapter14/blob/master/全面解析SQLite.pdf">全面解析 SQLite</a></p><hr><h1 id="2-如何优化数据存储？"><a href="#2-如何优化数据存储？" class="headerlink" title="2 如何优化数据存储？"></a>2 如何优化数据存储？</h1><h2 id="2-1-对象的序列化"><a href="#2-1-对象的序列化" class="headerlink" title="2.1 对象的序列化"></a>2.1 对象的序列化</h2><p>应用程序中的对象存储在内存中，如果我们想把对象存储下来或者在网络上传输，这个时候就需要用到对象的序列化和反序列化。</p><p>对象序列化就是把一个 <code>Object</code> 对象所有的信息表示成一个字节序列，这包括 <code>Class</code> 信息、继承关系信息、访问权限、变量类型以及数值信息等。</p><h3 id="2-1-1-Serializable"><a href="#2-1-1-Serializable" class="headerlink" title="2.1.1 Serializable"></a>2.1.1 Serializable</h3><p><code>Serializable</code> 是 <code>Java</code> 原生的序列化机制，在 <code>Android</code> 中也有被广泛使用。我们可以通过 <code>Serializable</code> 将对象持久化存储，也可以通过 <code>Bundle</code> 传递 <code>Serializable</code> 的序列化数据。</p><h4 id="Serializable-的原理"><a href="#Serializable-的原理" class="headerlink" title="Serializable 的原理"></a><strong>Serializable 的原理</strong></h4><p><code>Serializable</code> 的原理是通过 <code>ObjectInputStream</code> 和 <code>ObjectOutputStream</code> 来实现的，以 Android 6.0 的源码为例，可以看到 <a href="http://androidxref.com/6.0.0_r1/xref/libcore/luni/src/main/java/java/io/ObjectOutputStream.java#927">ObjectOutputStream</a> 的部分源码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeFieldValues</span><span class="params">(Object obj, ObjectStreamClass classDesc)</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (ObjectStreamField fieldDesc : classDesc.fields()) &#123;</span><br><span class="line">        ...</span><br><span class="line">        Field field = classDesc.checkAndGetReflectionField(fieldDesc);</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>整个序列化过程使用了大量的反射和临时变量，而且在序列化对象的时候，不仅会序列化当前对象本身，还需要递归序列化对象引用的其他对象。</p><p>整个过程计算非常复杂，而且因为存在大量反射和 <code>GC</code> 的影响，序列化的性能会比较差。另外一方面因为序列化文件需要包含的信息非常多，导致它的大小比 Class 文件本身还要大很多，这样又会导致 I/O 读写上的性能问题。</p><h4 id="Serializable-的进阶"><a href="#Serializable-的进阶" class="headerlink" title="Serializable 的进阶"></a><strong>Serializable 的进阶</strong></h4><p>既然 <code>Serializable</code> 性能那么差，那它有哪些优势呢？可能很多同学都不知道它还有一些进阶的用法，你可以参考<a href="https://www.ibm.com/developerworks/cn/java/j-5things1/index.html">《Java 对象序列化，您不知道的 5 件事》</a> 这篇文章。</p><p>自定义序列化：</p><ul><li><code>writeObject</code> 和 <code>readObject</code> 方法。<code>Serializable</code> 序列化支持替代默认流程，它会先反射判断是否存在我们自己实现的序列化方法 <code>writeObject</code> 或反序列化方法 <code>readObject</code> 。<strong>通过这两个方法，我们可以对某些字段做一些特殊修改，也可以实现序列化的加密功能。</strong></li><li><code>writeReplace</code> 和 <code>readResolve</code> 方法。这两个方法代理序列化的对象，可以实现自定义返回的序列化实例。那它有什么用呢？我们可以通过它们实现对象序列化的版本兼容，例如通过 <code>readResolve</code> 方法可以把老版本的序列化对象转换成新版本的对象类型。</li></ul><p><code>Serializable</code> 的序列化与反序列化的调用流程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 序列化</span></span><br><span class="line">E/test:SerializableTestData writeReplace</span><br><span class="line">E/test:SerializableTestData writeObject</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反序列化</span></span><br><span class="line">E/test:SerializableTestData readObject</span><br><span class="line">E/test:SerializableTestData readResolve</span><br></pre></td></tr></table></figure><h4 id="Serializable-的注意事项"><a href="#Serializable-的注意事项" class="headerlink" title="Serializable 的注意事项"></a><strong>Serializable 的注意事项</strong></h4><p><code>Serializable</code> 虽然使用非常简单，但是也有一些需要注意的事项字段。</p><ul><li><p><strong>不被序列化的字段。</strong>类的 <code>static</code> 变量以及被声明为 <code>transient</code> 的字段，默认的序列化机制都会忽略该字段，不会进行序列化存储。当然我们也可以使用进阶的 <code>writeReplace</code> 和 <code>readResolve</code> 方法做自定义的序列化存储。</p></li><li><p><strong>serialVersionUID。</strong>在类实现了 <code>Serializable</code> 接口后，我们需要添加一个 <code>Serial Version ID</code>，它相当于类的版本号。这个 <code>ID</code> 我们可以显式声明也可以让编译器自己计算。通常我建议显式声明会更加稳妥，因为隐式声明假如类发生了一点点变化，进行反序列化都会由于 <code>serialVersionUID</code> 改变而导致 <code>InvalidClassException</code> 异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1234567890L</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>构造方法。</strong><code>Serializable</code> 的反序列默认是不会执行构造函数的，它是根据数据流中对 <code>Object</code> 的描述信息创建对象的。如果一些逻辑依赖构造函数，就可能会出现问题，例如一个静态变量只在构造函数中赋值，当然我们也可以通过进阶方法做自定义的反序列化修改。</p></li></ul><h3 id="2-1-2-Parcelable"><a href="#2-1-2-Parcelable" class="headerlink" title="2.1.2 Parcelable"></a>2.1.2 Parcelable</h3><p>由于 <code>Java</code> 的<code>Serializable</code> 的性能较低，<code>Android</code> 需要重新设计一套更加轻量且高效的对象序列化和反序列化机制。<code>Parcelable</code> 正是在这个背景下产生的，它核心的作用就是为了解决 <code>Android</code> 中大量跨进程通信的性能问题。</p><h4 id="Parcelable-的永久存储"><a href="#Parcelable-的永久存储" class="headerlink" title="Parcelable 的永久存储"></a>Parcelable 的永久存储</h4><p>Parcelable 的原理十分简单，它的核心实现都在 <a href="http://androidxref.com/6.0.0_r1/xref/frameworks/native/libs/binder/Parcel.cpp">Parcel.cpp</a> 。 </p><p>你可以发现 <code>Parcel</code> 序列化和 <code>Java</code> 的 <code>Serializable</code> 序列化差别还是比较大的，<code>Parcelable</code> 只会在内存中进行序列化操作，并不会将数据存储到磁盘里。</p><p>当然我们也可以通过 <a href="http://androidxref.com/6.0.0_r1/xref/frameworks/base/core/java/android/os/Parcel.java">Parcel.java</a> 的 <code>marshall</code> 方法获取 <code>byte</code> 数组，然后存在文件中从而实现 <code>Parcelable</code> 的永久存储。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Returns the raw bytes of the parcel.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] marshall() &#123;</span><br><span class="line">    <span class="keyword">return</span> nativeMarshall(mNativePtr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Set the bytes in data to be the raw bytes of this Parcel.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">unmarshall</span><span class="params">(<span class="keyword">byte</span>[] data, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    nativeUnmarshall(mNativePtr, data, offset, length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ProcessCpuTracker pct=<span class="keyword">new</span> ProcessCpuTracker();</span><br><span class="line">Parcel parcel = Parcel.obtain();</span><br><span class="line">parcel.writeValue(pct);</span><br><span class="line"><span class="keyword">byte</span>[] bytes = parcel.marshall();</span><br><span class="line">parcel.recycle();</span><br><span class="line"></span><br><span class="line">Parcel thatParcel = Parcel.obtain();</span><br><span class="line">thatParcel.unmarshall(bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">thatParcel.setDataPosition(<span class="number">0</span>);</span><br><span class="line">ProcessCpuTracker that = (ProcessCpuTracker)thatParcel.readValue(ProcessCpuTracker.class.getClassLoader());</span><br><span class="line">thatParcel.recycle();</span><br></pre></td></tr></table></figure><h4 id="Parcelable-的注意事项"><a href="#Parcelable-的注意事项" class="headerlink" title="Parcelable 的注意事项"></a>Parcelable 的注意事项</h4><p>在时间开销和使用成本的权衡上，<code>Parcelable</code> 机制选择的是性能优先。</p><p>所以它在写入和读取的时候都需要手动添加自定义代码，使用起来相比 <code>Serializable</code> 会复杂很多。但是正因为这样，<code>Parcelable</code> 才不需要采用反射的方式去实现序列化和反序列化。</p><p>虽然通过取巧的方法可以实现 <code>Parcelable</code> 的永久存储，但是它也存在两个问题。</p><ul><li>系统版本的兼容性。由于 <code>Parcelable</code> 设计本意是在内存中使用的，我们无法保证所有 <code>Android</code> 版本的 Parcel.cpp 实现都完全一致。如果不同系统版本实现有所差异，或者有厂商修改了实现，可能会存在问题。</li><li>数据前后兼容性。<code>Parcelable</code> 并没有版本管理的设计，如果我们类的版本出现升级，写入的顺序及字段类型的兼容都需要格外注意，这也带来了很大的维护成本。</li></ul><p>一般来说，如果需要持久化存储的话，一般还是不得不选择性能更差的 Serializable 方案。</p><h3 id="2-1-3-Serial"><a href="#2-1-3-Serial" class="headerlink" title="2.1.3 Serial"></a>2.1.3 Serial</h3><p>直击痛点的方案，<code>Twitter</code> 开源的 <a href="https://github.com/twitter/Serial/blob/master/README-CHINESE.rst/">Serial</a> </p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/71e3e58ed10ecc09646101ec22e360df.png" alt="图片来源于 Android 开发高手课"></p><p>从图中数据上看来，<code>Serial</code> 在序列化与反序列化耗时，以及落地的文件大小都有很大的优势。从实现原理上看，<code>Serial</code> 就像是把 <code>Parcelable</code> 和 <code>Serializable</code> 的优点集合在一起的方案。</p><ul><li>由于没有使用反射，相比起传统的反射序列化方案更加高效，具体你可以参考上面的测试数据。</li><li>开发者对于序列化过程的控制较强，可定义哪些 <code>Object</code>、<code>Field</code> 需要被序列化。</li><li>有很强的 <code>debug</code> 能力，可以调试序列化的过程。</li><li>有很强的版本管理能力，可以通过版本号和 <code>OptionalFieldException</code> 做兼容。</li></ul><h2 id="2-2-数据的序列化"><a href="#2-2-数据的序列化" class="headerlink" title="2.2 数据的序列化"></a>2.2 数据的序列化</h2><p><code>Serial</code> 性能看起来还不错，但是对象的序列化要记录的信息还是比较多，在操作比较频繁的时候，对应用的影响还是不少的，这个时候我们可以选择使用数据的序列化。</p><h3 id="2-2-1-Json"><a href="#2-2-1-Json" class="headerlink" title="2.2.1 Json"></a>2.2.1 Json</h3><p><code>JSON</code> 是一种轻量级的数据交互格式，它被广泛使用在网络传输中，很多应用与服务端的通信都是使用 <code>JSON</code> 格式进行交互。</p><p>JSON 的确有很多得天独厚的优势，主要有：</p><ul><li>相比对象序列化方案，速度更快，体积更小。</li><li>相比二进制的序列化方案，结果可读，易于排查问题。</li><li>使用方便，支持跨平台、跨语言，支持嵌套引用。</li></ul><p>因为每个应用基本都会用到 <code>JSON</code>，所以每个大厂也基本都有自己的 “ 轮子 ” 。例如 <code>Android</code> 自带的 <code>JSON</code> 库、<code>Google</code> 的 <code>Gson</code> 、阿里巴巴的 <code>Fastjson</code> 、美团的 <code>MSON</code> 。</p><p>各个自研的 JSON 方案主要在下面两个方面进行优化：</p><ul><li><strong>便利性。</strong>例如支持 JSON 转换成 JavaBean 对象，支持注解，支持更多的数据类型等。</li><li><strong>性能。</strong>减少反射，减少序列化过程内存与 CPU 的使用，特别是在数据量比较大或者嵌套层级比较深的时候效果会比较明显。</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/984bb5dc6300f25ba142c208bdca3178.png" alt="图片来源于 Android 开发高手课"></p><p>在数据量比较少的时候，系统自带的 <code>JSON</code> 库还稍微有一些优势。但在数据量大了之后，差距逐渐被拉开。总的来说，<code>Gson</code> 的兼容性最好，一般情况下它的性能与 <code>Fastjson</code> 相当。但是在数据量极大的时候，<code>Fastjson</code> 的性能更好。</p><h3 id="2-2-2-Protocol-Buffers"><a href="#2-2-2-Protocol-Buffers" class="headerlink" title="2.2.2 Protocol Buffers"></a>2.2.2 Protocol Buffers</h3><p>相比对象序列化方案，<code>JSON</code> 的确速度更快、体积更小。不过为了保证 <code>JSON</code> 的中间结果是可读的，它并没有做二进制的压缩，也因此 <code>JSON</code> 的性能还没有达到极致。</p><p>如果应用的数据量非常大，又或者对性能有更高的要求，此时 <a href="https://developers.google.com/protocol-buffers/docs/overview">Protocol Buffers</a> 是一个非常好的选择。它是 <code>Google</code> 开源的跨语言编码协议，<code>Google</code> 内部的几乎所有 <code>RPC</code> 都在使用这个协议。</p><p>下面我来总结一下它的优缺点。</p><ul><li><strong>性能。</strong>使用了二进制编码压缩，相比 JSON 体积更小，编解码速度也更快，感兴趣的同学可以参考protocol-buffers 编码规则。</li><li><strong>兼容性。</strong>跨语言和前后兼容性都不错，也支持基本类型的自动转换，但是不支持继承与引用类型。</li><li><strong>使用成本。</strong><code>Protocol Buffers</code> 的开发成本很高，需要定义 <code>.proto</code> 文件，并用工具生成对应的辅助类。辅助类特有一些序列化的辅助方法，所有要序列化的对象，都需要先转化为辅助类的对象，这让序列化代码跟业务代码大量耦合，是侵入性较强的一种方式。</li></ul><p>对于 <code>Android</code> 来说，官方的 <code>Protocol Buffers</code> 会导致生成的方法数很多。我们可以修改它的自动代码生成工具，例如在微信中，每个 <code>.proto</code> 生成的类文件只会包含一个方法即 <code>op</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestProtocal</span> <span class="keyword">extends</span>  <span class="title">com</span>.<span class="title">tencent</span>.<span class="title">mm</span>.<span class="title">protocal</span>.<span class="title">protobuf</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">op</span><span class="params">(<span class="keyword">int</span> opCode, Object ...objs)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (opCode == OPCODE_WRITEFIELDS) &#123;</span><br><span class="line">           ... </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (opCode == OPCODE_COMPUTESIZE) &#123;</span><br><span class="line">           ...</span><br></pre></td></tr></table></figure><p><code>Google</code> 后面还推出了压缩率更高的 <code>FlatBuffers</code>，对于它的使用你可以参考<a href="https://www.race604.com/flatbuffers-intro/">《FlatBuffers 体验》</a>。最后，我再结合 “六要素”，综合对比一下 <code>Serial</code>、<code>JSON</code>、<code>Protocol Buffers</code> 这三种序列化方案。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/1afba11681441b6a8ab8f0d86337ea28.png" alt="图片来源于 Android 开发高手课"></p><h1 id="3-Demo-相关练习"><a href="#3-Demo-相关练习" class="headerlink" title="3 Demo 相关练习"></a>3 Demo 相关练习</h1><h2 id="3-1-重写-SharedPreferencesImpl"><a href="#3-1-重写-SharedPreferencesImpl" class="headerlink" title="3.1 重写 SharedPreferencesImpl"></a>3.1 重写 <code>SharedPreferencesImpl</code></h2><p><a href="https://github.com/AndroidAdvanceWithGeektime/Chapter12">Chapter12 SharedPreferencesImpl</a> 这是一个简单的示例。</p><p>通过继承 <code>SharedPreferences</code> 重写 <code>SharedPreferencesImpl</code> ，并通过 <code>Application</code> 的 <code>getSharedPreferences</code> 方法，替换系统 <code>SharedPreferences</code> 的具体实现。还可以替换它的存储结构、增加加密等其他自定义功能。</p><h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a><strong>感谢</strong></h1><blockquote><p><a href="https://time.geekbang.org/column/article/74044">极客时间 Android开发高手课</a>  </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>App 电量优化</title>
      <link href="2020/power-optimization.html"/>
      <url>2020/power-optimization.html</url>
      
        <content type="html"><![CDATA[<p>耗电优化究竟需要做哪些工作？我们如何快速定位代码中的不合理调用，并且持续监控应用的耗电情况呢？</p><h1 id="本文主要记载"><a href="#本文主要记载" class="headerlink" title="本文主要记载"></a>本文主要记载</h1><ul><li><strong>1 优化哪些耗电行为？</strong></li><li><strong>2 耗电优化的难点以及方法</strong></li><li><strong>3 耗电监控</strong><ul><li>3.1 耗电监控都监控什么</li><li>3.2 Battery Historian</li><li>3.3 Android Vitals</li><li>3.4 Java Hook</li><li>3.5 插桩</li></ul></li><li>4 耗电量计算原理</li></ul><hr><h1 id="1-优化哪些耗电行为？"><a href="#1-优化哪些耗电行为？" class="headerlink" title="1 优化哪些耗电行为？"></a>1 优化哪些耗电行为？</h1><p>所谓的耗电优化不就是减少应用的耗电，增加用户的续航时间吗？但是落到实践中，如果应用需要播放视频、需要获取 <code>GPS</code> 信息、需要拍照，这些耗电看起来是无法避免的。</p><p>假设这个时候发现某个应用他根本没怎么使用（前台时间很少），但是耗电却非常多。这种情况会跟用户的预期差别很大，他可能就会想去投诉。</p><ul><li><p><strong>所以耗电优化的第一个方向是优化应用的后台耗电。</strong> 知道了系统是如何计算耗电的，那反过来看，我们也就可以知道应用在后台不应该做什么，例如长时间获取 <code>WakeLock</code>、<code>WiFi</code> 和蓝牙的扫描等。为什么说耗电优化第一个方向就是优化应用后台耗电，因为大部分厂商预装项目要求最严格的正是应用后台待机耗电。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/b01e359b45d22bd80efda51eee2f5f2b.png" alt="图片来源于 Android 开发高手课"></p></li><li><p><strong>耗电优化的第二个方向是符合系统的规则，让系统认为你耗电是正常的。</strong>而 <code>Android P</code> 是通过 <code>Android Vitals</code> 监控后台耗电，所以我们需要符合 <code>Android Vitals</code> 的规则，目前它的具体规则如下：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/620748a58e45e50fdea1098f15c77d15.png" alt="图片来源于 Android 开发高手课"></p><p>虽然上面的标准可能随时会改变，但是可以看到，<code>Android</code> 系统目前比较关心后台 <code>Alarm</code> 唤醒、后台网络、后台 <code>WiFi</code> 扫描以及部分长时间 <code>WakeLock</code> 阻止系统后台休眠。</p></li></ul><h1 id="2-耗电优化的难点以及方法"><a href="#2-耗电优化的难点以及方法" class="headerlink" title="2 耗电优化的难点以及方法"></a>2 耗电优化的难点以及方法</h1><p><strong>难点：</strong></p><ul><li><strong>缺乏现场，无法复现。</strong></li><li><strong>信息不全，难以定位。</strong></li><li><strong>无法评估结果。</strong>从 <code>Android 4.4</code> 开始，我们无法拿到应用的耗电信息。尽管我们解决了某个耗电问题，也很难去评估它是否已经生效，以及对用户产生的价值有多大。</li></ul><p><strong>耗电优化的方法和思路：</strong></p><ul><li><p><strong>代码的 Bug。</strong>因为某些逻辑考虑不周，可能导致 <code>GPS</code> 没有关闭、<code>WakeLock</code> 没有释放。</p></li><li><p><strong>找到需求场景的替代方案。</strong></p><ul><li>最普遍的场景就是推送，为了实现推送我们只能做各种各样的保活。在需求面前，用户的价值可能被排到第二位。我们是否可以更多地利用厂商通道，或者定时的拉取最新消息这种模式。如果真是迫不得已，是不是可以使用 <code>foreground service</code> 或者引导用户加入白名单。后台任务的总体指导思想是减少、延迟和合并，可以参考微信一个小伙写的<a href="https://blog.dreamtobe.cn/2016/08/15/android_scheduler_and_battery/">《Android 后台调度任务与省电》</a>。</li></ul></li><li><p><strong>符合 Android 规则。</strong>首先系统的大部分耗电监控，都是在手机在没有充电的时候。我们可以选择在用户充电时才去做一些耗电的工作，具体方法可查看官方文档 <a href="https://developer.android.google.cn/training/monitoring-device-state/battery-monitoring">监控电池电量和充电状态</a>  。其次是尽早适配最新的 <code>Target API</code>，因为高版本系统后台限制本来就非常严格，应用在后台耗电本身就变得比较困难了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">IntentFilter ifilter = <span class="keyword">new</span> IntentFilter(Intent.ACTION_BATTERY_CHANGED);</span><br><span class="line">Intent batteryStatus = context.registerReceiver(<span class="keyword">null</span>, ifilter);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取用户是否在充电的状态或者已经充满电了</span></span><br><span class="line"><span class="keyword">int</span> status = batteryStatus.getIntExtra(BatteryManager.EXTRA_STATUS, -<span class="number">1</span>);</span><br><span class="line"><span class="keyword">boolean</span> isCharging = status == BatteryManager.BATTERY_STATUS_CHARGING || status == BatteryManager.BATTERY_STATUS_FULL;</span><br></pre></td></tr></table></figure></li><li><p><strong>异常情况监控。</strong>即使是最严格的 <code>Android P</code> <a href="https://mp.weixin.qq.com/s/APhUH7MBDUZ6tQv0xDgaWQ">Android P 电量管理</a> ，系统也会允许应用部分地使用后台网络、<code>Alarm</code> 以及 <code>JobSheduler</code> 事件（<a href="https://developer.android.google.cn/topic/performance/power/power-details">不同的分组，限制次数不同</a>）。因此出现异常情况的可能性还是存在的，更不用说低版本的系统。对于异常的情况，我们需要类似 <code>Android Vitals</code> 电量监控一样，将规则抽象出来，并且增加上更多辅助我们定位问题的信息。</p></li></ul><h1 id="3-耗电监控"><a href="#3-耗电监控" class="headerlink" title="3 耗电监控"></a>3 耗电监控</h1><h2 id="3-1-耗电监控都监控什么"><a href="#3-1-耗电监控都监控什么" class="headerlink" title="3.1 耗电监控都监控什么"></a>3.1 耗电监控都监控什么</h2><ul><li><strong>监控信息。</strong> 简单来说系统关心什么，我们就监控什么，而且应该以<strong>后台耗电监控为主</strong>。类似 <code>Alarm wakeup</code>、<code>WakeLock</code>、<code>WiFi scans</code>、<code>Network</code> 都是必须的，其他的可以根据应用的实际情况。如果是地图应用，后台获取 <code>GPS</code> 是被允许的；如果是计步器应用，后台获取 <code>Sensor</code> 也没有太大问题。</li><li><strong>现场信息。</strong> 监控系统希望可以获得完整的堆栈信息，比如哪一行代码发起了 <code>WiFi scans</code>、哪一行代码申请了 <code>WakeLock</code> 等。还有当时手机是否在充电、手机的电量水平、应用前台和后台时间、<code>CPU</code> 状态等一些信息也可以帮助我们排查某些问题。</li><li><strong>提炼规则。</strong> 最后我们需要将监控的内容抽象成规则，当然不同应用监控的事项或者参数都不太一样。</li></ul><p>简单规则：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/d48b7e4d3fdceb101fa7716b5892b0be.png" alt="图片来源于 Android 开发高手课"></p><p>在安卓绿色联盟的会议中，华为公开过他们后台资源使用的 “红线” </p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/86a65ea0d9216a11a341d7224fce93ff.png" alt="图片来源于 Android 开发高手课"></p><h2 id="3-2-Battery-Historian"><a href="#3-2-Battery-Historian" class="headerlink" title="3.2 Battery Historian"></a>3.2 Battery Historian</h2><p><a href="https://www.jianshu.com/p/0fa57924f228">Battery Historian 的使用与安装</a>  </p><p><a href="https://github.com/google/battery-historian">Battery Historian</a> 是 <code>Android5.0</code> 之后 <code>Google</code> 开源的一款用于检测与电池有关的信息和事件的工具，从设备中收集电池数据，然后使用 <code>Battery Historian</code> 可以可视化分析相关指标如耗电比例、<code>Wifi</code>、蜂窝数据量、<code>WakeLock</code> 唤醒次数。随着 <code>Android 6.0</code> 更新了 <code>Battery Historian 2.0</code> 加入引起手机状态变化的应用。</p><p>通过 <code>Battery Historian</code> 可以方便的看到各耗电模块随着时间的耗电情况：包含操作类型、执行时间、对应 <code>App</code> 等；还可以进行筛选特定的 <code>App</code> ，给出一个总结性的说明，包括：<code>Network Information</code>、 <code>Syncs</code>、<code>WakeLock</code>、<code>Services</code>、<code>Process info</code>、<code>Scheduled Job</code>、<code>Sensor Use</code> 等，查看每一个模块的总结，可以看出来每一项的耗时以及执行次数。当发现异常的时候可以针对性的进行排查。</p><h2 id="3-3-Android-Vitals"><a href="#3-3-Android-Vitals" class="headerlink" title="3.3 Android Vitals"></a>3.3 Android Vitals</h2><p><code>Android Vitals</code> 的几个关于电量的监控方案与规则</p><p><a href="https://developer.android.google.cn/topic/performance/vitals/wakeup">Alarm Manager wakeup 唤醒过多频繁</a></p><p><a href="https://developer.android.google.cn/topic/performance/vitals/wakelock">使用局部唤醒锁</a></p><p><a href="https://developer.android.google.cn/topic/performance/vitals/bg-network-usage">后台网络使用量过高</a></p><p><a href="https://developer.android.google.cn/topic/performance/vitals/bg-wifi">后台 WiFi scans 过多</a></p><p><code>Android Vitals</code> 跟 <code>Battery Historian</code> 一样，我们只能拿到 <code>wakeup</code> 的标记的组件，拿不到申请的堆栈，也拿不到当时手机是否在充电、剩余电量等信息。</p><p>对于网络、<code>WiFi scans</code> 以及 <code>WakeLock</code> 也是如此。虽然 <code>Vitals</code> 帮助我们缩小了排查的范围，但是依然需要在茫茫的代码中寻找对应的可疑代码。</p><h2 id="3-4-Java-Hook"><a href="#3-4-Java-Hook" class="headerlink" title="3.4 Java Hook"></a>3.4 Java Hook</h2><ul><li><p><a href="https://developer.android.google.cn/training/scheduling/wakelock">WakeLock</a> 。<code>WakeLock</code> 用来阻止 <code>CPU</code>、屏幕甚至是键盘的休眠。类似 <code>Alarm</code>、<code>JobService</code> 也会申请 <code>WakeLock</code> 来完成后台 <code>CPU</code> 操作。<code>WakeLock</code> 的核心控制代码都在 <a href="http://androidxref.com/7.0.0_r1/xref/frameworks/base/services/core/java/com/android/server/power/PowerManagerService.java">PowerManagerService</a> 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代理PowerManagerService</span></span><br><span class="line">ProxyHook().proxyHook(context.getSystemService(Context.POWER_SERVICE), <span class="string">&quot;mService&quot;</span>, <span class="keyword">this</span>)；</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeInvoke</span><span class="params">(Method method, Object[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 申请Wakelock</span></span><br><span class="line">    <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;acquireWakeLock&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">//获取应用堆栈等等 </span></span><br><span class="line">        <span class="keyword">if</span> (isAppForeground()) &#123;</span><br><span class="line">            <span class="comment">// 应用前台逻辑，上面的规则    </span></span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 应用后台逻辑，上面的规则</span></span><br><span class="line">         &#125;</span><br><span class="line">    <span class="comment">// 释放Wakelock</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;releaseWakeLock&quot;</span>)) &#123;</span><br><span class="line">       <span class="comment">// 释放的逻辑    </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://developer.android.google.cn/training/scheduling/alarms">Alarm</a> 。<code>Alarm</code> 用来做一些定时的重复任务，它一共有四个类型，其中 <a href="https://developer.android.google.cn/reference/android/app/AlarmManager.html#RTC_WAKEUP">ELAPSED_REALTIME_WAKEUP</a> 和 <a href="https://developer.android.google.cn/reference/android/app/AlarmManager.html#ELAPSED_REALTIME_WAKEUP">RTC_WAKEUP</a> 类型都会唤醒设备。同样，<code>Alarm</code> 的核心控制逻辑都在 <a href="http://androidxref.com/7.0.0_r1/xref/frameworks/base/services/core/java/com/android/server/AlarmManagerService.java">AlarmManagerService</a> 中，实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代理AlarmManagerService</span></span><br><span class="line"><span class="keyword">new</span> ProxyHook().proxyHook(context.getSystemService</span><br><span class="line">(Context.ALARM_SERVICE), <span class="string">&quot;mService&quot;</span>, <span class="keyword">this</span>)；</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeInvoke</span><span class="params">(Method method, Object[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置Alarm</span></span><br><span class="line">    <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;set&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">// 不同版本参数类型的适配，获取应用堆栈等等</span></span><br><span class="line">    <span class="comment">// 清除Alarm</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;remove&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">// 清除的逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><a href="https://github.com/simplezhli/Chapter19">唯鹿 Chapter19</a> </p><p>这个 <code>Demo</code> 使用 <code>Java Hook</code> 实现 <code>Alarm</code>、<code>WakeLock</code> 与 <code>GPS</code> 的耗电监控。</p><p>动态代理对应的 <a href="http://androidxref.com/7.0.0_r1/xref/frameworks/base/core/java/android/os/PowerManager.java">PowerManager</a>、<a href="http://androidxref.com/7.0.0_r1/xref/frameworks/base/core/java/android/app/AlarmManager.java">AlarmManager</a>、<a href="http://androidxref.com/7.0.0_r1/xref/frameworks/base/location/java/android/location/LocationManager.java">LocationManager</a>的<code>mService</code>实现，要拦截的方法在 <a href="http://androidxref.com/7.0.0_r1/xref/frameworks/base/services/core/java/com/android/server/power/PowerManagerService.java">PowerManagerService</a>、<a href="http://androidxref.com/7.0.0_r1/xref/frameworks/base/services/core/java/com/android/server/AlarmManagerService.java">AlarmManagerService</a>、<a href="http://androidxref.com/7.0.0_r1/xref/frameworks/base/services/core/java/com/android/server/LocationManagerService.java">LocationManagerService</a> 中。</p><p><a href="https://blog.csdn.net/qq_17766199/article/details/86770948">唯鹿原文</a> </p><h2 id="3-5-插桩"><a href="#3-5-插桩" class="headerlink" title="3.5 插桩"></a>3.5 插桩</h2><p>在使用 <code>Hook</code> 的时候，某些规则可能不太容易找到合适的 <code>Hook</code> 点。而且在 <code>Android P</code> 之后，很多的 <code>Hook</code> 点都不支持了。</p><p>出于兼容性考虑，写一个基础类，然后在统一的调用接口中增加监控逻辑。以 <code>WakeLock</code> 为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WakelockMetrics</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Wakelock 申请</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(PowerManager.WakeLock wakelock)</span> </span>&#123;</span><br><span class="line">        wakeLock.acquire();</span><br><span class="line">        <span class="comment">// 在这里增加Wakelock 申请监控逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Wakelock 释放</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(PowerManager.WakeLock wakelock, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">        wakelock.release();</span><br><span class="line">        <span class="comment">// 在这里增加Wakelock 释放监控逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Facebook</code> 也有一个耗电监控的开源库 <a href="https://github.com/facebookincubator/Battery-Metrics">Battery-Metrics</a> ，它监控的数据非常全，包括 <code>Alarm</code>、<code>WakeLock</code>、<code>Camera</code>、<code>CPU</code>、<code>Network</code> 等，而且也有收集电量充电状态、电量水平等信息。</p><p><code>Battery-Metrics</code> 只是提供了一系列的基础类，在实际使用中，接入者可能需要修改大量的源码。但对于一些第三方 <code>SDK</code> 或者后续增加的代码，我们可能就不太能保证可以监控到了。这些场景也就无法监控了，所以 <code>Facebook</code> 内部是使用插桩来动态替换。</p><p>插桩方案使用起来兼容性非常好，并且使用者也没有太大的接入成本。但是它并不是完美无缺的，对于系统的代码插桩方案是无法替换的，例如 <code>JobService</code> 申请 <code>PARTIAL_WAKE_LOCK</code> 的场景。</p><h1 id="4-耗电量计算原理"><a href="#4-耗电量计算原理" class="headerlink" title="4 耗电量计算原理"></a>4 耗电量计算原理</h1><p>根据物理学的知识，电能的计算公式为 <code>电能 = 电压 * 电流 * 时间</code>。对于手机来说电压一般不会改变，所以在电压恒定的前提下，只需要测量电流和时间就可以确定耗电。</p><p>最终不同模块的耗电情况可以通过下面的这个公式计算：<code>模块电量(mAh) = 模块电流(mA) * 模块耗时(h)</code> 模块耗时比较容易理解，但是模块电流应该怎样去获取呢？</p><p><code>Android</code> 系统要求不同的厂商必须在 <code>/frameworks/base/core/res/res/xml/power_profile.xml</code> 中提供组件的电源配置文件。</p><p><a href="https://android.googlesource.com/platform/frameworks/base/+/master/core/res/res/xml/power_profile.xml">power_profiler.xml</a> 文件定义了不同模块的电流消耗值以及该模块在一段时间内大概消耗的电量，你也可以参考 <a href="https://source.android.com/devices/tech/power">Android Developer</a> 文档《Android 电源配置文件》。当然电流的大小和模块的状态也有关系，例如屏幕在不同亮度时的电流肯定会不一样。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/fa38166961e917ea6a321f84d3d4d4c1.png" alt="图片来源于 Android开发高手课"></p><p>Android 系统的电量计算 <a href="http://androidxref.com/7.0.0_r1/s?defs=PowerProfile&project=frameworks">PowerProfile</a> 也是通过读取 <code>power_profile.xml</code> 的数值而已，不同的厂商具体的数值都不太一样，我们可以通过下面的方法获取：</p><ul><li>从手机中导出 <code>/system/framework/framework-res.apk</code> 文件。</li><li>使用反编译工具（如 <code>apktool</code>）对导出文件 <code>framework-res.apk</code> 进行反编译。</li><li>查看 <code>power_profile.xml</code> 文件在 <code>framework-res</code> 反编译目录路径：<code>/res/xml/power_profile.xml</code>。</li></ul><p>对于系统的电量消耗情况，我们可以通过 <code>dumpsys batterystats</code> 导出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">adb shell dumpsys batterystats &gt; battery.txt</span><br><span class="line">&#x2F;&#x2F; 各个Uid的总耗电量，而且是粗略的电量计算估计。</span><br><span class="line">Estimated power use (mAh):</span><br><span class="line">    Capacity: 3450, Computed drain: 501, actual drain: 552-587</span><br><span class="line">    ...</span><br><span class="line">    Idle: 41.8</span><br><span class="line">    Uid 0: 135 ( cpu&#x3D;103 wake&#x3D;31.5 wifi&#x3D;0.346 )</span><br><span class="line">    Uid u0a208: 17.8 ( cpu&#x3D;17.7 wake&#x3D;0.00460 wifi&#x3D;0.0901 )</span><br><span class="line">    Uid u0a65: 17.5 ( cpu&#x3D;12.7 wake&#x3D;4.11 wifi&#x3D;0.436 gps&#x3D;0.309 )</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; reset电量统计</span><br><span class="line">adb shell dumpsys batterystats --reset</span><br></pre></td></tr></table></figure><p><a href="http://androidxref.com/7.0.0_r1/xref/frameworks/base/services/core/java/com/android/server/am/BatteryStatsService.java">BatteryStatsService</a> 是对外的电量统计服务，但具体的统计工作是由 <a href="http://androidxref.com/7.0.0_r1/xref/frameworks/base/core/java/com/android/internal/os/BatteryStatsImpl.java">BatteryStatsImpl</a> 来完成的，而 <a href="http://androidxref.com/7.0.0_r1/xref/frameworks/base/core/java/com/android/internal/os/BatteryStatsImpl.java">BatteryStatsImpl</a> 内部使用的就是 <code>PowerProfile</code>。<code>BatteryStatsImpl</code> 会为每一个应用创建一个 <code>UID</code> 实例来监控应用的系统资源使用情况。</p><p>电量的使用也会跟环境有关，例如在零下十度的冬天电量会消耗得更快一些，系统提供的电量测量方法只是提供一个参考的数值。不过通过上面的这个方法，我们可以成功把电量的测量转化为功能模块的使用时间或者次数。</p><p>准确的测量电量并不是那么容易，在<a href="https://tech.meituan.com/2018/03/11/dianping-shortvideo-battery-testcase.html">《大众点评 App 的短视频耗电量优化实战》</a> 一文中，总结了下面几种电量测试的方法。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/ae1b52340f802f25a09c31c13a2a22fe.png" alt="图片来源于 Android开发高手课"></p><h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a><strong>感谢</strong></h1><blockquote><p><a href="https://time.geekbang.org/column/article/74044">极客时间 Android开发高手课</a>  </p><p><a href="https://blog.csdn.net/aa20616012/article/details/49781875">Android 6.0新特性之Doze模式</a> </p><p><a href="https://www.jianshu.com/p/5d83d8649c98">Android性能优化（九）之不可忽视的电量</a> </p><p>以及上文中的链接</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>App 直观感受-卡顿优化🌈</title>
      <link href="2020/hobble-optimization.html"/>
      <url>2020/hobble-optimization.html</url>
      
        <content type="html"><![CDATA[<p>对用户来说，<strong>内存占用高</strong>、<strong>耗费电量</strong>、<strong>耗费流量</strong> 可能不容易被发现，但是用户对 <strong>卡顿</strong> 特别敏感，很容易直观感受到。</p><p><strong>注意：如果出现图片不显示问题请移步</strong> <a href="https://calmcenter.club/2019/PicNotShow.html">图片不显示问题</a></p><h1 id="本文主要记载"><a href="#本文主要记载" class="headerlink" title="本文主要记载"></a>本文主要记载</h1><ul><li><strong>1 如何定义卡顿？</strong></li><li><strong>2 如何排查卡顿？</strong><ul><li>2.1 Linux 命令组合排查</li><li>2.2 使用 top 命令查看进程信息</li></ul></li><li><strong>3 有没有方便的 Android 卡顿排查工具？</strong><ul><li>3.1 TraceView</li><li>3.2 Nanoscope</li><li>3.3 systrace</li><li>3.4 Simpleperf</li><li>3.5 可视化方法(Android Studio Profiler)</li><li>3.6 Android Performance Montitor(BlockCanary)</li><li>3.7 Profilo</li></ul></li><li><strong>4 卡顿现场</strong><ul><li>4.1 获取 java 线程状态</li><li>4.2 获得所有线程堆栈</li><li>4.3 SIGQUIT 信号实现</li><li>4.4 Hook 实现</li></ul></li><li><strong>5 相关 Demo 学习</strong><ul><li>5.1 抓取 CPU 数据</li><li>5.2 PLTHook 监控 Thread 的创建</li><li>5.3 Loop 监控卡顿</li></ul></li><li>总结</li></ul><hr><h1 id="1-如何定义卡顿？"><a href="#1-如何定义卡顿？" class="headerlink" title="1 如何定义卡顿？"></a>1 如何定义卡顿？</h1><p><code>60帧</code> 每秒是目前最合适的图像显示速度，也是绝大部分 <code>Android</code> 设备设置的调试频率，如果在 <code>16ms</code> 内顺利完成界面刷新操作可以展示出流畅的画面，而由于任何原因导致接收到 <code>VSYNC</code> 信号的时候无法完成本次刷新操作，就会产生掉帧的现象，刷新帧率自然也就跟着下降(假定刷新帧率由正常的 <code>60fps</code> 降到 <code>30fps</code> ，用户就会明显感知到卡顿)。</p><p>卡顿的原因可以定义为 <code>UI 复杂度问题</code> ，<code>没有提前或异步初始化问题</code> ， <code>内存泄漏频繁 GC 的问题</code> 等，卡顿的解决思路是集结了 启动优化、内存优化、UI 优化 的所有知识点，所以这篇也是对之前的扩展补充。</p><p>造成卡顿的原因可能有千百种，不过最终都会反映到 CPU 时间上。</p><p>我们可以把 CPU 时间分为两种：</p><ol><li>用户时间：执行用户态应用程序代码所消耗的时间</li><li>系统时间：执行内核态系统调用所消耗的时间，包括 I/O、锁、中断以及其他系统调用的时间。</li></ol><hr><h1 id="2-如何排查卡顿"><a href="#2-如何排查卡顿" class="headerlink" title="2 如何排查卡顿"></a>2 如何排查卡顿</h1><h2 id="2-1-Linux-命令组合排查"><a href="#2-1-Linux-命令组合排查" class="headerlink" title="2.1 Linux 命令组合排查"></a>2.1 Linux 命令组合排查</h2><ol><li><strong>获取 <code>CPU</code> 核心数</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;possible</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>获取某个 <code>CPU</code> 的频率</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpu0&#x2F;cpufreq&#x2F;cpuinfo_max_freq</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/20200420172904.png" alt=""></p><p>我们需要根据设备 <code>CPU</code> 性能来 “看菜下饭” ，例如线程池使用线程数根据 <code>CPU</code> 的核心数，一些高级的 <code>AI</code> 功能只在主频比较高或者带有 <code>NPU</code> 的设备开启。</p><ol start="3"><li><strong>查看 <code>CPU</code> 的使用率</strong></li></ol><p><strong>整个系统的 CPU 使用情况</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;proc&#x2F;stat</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;adb shell</span><br><span class="line">cat &#x2F;proc&#x2F;stat</span><br><span class="line">cpu  166492 36473 149538 7550789 34852 0 9110 0 0 0</span><br><span class="line">cpu0 31858 4048 34220 808812 5172 0 4604 0 0 0</span><br><span class="line">cpu1 22897 4439 25504 894380 7874 0 1514 0 0 0</span><br><span class="line">cpu2 29068 6317 27063 908505 7657 0 673 0 0 0</span><br><span class="line">cpu3 25916 6157 23508 931591 6625 0 259 0 0 0</span><br><span class="line">cpu4 28689 5321 22388 971414 2544 0 1030 0 0 0</span><br><span class="line">cpu5 10136 3778 6687 1009482 1551 0 606 0 0 0</span><br><span class="line">cpu6 8074 3398 5163 1014162 1489 0 218 0 0 0</span><br><span class="line">cpu7 9854 3015 5005 1012443 1940 0 206 0 0 0</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>第一行的数据表示的是 <code>CPU</code> 总的使用情况</p><ol><li><p>这些数值的单位都是 <code>jiffies</code>。<code>jiffies</code> 是内核中的一个全局变量，用来记录系统启动以来产生的节拍数，在 <code>Linux</code> 中，一个节拍大致可以理解为操作系统进程调度的最小时间片，不同的 <code>Linux</code> 系统内核这个值可能不同，通常在 <code>1ms</code> 到 <code>10ms</code> 之间。</p></li><li><p>cpu  166492 36473 149538 7550789 34852 0 9110 0 0 0</p><ul><li><code>user</code>(166492) 从系统启动开始累积到当前时刻，处于用户态的运行时间，不包含 nice 值为负的进程。</li><li><code>nice</code>(36473) 从系统启动开始累积到当前时刻，nice 值为负的进程所占用的 CPU 时间。</li><li><code>system</code>(149538) 从系统启动开始累积到当前时刻，处于核心态的运行时间。</li><li><code>idle</code>(7550789) 从系统启动开始累积到当前时刻，除 IO 等待时间以外的其他等待时间。</li><li><code>iowait</code>(34852) 从系统启动开始累积到当前时刻，IO 等待时间。(since 2.5.41)</li><li><code>irq</code>(0) 从系统启动开始累积到当前时刻，硬中断时间。(since 2.6.0-test4)</li><li><code>softirq</code>(9110) 从系统启动开始累积到当前时刻，软中断时间。(since 2.6.0-test4)</li><li><code>stealstolen</code>(0) 这是在虚拟环境中运行时在其他操作系统中花费的时间。(since 2.6.11)</li><li><code>guest</code>(0) 这是运行 Linux 内核控制下的来宾操作系统的虚拟 CPU 所花费的时间。(since 2.6.24)</li><li><code>guest_nice</code>(0) 运行 niced 客户端的时间( Linux 内核控制下的客户操作系统的虚拟CPU)。(since Linux 2.6.33)</li></ul><p>具体使用率计算请查看 <a href="https://time.geekbang.org/column/article/71982">《Linux环境下进程的CPU占用率》</a> 还是有点麻烦的 ~ </p></li></ol><h2 id="2-2-使用-top-命令查看进程信息"><a href="#2-2-使用-top-命令查看进程信息" class="headerlink" title="2.2 使用 top 命令查看进程信息"></a>2.2 使用 top 命令查看进程信息</h2><ol><li><p>直接输入 <code>top</code> 可查看所有进程的 <code>cpu</code> 使用情况</p><p>几个常用的参数：</p><ul><li><code>-d</code>: 后面接秒数，就是整个进程画面更新的频率。默认是 5 秒。</li><li><code>-b</code>: 以批处理的方式执行 top，还有更多的参数可用。通常会搭配数据流重导向，将批处理的结果输出为文件。</li><li><code>-n</code>: 与 -b 搭配，意义是，需要进行几次 top 的输出结果。</li><li><code>-p</code>: 指定某个 PID 来进行观察监测。</li><li>在 top 执行过程中可以使用的按键命令：</li><li><code>?</code>: 显示在 top 中可以输入的按键命令。</li><li><code>P</code>: 按照 CPU 的使用资源排序显示。</li><li><code>M</code>: 按内存（Memory）的使用资源排序显示。</li><li><code>N</code>: 按 PID 来排序。</li><li><code>T</code>: 按该进程使用的 CPU 时间积累（TIME+）排序。</li><li><code>k</code>: 给某个 PID 一个信号（signal）。</li><li><code>r</code>: 给某个 PID 重新确定一个值。</li><li><code>1</code>: 显示所有 CPU 占用信息。</li></ul></li><li><p>监测进程 13620</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -d 2 -p 13620</span><br></pre></td></tr></table></figure><p>会一直输出进程 13620 的信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">top - 16:27:35 up 4 days, 7:43, 2 users, load average: 0.35, 0.47, 0.44</span><br><span class="line">Tasks: 1 total, 1 running, 0 sleeping, 0 stopped, 0 zombie</span><br><span class="line">Cpu(s): 0.1%us, 3.1%sy, 0.0%ni, 96.5%id, 0.0%wa, 0.0%hi, 0.3%si, 0.0%st</span><br><span class="line">Mem: 16320632k total, 1790796k used, 14529836k free, 233168k buffers</span><br><span class="line">Swap: 8232952k total, 0k used, 8232952k free, 941540k cached</span><br><span class="line"> </span><br><span class="line">PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND</span><br><span class="line">13620 test1370 20 0 11060 944 760 R 53.4 0.0 0:04.78 netperf</span><br></pre></td></tr></table></figure><hr><h1 id="3-有没有方便的-Android-卡顿排查工具？"><a href="#3-有没有方便的-Android-卡顿排查工具？" class="headerlink" title="3 有没有方便的 Android 卡顿排查工具？"></a>3 有没有方便的 Android 卡顿排查工具？</h1><p>日常开发中比较熟悉的工具分为两个流派：</p><ul><li><p>instrument 流派</p><p>获取一段时间内所有函数的调用过程，可以通过分析这段时间内的函数调用流程，再进一步分析待优化的点。</p></li><li><p>sample 流派</p><p>有选择性或者采用抽样的方式观察某些函数调用过程，可以通过这些有限的信息推测出流程中的可疑点，然后再继续细化分析。</p></li></ul><h2 id="3-1-Traceview"><a href="#3-1-Traceview" class="headerlink" title="3.1 Traceview"></a>3.1 Traceview</h2><p>我在 <a href="https://calmcenter.club/2019/start-optimization.html#toc-heading-7">《App 初体验-启动优化 2.2.1 TraceView》</a> 中讲过 <code>TraceView</code>  的基本使用方法。<code>Traceview</code> 属于 <code>instrument</code> 类型，它利用 Android Runtime 函数调用的 event 事件，将函数运行的耗时和调用关系写入 trace 文件中，它可以用来查看整个过程有哪些函数调用。</p><p>工具本身带来的性能开销过大，有时无法反映真实的情况。在 <code>Android 5.0</code> 之后，新增了<code>startMethodTracingSampling</code> 方法，可以使用基于样本的方式进行分析，以减少分析对运行时的性能影响。新增了 sample 类型后，就需要我们在开销和信息丰富度之间做好权衡。</p><h2 id="3-2-Nanoscope"><a href="#3-2-Nanoscope" class="headerlink" title="3.2 Nanoscope"></a>3.2 Nanoscope</h2><p> <a href="https://calmcenter.club/2019/start-optimization.html#toc-heading-10">《App 初体验-启动优化 2.2.4 Nanoscope》</a> 查看原理即项目地址。它是在 <code>instrument</code> 类型的性能分析工具中性能损耗比较小的。</p><h2 id="3-3-systrace"><a href="#3-3-systrace" class="headerlink" title="3.3 systrace"></a>3.3 systrace</h2><p> <a href="https://calmcenter.club/2019/start-optimization.html#toc-heading-8">《App 初体验-启动优化 2.2.2 systrace》</a> 查看具体使用方法。其中还讲到了 <code>systrace + 函数插桩 AOP</code></p><p><code>systrace</code> 工具只能监控特定系统调用的耗时情况，所以它是属于 <code>sample</code> 类型，而且性能开销非常低。但是它不支持应用程序代码的耗时分析，所以在使用时有一些局限性。</p><h2 id="3-4-Simpleperf"><a href="#3-4-Simpleperf" class="headerlink" title="3.4 Simpleperf"></a>3.4 Simpleperf</h2><p>分析 <code>Native</code> 函数时使用的工具，在 <code>Android Studio 3.2</code> 也在 <code>Profiler</code> 中直接支持 <code>Simpleperf</code>。</p><p><code>Simpleperf</code> 属于 <code>sample</code> 类型，它的性能开销非常低，使用火焰图展示分析结果。</p><p><strong>总结：</strong></p><p>选择哪种工具，需要看具体的场景。如果需要分析 <code>Native</code> 代码的耗时，可以选择 <code>Simpleperf</code>；如果想分析系统调用，可以选择 <code>systrace</code>；如果想分析整个程序执行流程的耗时，可以选择 <code>Traceview</code> 或者<code>插桩版本的 systrace</code>。<br><code>systrace</code> 利用了 <code>Linux</code> 的 <a href="http://source.android.com/devices/tech/debug/ftrace">ftrace</a> 调试工具，相当于在系统各个关键位置都添加了一些性能探针，也就是在代码里加了一些性能监控的埋点。<code>Android</code> 在 <code>ftrace</code> 的基础上封装了<code>atrace</code>，并增加了更多特有的探针，例如 <code>Graphics</code>、<code>Activity Manager</code>、<code>Dalvik VM</code>、<code>System Server</code> 等。</p><h2 id="3-5-可视化方法（Android-Studio-Profiler）"><a href="#3-5-可视化方法（Android-Studio-Profiler）" class="headerlink" title="3.5 可视化方法（Android Studio Profiler）"></a>3.5 可视化方法（Android Studio Profiler）</h2><p>在 <code>Android Studio 3.2</code> 的 <code>CPU Profiler</code> 中直接集成了几种性能分析工具</p><ul><li><strong>Sample Java Methods</strong> 的功能类似于 <code>Traceview</code> 的 <code>sample</code> 类型。</li><li><strong>Trace Java Methods</strong> 的功能类似于 <code>Traceview</code> 的 <code>instrument</code> 类型。</li><li><strong>Trace System Calls</strong> 的功能类似于 <code>systrace</code>。</li><li><strong>SampleNative</strong> (API Level 26+) 的功能类似于 <code>Simpleperf</code>。</li></ul><p>这些分析工具都支持了 <code>Call Chart</code> 和 <code>Flame Chart</code> 两种展示方式。</p><ol><li><p><strong>Call Chart</strong></p><p><code>Call Chart</code> 是 <code>Traceview</code> 和 <code>systrace</code> 默认使用的展示方式。它按照应用程序的函数执行顺序来展示，适合用于分析整个流程的调用。举一个最简单的例子，A 函数调用 B 函数，B 函数调用 C 函数，循环三次，就得到了下面的 <code>Call Chart</code>。</p><p><img src= "/img/loading.gif" data-lazy-src="https://static001.geekbang.org/resource/image/db/3e/db3612f661d29efe59854df2e6c2383e.jpg" alt="图片来源于 Android开发高手课"></p><p><code>Call Chart</code> 就像给应用程序做一个心电图，我们可以看到在这一段时间内，各个线程的具体工作，比如是否存在线程间的锁、主线程是否存在长时间的 <code>I/O</code> 操作、是否存在空闲等。</p></li><li><p><strong>Flame Chart</strong></p></li></ol><p>Flame Chart 也就是<strong>火焰图</strong>。它跟 Call Chart 不同的是，Flame Chart 以一个全局的视野来看待一段时间的调用分布，它就像给应用程序拍 X 光片，可以很自然地把时间和空间两个维度上的信息融合在一张图上。</p><p>上面函数调用的例子，换成火焰图的展示结果如下。</p><p><img src= "/img/loading.gif" data-lazy-src="https://static001.geekbang.org/resource/image/6c/01/6ca232173daf9e71f06ac22252d65d01.jpg" alt="图片来源于 Android开发高手课"></p><p>当我们不想知道应用程序的整个调用流程，只想直观看出哪些代码路径花费的 <code>CPU</code> 时间较多时，火焰图就是一个非常好的选择。</p><p>火焰图还可以使用在各种各样的维度，例如内存、I/O 的分析。有些内存可能非常缓慢地泄漏，通过一个内存的火焰图，我们就知道哪些路径申请的内存最多，有了火焰图我们根本不需要分析源代码，也不需要分析整个流程。</p><h2 id="3-6-Android-Performance-Monitor（BlockCanary）"><a href="#3-6-Android-Performance-Monitor（BlockCanary）" class="headerlink" title="3.6 Android Performance Monitor（BlockCanary）"></a>3.6 Android Performance Monitor（BlockCanary）</h2><p><a href="https://github.com/markzhai/AndroidPerformanceMonitor">AndroidPerformanceMonitor</a> 是一个Android平台的一个非侵入式的性能监控组件，应用只需要实现一个抽象类，提供一些该组件需要的上下文环境，就可以在平时使用应用的时候检测主线程上的各种卡慢问题，并通过组件提供的各种信息分析出原因并进行修复。</p><h2 id="3-7-Profilo"><a href="#3-7-Profilo" class="headerlink" title="3.7 Profilo"></a>3.7 Profilo</h2><p>2018 年 3 月，<code>Facebook</code> 开源了一个叫 <a href="https://github.com/facebookincubator/profilo">Profilo</a> 的库， 它收集了各大方案的优点。</p><ol><li><p><strong>集成 atrace 功能</strong>。</p><p>这样所有 <code>systrace</code> 的探针我们都可以拿到，例如四大组件生命周期、锁等待时间、类校验、<code>GC</code> 时间等。</p></li><li><p><strong>快速获取 Java 堆栈</strong></p><p>这里有一个误区，大家都觉得在某个线程不断地获取主线程堆栈是不耗时的。但是事实上获取堆栈的代价是巨大的，它要暂停主线程的运行。</p><p>而 <code>profilo</code> 巧妙的解决的这个问题，可以实现线程一边继续跑步，我们还可以帮它做检查，而且耗时基本忽略不计。</p></li></ol><p>不用插桩、性能基本没有影响、捕捉信息还全，那 <code>Profilo</code> 不就是完美的化身吗？当然由于它利用了大量的黑科技，兼容性是需要注意的问题。它内部实现有大量函数的 <code>Hook</code>，<code>unwind</code> 也需要强依赖 <code>Android Runtime</code> 实现。<code>Facebook</code> 已经将 <code>Profilo</code> 投入到线上使用，但由于目前 <code>Profilo</code> 快速获取堆栈功能依然不支持 <code>Android 8.0</code> 和 <code>Android 9.0</code>，鉴于稳定性问题，建议采取抽样部分用户的方式来开启该功能。</p><p><strong>帮助理解</strong></p><ul><li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-ftrace/index.html">ftrace 简介</a>、<a href="https://www.ibm.com/developerworks/cn/linux/l-cn-ftrace1/index.html">ftrace 使用（上）</a>、<a href="https://www.ibm.com/developerworks/cn/linux/l-cn-ftrace2/index.html">frace 使用（下）</a></li><li><a href="http://source.android.com/devices/tech/debug/ftrace">atrace 介绍</a>、<a href="http://android.googlesource.com/platform/frameworks/native/+/master/cmds/atrace/atrace.cpp">atrace 实现</a></li></ul><p>每个工具都可以生成不同的展示方式，我们需要根据不同的使用场景选择合适的方式。</p><hr><h1 id="4-卡顿现场"><a href="#4-卡顿现场" class="headerlink" title="4 卡顿现场"></a>4 卡顿现场</h1><h2 id="4-1-获取-java-线程状态"><a href="#4-1-获取-java-线程状态" class="headerlink" title="4.1 获取 java 线程状态"></a>4.1 获取 java 线程状态</h2><p>通过 <code>Thread</code> 的 <code>getState</code> 方法可以获取线程状态，<strong>WAITING</strong>、<strong>TIME_WAITING</strong> 和 <strong>BLOCKED</strong> 都是需要特别注意的状态。</p><p>BLOCKED: 是指线程正在等待获取锁，对应的是下面代码中的情况一；</p><p>WAITING: 是指线程正在等待其他线程的“唤醒动作”，对应的是代码中的情况二。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (object)  &#123;     <span class="comment">// 情况一：在这里卡住 --&gt; BLOCKED</span></span><br><span class="line">    object.wait();           <span class="comment">// 情况二：在这里卡住 --&gt; WAITING</span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>不过当一个线程进入 WAITING 状态时，它不仅会释放 CPU 资源，还会将持有的 object 锁也同时释放。</p><p>更多相关资料 <a href="https://juejin.im/post/5b31b510e51d4558a426f7e9">《Java 线程 Dump 分析》</a></p><h2 id="4-2-获得所有线程堆栈"><a href="#4-2-获得所有线程堆栈" class="headerlink" title="4.2 获得所有线程堆栈"></a>4.2 获得所有线程堆栈</h2><p>当我们发现有个线程导致主线程 <code>BLOCKED</code> ，需要通过 <code>Thread.getAllStackTraces()</code> 拿所有线程的堆栈，需要注意的是在 <code>Android 7.0</code>，<code>getAllStackTraces</code>是不会返回主线程的堆栈的。</p><h2 id="4-4-SIGQUIT-信号实现"><a href="#4-4-SIGQUIT-信号实现" class="headerlink" title="4.4 SIGQUIT 信号实现"></a>4.4 SIGQUIT 信号实现</h2><p>注：需要 <code>root</code> </p><p><code>Android</code> 应用发生 <code>ANR</code> 时，系统会发出 <code>SIGQUIT</code> 信号给发生 <code>ANR</code> 进程。系统信号捕捉线程触发输出<code>/data/anr/traces.txt</code> 文件，记录问题产生虚拟机、线程堆栈相关信息。这个 <code>trace</code> 文件中包含了线程信息和锁的信息，借助这个 <code>trace</code> 文件可以分析卡死的原因。</p><p>由此，如果利用这个系统原有的机制，自己在线程卡死时候触发traces文件的形成进行上报，便可以把线程卡死的关键进行进行上报。本监控方案便是<strong>利用系统机制进行卡死信息的抓取</strong>：</p><ol><li><p>当监控线程发现被监控线程卡死时，主动向系统发送 <code>SIGQUIT</code> 信号。</p></li><li><p>等待 <code>/data/anr/traces.txt</code> 文件生成。</p></li><li><p>文件生成以后进行上报。</p></li></ol><p>分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程名称; 优先级; 线程id; 线程状态</span></span><br><span class="line"><span class="string">&quot;main&quot;</span> prio=<span class="number">5</span> tid=<span class="number">1</span> Suspended</span><br><span class="line">  <span class="comment">// 线程组;  线程suspend计数; 线程debug suspend计数; </span></span><br><span class="line">  | group=<span class="string">&quot;main&quot;</span> sCount=<span class="number">1</span> dsCount=<span class="number">0</span> obj=<span class="number">0x74746000</span> self=<span class="number">0xf4827400</span></span><br><span class="line">  <span class="comment">// 线程native id; 进程优先级; 调度者优先级;</span></span><br><span class="line">  | sysTid=<span class="number">28661</span> nice=-<span class="number">4</span> cgrp=<span class="keyword">default</span> sched=<span class="number">0</span>/<span class="number">0</span> handle=<span class="number">0xf72cbbec</span></span><br><span class="line">  <span class="comment">// native线程状态; 调度者状态; 用户时间utime; 系统时间stime; 调度的CPU</span></span><br><span class="line">  | state=D schedstat=( <span class="number">3137222937</span> <span class="number">94427228</span> <span class="number">5819</span> ) utm=<span class="number">218</span> stm=<span class="number">95</span> core=<span class="number">2</span> HZ=<span class="number">100</span></span><br><span class="line">  <span class="comment">// stack相关信息</span></span><br><span class="line">  | stack=<span class="number">0xff717000</span>-<span class="number">0xff719000</span> stackSize=<span class="number">8</span>MB</span><br></pre></td></tr></table></figure><p>其中 <code>utm</code> 代表 <code>utime</code>，<code>HZ</code> 代表 <code>CPU</code> 的时钟频率，将 <code>utime</code> 转换为毫秒的公式是 <code>time * 1000/HZ</code>。例子中 <code>utm=218</code>，也就是 <code>218*1000/100=2180</code> 毫秒。</p><h2 id="4-5-Hook-实现"><a href="#4-5-Hook-实现" class="headerlink" title="4.5 Hook 实现"></a>4.5 Hook 实现</h2><p>用 <code>SIGQUIT</code> 信号量获取 <code>ANR</code> 日志，从而拿到所有线程的各种信息，这套方案看起来很美好。但事实上，它存在这几个问题：</p><ol><li><strong>可行性。</strong> 高版本系统已经没有权限读取 <code>/data/anr/traces.txt</code> 文件。需要 <code>root</code> 手机</li><li><strong>性能。</strong>获取所有线程堆栈以及各种信息非常耗时，对于卡顿场景不一定合适，它可能会进一步加剧用户的卡顿。</li></ol><p><a href="https://www.jianshu.com/p/f406d535a8bc">Android trace文件抓取原理</a>   <a href="https://mp.weixin.qq.com/s/g-WzYF3wWAljok1XjPoo7w?">Android 平台 Native 代码的崩溃捕获机制及实现</a></p><p><a href="https://blog.csdn.net/oujunli/article/details/9102101">通过Android trace文件分析死锁ANR</a> </p><p>能力有限，还在研究中。。</p><p><strong>思路：</strong> <code>hook libart.so</code> 。通过<code>hook ThreadList</code> 和 <code>Thread</code> 的函数，获得跟 <code>ANR</code> 一样的堆栈。为了稳定性，我们会在 <code>fork</code> 子进程执行。</p><p>  优点：信息很全，基本跟 <code>ANR</code> 的日志一样，有 <code>native</code> 线程状态，锁信息等等。<br>  缺点：黑科技的兼容性问题，失败时可以用 <code>Thread.getAllStackTraces()</code> 兜底</p><p>获取Java堆栈的方法还可以用在卡顿时，因为使用fork进程，所以可以做到完全不卡主进程。</p><p><code>Breakpad</code> 使用了 <code>fork</code> 子进程甚至孙进程的方式去收集崩溃现场，即便出现二次崩溃，也只是这部分信息丢失。</p><h1 id="5-Demo-相关-Demo-学习"><a href="#5-Demo-相关-Demo-学习" class="headerlink" title="5 Demo 相关 Demo 学习"></a>5 Demo 相关 Demo 学习</h1><h2 id="5-1-抓取-CPU-数据"><a href="#5-1-抓取-CPU-数据" class="headerlink" title="5.1 抓取 CPU 数据"></a>5.1 抓取 CPU 数据</h2><p><a href="https://github.com/AndroidAdvanceWithGeektime/Chapter05">Chapter05</a> </p><p>模仿 <a href="http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/java/com/android/internal/os/ProcessCpuTracker.java">ProcessCpuTracker.java</a> 拿到一段时间内各个线程的耗时占比</p><p>示例的日志数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">usage: CPU usage <span class="number">5000</span>ms(from <span class="number">23</span>:<span class="number">23</span>:<span class="number">33.000</span> to <span class="number">23</span>:<span class="number">23</span>:<span class="number">38.000</span>):</span><br><span class="line">System TOTAL: <span class="number">2.1</span>% user + <span class="number">16</span>% kernel + <span class="number">9.2</span>% iowait + <span class="number">0.2</span>% irq + <span class="number">0.1</span>% softirq + <span class="number">72</span>% idle</span><br><span class="line">CPU Core: <span class="number">8</span></span><br><span class="line">Load Average: <span class="number">8.74</span> / <span class="number">7.74</span> / <span class="number">7.36</span></span><br><span class="line"></span><br><span class="line">Process:com.sample.app </span><br><span class="line">  <span class="number">50</span>% <span class="number">23468</span>/com.sample.app(S): <span class="number">11</span>% user + <span class="number">38</span>% kernel faults:<span class="number">4965</span></span><br><span class="line"></span><br><span class="line">Threads:</span><br><span class="line">  <span class="number">43</span>% <span class="number">23493</span>/singleThread(R): <span class="number">6.5</span>% user + <span class="number">36</span>% kernel faults：<span class="number">3094</span></span><br><span class="line">  <span class="number">3.2</span>% <span class="number">23485</span>/RenderThread(S): <span class="number">2.1</span>% user + <span class="number">1</span>% kernel faults：<span class="number">329</span></span><br><span class="line">  <span class="number">0.3</span>% <span class="number">23468</span>/.sample.app(S): <span class="number">0.3</span>% user + <span class="number">0</span>% kernel faults：<span class="number">6</span></span><br><span class="line">  <span class="number">0.3</span>% <span class="number">23479</span>/HeapTaskDaemon(S): <span class="number">0.3</span>% user + <span class="number">0</span>% kernel faults：<span class="number">982</span></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><ol><li>在 <code>System Total</code> 部分 <code>user</code> 占用不多，<code>CPU idle</code> 很高，消耗多在 <code>kernel</code> 和 <code>iowait</code>。</li><li><code>CPU</code> 是 8 核的，<code>Load Average</code> 大约也是 8，表示 <code>CPU</code> 并不处于高负载情况。</li><li>在 <code>Process</code> 里展示了这段时间内 <code>sample app</code> 的 <code>CPU</code> 使用情况：<code>user</code> 低，<code>kernel</code> 高，并且有 <code>4965</code> 次 <code>page faults</code>。<ol><li><code>page faluts</code> 分为三种：<code>minor page fault</code>、<code>major page fault</code> 和 <code>invalid page fault</code></li></ol></li><li>在 <code>Threads</code> 里展示了每个线程的 <code>usage</code> 情况，当前只有 <code>singleThread</code> 处于 <code>R</code> 状态，并且当前线程产生了 3096 次 <code>page faults</code>，其他的线程包括主线程（<code>Sample</code> 日志里可见的）都是处于 <code>S</code>状态。<ol><li><code>R</code>：代表线程处于 <code>Running</code> 或者 <code>Runnable</code> 状态。<code>Running</code> 状态说明线程当前被某个 <code>Core</code> 执行，<code>Runnable</code> 状态说明线程当前正在处于等待队列中等待某个 <code>Core</code> 空闲下来去执行。</li><li><code>S</code>： <code>TASK_INTERRUPTIBLE（可中断）</code>  发生这种状态是线程主动让出了 <code>CPU</code>，如果线程调用了 <code>sleep</code> 或者其他情况导致了自愿式的上下文切换就会处于 <code>S</code> 状态。</li></ol></li></ol><p><code>Demo</code> 中执行 <code>Test</code> 抓取数据如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CPU usage from <span class="number">5137</span>ms to <span class="number">81</span><span class="function">ms <span class="title">ago</span> <span class="params">(<span class="number">2020</span><span class="number">-05</span><span class="number">-13</span> <span class="number">21</span>:<span class="number">57</span>:<span class="number">32.764</span> to <span class="number">2020</span><span class="number">-05</span><span class="number">-13</span> <span class="number">21</span>:<span class="number">57</span>:<span class="number">37.819</span>)</span>:</span></span><br><span class="line"><span class="function">16% 15921/com.sample.<span class="title">processtracker</span><span class="params">(R)</span>: 6.3% user + 9.6% kernel / faults: 3332 minor</span></span><br><span class="line"><span class="function">thread stats:</span></span><br><span class="line"><span class="function">15% 16145/<span class="title">SingleThread</span><span class="params">(S)</span>: 1.9% user + 13% kernel / faults: 3014 minor</span></span><br><span class="line"><span class="function">13% 17088/<span class="title">SingleThread</span><span class="params">(S)</span>: 1.3% user + 12% kernel / faults: 3016 minor</span></span><br><span class="line"><span class="function">1.3% 15921/.<span class="title">processtracker</span><span class="params">(R)</span>: 0.9% user + 0.3% kernel / faults: 40 minor</span></span><br><span class="line"><span class="function">0.5% 16002/<span class="title">RenderThread</span><span class="params">(S)</span>: 0.1% user + 0.3% kernel / faults: 37 minor</span></span><br><span class="line"><span class="function">0.1% 15942/Jit thread <span class="title">pool</span><span class="params">(S)</span>: 0.1% user + 0% kernel / faults: 222 minor</span></span><br><span class="line"><span class="function">0% 15949/<span class="title">HeapTaskDaemon</span><span class="params">(S)</span>: 0% user + 0% kernel</span></span><br><span class="line"><span class="function">...</span></span><br><span class="line"><span class="function">0% <span class="title">TOTAL</span><span class="params">()</span>: 0% user + 0% kernel</span></span><br><span class="line"><span class="function">Load: 0.0 / 0.0 / 0.0</span></span><br></pre></td></tr></table></figure><p>这里不太清楚为什么后面的数据都是 0 ，最后应该输出 <code>iowait</code> 才对。</p><p>极客时间原文例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CPU usage from <span class="number">5187</span>ms to <span class="number">121</span><span class="function">ms <span class="title">ago</span> <span class="params">(<span class="number">2018</span><span class="number">-12</span><span class="number">-28</span> <span class="number">08</span>:<span class="number">28</span>:<span class="number">27.186</span> to <span class="number">2018</span><span class="number">-12</span><span class="number">-28</span> <span class="number">08</span>:<span class="number">28</span>:<span class="number">32.252</span>)</span>:</span></span><br><span class="line"><span class="function">40% 24155/com.sample.<span class="title">processtracker</span><span class="params">(R)</span>: 14% user + 26% kernel / faults: 5286 minor</span></span><br><span class="line"><span class="function">thread stats:</span></span><br><span class="line"><span class="function">35% 24184/<span class="title">SingleThread</span><span class="params">(S)</span>: 11% user + 24% kernel / faults: 3055 minor</span></span><br><span class="line"><span class="function">2.1% 24174/<span class="title">RenderThread</span><span class="params">(S)</span>: 1.3% user + 0.7% kernel / faults: 384 minor</span></span><br><span class="line"><span class="function">1.5% 24155/.<span class="title">processtracker</span><span class="params">(R)</span>: 1.1% user + 0.3% kernel / faults: 95 minor</span></span><br><span class="line"><span class="function">0.1% 24166/<span class="title">HeapTaskDaemon</span><span class="params">(S)</span>: 0.1% user + 0% kernel / faults: 1070 minor</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">100% <span class="title">TOTAL</span><span class="params">()</span>: 3.8% user + 7.8% kernel + 11% iowait + 0.1% irq + 0% softirq + 76% idle</span></span><br><span class="line"><span class="function">Load: 6.31 / 6.52 / 6.66</span></span><br></pre></td></tr></table></figure><p>如果有大佬知道原因，还请告知。</p><p>如果产生大量的 <code>faults</code> 其实是不太正常的，或者 <code>iowait</code> 过高就需要关注是否有很密集的 <code>I/O</code> 操作。</p><p><a href="https://yq.aliyun.com/articles/55820">《page fault 带来的性能问题》</a> </p><p><a href="http://oenhan.com/iowait-wa-vmstat">《iowait 的形成原因和内核分析》</a></p><h2 id="5-2-PLTHook-监控-Thread-的创建"><a href="#5-2-PLTHook-监控-Thread-的创建" class="headerlink" title="5.2 PLTHook 监控 Thread 的创建"></a>5.2 PLTHook 监控 Thread 的创建</h2><p><a href="https://github.com/AndroidAdvanceWithGeektime/Chapter06-plus">Chapter06-plus</a> 这个 <code>Demo</code> 与 <a href="https://www.jianshu.com/p/a26d11502ec8">Android线程的创建过程</a>  结合，了解 <code>PLTHook</code> 的使用，以及 <code>Thread</code> 状态知识、如何创建的。</p><h2 id="5-3-Loop-监控卡顿"><a href="#5-3-Loop-监控卡顿" class="headerlink" title="5.3 Loop 监控卡顿"></a>5.3 Loop 监控卡顿</h2><p>在 <code>Android UI</code> 线程中有个 <code>Looper</code>，在其 <code>loop</code> 方法中会不断取出 <code>Message</code>，调用其绑定的 <code>Handler</code> 在 <code>UI</code> 线程进行执行。</p><p>部分代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Looper me = myLooper();</span><br><span class="line">    <span class="keyword">final</span> MessageQueue queue = me.mQueue;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Message msg = queue.next(); <span class="comment">// might block</span></span><br><span class="line">        <span class="comment">// This must be in a local variable, in case a UI event sets the logger</span></span><br><span class="line">        <span class="keyword">final</span> Printer logging = me.mLogging;</span><br><span class="line">        <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">            logging.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot;</span> + msg.target + <span class="string">&quot; &quot;</span> +</span><br><span class="line">                            msg.callback + <span class="string">&quot;: &quot;</span> + msg.what);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            msg.target.dispatchMessage(msg);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">            logging.println(<span class="string">&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot;</span> + msg.target + <span class="string">&quot; &quot;</span> + msg.callback);</span><br><span class="line">        &#125;</span><br><span class="line">        msg.recycleUnchecked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在执行此代码前后，如果设置了 <code>logging</code>，会分别打印出 <code>&gt;&gt;&gt;&gt;&gt; Dispatching to</code>和 <code>&lt;&lt;&lt;&lt;&lt; Finished to</code> 这样的<code>log</code> 。</p><p>我们可以通过计算两次 <code>log</code> 之间的时间差值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Looper.getMainLooper().setMessageLogging(<span class="keyword">new</span> Printer() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String START = <span class="string">&quot;&gt;&gt;&gt;&gt;&gt; Dispatching&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String END = <span class="string">&quot;&lt;&lt;&lt;&lt;&lt; Finished&quot;</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(String x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x.startsWith(START)) &#123;</span><br><span class="line">            LogMonitor.getInstance().startMonitor();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x.startsWith(END)) &#123;</span><br><span class="line">            LogMonitor.getInstance().removeMonitor();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>假设我们的阈值是 <code>1000ms</code>，当我在匹配到 <code>&gt;&gt;&gt;&gt;&gt; Dispatching</code> 时，我会在 <code>1000ms</code> 毫秒后执行一个任务（打印出 <code>UI</code> 线程的堆栈信息，会在非 <code>UI</code> 线程中进行）；</p><p>正常情况下，肯定是低于 <code>1000ms</code> 执行完成的，所以当我匹配到 <code>&lt;&lt;&lt;&lt;&lt; Finished</code> ，会移除该任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogMonitor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LogMonitor sInstance = <span class="keyword">new</span> LogMonitor();</span><br><span class="line">    <span class="keyword">private</span> Handler mIoHandler;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> TIME_BLOCK = <span class="number">1000L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LogMonitor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HandlerThread mLogThread = <span class="keyword">new</span> HandlerThread(<span class="string">&quot;log&quot;</span>);</span><br><span class="line">        mLogThread.start();</span><br><span class="line">        mIoHandler = <span class="keyword">new</span> Handler(mLogThread.getLooper());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Runnable mLogRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            StackTraceElement[] stackTrace = Looper.getMainLooper().getThread().getStackTrace();</span><br><span class="line">            <span class="keyword">for</span> (StackTraceElement s : stackTrace) &#123;</span><br><span class="line">                sb.append(s.toString() + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Log.e(<span class="string">&quot;TAG&quot;</span>,sb.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LogMonitor <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMonitor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; handlerClass = Class.forName(<span class="string">&quot;android.os.Handler&quot;</span>);</span><br><span class="line">            java.lang.reflect.Method method = handlerClass.getMethod(<span class="string">&quot;hasCallbacks&quot;</span>, Runnable.class);</span><br><span class="line">            Boolean ret = (Boolean) method.invoke(mIoHandler, mLogRunnable);</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startMonitor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        mIoHandler.postDelayed(mLogRunnable,TIME_BLOCK);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeMonitor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        mIoHandler.removeCallbacks(mLogRunnable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们利用了 <code>HandlerThread</code> 这个类，同样利用了 <code>Looper</code> 机制，只不过在非UI线程中，如果执行耗时达到我们设置的阈值，则会执行 <code>mLogRunnable</code> ，打印出 <code>UI</code> 线程当前的堆栈信息；如果你阈值时间之内完成，则会 <code>remove</code> 掉该 <code>runnable</code>。</p><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fmarkzhai%2FAndroidPerformanceMonitor">BlockCanary 16 年原理分析</a>   </p><p>代码修改自于 <a href="https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&mid=2650822205&idx=1&sn=6b8e78bc1d71eb79a199667cf132acf7&chksm=80b782a3b7c00bb5c12437556fca68136c75409855e9252e395b545621319edf23959942b67c&scene=21#wechat_redirect">Android UI性能优化 检测应用中的UI卡顿</a> 修改了 <code>hasCallbacks</code> 调用方式</p><p><strong>这个方法的缺点：</strong> 大量字符串拼接导致性能损耗严重，快速滑动时会降低帧数。</p><ul><li><strong>消息队列</strong></li></ul><p>可以通过一个监控线程，每隔 1 秒向主线程消息队列的头部插入一条空消息。假设 1 秒后这个消息并没有被主线程消费掉，说明阻塞消息运行的时间在 0～1 秒之间。换句话说，如果我们需要监控 3 秒卡顿，那在第 4 次轮询中头部消息依然没有被消费的话，就可以确定主线程出现了一次 3 秒以上的卡顿。</p><p><img src= "/img/loading.gif" data-lazy-src="https://static001.geekbang.org/resource/image/b0/56/b06d5aa439e8bb75885a338df9a25f56.png" alt="图片来源于 Android开发高手课"></p><p>这个方案也存在一定的误差，那就是发送空消息的间隔时间。但这个间隔时间也不能太小，因为监控线程和主线程处理空消息都会带来一些性能损耗，但基本影响不大。</p><p><strong>这个方法的缺点：</strong> 基于消息队列的卡顿监控并不准确，正在运行的函数有可能并不是真正耗时的函数。</p><ul><li><strong>插桩</strong></li></ul><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FTencent%2Fmatrix">参考 微信 开源库 matrix</a></p><p><strong>避免方法数暴增。</strong>在函数的入口和出口应该插入相同的函数，在编译时提前给代码中每个方法分配一个独立的 <code>ID</code> 作为参数。</p><p><strong>过滤简单的函数。</strong>过滤一些类似直接 <code>return</code>、<code>i++</code> 这样的简单函数，并且支持黑名单配置。对一些调用非常频繁的函数，需要添加到黑名单中来降低整个方案对性能的损耗。</p><p>基于性能的考虑，线上只会监控主线程的耗时。最终安装包体积只增大 1～2%，平均帧率下降也在 2 帧以内。</p><p>插桩方案看起来美好，它也有自己的短板，那就是只能监控应用内自身的函数耗时，无法监控系统的函数调用，整个堆栈看起来好像 “缺失了” 一部分。</p><h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h1><blockquote><p><a href="https://time.geekbang.org/column/article/74044">极客时间 Android开发高手课</a>  </p><p><a href="https://time.geekbang.org/column/article/71982">《Linux环境下进程的CPU占用率》</a></p><p><a href="http://man7.org/linux/man-pages/man5/proc.5.html">《Linux 文档》</a></p><p><a href="https://juejin.im/post/5b31b510e51d4558a426f7e9">《Java线程Dump分析》</a></p><p><a href="https://cloud.tencent.com/developer/article/1064396">《手Q Android线程死锁监控与自动化分析实践》</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&mid=2650822205&idx=1&sn=6b8e78bc1d71eb79a199667cf132acf7&chksm=80b782a3b7c00bb5c12437556fca68136c75409855e9252e395b545621319edf23959942b67c&scene=21#wechat_redirect">Android UI性能优化 检测应用中的UI卡顿</a></p><p>以及上文中的链接</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>App UI优化💦</title>
      <link href="2020/ui-optimization.html"/>
      <url>2020/ui-optimization.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>每个做 UI 的 Android 开发，上辈子都是折翼的天使。</p></blockquote><h1 id="本文主要记载"><a href="#本文主要记载" class="headerlink" title="本文主要记载"></a>本文主要记载</h1><ul><li><strong>1 UI 优化究竟指的是什么呢？</strong></li><li><strong>2 屏幕适配？？？</strong></li><li><strong>3 如何测量、监控 UI 需要优化？</strong><ul><li>3.1 过度绘制</li><li>3.2 Profile GPU Rendering</li><li>3.3 测量 setContentView 具体耗时<ul><li>3.3.1 AOP</li><li>3.3.2 Factory2</li></ul></li><li>3.4 问题定位 systrace</li></ul></li><li><strong>4 UI 优化常用手段</strong><ul><li>4.1 尽量使用硬件加速</li><li>4.2 Create View 优化<ul><li>4.2.1 使用代码创建</li><li>4.2.2 异步创建</li></ul></li><li>4.3. measure/layout 优化</li><li>4.4 其他<ul><li>4.4.1 Litho：异步布局</li><li>4.4.2 Flutter：自己的布局 + 渲染引擎</li><li>4.4.3 RenderThread 与 RenderScript</li></ul></li></ul></li><li><strong>5 总结</strong></li></ul><hr><h1 id="1-UI-优化究竟指的是什么呢？"><a href="#1-UI-优化究竟指的是什么呢？" class="headerlink" title="1 UI 优化究竟指的是什么呢？"></a>1 UI 优化究竟指的是什么呢？</h1><p>我认为所谓的 <code>UI</code> 优化，应该包含两个方面</p><ol><li>一个是效率的提升，我们可以非常高效地把 <code>UI</code> 的设计图转化成应用界面，并且保证 <code>UI</code> 界面在不同尺寸和分辨率的手机上都是一致的</li><li>另一个是性能的提升，在正确实现复杂、炫酷的 <code>UI</code> 设计的同时，需要保证用户有流畅的体验。</li></ol><hr><h1 id="2-屏幕适配？？？"><a href="#2-屏幕适配？？？" class="headerlink" title="2 屏幕适配？？？"></a>2 屏幕适配？？？</h1><p><code>Android</code> 的碎片化问题令人痛心疾首，屏幕的差异正是碎片化问题的 “中心” ，多年来，有那么一群苦逼的 <code>Android</code> 开发，他们饱受碎片化之苦，面对着各式各样的手机屏幕尺寸和分辨率，还要与“凶残”的产品和 <code>UI</code> 设计师过招，日复一日、年复一年的做着 <code>UI</code> 适配和优化工作，蹉跎着青春的岁月。更加不幸的是，最近两年这个趋势似乎还愈演愈烈：刘海屏、全面屏，还有即将推出的柔性折叠屏，<code>UI</code> 适配将变得越来越复杂。</p><p>对于屏幕碎片化的问题，<code>Android</code> 推荐使用 <code>dp</code> 作为尺寸单位来适配 <code>UI</code>，因此每个 <code>Android</code> 开发都应该很清楚 <code>px</code>、<code>dp</code>、<code>dpi</code>、<code>ppi</code>、<code>density</code> 这些概念。<br><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/20200416135354.png" alt=""></p><p>通过 <code>dp</code> 加上自适应布局可以基本解决屏幕碎片化的问题。</p><ul><li>不一致性。因为 dpi 与实际 ppi 的差异性，导致在相同分辨率的手机上，控件的实际大小会有所不同。</li><li>效率。设计师的设计稿都是以 px 为单位的，开发人员为了 UI 适配，需要手动通过百分比估算出 dp 值。</li></ul><p>除了直接 dp 适配之外，目前业界比较常用的 UI 适配方法主要有下面几种：</p><p>限制符适配方案。主要有宽高限定符与 smallestWidth 限定符适配方案，具体可以参考<a href="https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&mid=2650826034&idx=1&sn=5e86768d7abc1850b057941cdd003927&chksm=80b7b1acb7c038ba8912b9a09f7e0d41eef13ec0cea19462e47c4e4fe6a08ab760fec864c777&scene=21#wechat_redirect">《Android 目前稳定高效的 UI 适配方案》</a><a href="https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&mid=2650826381&idx=1&sn=5b71b7f1654b04a55fca25b0e90a4433&chksm=80b7b213b7c03b0598f6014bfa2f7de12e1f32ca9f7b7fc49a2cf0f96440e4a7897d45c788fb&scene=21#wechat_redirect">《smallestWidth 限定符适配方案》</a>。今日头条适配方案。通过反射修正系统的 density 值，具体可以参考<a href="https://mp.weixin.qq.com/s?__biz=MzI1MzYzMjE0MQ==&mid=2247484502&idx=2&sn=a60ea223de4171dd2022bc2c71e09351&scene=21#wechat_redirect">《一种极低成本的 Android 屏幕适配方式》</a><a href="https://mp.weixin.qq.com/s/oSBUA7QKMWZURm1AHMyubA">《今日头条适配方案》</a>。</p><hr><h1 id="3-如何测量、监控-UI-需要优化？"><a href="#3-如何测量、监控-UI-需要优化？" class="headerlink" title="3 如何测量、监控 UI 需要优化？"></a>3 如何测量、监控 UI 需要优化？</h1><h2 id="3-1-过度绘制"><a href="#3-1-过度绘制" class="headerlink" title="3.1 过度绘制"></a>3.1 过度绘制</h2><blockquote><p><strong>理论上一个像素每次只绘制一次是最优的，但是由于重叠的布局导致一些像素会被多次绘制，Overdraw由此产生。</strong></p></blockquote><p>我们可以通过调试工具来检测 <code>Overdraw</code> ：<code>设置——&gt;开发者选项——&gt;调试 GPU 过度绘制——&gt;显示过度绘制区域</code>。<br><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/20200416164642.png" alt=""></p><blockquote><p>原色 – 没有过度绘制 – 这部分的像素点只在屏幕上绘制了一次。<br>蓝色 – 1次过度绘制   – 这部分的像素点只在屏幕上绘制了两次。<br>绿色 – 2次过度绘制   – 这部分的像素点只在屏幕上绘制了三次。<br>粉色 – 3次过度绘制   – 这部分的像素点只在屏幕上绘制了四次。<br>红色 – 4次过度绘制   – 这部分的像素点只在屏幕上绘制了五次。</p></blockquote><p><strong>在实际项目中，一般认为蓝色即是可以接受的颜色。</strong></p><p><strong>具体优化点：</strong></p><ol><li>各种控件背景颜色</li><li><code>Activity</code> 的 <code>Theme</code> 中的背景颜色</li></ol><p><strong>备注：有些过度绘制都是不可避免的，需要结合具体的布局场景具体分析。</strong></p><h2 id="3-2-Profile-GPU-Rendering"><a href="#3-2-Profile-GPU-Rendering" class="headerlink" title="3.2 Profile GPU Rendering"></a>3.2 Profile GPU Rendering</h2><p><code>设置——&gt;开发者选项——&gt;GPU 呈现模式分析——&gt;条形图</code><br><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/20200416171116.png" alt=""></p><p>如果我们把上面的步骤转化线程模型，可以得到下面的流水线模型。<code>CPU</code> 将数据同步（<code>sync</code>）给 <code>GPU</code> 之后，一般不会阻塞等待<code>GPU</code> 渲染完毕，而是通知结束后就返回。而 <code>RenderThread</code> 承担了比较多的绘制工作，分担了主线程很多压力，提高了 <code>UI</code> 线程的响应速度。<br><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/20200416173431.png" alt=""></p><h2 id="3-3-测量-setContentView-具体耗时"><a href="#3-3-测量-setContentView-具体耗时" class="headerlink" title="3.3 测量 setContentView 具体耗时"></a>3.3 测量 <code>setContentView</code> 具体耗时</h2><h3 id="3-3-1-AOP"><a href="#3-3-1-AOP" class="headerlink" title="3.3.1 AOP"></a>3.3.1 AOP</h3><p>我们可以通过 <code>AOP</code> 将代码切入到 <code>android.app.Activity.setContentView(..)</code> 中。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around(&quot;execution(* android.app.Activity.setContentView(..))&quot;)</span> <span class="comment">//方法切入点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodAnnotated</span><span class="params">(ProceedingJoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">Signature signature = joinPoint.getSignature();</span><br><span class="line">String name = signature.toShortString();</span><br><span class="line"><span class="keyword">long</span> time = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">joinPoint.proceed();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">throwable.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">LogUtils.i(name + <span class="string">&quot; cost &quot;</span> + (System.currentTimeMillis() - time));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-2-Factory2"><a href="#3-3-2-Factory2" class="headerlink" title="3.3.2 Factory2"></a>3.3.2 Factory2</h3><p><code>View</code> 的绘制源码中，在生成我们 <code>xml</code> 所对应的 <code>View</code> 的时候有一个 <code>mFactory2</code> 的判断，我们可以在创建的时候做一些事情。<br><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/20200416180108.png" alt=""></p><p>作用：</p><ol><li>定制生成控件的过程，全局替换，比如将 <code>TextView</code> 替换为 <code>CustomTextView</code>。</li><li>监控控件的生成时间，自己调用系统创建方法并且在方法前后记录时间。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">LayoutInflaterCompat.setFactory2(getLayoutInflater(), <span class="keyword">new</span> LayoutInflater.Factory2() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(View parent, String name, Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (name.equals(<span class="string">&quot;TextView&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">//创建 CustomTextView</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        View view = getDelegate().createView(parent,name,context,attrs);</span><br><span class="line">        LogUtils.i(name + <span class="string">&quot; cost &quot;</span> + (System.currentTimeMillis() - startTime));</span><br><span class="line">        <span class="keyword">return</span> view;<span class="comment">//返回生成后的 View</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(String name, Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="3-4-问题定位-systrace"><a href="#3-4-问题定位-systrace" class="headerlink" title="3.4 问题定位 systrace"></a>3.4 问题定位 systrace</h2><p>在 <code>Android 4.1</code>，新增了 <code>Systrace</code> 性能数据采样和分析工具。在启动优化中，已经用过 Systrace 了，这里也可以用它来检测每一帧的渲染情况。</p><p>结合 Android 内核的数据，生成 HTML 报告，<code>API 18</code> 以上，推荐 <code>TraceCompat</code></p><ul><li><strong>首先清空后台💦</strong></li></ul><p>杀掉所有应用，防止出现莫名莫名方法。</p><ul><li><strong>在需要检测的地方写入代码(可以不写，但是会少一些 tag 提示)💦</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TraceCompat.beginSection(<span class="string">&quot;AppOnCreate&quot;</span>);</span><br><span class="line">...</span><br><span class="line">TraceCompat.endSection();</span><br></pre></td></tr></table></figure><ul><li><strong>执行检测💦</strong></li></ul><p>首先进入 <code>SDK</code> 目录，<code>Sdk\platform-tools\systrace\</code> 目录下有一个 <code>systrace.py</code> 文件，打开 <code>cmd</code> 输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python systrace.py -b 32768 -t 5 -a &lt;packagename&gt; -o test.log.html sched gfx view wm am</span><br></pre></td></tr></table></figure><p>这种方式是 <code>5</code> 秒后自动输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python systrace.py gfx view wm am pm ss dalvik sched -b 32768 -a &lt;packagename&gt; -o test.log.html</span><br></pre></td></tr></table></figure><p>这种方式可以在自己收集完后，点击 <code>Enter</code> 键停止收集</p><p>两种内容是不太一样的， <code>-t</code> 表示时间，<code>-a</code> 表示包名，<code>-o</code> 输出文件名，最终在当前目录打开文件即可看到，文件只能使用 <code>Chrome</code> 来打开，如果打开 <code>HTML</code> 出现 </p><p><code>Unable to select a master clock domain because no path can be found from &quot;SYSTRACE&quot; to &quot;LINUX_FTRACE_GLOBAL&quot;.</code></p><p>那就是命令出错了，命令我也是收集了好久，最终找到可用的，想了解更多的请查看 <a href="http://gityuan.com/2016/01/17/systrace/">Gityuan</a> 或 <a href="https://source.android.com/devices/tech/debug/systrace">官方文档</a> </p><ul><li><p><strong>分析文件</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/20200416163431.png" alt=""></p></li></ul><p>在每个 <code>app</code> 进程，都有一个 <code>Frames</code> 行，正常情况以绿色的圆点表示。当圆点颜色为黄色或者红色时，意味着这一帧超过 <code>16.6ms</code> （即发现丢帧），这时需要通过放大那一帧进一步分析问题。对于 <code>Android 5.0(API level 21)</code> 或者更高的设备，该问题主要聚焦在 <code>UI Thread</code> 和 <code>Render Thread</code> 这两个线程当中。对于更早的版本，则所有工作在 <code>UI Thread</code> 。</p><p>想要了解更多，全力推荐 <a href="https://www.androidperformance.com/2019/05/28/Android-Systrace-About/">Android Systrace</a> </p><ul><li><strong>Alerts</strong></li></ul><p><code>Systrace</code> 能自动分析 <code>trace</code> 中的事件，并能自动高亮性能问题作为一个 <code>Alerts</code> ，建议调试人员下一步该怎么做。</p><p>比如对于丢帧是，点击黄色或红色的 <code>Frames</code> 圆点便会在下方有相关的提示信息；另外，在 <code>systrace</code> 的最右上方，有一个 <code>Alerts tab</code> 可以展开，这里记录着所有的的警告提示信息。</p><p>总的来说，UI 渲染的优化必然会朝着两个方向。一个是进一步压榨硬件的性能，让 UI 可以更加流畅。一个是改进或者增加更多的分析工具，帮助我们更容易地发现以及定位问题。</p><hr><h1 id="4-UI-优化常用手段"><a href="#4-UI-优化常用手段" class="headerlink" title="4 UI 优化常用手段"></a>4 UI 优化常用手段</h1><h2 id="4-1-尽量使用硬件加速"><a href="#4-1-尽量使用硬件加速" class="headerlink" title="4.1 尽量使用硬件加速"></a>4.1 尽量使用硬件加速</h2><p>硬件加速绘制的性能是远远高于软件绘制的。所以说 <code>UI</code> 优化的第一个手段就是保证渲染尽量使用硬件加速。</p><p>有哪些情况我们不能使用硬件加速呢？之所以不能使用硬件加速，是因为硬件加速不能支持所有的 <code>Canvas API</code>。如果使用了不支持的 <code>API</code>，系统就需要通过 <code>CPU</code> 软件模拟绘制，这也是渐变、磨砂、圆角等效果渲染性能比较低的原因。</p><p><code>SVG</code> 也是一个非常典型的例子，<code>SVG</code> 有很多指令硬件加速都不支持。但我们可以用一个取巧的方法，提前将这些 <code>SVG</code> 转换成 <code>Bitmap</code> 缓存起来，这样系统就可以更好地使用硬件加速绘制。</p><h2 id="4-2-Create-View-优化"><a href="#4-2-Create-View-优化" class="headerlink" title="4.2 Create View 优化"></a>4.2 Create View 优化</h2><p><code>View</code> 的创建是在 <code>UI</code> 线程里，对于一些非常复杂的界面，这部分的耗时不容忽视。</p><h3 id="4-2-1-使用代码创建"><a href="#4-2-1-使用代码创建" class="headerlink" title="4.2.1 使用代码创建"></a>4.2.1 使用代码创建</h3><p>使用 <code>XML</code> 进行 <code>UI</code> 编写可以说是十分方便，可以在 <code>Android Studio</code> 中实时预览到界面。如果我们要对一个界面进行极致优化，就可以使用代码进行编写界面。</p><p>但是这种方式对开发效率来说简直是灾难，因此我们可以使用一些开源的 <code>XML</code> 转换为 <code>Java</code> 代码的工具，例如 <a href="https://github.com/iReaderAndroid/X2C">X2C</a> 。但坦白说，还是有不少情况是不支持直接转换的，有时候需要修改源码。</p><p>所以我们需要兼容性能与开发效率，我建议只在对性能要求非常高，但修改又不非常频繁的场景才使用这个方式。</p><h3 id="4-2-2-异步创建"><a href="#4-2-2-异步创建" class="headerlink" title="4.2.2 异步创建"></a>4.2.2 异步创建</h3><p>之前在 <a href="http://localhost:4000/2019/start-optimization.html">启动优化</a> 中提到的参考文章 <a href="https://juejin.im/post/5d63cdf7f265da03ed195f68?utm_source=gold_browser_extension#comment">Android - 一种新奇的冷启动速度优化思路(Fragment极度懒加载 + Layout子线程预加载)</a> </p><p>遇到个点，如果 <code>xml</code> 中是 <code>com.google.android.material.appbar.AppBarLayout</code> 等 <code>google</code> 包里的，需要加上一条属性</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:theme=&quot;@style/Theme.AppCompat.Light.DarkActionBar&quot;</span><br></pre></td></tr></table></figure><p>这个属性与自己 <code>Activity</code> 的 <code>theme</code> 相对应。</p><p>即刻时间中还提到一个错误 ：<code>java.lang.RuntimeException: Can&#39;t create handler inside thread that has not called Looper.prepare() at android.os.Handler.(Handler.java:121)</code> </p><p>这个问题在异步初始化 <code>WebView</code> 是有出现过。</p><p>解决办法：通过又一个非常取巧的方式来实现。在使用线程创建 UI 的时候，先把线程的 Looper 的 MessageQueue 替换成 UI 线程 Looper 的 Queue。<br><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/20200417114544.png" alt=""></p><p>不过需要注意的是，在创建完 View 后我们需要把线程的 Looper 恢复成原来的。</p><blockquote><p>x5WebView 中异步调用会报错，还在研究中。。。</p></blockquote><h2 id="4-3-measure-layout-优化"><a href="#4-3-measure-layout-优化" class="headerlink" title="4.3. measure/layout 优化"></a>4.3. measure/layout 优化</h2><p>渲染流程中 <code>measure</code> 和 <code>layout</code> 也是需要 <code>CPU</code> 在主线程执行的，对于这块内容网上有很多优化的文章，一般的常规方法有：</p><ul><li><strong>减少 UI 布局层次</strong>。例如尽量扁平化，使用 等优化。</li><li><strong>优化 layout 的开销</strong>。尽量不使用 <code>RelativeLayout</code> 或者基于 <code>weighted LinearLayout</code>，它们 layout 的开销非常巨大。这里我推荐使用 <code>ConstraintLayout</code> 替代 <code>RelativeLayout</code> 或者 <code>weighted LinearLayout</code>。</li><li><strong>背景优化</strong>。尽量不要重复去设置背景，这里需要注意的是主题背景（<code>theme</code>)， <code>theme</code> 默认会是一个纯色背景，如果我们自定义了界面的背景，那么主题的背景我们来说是无用的。但是由于主题背景是设置在 <code>DecorView</code> 中，所以这里会带来重复绘制，也会带来绘制性能损耗。</li></ul><p>对于 <code>measure</code> 和 <code>layout</code>，我们可以像 <code>Create View</code> 一样实现异步创建，这样可以大大地提升首次显示的性能。</p><p><code>Textview</code> 是系统控件中非常强大也非常重要的一个控件，强大的背后就代表着需要做很多计算。在 <code>2018</code> 年的 <code>Google I/O</code> 大会，发布了 <code>PrecomputedText</code> 并已经集成在 <code>Jetpack</code> 中，它给我们提供了接口，可以异步进行 <code>measure</code> 和 <code>layout</code>，不必在主线程中执行。</p><p><strong>PrecomputedText</strong></p><p>在 <code>xml</code> 布局中使用 <code>AppCompatTextView</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">androidx.appcompat.widget.AppCompatTextView</span></span></span><br></pre></td></tr></table></figure><p>赋值的时候</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;PrecomputedTextCompat&gt; future = PrecomputedTextCompat.getTextFuture(</span><br><span class="line">                <span class="string">&quot;content xxx&quot;</span>, mTextView.getTextMetricsParamsCompat(), <span class="keyword">null</span>);</span><br><span class="line"> </span><br><span class="line">mTextView.setTextFuture(future);</span><br></pre></td></tr></table></figure><p>如果使用 <code>kotlin</code> ，那么利用拓展方法会更加酸爽。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> AppCompatTextView.<span class="title">setTextFuture</span><span class="params">(charSequence: <span class="type">CharSequence</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.setTextFuture(PrecomputedTextCompat.getTextFuture(</span><br><span class="line">            charSequence,</span><br><span class="line">            TextViewCompat.getTextMetricsParams(<span class="keyword">this</span>),</span><br><span class="line">            <span class="literal">null</span></span><br><span class="line">    ))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">textView.setTextFuture(“text”)</span><br></pre></td></tr></table></figure><h2 id="4-4-其他"><a href="#4-4-其他" class="headerlink" title="4.4 其他"></a>4.4 其他</h2><h3 id="4-4-1-Litho：异步布局"><a href="#4-4-1-Litho：异步布局" class="headerlink" title="4.4.1 Litho：异步布局"></a>4.4.1 Litho：异步布局</h3><p><a href="https://github.com/facebook/litho">Litho</a> 是 <code>Facebook</code> 开源的声明式 <code>Android UI</code> 渲染框架，它是基于另外一个 <code>Facebook</code> 开源的布局引擎 <a href="https://github.com/facebook/yoga">Yoga</a> 开发的。</p><p><code>Litho 如何优化的</code></p><ol><li><p><strong>异步布局</strong></p><p>一般来说的 Android 所有的控件绘制都要遵守 measure -&gt; layout -&gt; draw 的流水线，并且这些都发生在主线程中。<br><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/20200417165148.png" alt=""></p></li></ol><p>   <code>Litho</code> 如我前面提到的 <code>PrecomputedText</code> 一样，把 <code>measure</code> 和 <code>layout</code> 都放到了后台线程，只留下了必须要在主线程完成的 <code>draw</code>，这大大降低了 <code>UI</code> 线程的负载。它的渲染流水线如下：<br>   <img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/20200417165357.png" alt=""></p><ol start="2"><li><p><strong>界面扁平化</strong></p><p>前面也提到过，降低 <code>UI</code> 的层级是一个非常通用的优化方法。<code>Litho</code> 就给了我们一种方案，由于 <code>Litho</code> 使用了自有的布局引擎（<code>Yoga</code>)，在布局阶段就可以检测不必要的层级、减少 <code>ViewGroups</code>，来实现 <code>UI</code> 扁平化。</p></li><li><p><strong>优化 RecyclerView</strong></p><p><code>Litho</code> 还优化了 <code>RecyclerView</code> 中 <code>UI</code>组件的缓存和回收方法。原生的 <code>RecyclerView</code> 或者 <code>ListView</code> 是按照 <code>viewType</code> 来进行缓存和回收，但如果一个<code>RecyclerView/ListView</code> 中出现 <code>viewType</code> 过多，会使缓存形同虚设。但 <code>Litho</code> 是按照 <code>text</code>、<code>image</code> 和 <code>video</code> 独立回收的，这可以提高缓存命中率、降低内存使用率、提高滚动帧率。</p><p><code>Litho</code> 虽然强大，但也有自己的缺点。它为了实现 <code>measure/layout</code> 异步化，使用了类似 <code>react</code> 单向数据流设计，这一定程度上加大了 <code>UI</code> 开发的复杂性。并且 <code>Litho</code> 的 <code>UI</code>代码是使用 <code>Java/Kotlin</code> 来进行编写，无法做到在 <code>AS</code> 中预览。如果你没有计划完全迁移到 <code>Litho</code>，我建议可以优先使用 <code>Litho</code> 中的 <code>RecyclerCollectionComponent</code> 和 <code>Sections</code> 来优化自己的 <code>RecyelerView</code> 的性能。</p></li></ol><h3 id="4-4-2-Flutter：自己的布局-渲染引擎"><a href="#4-4-2-Flutter：自己的布局-渲染引擎" class="headerlink" title="4.4.2 Flutter：自己的布局 + 渲染引擎"></a>4.4.2 <strong>Flutter：自己的布局 + 渲染引擎</strong></h3><p>如下图所示，<code>Litho</code> 虽然通过使用自己的布局引擎 <code>Yoga</code>，一定程度上突破了系统的一些限制，但是在 <code>draw</code> 之后依然走的系统的渲染机制。</p><p><a href="https://github.com/flutter/flutter">Flutter</a> 把 <code>Skia</code> 引擎直接集成进了 <code>App</code> 中，这使得 <code>Flutter App</code> 就像一个游戏 <code>App</code>。并且直接使用了 <code>Dart</code> 虚拟机，可以说是一套跳脱出 <code>Android</code> 的方案，所以 <code>Flutter</code> 也可以很容易实现跨平台。</p><p><a href="https://tech.meituan.com/2018/08/09/waimai-flutter-practice.html">《Flutter 原理与实践》</a></p><h3 id="4-4-3-RenderThread-与-RenderScript"><a href="#4-4-3-RenderThread-与-RenderScript" class="headerlink" title="4.4.3 RenderThread 与 RenderScript"></a>4.4.3 RenderThread 与 RenderScript</h3><p>在 <code>Android 5.0</code>，系统增加了 <code>RenderThread</code>，对于 <code>ViewPropertyAnimator</code> 和 <code>CircularReveal</code> 动画，我们可以使用 <a href="https://mp.weixin.qq.com/s?__biz=MzUyMDAxMjQ3Ng==&mid=2247489230&idx=1&sn=adc193e35903ab90a4c966059933a35a&source=41#wechat_redirect">RenderThead 实现动画的异步渲染</a>。当主线程阻塞的时候，普通动画会出现明显的丢帧卡顿，而使用 <code>RenderThread</code> 渲染的动画即使阻塞了主线程仍不受影响。</p><p>我们可以通过 <code>RenderScript</code>，它是 <code>Android</code> 操作系统上的一套 <code>API</code>。它基于异构计算思想，专门用于密集型计算。<code>RenderScript</code> 提供了三个基本工具：一个硬件无关的通用计算 <code>API</code>；一个类似于 <code>CUDA</code>、<code>OpenCL</code> 和 <code>GLSL</code> 的计算 <code>API</code>；一个类 <code>C99</code> 的脚本语言。允许开发者以较少的代码实现功能复杂且性能优越的应用程序。</p><ul><li><a href="https://www.jianshu.com/p/b72da42e1463">RenderScript 渲染利器</a></li><li><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2016/0504/4205.html?utm_source=itdadao&utm_medium=referral">RenderScript : 简单而快速的图像处理</a></li><li>…</li></ul><hr><h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h1><ol><li><strong>在系统的框架下优化。</strong>布局优化、使用代码创建、<code>View</code> 缓存等都是这个思路，我们希望减少甚至省下渲染流水线里某个阶段的耗时。</li><li><strong>利用系统新的特性。</strong>使用硬件加速、<code>RenderThread</code>、<code>RenderScript</code> 都是这个思路，通过系统一些新的特性，最大限度压榨出性能。</li><li><strong>突破系统的限制。</strong>由于 <code>Android</code> 系统碎片化非常严重，很多好的特性可能低版本系统并不支持。而且系统需要支持所有的场景，在一些特定场景下它无法实现最优解。这个时候，我们希望可以突破系统的条条框框，例如 <code>Litho</code> 突破了布局，<code>Flutter</code> 则更进一步，把渲染也接管过来了。</li></ol><p>对于 <code>UI</code> 优化的另一个思考是效率，目前 <code>Android Studio</code> 对设计并不友好，例如不支持 <code>Sketch</code> 插件和 <code>AE</code> 插件。<a href="https://github.com/airbnb/lottie-android">Lottie</a> 是一个非常好的案例，它很大提升了开发人员写动画的效率。</p><blockquote><p>“设计师和产品，你们长大了，要学会自己写 UI 了”。在未来，我们希望 UI 界面与适配可以实现自动化，或者干脆把它交还给设计师和产品。</p></blockquote><h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a><strong>感谢</strong></h1><blockquote><p><a href="https://time.geekbang.org/column/article/74044">极客时间 Android开发高手课</a>  </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>App 内存检测优化💦</title>
      <link href="2020/memory-optimization2.html"/>
      <url>2020/memory-optimization2.html</url>
      
        <content type="html"><![CDATA[<p>🌞一个好的架构可以减少甚至避免我们犯错，而一个好的监控可以帮助我们及时发现问题🌞内存优化的重点在于监控，和平时代码规范。这篇文章带你了解监控工具 Memory Profiler、MAT、LeakCanary 的使用以及分析。</p><h1 id="本文主要记载"><a href="#本文主要记载" class="headerlink" title="本文主要记载"></a>本文主要记载</h1><ul><li><strong>1 什么是 Memory Profiler？</strong><ul><li>1.1 使用介绍<ul><li>1.1.1 启用高级分析</li><li>1.1.2 计算内存(每个内存类别当前使用多少内存)</li><li>1.1.3 查看内存分配(分配的对象数)</li><li>1.1.4 在分析时提高应用性能</li><li>1.1.5 捕获堆转储</li><li>1.1.6 将堆转储另存为 HPROF 文件</li></ul></li></ul></li><li><strong>2 什么是 MAT？</strong><ul><li>2.1 使用前提</li><li>2.2 使用介绍</li></ul></li><li><strong>3 什么是 LeakCanary？</strong><ul><li>3.1 LeakCanary 原理</li><li>3.2 LeakCanary 使用</li></ul></li><li><strong>4 自定义实现 Demo</strong><ul><li>4.1 自动化监测 Demo</li><li>4.2 重复图片监测 Demo</li></ul></li><li><strong>5 优化思路</strong><ul><li>5.1 设备分级</li><li>5.2 Bitmap 优化</li></ul></li><li><strong>6 更多</strong></li></ul><hr><blockquote><p>一个好的架构可以减少甚至避免我们犯错，而一个好的监控可以帮助我们及时发现问题。</p></blockquote><p>检测工具常见的有 <code>Memory Profiler</code> <code>MAT</code> <code>LeakCanary</code></p><h1 id="1-什么是-Memory-Profiler"><a href="#1-什么是-Memory-Profiler" class="headerlink" title="1  什么是 Memory Profiler?"></a>1  什么是 Memory Profiler?</h1><p><code>Profiler</code> 是 <code>Android Studio</code> 为我们提供的性能分析工具，它包含了 <code>CPU</code>、<code>内存</code>、<code>网络</code>以及 <code>电量</code> 的分析信息，而 <code>Memory Profiler</code> 则是 <code>Profiler</code> 中的其中一个版块。</p><p>打开 <code>Profiler</code>  方式</p><ol><li>View &gt; Tool Windows &gt; Android Profiler</li><li>下方的 Profiler 标签</li><li>双击 shift 搜索 profiler</li></ol><h2 id="1-1-使用介绍"><a href="#1-1-使用介绍" class="headerlink" title="1.1 使用介绍"></a>1.1 使用介绍</h2><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/20200413144637.png" alt=""></p><ol><li><p>用于强制执行垃圾回收事件的按钮（强制 <code>GC</code> ）。</p></li><li><p>用于 <code>1.1.5 捕获堆转储</code> 的按钮。</p><p><strong>注意</strong>：只有在连接到搭载 <code>Android 7.1</code>（<code>API</code> 级别 25）或更低版本的设备时，才会在堆转储按钮右侧显示用于 <code>记录内存分配</code> 的按钮。</p></li><li><p>用于指定分析器多久捕获一次内存分配的下拉菜单。选择适当的选项可 <code>1.1.4 在分析时提高应用性能</code>。</p></li><li><p>用于缩放时间轴的按钮。</p></li><li><p>用于跳转到实时内存数据的按钮。</p></li><li><p>事件时间轴，显示活动状态、用户输入事件和屏幕旋转事件。</p></li><li><p>内存使用量时间轴，它会显示以下内容：</p><ul><li>一个堆叠图表，显示 <code>1.1.2 每个内存类别当前使用多少内存</code> ，如左侧的 y 轴以及顶部的彩色键所示。</li><li>一条虚线，表示 <code>1.1.3 分配的对象数</code>，如右侧的 y 轴所示。</li><li>每个垃圾回收事件的图标。</li></ul></li></ol><p>如果使用的是搭载 Android 7.1 或更低版本的设备，则并非所有分析数据在默认情况下都可见。如果看到一条消息，显示“Advanced profiling is unavailable for the selected process”，需要 <code>1.1.1 启用高级分析</code> 才能看到以下内容：</p><ul><li>事件时间轴</li><li>分配的对象数</li><li>垃圾回收事件</li></ul><p>在 Android 8.0 及更高版本上，始终为可调试应用启用高级分析。</p><h3 id="1-1-1-启用高级分析"><a href="#1-1-1-启用高级分析" class="headerlink" title="1.1.1  启用高级分析"></a>1.1.1  启用高级分析</h3><ol><li>依次选择 <strong>Run &gt; Edit Configurations</strong>。</li><li>在左侧窗格中选择本应用模块。</li><li>点击 <strong>Profiling</strong> 标签，然后勾选 <strong>Enable advanced profiling</strong>。</li><li>重新编译并运行应用。</li></ol><h3 id="1-1-2-计算内存-每个内存类别当前使用多少内存"><a href="#1-1-2-计算内存-每个内存类别当前使用多少内存" class="headerlink" title="1.1.2 计算内存(每个内存类别当前使用多少内存)"></a>1.1.2 计算内存(每个内存类别当前使用多少内存)</h3><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/20200414112438.png" alt=""></p><p>内存计数中的类别如下：</p><ul><li><p><strong>Java</strong>：从 <code>Java</code> 或 <code>Kotlin</code> 代码分配的对象的内存。</p></li><li><p><strong>Native</strong>：从 <code>C</code> 或 <code>C++</code> 代码分配的对象的内存。</p><p>即使应用中不使用 <code>C++</code>，也可能会看到此处使用的一些原生内存，因为 <code>Android</code> 框架使用原生内存处理各种任务，如处理图像资源和其他图形时。</p></li><li><p><strong>Graphics</strong>：图形缓冲区队列向屏幕显示像素（包括 <code>GL</code> 表面、<code>GL</code> 纹理等等）所使用的内存。（请注意，这是与 <code>CPU</code> 共享的内存，不是 <code>GPU</code> 专用内存。）</p></li><li><p><strong>Stack</strong>：应用中的原生堆栈和 <code>Java</code> 堆栈使用的内存。这通常与应用运行多少线程有关。</p></li><li><p><strong>Code</strong>：应用用于处理代码和资源（如 <code>dex</code> 字节码、经过优化或编译的 <code>dex</code> 代码、<code>.so</code> 库和字体）的内存。</p></li><li><p><strong>Others</strong>：应用使用的系统不确定如何分类的内存。</p></li><li><p><strong>Allocated</strong>：应用分配的 <code>Java/Kotlin</code> 对象数。此数字没有计入 C 或 C++ 中分配的对象。</p><p>如果连接到搭载 <code>Android 7.1</code> 及更低版本的设备，只有在 <code>Memory Profiler</code> 连接到运行的应用时，才开始此分配计数。因此，开始分析之前分配的任何对象都不会被计入。不过，<code>Android 8.0</code> 及更高版本附带一个设备内置分析工具，该工具可跟踪所有分配，因此，在 <code>Android 8.0</code> 及更高版本上，此数字始终表示应用中待处理的 Java 对象总数。</p></li></ul><p><strong>注意：</strong>高级分析配置会使编译过程变慢，所以仅在想要开始分析应用时，才应启用该配置。</p><h3 id="1-1-3-查看内存分配-分配的对象数"><a href="#1-1-3-查看内存分配-分配的对象数" class="headerlink" title="1.1.3 查看内存分配(分配的对象数)"></a>1.1.3 查看内存分配(分配的对象数)</h3><p>对于 <code>Android 8.0</code> 及更高版本，选择一个现有时间轴区域以查看对象分配</p><p>对于 <code>Android 7.1</code> 及更低版本，必须明确记录内存分配，点击 <code>Memory Profiler</code> 工具栏中的 <code>Record memory allocations</code> 图标或者 一个 <code>Record</code> 的按钮。记录时，<code>Memory Profiler</code> 会跟踪应用中发生的所有分配。完成后，请点击 <code>Stop recording</code> 图标或者一个 <code>Stop</code> 的按钮，查看分配。</p><p><strong>注意</strong>：在 <code>Android 7.1</code> 及更低版本上，最多可以记录 <code>65535</code> 个分配。 如果记录会话超出此限制，则记录中仅保存最新的 <code>65535</code> 个分配。（在 <code>Android 8.0</code> 及更高版本上，则没有实际的限制。）<br><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/20200414135710.png" alt=""></p><ol><li>浏览列表以查找堆计数异常大且可能存在泄露的对象。为帮助查找已知类，点击 <code>Class Name</code> 列标题以按字母顺序排序。然后，点击一个类名称。此时右侧将出现 <code>Instance View</code> 窗格，显示该类的每个实例。</li><li>在 <code>Instance View</code> 窗格中，点击一个实例。此时下方将出现 <code>Call Stack</code> 标签页，显示该实例被分配到何处以及在哪个线程中。</li><li>在 <code>Call Stack</code> 标签页中，右键点击任意行并选择 <code>Jump to Source</code>，以在编辑器中打开该代码。</li></ol><p><code>Live Allocation</code> 第一个选择框是选择要检查的堆：</p><ul><li><strong>default heap</strong>：当系统未指定堆时。</li><li><strong>image heap</strong>：系统启动映像，包含启动期间预加载的类。此处的分配保证绝不会移动或消失。</li><li><strong>zygote heap</strong>：写时复制堆，其中的应用进程是从 <code>Android</code> 系统中派生的。</li><li><strong>app heap</strong>：您的应用在其中分配内存的主堆。</li><li><strong>JNI heap</strong>：显示 Java 原生接口 (<code>JNI</code>) 引用被分配和释放到什么位置的堆。</li></ul><p>第二个选择框选择如何安排分配：</p><ul><li><strong>Arrange by class</strong>：根据类名称对所有分配进行分组。这是默认选项。</li><li><strong>Arrange by package</strong>：根据软件包名称对所有分配进行分组。</li><li><strong>Arrange by callstack</strong>：将所有分配分组到其对应的调用堆栈。只有在记录分配期间 <code>捕获堆转储</code> 时，此选项才有效。即便如此，堆中也很可能有在开始记录之前分配的对象，所以会先显示这些分配，直接按类名称列出它们。</li></ul><h3 id="1-1-4-在分析时提高应用性能"><a href="#1-1-4-在分析时提高应用性能" class="headerlink" title="1.1.4 在分析时提高应用性能"></a>1.1.4 在分析时提高应用性能</h3><p>为了在分析时提高应用性能，<code>Memory Profiler</code> 在默认情况下会定期对内存分配进行采样。在运行 <code>API</code> 级别 <code>26</code> 或更高级别的设备上进行测试时，可以使用 <code>Allocation Tracking</code> 下拉菜单来更改此行为。可用选项如下：</p><ul><li><strong>Full</strong>：捕获内存中的所有对象分配。这是 <code>Android Studio 3.2</code> 及更低版本中的默认行为。如果您有一个分配了大量对象的应用，则可能会在分析时观察到应用的运行速度明显减慢。</li><li><strong>Sampled</strong>：定期对内存中的对象分配进行采样。这是默认选项，在分析时对应用性能的影响较小。在短时间内分配大量对象的应用仍可能会表现出明显的速度减慢。</li><li><strong>Off</strong>：停止跟踪应用的内存分配。</li></ul><h3 id="1-1-5-捕获堆转储"><a href="#1-1-5-捕获堆转储" class="headerlink" title="1.1.5 捕获堆转储"></a>1.1.5 捕获堆转储</h3><p>堆转储显示在捕获堆转储时应用中哪些对象正在使用内存。特别是在长时间的用户会话后，堆转储会显示认为不应再位于内存中却仍在内存中的对象，从而帮助识别内存泄露。<br><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/20200414161957.png" alt=""></p><p>要捕获堆转储，请点击 Memory Profiler 工具栏中的 <strong>Dump Java heap</strong> 图标 <img src= "/img/loading.gif" data-lazy-src="https://developer.android.google.cn/studio/images/buttons/profiler-heap-dump.png" style="zoom:70%">  在转储堆期间，Java 内存量可能会暂时增加。 这很正常，因为堆转储与您的应用发生在同一进程中，并需要一些内存来收集数据。</p><ul><li><p><strong>Allocations</strong>：堆中的分配数。</p></li><li><p><strong>Native Size</strong>：此对象类型使用的原生内存总量（以字节为单位）。只有在使用 <code>Android 7.0</code> 及更高版本时，才会看到此列。</p><p>您会在此处看到采用 <code>Java</code> 分配的某些对象的内存，因为 <code>Android</code> 对某些框架类（如 <code>Bitmap</code>）使用原生内存。</p></li><li><p><strong>Shallow Size</strong>：此对象类型使用的 Java 内存总量（以字节为单位）。</p></li><li><p><strong>Retained Size</strong>：为此类的所有实例而保留的内存总大小（以字节为单位）。</p></li></ul><p>点击一个类名称可在右侧打开 <strong>Instance View</strong> 窗口。</p><ul><li><strong>Depth</strong>：从任意 <code>GC</code> 根到选定实例的最短跳数。</li><li><strong>Native Size</strong>：原生内存中此实例的大小。 只有在使用 Android 7.0 及更高版本时，才会看到此列。</li><li><strong>Shallow Size</strong>：<code>Java</code> 内存中此实例的大小。</li><li><strong>Retained Size</strong>：此实例所支配内存的大小。</li></ul><p>如果你 <code>ClassName</code> 选中的是 <code>Bitmap</code> ,在 <code>7.1</code> 及以下版本的设备中 <code>Call Sack</code>位置会出现 <code>Bitmap Preview</code> 功能，来预览是哪张图片</p><p><code>References</code> 标签页，显示对该对象的每个引用，如果发现某个引用可能在泄露内存，右键点击它并选择 <code>Go to Instance</code>。这样会从堆转储中选择相应的实例，从而显示它自己的实例数据。</p><h3 id="1-1-6-将堆转储另存为-HPROF-文件"><a href="#1-1-6-将堆转储另存为-HPROF-文件" class="headerlink" title="1.1.6 将堆转储另存为 HPROF 文件"></a>1.1.6 将堆转储另存为 HPROF 文件</h3><p>在 Android Studio 3.1 及更低版本中，<code>Export capture to file</code> 按钮 <img src= "/img/loading.gif" data-lazy-src="https://developer.android.google.cn/studio/images/buttons/profiler-export-hprof.png" alt="img"> 位于时间轴下方工具栏的左侧</p><p>在 Android Studio 3.2 及更高版本中，<code>Sessions</code> 窗格中每个 <code>Heap Dump</code>条目的右侧都有一个 <code>Export Heap Dump</code> 按钮。在随即显示的 <code>Export As</code> 对话框中，使用 <code>.hprof</code>  文件扩展名保存文件。</p><hr><h1 id="2-什么是-MAT"><a href="#2-什么是-MAT" class="headerlink" title="2 什么是 MAT?"></a>2 什么是 MAT?</h1><p>对于内存泄漏问题，Memory Profiler 只能给我们提供一个简单的分析，不能够帮我们确认具体发生问题的地方。</p><p>而 MAT 就可以帮我们做到这一点，MAT 的全称是 Memory Analyzer Tool，它是一款功能强大的 Java 堆内存分析工具，可以用于查找内存泄漏以及查看内存消耗情况。</p><h2 id="2-1-使用前提"><a href="#2-1-使用前提" class="headerlink" title="2.1 使用前提"></a>2.1 使用前提</h2><ol><li><p>到 MAT 的官网 <a href="https://www.eclipse.org/mat/downloads.php">下载 MAT</a>。</p></li><li><p>使用 <code>Memory Profiler</code> 的堆转储功能，导出 <code>hprof（Heap Profile）</code>文件。</p></li><li><p>配置 <code>platform-tools</code> 环境变量</p></li><li><p>使用命令将 <code>Memory Profiler</code> 中导出来的 <code>hprof</code> 文件转换为 MAT 可以解析的 hprof 文件，命令如下</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hprof-conv ..&#x2F;原始文件.hprof ..&#x2F;输出文件.hprof</span><br></pre></td></tr></table></figure><ol start="5"><li>打开 MAT</li></ol><p><code>File &gt; open Heap dump</code> ，选择我们转换后的文件</p><h2 id="2-2-使用介绍"><a href="#2-2-使用介绍" class="headerlink" title="2.2 使用介绍"></a>2.2 使用介绍</h2><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/20200414173426.png" alt=""></p><ul><li><p><strong>Overview</strong>：概览信息</p><ul><li><strong>Unreachable Objects Histogram</strong>：可被回收的对象，但是仍在内存当中</li></ul></li><li><p><strong>Histogram</strong>：直方图，基于类来分析，会显示该类有多少个实例</p><p>第一行输入可以搜索，<code>Tool Bar</code> 中会多出一个 <code>Group by...</code>  选择 <code>package</code> 会变成已报名的形式来进行分类。</p><ul><li><strong>Object</strong>：有多少实例</li><li><strong>Shallow Heap</strong>：自己占了多少内存</li><li><strong>Retained Heap</strong>：应用链总共占了多少内存</li><li>选择一个类条目右键会出现 <code>List objects</code><ul><li><strong>with outgoing references</strong>：引用了些什么</li><li><strong>with incoming references</strong>：被谁引用着</li></ul></li></ul></li><li><p><strong>dominator_tree</strong>：基于实例来分析，会显示具体的实例是哪个</p><p>第一行输入可以搜索，<code>Tool Bar</code> 中会多出一个 <code>Group by...</code>  选择 <code>package</code> 会变成已报名的形式来进行分类。</p><ul><li><strong>Percentage</strong>：当前所有对象中，此对象内存占用百分比，可以发现那些内存占用过大的对象</li><li>右键点击会出现 <code>List objects</code> ，会显示出具体事例</li></ul></li><li><p><strong>OQL</strong>：对象查询语言</p><ul><li>例如 <code>slect * from com.package.Activity</code> ，会查询出该类所有的实例</li></ul></li><li><p><strong>thread_overview</strong>：<code>dump</code> 内存这个时刻的所有线程</p></li><li><p><strong>top_consumers</strong>：用图形列出占用内存比较大的实例</p><ul><li><strong>Biggest Objects</strong>：详细信息，点击出现 <code>List objects</code></li></ul></li><li><p><strong>Leak Suspects</strong>：更详细的分析，可以从这里找到可以的泄漏点</p><ul><li><strong>Probleam Suspect (x)</strong> ：点击 <code>Details</code> 会出现可疑的 引用链，找到泄漏点</li></ul></li></ul><hr><h1 id="3-什么是-LeakCanary？"><a href="#3-什么是-LeakCanary？" class="headerlink" title="3 什么是 LeakCanary？"></a>3 什么是 LeakCanary？</h1><p>如果使用 MAT 来分析内存问题，会有一些难度，而且效率也不是很高。</p><p>为了能迅速发现内存泄漏，Square 公司基于 MAT 开源了 <a href="https://square.github.io/leakcanary">LeakCanary</a>。</p><p><code>LeakCanary</code> 是一个内存泄漏检测框架。</p><h2 id="3-1-LeakCanary-原理"><a href="#3-1-LeakCanary-原理" class="headerlink" title="3.1 LeakCanary 原理"></a>3.1 LeakCanary 原理</h2><ol><li><p><strong>检测保留的实例</strong></p><p><code>LeakCanary</code> 是基于 <code>LeakSentry</code> 开发的，<code>LeakSentry</code> 会 <code>hook Android</code> 生命周期，自动检测当 <code>Activity</code> 或 <code>Fragment</code> 被销毁时，它们的实例是否被回收了。</p><p>销毁的实例会传给 <code>RefWatcher</code>，<code>RefWatcher</code> 会持有它们的弱引用。</p><p>你也可以观察所有不再需要的实例，比如一个不再使用的 <code>View</code>，不再使用的 <code>Presenter</code> 等。</p><p>如果等待了 5 秒，并且 <code>GC</code> 触发了之后，弱引用还没有被清理，那么 <code>RefWatcher</code> 观察的实例就可能处于内存泄漏状态了。</p></li><li><p><strong>堆转储</strong></p><p>当保留对象的数量达到阈值时，<code>LeakCanary</code> 将 <code>Java</code> 堆转储到<code>.hprof</code> 存储在 <code>Android</code> 文件系统中的文件中。</p><p>当应用程序可见时，默认的阈值是5个被保留的对象，当应用程序不可见时，默认的阈值是 1 个被保留的对象。如果您看到保留的对象通知，然后将应用程序放在后台(例如通过按Home按钮)，那么阈值将从 5 更改为 1 ，<code>LeakCanary</code> 将在 5 秒内转储堆。点击通知将迫使<code>LeakCanary</code> 立即转储堆。</p></li><li><p><strong>分析堆</strong></p><p><code>LeakCanary</code>  <code>.hprof</code>使用 <a href="https://square.github.io/leakcanary/shark/">Shark</a> 解析文件，并在该堆转储中找到保留的对象。</p><p>对于每个保留的对象，<code>LeakCanary</code> 会找到引用的路径，以防止对该保留的对象进行垃圾回收：其<strong>泄漏跟踪</strong>。泄漏跟踪是<em>从垃圾回收根到保留对象</em>的<em>最佳强引用路径的</em>另一个名称。</p></li><li><p><strong>泄漏分组</strong></p><p>当有两个泄漏分析结果相同时，<code>LeakCanary</code> <strong>为每个泄漏跟踪</strong>创建一个<strong>签名</strong>，并将具有相同签名的泄漏（即，由同一 <code>bug</code> 引起的泄漏）组合在一起，以免重复显示同样的泄漏信息。</p></li></ol><h2 id="3-2-LeakCanary-使用"><a href="#3-2-LeakCanary-使用" class="headerlink" title="3.2 LeakCanary 使用"></a>3.2 LeakCanary 使用</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  debugImplementation <span class="string">&#x27;com.squareup.leakcanary:leakcanary-android:2.2&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>2.2</code> 不需要初始化，如果你添加了</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;android-aspectjx&#x27;</span></span><br></pre></td></tr></table></figure><p>需要在文章添加</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">aspectjx &#123; </span><br><span class="line">    exclude <span class="string">&#x27;com.squareup&#x27;</span> </span><br><span class="line">    exclude <span class="string">&#x27;leakcanary&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>否则会报 <code>Unable to get provider leakcanary.internal.LeakCanaryFileProvider: java.lang.ClassNotFoundException: Didn&#39;t find class &quot;leakcanary.internal.LeakCanaryFileProvider&quot;</code></p><h1 id="4-自定义实现-Demo"><a href="#4-自定义实现-Demo" class="headerlink" title="4 自定义实现 Demo"></a>4 自定义实现 Demo</h1><p><code>Profiler</code> 中使用了 <code>Allocation Tracker</code> 技术，<a href="https://mp.weixin.qq.com/s/b_lFfL1mDrNVKj_VAcA2ZA?">Android内存申请分析</a> 这篇文章讲述了 <code>Allocation Tracker</code> 的使用方式，并且讲解了 <code>Android Studio</code> 是如何使用 <code>Allocation Tracker</code> 的。可以让我们更加熟悉 <code>Android Studio</code> 中 <code>Profiler</code> 各种工具的实现原理后。</p><p>文中提到了 <code>Allocation Tracker</code> 的三个缺点。</p><ul><li>获取的信息过于分散，中间夹杂着不少其他的信息，很多信息不是应用申请的，可能需要进行不少查找才能定位到具体的问题。</li><li>跟 <code>Traceview</code> 一样，无法做到自动化分析，每次都需要开发者手工开始 / 结束，这对于某些问题的分析可能会造成不便，而且对于批量分析来说也比较困难。</li><li>虽然在 <code>Allocation Tracking</code> 的时候，不会对手机本身的运行造成过多的性能影响，但是在停止的时候，直到把数据 <code>dump</code> 出来之前，经常会把手机完全卡死，如果时间过长甚至会直接 <code>ANR</code>。</li></ul><p>因此我们希望可以做到脱离 <code>Android Studio</code>，实现一个自定义的 <code>Allocation Tracker</code>，实现对象内存的自动化分析。通过这个工具可以获取所有对象的申请信息（大小、类型、堆栈等），可以找到一段时间内哪些对象占用了大量的内存。</p><p>我们可以用自定义的 <code>Allocation Tracker</code> 来监控 Java 内存的监控，也可以拓展成实时监控 <code>Java</code> 内存泄漏。不过任何一个工具如果只需要做到线下自动化测试，实现起来会相对简单，但想要移植到线上使用，那就要更加关注兼容性、稳定性和性能。</p><h2 id="4-1-自动化检测Demo"><a href="#4-1-自动化检测Demo" class="headerlink" title="4.1 自动化检测Demo"></a>4.1 自动化检测Demo</h2><p>这是一个自定义 <code>Allocation Tracker</code> 的 <code>Demo</code> <a href="https://github.com/AndroidAdvanceWithGeektime/Chapter03">极客时间 Android 高手课 Chapter03</a></p><blockquote><p>项目使用了 inline hook 来拦截内存对象分配时候的 RecordAllocation 函数，通过拦截该接口可以快速获取到当时分配对象的类名和分配的内存大小。<br>在初始化的时候我们设置了一个分配对象数量的最大值，如果从 start 开始对象分配数量超过最大值就会触发内存 dump，然后清空 alloc 对象列表，重新计算。该功能和 Android Studio 里的 Allocation Tracker 类似，只不过可以在代码级别更细粒度的进行控制。可以精确到方法级别。</p></blockquote><ul><li><code>ndk_dlopen</code> 用来获取动态链接库</li><li><code>ndk_dlsym</code> 通过动态链接库和函数签名拿到函数地址</li><li><code>Substrate</code> <a href="http://www.cydiasubstrate.com/api/c/MSHookFunction/">MSHookFunction</a>  一款经典的 <code>hook</code> 框架，支持 <code>hook C/C++</code> 代码 </li><li><a href="https://github.com/facebookincubator/profilo/tree/master/deps/fbjni">fbjni</a> 是从 <code>Facebook</code> 开源的一款jni工具类库，主要提供了工具类，ref utils ，Global JniEnv。</li><li><code>native-lib</code> 中 <code>JNI_OnLoad</code>  在 <code>System.loadLibrary(&quot;xxx&quot;);</code> 时执行</li></ul><p>代码运行流程：</p><ol><li><p>在 <code>MainActivity</code> 中调用 <code>AllocTracker.initForArt</code> 去初始化，然后通过 <code>ndk_dlopen</code> 和<code>ndk_dlsym</code> 拿到所有需要的函数，只是拿到函数并没有调用</p></li><li><p><code>JNI_OnLoad</code> 调用 <code>hookFunc();</code>这个方法就是真正的把系统的 <code>tracking</code> 函数 <code>hook</code> 住的地方</p><ol><li>通过 <code>ndk_dlsym</code> 拿到函数地址。</li><li>通过 <code>MSHookFunction</code> 把 <code>newArtRecordAllocation26</code> <code>hook</code> 进原函数地址里，同时拿到旧函数的实现并导向 <code>oldArtRecordAllocation26</code> 。这样做可以保留旧函数。</li><li>在新函数中有一句 <code>allocObjectCount &gt; setAllocRecordMax</code> ，当分配对象数量大于初始化时设置的最大值，就把数据保存在 <code>log</code> 文件中。</li></ol></li></ol><p><code>C/C++</code> 的 <code>hook</code> 和 <code>java</code> 反射一样，如果系统在新版本把函数名，或者函数签名改了那就无法使用了，所以在文件中出现了很多版本适配的地方。</p><p><code>Logcat</code> 中 <code>saveARTAllocationData write file to XXXX</code> 能找到对应的日志文件路径</p><p>看不到日志的输出情况，每个人设备内存情况不一样，<code>GC</code> 回收的频率也不一致，在你不停生产对象的时候，<code>GC</code> 不断的跟随回收，导致无法达到设置的最大的数据量，所以一直没有日志的写入。</p><p><strong>总结：</strong></p><p>这个 <code>Demo</code>  主要学习了 <code>Substrate</code> <a href="https://github.com/facebookincubator/profilo/tree/master/deps/fbjni">fbjni</a> <code>ndk_dlopen</code> 这几个库的简单使用，<code>CmakeList</code>  的很多写法，以及 <code>native</code> 函数简写</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JNI_METHOD_DECL(ret_type, method_name) \</span></span><br><span class="line">     <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> JNIEXPORT ret_type JNICALL Java_##com_dodola_alloctrack##_##AllocTracker##_##method_name</span><br></pre></td></tr></table></figure><p>还了解了一些 <code>hook</code> 点以及 <code>hook</code> 方法。</p><h2 id="4-2-重复图片检测Demo"><a href="#4-2-重复图片检测Demo" class="headerlink" title="4.2 重复图片检测Demo"></a>4.2 重复图片检测Demo</h2><p><a href="https://github.com/simplezhli/Chapter04">极客时间 Android 高手课 Chapter04</a> 已完成的 <code>Demo</code> </p><blockquote><p>通过分析内存文件 hprof 快速判断内存中是否存在重复的图片，并且将这些重复图片的 PNG 、堆栈等信息输出。</p><p><strong>需要注意的是需要使用8.0以下的机器，因为8.0以后Bitmap中的buffer已经放到native内存中了</strong></p></blockquote><p>代码在开始加载了两张相同的图片。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Bitmap bitmap1 = BitmapFactory.decodeResource(getResources(), R.mipmap.test); </span><br><span class="line">Bitmap bitmap2 = BitmapFactory.decodeResource(getResources(), R.mipmap.test);</span><br><span class="line">imageView1.setImageBitmap(bitmap1); </span><br><span class="line">imageView2.setImageBitmap(bitmap2);</span><br></pre></td></tr></table></figure><p>然后手动 <code>GC</code> 生成 <code>hprof</code> 文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手动触发GC</span></span><br><span class="line">Runtime.getRuntime().gc();</span><br><span class="line">System.runFinalization();</span><br><span class="line"><span class="comment">// 生成Hprof文件</span></span><br><span class="line">Debug.dumpHprofData(file.getAbsolutePath());</span><br></pre></td></tr></table></figure><p>接下来在<code>DuplicatedBitmapAnalyzer</code> 的一个 <code>java</code> 项目里，利用 <a href="https://github.com/square/haha">HAHA</a> 库进行文件分析，并输入重复图片。</p><p>作者已经将代码打成 <code>JAR</code> 包，可以直接调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar tools&#x2F;DuplicatedBitmapAnalyzer-1.0.jar hprof文件路径</span><br></pre></td></tr></table></figure><p>对于更多的信息，可以参看 <a href="https://github.com/square/leakcanary">LeakCanary</a> 源码</p><p><strong>总结：</strong></p><p>这个 <code>Demo</code> 主要学到了如何主动生成 <code>hprof</code> 文件，以及如何用 <a href="https://github.com/square/haha">HAHA</a> 这个库解析 <code>hprof</code> 文件。</p><p>联想：可以在特定场合去 <code>dump</code> 文件，比如内存大于最大内存 80%，因为 <code>hprof</code> 文件可能会很大，所以在用户 <code>wifi</code> 情况下回传。</p><p><a href="https://github.com/Tencent/matrix#matrix_android_cn">Tencent/matrix</a> 这个框架拥有更丰富的检测方式。</p><hr><h1 id="5-优化思路"><a href="#5-优化思路" class="headerlink" title="5 优化思路"></a>5 优化思路</h1><h2 id="5-1-设备分级"><a href="#5-1-设备分级" class="headerlink" title="5.1 设备分级"></a>5.1 设备分级</h2><p>内存优化首先需要根据设备环境来综合考虑</p><ul><li><strong>设备分级</strong>。使用类似 <a href="http://github.com/facebook/device-year-class">device-year-class</a> 的策略对设备分级，对于低端机用户可以关闭复杂的动画，或者是某些功能；使用 565 格式的图片，使用更小的缓存内存等。<ul><li><code>device-year-class</code> 会根据手机的内存、CPU 核心数和频率等信息决定设备属于哪一个年份，这个示例表示对于 2013 年之后的设备可以使用复杂的动画，对于 2010 年之前的低端设备则不添加任何动画。</li><li>565 格式图片：一张图片中每一个像素的大小取决于它的解码选项，而 Android 中能够选择的 Bitmap 解码选项有四种。<ul><li>ARGB_8888 ：ARGB 四个通道的值都是 8 位，加起来 32 位，也就是每个像素占 4 个字节</li><li>ARGB_4444： ARGB 四个通道的值都是 4 位，加起来 16 位，也就是每个像素占 2 个字节</li><li>RGB_565： RGB 三个通道分别是 5 位、6 位、5 位，加起来 16 位，也就是每个像素占 2 个字节</li><li>ALPHA_8：只有 A 通道，占 8 位，也就是每个像素占 1 个字节</li></ul></li></ul></li><li><strong>缓存管理</strong>。我们需要有一套统一的缓存管理机制，可以适当地使用内存；当“系统有难”时，也要义不容辞地归还。我们可以使用 <code>OnTrimMemory(本文 4.1.1 会讲到)</code> 回调，根据不同的状态决定释放多少内存。</li><li><strong>进程模型</strong>。一个空的进程也会占用 10MB 的内存，而有些应用启动就有十几个进程，甚至有些应用已经从双进程保活升级到四进程保活，所以减少应用启动的进程数、减少常驻进程、有节操的保活，对低端机内存优化非常重要。</li><li><strong>安装包大小</strong>。安装包中的代码、资源、图片以及 so 库的体积，跟它们占用的内存有很大的关系。一个 80MB 的应用很难在 512MB 内存的手机上流畅运行。这种情况我们需要考虑针对低端机用户推出 4MB 的轻量版本，例如 <code>Facebook Lite</code>、今日头条极速版都是这个思路。</li></ul><h2 id="5-2-Bitmap-优化"><a href="#5-2-Bitmap-优化" class="headerlink" title="5.2 Bitmap 优化"></a>5.2 Bitmap 优化</h2><p><code>Bitmap</code> 内存一般占应用总内存很大一部分，所以做内存优化永远无法避开图片内存这个“永恒主题”。</p><ol><li><p>统一图片库</p><p>图片内存优化的前提是收拢图片的调用，这样我们可以做整体的控制策略。就如设备分级中说的，低端设备策略等。</p></li><li><p>统一监控</p><ol><li><strong>大图片监控</strong>。我们需要注意某张图片内存占用是否过大，例如长宽远远大于 View 甚至是屏幕的长宽。在开发过程中，如果检测到不合规的图片使用，应该立即弹出对话框提示图片所在的 Activity 和堆栈，让开发同学更快发现并解决问题。<code>Glide</code> 可以有效的解决此类问题，因为 <code>Glide</code> 会根据 <code>ImageView</code> 的大小把图片大小调整成<code>ImageView</code> 的大小加载图片，并且 <code>Glide</code> 有三级缓存，在内存缓存中，<code>Glide</code> 会根据屏幕大小选择合适的大小作为图片内存缓存区的大小。</li><li><strong>重复图片监控</strong>。重复图片指的是 <code>Bitmap</code> 的像素数据完全一致，但是有多个不同的对象存在。这个监控不需要太多的样本量，一般只在内部使用。在检测模块中实现过一个内存 <code>Hprof</code> 的分析工具，它可以自动将重复 <code>Bitmap</code> 的图片和引用链输出。<ol><li><strong>图片总内存</strong>。通过收拢图片使用，我们还可以统计应用所有图片占用的内存，这样在线上就可以按不同的系统、屏幕分辨率等维度去分析图片内存的占用情况。在 <code>OOM</code> 崩溃的时候，也可以把图片占用的总内存、Top N 图片的内存都写到崩溃日志中，帮助我们排查问题。</li></ol></li></ol></li></ol><hr><h1 id="6-更多"><a href="#6-更多" class="headerlink" title="6 更多"></a>6 更多</h1><h2 id="6-1-监听系统内存状态"><a href="#6-1-监听系统内存状态" class="headerlink" title="6.1 监听系统内存状态"></a>6.1 监听系统内存状态</h2><p>Android 提供了两种方式让我们可以监听系统内存状态</p><h3 id="6-1-1-ComponentCallback2"><a href="#6-1-1-ComponentCallback2" class="headerlink" title="6.1.1 ComponentCallback2"></a>6.1.1 ComponentCallback2</h3><p>在 <code>Android 4.0</code> 后，<code>Android</code> 应用可以通过在 <code>Activity</code> 中实现 <code>ComponentCallback2</code> 接口获取系统内存的相关事件，这样就能在系统内存不足时提前知道这件事，提前做出释放内存的操作，避免我们自己的应用被系统干掉。</p><p><code>ComponentCallnback2</code> 提供了 <code>onTrimMemory(level)</code> 回调方法，在这个方法里我们可以针对不同的警告等级做出不同的释放内存操作。</p><p>原文是 <code>kotlin</code> 版，这里给出一个 <code>java</code> 版</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity2</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title">ComponentCallbacks2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTrimMemory</span><span class="params">(<span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onTrimMemory(level);</span><br><span class="line">        <span class="keyword">switch</span> (level) &#123;</span><br><span class="line">            <span class="keyword">case</span> ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN:</span><br><span class="line">                <span class="comment">// 应用界面处于后台</span></span><br><span class="line">                <span class="comment">// 可以在这里释放 UI 对象</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ComponentCallbacks2.TRIM_MEMORY_RUNNING_MODERATE:</span><br><span class="line">                <span class="comment">// 应用正常运行中，不会被杀掉，但是系统内存已经有点低了</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ComponentCallbacks2.TRIM_MEMORY_RUNNING_LOW:</span><br><span class="line">                <span class="comment">// 应用正常运行中，不会被杀掉，但是系统内存已经非常低了，</span></span><br><span class="line">                <span class="comment">// 这时候应该释放一些不必要的资源以提升系统性能</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL:</span><br><span class="line">                <span class="comment">// 应用正常运行，但是系统内存非常紧张，</span></span><br><span class="line">                <span class="comment">// 系统已经开始根据 LRU 缓存杀掉了大部分缓存的进程</span></span><br><span class="line">                <span class="comment">// 这时候我们要释放所有不必要的资源，不然系统可能会继续杀掉所有缓存中的进程</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ComponentCallbacks2.TRIM_MEMORY_BACKGROUND:</span><br><span class="line">                <span class="comment">// 系统内存很低，系统准备开始根据 LRU 缓存清理进程，</span></span><br><span class="line">                <span class="comment">// 这时我们的程序在 LRU 缓存列表的最近位置，不太可能被清理掉，</span></span><br><span class="line">                <span class="comment">// 但是也要去释放一些比较容易恢复的资源，让系统内存变得充足</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ComponentCallbacks2.TRIM_MEMORY_MODERATE:</span><br><span class="line">                <span class="comment">// 系统内存很低，并且我们的应用处于 LRU 列表的中间位置，</span></span><br><span class="line">                <span class="comment">// 这时候如果还不释放一些不必要资源，那么我们的应用可能会被系统干掉</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ComponentCallbacks2.TRIM_MEMORY_COMPLETE:</span><br><span class="line">                <span class="comment">// 系统内存非常低，并且我们的应用处于 LRU 列表的最边缘位置，</span></span><br><span class="line">                <span class="comment">// 系统会有限考虑干掉我们的应用，如果想活下来，就要把所有能释放的资源都释放了</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="comment">// 应用从系统接收到一个无法识别的内存等级值，</span></span><br><span class="line">                <span class="comment">// 跟一般的低内存消息提醒一样对待这个事件</span></span><br><span class="line">                <span class="comment">// 释放所有不重要的数据结构。</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-1-2-ActivityManager-getMemoryInfo"><a href="#6-1-2-ActivityManager-getMemoryInfo" class="headerlink" title="6.1.2 ActivityManager.getMemoryInfo()"></a>6.1.2 ActivityManager.getMemoryInfo()</h3><p>Android 提供了一个 <code>ActivityManager.getMemoryInfo()</code> 方法给我们查询内存信息，这个方法会返回一个 <code>ActivityManager.MemoryInfo</code> 对象，这个对象包含了系统当前内存状态，这些状态信息包括可用内存、总内存以及低杀内存阈值。</p><p><code>MemoryInfo</code> 中包含了一个 <code>lowMemory</code> 布尔值，这个布尔值用于表明系统是否处于低内存状态。</p><p>原文是 <code>kotlin</code> 版，这里给出一个 <code>java</code> 版</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomethingMemoryIntensive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在做一些需要很多内存的任务前，</span></span><br><span class="line">        <span class="comment">// 检查设备是否处于低内存状态、</span></span><br><span class="line">        <span class="keyword">if</span> (!getAvailableMemory().lowMemory) &#123;</span><br><span class="line">            <span class="comment">// 做需要很多内存的任务</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ActivityManager.<span class="function">MemoryInfo <span class="title">getAvailableMemory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ActivityManager activityManager = (ActivityManager) getSystemService(Context.ACTIVITY_SERVICE);</span><br><span class="line">        ActivityManager.MemoryInfo MemoryInfo = <span class="keyword">new</span> ActivityManager.MemoryInfo();</span><br><span class="line">        activityManager.getMemoryInfo(MemoryInfo);</span><br><span class="line">        <span class="keyword">return</span> MemoryInfo;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="6-2-内存优化技巧"><a href="#6-2-内存优化技巧" class="headerlink" title="6.2 内存优化技巧"></a>6.2 内存优化技巧</h2><h3 id="6-2-1-谨慎使用-Service"><a href="#6-2-1-谨慎使用-Service" class="headerlink" title="6.2.1 谨慎使用 Service"></a>6.2.1 谨慎使用 Service</h3><p>让一个没用的 <code>Service</code> 在后台运行对于一个应用的内存管理来说是一件最糟糕的事情。</p><p>要在 <code>Service</code> 的任务完成后停止它，不然 <code>Service</code> 占用的这块内存会泄漏。</p><p>当你的应用中运行着一个 <code>Service</code>，除非系统内存不足，否则它不会被干掉。</p><p>这就导致对于系统来说 <code>Service</code> 的运行成本很高，因为 <code>Service</code> 占用的内存其他的进程是不能使用的。</p><p><code>Android</code> 有一个缓存进程列表，当可用内存减少时，这个列表也会随之缩小，这就会导致应用间的切换变得很慢。</p><p>如果我们是用 <code>Service</code> 监听一些系统广播，希望在特定情况下再启动事务，可以考虑使用 <code>JobScheduler</code>。</p><p>如果你真的要用 <code>Service</code>，可以考虑使用 <code>IntentService</code>，<code>IntentService</code> 是 <code>Service</code> 的一个子类，在它的内部有一个工作线程来处理耗时任务，当任务执行完后，<code>IntentService</code> 就会自动停止。</p><h3 id="6-2-2-选择优化后的数据容器"><a href="#6-2-2-选择优化后的数据容器" class="headerlink" title="6.2.2 选择优化后的数据容器"></a>6.2.2 选择优化后的数据容器</h3><p><code>Java</code> 提供的部分数据容器并不适合 <code>Android</code>，比如 <code>HashMap</code>，<code>HashMap</code> 需要中存储每一个键值对都需要一个额外的 <code>Entry</code> 对象。</p><p>Android 提供了几个优化后的数据容器，包括 <code>SparseArray</code>、<code>SparseBooleanArray</code> 以及 <code>LongSparseArray</code>。</p><p><code>SparseArray</code>和<code>ArrayMap</code>是Android专门针对内存优化而设计的取代 <code>Java API</code> 中的<code>HashMap</code>的数据结构。对于 <code>key</code> 是 <code>int</code> 类型则使用<code>SparseArray</code>，可避免自动装箱过程；对于 <code>key</code> 为其他类型则使用<code>ArrayMap</code>。<code>HashMap</code>的查找和插入时间复杂度为 <code>O(1)</code> 的代价是牺牲大量的内存来实现的，而<code>SparseArray</code>和<code>ArrayMap</code>性能略逊于<code>HashMap</code>，但更节省内存。</p><h3 id="6-2-3-小心代码抽象"><a href="#6-2-3-小心代码抽象" class="headerlink" title="6.2.3 小心代码抽象"></a>6.2.3 小心代码抽象</h3><p>抽象可以优化代码的灵活性和可维护性，但是抽象也会带来其他成本。</p><p>抽象会导致更多的代码需要被执行，也就是需要更多的时间和把更多的代码映射到内存中。</p><p>如果某段抽象代码带来的好处不大，比如一个地方可以直接实现而不需要用到接口的，那就不用接口。</p><h3 id="6-2-4-使用-protobuf-作为序列化数据"><a href="#6-2-4-使用-protobuf-作为序列化数据" class="headerlink" title="6.2.4 使用 protobuf 作为序列化数据"></a>6.2.4 使用 protobuf 作为序列化数据</h3><p><code>Protocol buffers</code> 是 <code>Google</code> 设计的，它可以对结构化的数据序列化，与<code>XML</code> 类似，不过比<code>XML</code> 更小，更快，而且更简单。</p><p>如果你决定使用 <code>protobuf</code> 作为序列化数据格式，那在客户端代码中应该使用轻量级的 <code>protobuf</code>。</p><p>因为一般的 <code>protobuf</code> 会生成冗长的代码，这样会导致内存增加、<code>APK</code> 大小增加，执行速度变慢等问题。</p><p>更多关于 <code>protobuf</code> 的信息可以查看 <a href="https://android.googlesource.com/platform/external/protobuf/+/master/java/README.md#installation-lite-version-with-maven">protobuf readme</a> 中的 “轻量级版本”  。</p><h3 id="6-2-5-Apk-瘦身"><a href="#6-2-5-Apk-瘦身" class="headerlink" title="6.2.5 Apk 瘦身"></a>6.2.5 Apk 瘦身</h3><p>有些资源和第三方库会在我们不知情的情况下大量消耗内存。</p><p><code>Bitmap</code> 大小、资源、动画以及第三方库会影响到 <code>APK</code> 的大小，<code>Android Studio</code> 提供了 <code>R8</code> 和 <code>ProGuard</code> 帮助我们缩小 <code>Apk</code>，去掉不必要的资源。</p><p>如果你使用的 <code>Android Studio</code> 版本是 3.3 以下的，可以使用 <code>ProGuard</code>，3.3 及以上版本的可以使用 <code>R8</code>。</p><h3 id="6-2-6-使用-Dagger2-进行依赖注入"><a href="#6-2-6-使用-Dagger2-进行依赖注入" class="headerlink" title="6.2.6 使用 Dagger2 进行依赖注入"></a>6.2.6 使用 Dagger2 进行依赖注入</h3><p>依赖注入框架不仅可以简化我们的代码，而且能让我们在测试代码的时候更方便。</p><p>如果我们想在应用中使用依赖注入，可以考虑使用 <code>Dagger2</code>。</p><p><code>Dagger2</code> 是在编译期生成代码，而不是用反射实现的，这样就避免了反射带来的内存开销，而是在编译期生成代码，</p><h3 id="6-2-7-谨慎使用第三方库"><a href="#6-2-7-谨慎使用第三方库" class="headerlink" title="6.2.7 谨慎使用第三方库"></a>6.2.7 谨慎使用第三方库</h3><p>当你决定使用一个不是为移动平台设计的第三方库时，你需要对它进行优化，让它能更好地在移动设备上运行。</p><p>这些第三方库包括日志、分析、图片加载、缓存以及其他框架，都有可能带来性能问题。</p><h3 id="6-2-8-使用-IntDef-和-StringDef-替代枚举类型"><a href="#6-2-8-使用-IntDef-和-StringDef-替代枚举类型" class="headerlink" title="6.2.8 使用  IntDef 和 StringDef 替代枚举类型"></a>6.2.8 使用  IntDef 和 StringDef 替代枚举类型</h3><p>使用枚举类型的 <code>dex size</code> 是普通常量定义的 <code>dex size</code> 的 13 倍以上，同时，运行时的内存分配，一个 <code>enum</code> 值的声明会消耗至少 <code>20 bytes</code> 。</p><p>枚举最大的优点是类型安全，但在Android平台上，枚举的内存开销是直接定义常量的三倍以上。所以Android提供了注解的方式检查类型安全。目前提供了int型和String型两种注解方式：<code>IntDef</code> 和 <code>StringDef</code> ，用来提供编译期的类型检查。</p><p>使用 <code>IntDef</code>和 <code>StringDef</code> 需要在 <code>Gradle</code> 配置中引入相应的依赖包：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile <span class="string">&#x27;com.android.support:support-annotations:22.0.0&#x27;</span></span><br></pre></td></tr></table></figure><hr><h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a><strong>感谢</strong></h1><blockquote><p><a href="https://time.geekbang.org/column/article/74044">极客时间 Android开发高手课</a>  </p><p><a href="https://coding.imooc.com/learn/list/308.html">慕课 Top团队大牛带你玩转Android性能分析与优化</a></p><p><a href="https://juejin.im/post/5d3ada056fb9a07eb94fd1bc">探索 Android 内存优化方法</a></p><p><a href="https://juejin.im/post/58b80c3b61ff4b006cd8c33d">Android 性能优化（四）之内存优化实战</a></p><p><a href="https://square.github.io/leakcanary">LeakCanary</a></p><p><a href="https://developer.android.google.cn/studio/profile/memory-profiler">AndroidDeveloper</a> </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>App 内存知识介绍💦</title>
      <link href="2020/memory-optimization.html"/>
      <url>2020/memory-optimization.html</url>
      
        <content type="html"><![CDATA[<p>Android 性能优化第二篇， 内存优化是减少崩溃率工作中非常关键的一部分，由于Android有垃圾自动回收机制不需要手动干预，但也因此，经常出现内存问题如内存泄漏、内存泄漏引发 <code>GC</code> 频繁导致页面卡顿和内存溢出等问题，如果不了解内存是如何管理的以及如何优化，会难以排查问题。</p><p>这篇文章集结了很多文章精华部分(个人认为)，在这里整理分享出更多更完整内存知识，所以这篇文章会很长，目录我会分的很细，方便查找，文末会贴出参考文章。</p><p><strong>注意：如果出现图片不显示问题请移步</strong> <a href="https://calmcenter.club/2019/PicNotShow.html">图片不显示问题</a></p><h1 id="本文主要记载"><a href="#本文主要记载" class="headerlink" title="本文主要记载"></a>本文主要记载</h1><ul><li><strong>1 什么是内存？</strong></li><li><strong>2 JVM 如何分配内存？</strong><ul><li>2.1 所有线程共享的数据区域</li><li>2.2 线程私有的数据区域</li></ul></li><li><strong>3 JVM 如何管理内存？</strong><ul><li>3.1 引用计数算法</li><li>3.2 可达性算法</li><li>3.3 引用介绍</li><li>3.4 垃圾回收器<ul><li>3.4.1 标记-清除算法（Mark-Sweep）</li><li>3.4.2 复制算法（Copying）</li><li>3.4.3 标记-整理算法（Mark-Compact）</li><li>3.4.4 分代收集算法（Generational Collection）</li></ul></li></ul></li><li><strong>4 什么是 Dalvik?</strong><ul><li>4.1 Dalvik 与 JVM 的区别</li><li>4.2 Dalvik 堆大小</li></ul></li><li><strong>5 什么是 ART?</strong><ul><li>5.1 ART 与 Dalvik 的区别</li></ul></li><li><strong>6 内存引发的问题</strong><ul><li>6.1 内存泄漏<ul><li>6.1.1 常见的内存泄漏</li></ul></li><li>6.2 低杀</li><li>6.3 内存抖动</li></ul></li><li><strong>7 Android Bitmap 内存分配的变化</strong></li><li><strong>8 内存优化的两个误区</strong><ul><li>8.1 内存占用越少越好</li><li>8.2 Native 内存不用管</li></ul></li></ul><hr><h1 id="1-什么是内存？"><a href="#1-什么是内存？" class="headerlink" title="1 什么是内存？"></a>1 什么是内存？</h1><p>内存是计算机中重要的部件之一，是与 CPU 进行沟通的桥梁，是 CPU 能直接寻址的存储空间，由半导体器件制成。</p><blockquote><p>如果说数据是商品，那硬盘就是商店的仓库，内存就是商店的货架，仓库里的商品你是不能直接买的，你只能买货架上的商品。</p><p>每一个程序中使用的内存区域相当于是不同的货架，当一个货架上需要摆放的商品超过这个货架所能容纳的最大值，就会出现放不下的情况，也就是内存溢出。</p></blockquote><hr><h1 id="2-JVM-如何分配内存？"><a href="#2-JVM-如何分配内存？" class="headerlink" title="2 JVM 如何分配内存？"></a>2 JVM 如何分配内存？</h1><h2 id="2-1-所有线程共享的数据区域"><a href="#2-1-所有线程共享的数据区域" class="headerlink" title="2.1 所有线程共享的数据区域"></a>2.1 <strong>所有线程共享的数据区域</strong></h2><ul><li><strong>堆</strong>（Java Heap）<ul><li><code>Java</code> 堆是 <code>JVM</code> 管理的内存中最大的一块内存区域。</li><li>几乎所有的对象实例都是在堆中分配内存。</li><li>此区域也是垃圾回收器（<code>Garbage Collection</code>）主要的作用区域，内存泄漏就发生在这个区域。</li></ul></li><li><strong>方法区</strong>（Method Area）<ul><li>方法区存放的是 <strong>类信息、常量、静态变量</strong></li><li>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机会抛出内存溢出异常 <code>OutOfMemoryError</code>。</li></ul></li></ul><h2 id="2-2-线程私有的数据区域"><a href="#2-2-线程私有的数据区域" class="headerlink" title="2.2 线程私有的数据区域"></a>2.2 <strong>线程私有的数据区域</strong></h2><ul><li><p><strong>程序计数器</strong>（Program Counter Register）</p><ul><li><p>一块较小的内存空间，可看做是当前线程所执行的字节码的行号指示器。</p></li><li><p>为了线程切换后能恢复到正确的执行位置，每条线程都有一个私有的程序计数器。</p></li><li><p>如果线程在执行 <code>Java</code> 方法，这个计数器记录的是正在执行的虚拟机字节码指令地址；</p></li><li><p>如果执行的是 <code>Native</code> 方法，这个计数器的值为空（Undefined）。</p></li><li><p>程序计数器是唯一一个在 Java 虚拟机规范中没有规定任何 <code>OOM</code> 情况的区域。</p></li></ul></li><li><p><strong>本地方法栈</strong>（Native Method Stack）</p><ul><li>本地方法栈与虚拟机栈的区别是虚拟机栈为 <code>Java</code> 方法服务，而本地方法栈为 <code>Native</code> 方法服务。</li><li>与虚拟机栈一样，本地方法栈也会抛出 <code>StackOverflowError</code> 和 <code>OutOfMemoryError</code> 异常。</li></ul></li><li><p><strong>虚拟机栈</strong>（Virtual Machine Stack ）</p><ul><li>每个方法在执行的同时都会创建一个<strong>栈帧（Stack Frame）</strong>用于存储局部变量表、操作数栈、动态链接、方法出口等信息。</li><li>虚拟机栈生命周期与线程相同。</li><li>当执行 Java 方法时会进行压栈的操作，在栈中会保存局部变量、操作数栈和方法出口等信息。<code>JVM</code> 规定了栈的最大深度，如果线程请求执行方法时栈的深度大于规定的深度，就会抛出栈溢出异常 <code>StackOverflowError</code>。</li><li>如果虚拟机在扩展时无法申请到足够的内存，就会抛出内存溢出异常 <code>OutOfMemoryError</code>。</li></ul><div class="note default no-icon flat"><p><strong>栈帧（Stack Frame）</strong></p><p>当 <code>Java</code> 程序出现异常时，程序会打印出对应的异常堆栈，通过这个堆栈我们可以知道方法的调用链路，而这个调用链路就是由一个个 Java 方法栈帧组成的。</p><ol><li><p><strong>局部变量表</strong>（Local Variable Table）：里面的变量只在当前函数调用中有效，当函数调用结束后，随着函数栈帧的销毁，局部变量表也会随之销毁。</p><p>局部变量表中存放的<strong>编译期</strong>可知的各种数据有：</p><ul><li><p>基本数据类型：如 boolean、char、int 等。</p></li><li><p>对象引用：reference 类型，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置。</p></li><li><p><code>returnAddress</code>类型：指向一条虚拟机指令的操作码。与前面介绍的那些数值类的原生类型不同，<code>returnAddress</code> 类型在 <code>Java</code> 语言之中并不存在相应的类型，也无法在程序运行期间更改 <code>returnAddress</code> 类型的值。</p></li></ul></li><li><p><strong>操作数栈</strong>（Operand Stack）：操作数栈（Operand Stack）也叫操作栈，它主要用于保存计算过程的中间结果，同时作为计算过程中临时变量的存储空间。</p></li><li><p><strong>动态连接</strong>（Dynamic Linking）：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接</p></li><li><p><strong>方法返回地址</strong>：当一个方法开始执行后，只有两种方式可以退出这个方法，一种是正常完成出口，另一种是异常完成出口。</p><ul><li>正常完成出口（Normal Method Invocation Completion）：执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者。是否有返回值和返回值的类型将根据遇到哪种方法返回指令来决定，这种退出方法的方式称为正常完成出口。</li><li>异常完成出口（Abrupt Method Invocation Completion）：在方法执行过程中遇到异常，并且这个异常没有在方法体内得到处理，就会导致方法退出，这种退出方式称为异常完成出口。一个方法使用异常完成出口的方式退出，任何值都不会返回给它的调用者。</li></ul><p>无论采用哪种退出方式，在方法退出后，都需要返回到方法被调用的位置，程序才能继续执行。</p></li></ol></div></li></ul><hr><h1 id="3-JVM-如何管理内存？"><a href="#3-JVM-如何管理内存？" class="headerlink" title="3 JVM 如何管理内存？"></a>3 JVM 如何管理内存？</h1><p>JVM 的管理主要有 <strong>引用计数算法</strong>、<strong>可达性算法</strong>、<strong>Java 引用</strong> 以及 <strong>垃圾回收器</strong> 知识点。</p><h2 id="3-1-引用计数算法"><a href="#3-1-引用计数算法" class="headerlink" title="3.1 引用计数算法"></a>3.1 引用计数算法</h2><p>给对象中添加一个引用计数器，每当有一个地方引用该对象时，计数器值加1；引用失效时，计数器值减1；任意时刻计数器为0的对象就是不可能再被使用的，表示该对象不存在引用关系。</p><p>优点：实现简单，判定效率也很高；<br>缺点：难以解决对象之间相互循环引用导致计数器值不等于0的问题。</p><h2 id="3-2-可达性算法"><a href="#3-2-可达性算法" class="headerlink" title="3.2 可达性算法"></a>3.2 可达性算法</h2><p>判定对象是否是存活的</p><p>这个算法的基本思路就是通过一系列 <code>GC Roots</code> 对象作为起始点，从这些节点开始向下搜索，搜索走过的路径就叫引用链。<br>当一个对象到 <code>GC Roots</code> 没有任何引用链相连时（<code>GC Roots</code> 到这个对象不可达），则证明此对象是不可用的。</p><p>比如下图中的 <code>object5、object6、object7</code>，虽然它们互有关联，但是它们到 <code>GC Roots</code> 是不可达的，所以它们会被判定为可回收对象。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/20200330171812.png" alt=""></p><p>那么那些点可以作为 <code>GC Roots</code> 呢？一般来说，如下情况的对象可以作为 <code>GC Roots</code> ：</p><ol><li><p>虚拟机栈</p><p>虚拟机栈的栈帧中的局部变量表中引用的对象，比如某个方法正在使用的类字段。</p></li><li><p>方法区</p><ul><li><p>类静态属性引用的对象</p></li><li><p>常量引用的对象</p></li></ul></li><li><p>本地方法栈</p><p>本地方法栈中 <code>Native</code> 方法引用的对象。</p></li></ol><h2 id="3-3-引用介绍"><a href="#3-3-引用介绍" class="headerlink" title="3.3 引用介绍"></a>3.3 引用介绍</h2><p>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判定对象是否存活都与引用有关。</p><p>在 <code>JDK 1.2</code> 之后，<code>Java</code> 对引用的概念进行了扩充，将引用分为<strong>强引用</strong>、<strong>软引用</strong>、<strong>弱引用</strong>和<strong>虚引用</strong>四种，这四种引用强度按顺序依次减弱。如果没有指定对象引用类型，默认是<strong>强引用</strong>。</p><ol><li><strong>强引用</strong>：<ul><li>强引用是指代码中普遍存在的，比如 <code>Object obj = new Object()</code> 这类引用。</li><li>强引用可以直接访问目标对象。</li><li>强引用指向的对象在任何时候都不会被系统回收，虚拟机即使抛出 <code>OOM</code> 异常，也不会回收强引用指向的对象。<br>使用 <code>obj = null</code> 不会触发 <code>GC</code>，但是在下次 <code>GC</code> 的时候这个强引用对象就可以被回收了。</li><li>强引用可能导致内存泄漏。</li></ul></li><li><strong>软引用</strong>：<ul><li>软引用用于描述一些还有用但非必需的对象。</li><li>对于软引用关联的对象，在系统即将发生内存溢出前，会把这些对象列入回收范围中进行二次回收。</li><li>如果二次回收后还没有足够的内存，就会抛出内存溢出异常。</li><li>在 <code>JDK 1.2</code> 后，<code>Java</code> 提供了 <code>SoftReference</code> 类来实现软引用。</li></ul></li><li><strong>弱引用</strong>：<ul><li>弱引用的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次 <code>GC</code> 前。</li><li>在 <code>GC</code> 时，只要发现弱引用，不管系统堆空间使用情况如何，都会将对象进行回收。</li><li>软引用、弱引用适合保存可有可无的缓存数据。</li><li><code>JDK 1.2</code> 后，提供了 <code>WeakReference</code> 类来实现弱引用。</li></ul></li><li><strong>虚引用</strong>：<ul><li>一个对象是否有虚引用的存在，都不会对其生存时间构成影响，也无法通过虚引用取得一个对象实例。</li><li>为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</li><li>在 <code>JDK 1.2</code> 后，提供了 <code>PhantomReference</code> 类来实现虚引用。</li></ul></li></ol><h2 id="3-4-垃圾回收器"><a href="#3-4-垃圾回收器" class="headerlink" title="3.4 垃圾回收器"></a>3.4 垃圾回收器</h2><p>垃圾回收器就是我们经常说到的 <code>GC（Garbage Collector）</code>，当我们操作不当导致某块内存泄漏时，<code>GC</code> 就不能对这块内存进行回收。</p><p>拿 <code>Android</code> 来说，进行 <code>GC</code> 时，所有线程都要暂停，包括主线程，<code>16ms</code> 是 <code>Android</code> 要求的每帧绘制时间，而当 <code>GC</code> 的时间超过 <code>16ms</code>，就会造成丢帧的情况，也就是界面卡顿。</p><p>垃圾回收器回收资源的方式就是垃圾回收算法</p><h3 id="3-4-1-标记-清除算法（Mark-Sweep）"><a href="#3-4-1-标记-清除算法（Mark-Sweep）" class="headerlink" title="3.4.1 标记-清除算法（Mark-Sweep）"></a>3.4.1 标记-清除算法（Mark-Sweep）</h3><p>最基础的收集算法：分为 <strong>标记</strong> 和 <strong>清除</strong> 两个阶段，首先，标记出所有需要回收的对象，然后统一回收所有被标记的对象。<br>这种方法有两个不足点：</p><ol><li>标记和清除的效率都不高</li><li>标记清除后会产生大量不连续的内存碎片，内存碎片太多会导致当程序需要分配较大的对象时，无法找到足够的连续内存而不得不提前触发 ·<code>GC</code></li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/20200330181053.png" alt=""></p><h3 id="3-4-2-复制算法（Copying）"><a href="#3-4-2-复制算法（Copying）" class="headerlink" title="3.4.2 复制算法（Copying）"></a>3.4.2 复制算法（Copying）</h3><p>为了解决 <strong>标记-清除算法</strong> 效率问题，<strong>复制收集算法</strong> 出现了。</p><p>将内存按容量划分为大小相等的两块，每次只使用其中的一块，当这一块内存将用完了，就将还存活着的对象复制到另一块内存上面，然后再把已使用过的内存空间一次清理掉。</p><ul><li>优点：实现简单，运行高效；每次都是对整个半区进行内存回收，内存分配时也不需要考虑内存碎片等情况，只要移动堆顶指针，按顺序分配内存即可；</li><li>缺点：粗暴的将内存一分为二，代价有点高。在对象存活率高时，要进行较多的复制操作，这时效率就变低了</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/20200330181822.png" alt=""></p><h3 id="3-4-3-标记-整理算法（Mark-Compact）"><a href="#3-4-3-标记-整理算法（Mark-Compact）" class="headerlink" title="3.4.3 标记-整理算法（Mark-Compact）"></a>3.4.3 标记-整理算法（Mark-Compact）</h3><p><strong>标记-整理算法</strong> 的标记过程与 <strong>标记-清除算法</strong> 一样，但后续步骤是让所有存活的对象向一端移动，然后直接清理掉边界外的内存。</p><ul><li>避免了 <strong>标记-清除算法</strong> 内存碎片；</li><li>避免了 <strong>复制算法</strong> 50%的空间浪费；</li><li>主要针对对象存活率高的老年代。<br><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/20200403112950.png" alt=""></li></ul><h3 id="3-4-4-分代收集算法（Generational-Collection）"><a href="#3-4-4-分代收集算法（Generational-Collection）" class="headerlink" title="3.4.4 分代收集算法（Generational Collection）"></a>3.4.4 分代收集算法（Generational Collection）</h3><p>现代商业虚拟机的垃圾回收都采用 <strong>分代收集算法</strong> ，这种算法会根据对象存活周期的不同将内存划分为几块，这样就可以根据各个区域的特点采用最适当的收集算法。</p><p>堆内存可分为 <strong>新生区</strong> 、<strong>养老区</strong> 和 <strong>永久存</strong> 储区三个区域。</p><ul><li><p><strong>新生区（Young Generation Space）</strong></p><p>由 <strong>一个伊甸区（Eden space）</strong> 和 <strong>两个幸存者区（Survivor space）区</strong> 组成。<br>每次垃圾收集都有大批对象死去，只有少量存活，所以可以用复制算法。</p><ul><li><strong>伊甸区</strong></li></ul><p>大多数情况下，对象都是在伊甸区中分配的，当伊甸区没有足够的空间进行分配时，虚拟机将发起一次 <code>Minor GC</code>。<br><code>Minor GC</code> 是指发生在新生区的垃圾收集动作，<code>Minor GC</code> 非常频繁，回收速度也比较快。<br>当伊甸区的空间用完时，<code>GC</code> 会对伊甸区进行垃圾回收，然后把伊甸区剩下的对象移动到幸存 0 区。</p><ul><li><strong>幸存 0 区</strong></li></ul><p>如果幸存 0 区满了，<code>GC</code> 会对该区域进行垃圾回收，然后再把该区剩下的对象移动到幸存 1 区。</p><ul><li><strong>幸存 1 区</strong></li></ul><p>如果幸存 1 区满了，<code>GC</code> 会对该区域进行垃圾回收，然后把幸存 1 区中的对象移动到养老区。</p></li><li><p><strong>养老区（Tenure Generation Space）</strong></p></li></ul><p>对象存活率高、没有额外空间对它进行担保，就必须使用 <strong>标记-清理</strong> 或 <strong>标记-整理算法</strong> 进行回收。</p><p>用于保存从新生区筛选出来的 <code>Java</code> 对象。<br>当幸存 1 区移动尝试对象到养老区，但是发现空间不足时，虚拟机会发起一次 <code>Major GC</code>。<br><code>Major GC</code> 的速度一般比 <code>Minor GC</code> 慢 10 倍以上。<br>大对象会直接进入养老区，比如很大的数字和很长的字符串。</p><ul><li><strong>永久存储区（Permanent Space）</strong></li></ul><p>一个常驻内存区域，用于存放 <code>JDK</code> 自身携带的 <code>Class Interface</code> 元数据。<br>永久存储区存储的是运行环境必需的类信息，被装载进该区域的数据是不会被垃圾回收器回收掉的，只有 <code>JVM</code> 关闭时才会释放此区域的内存。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/20200403114531.png" alt=""></p><hr><h1 id="4-什么是-Dalvik"><a href="#4-什么是-Dalvik" class="headerlink" title="4 什么是 Dalvik?"></a>4 什么是 Dalvik?</h1><p><code>Dalvik</code> 是 <code>Dalvik Virtual Machine</code>（<code>Dalvik</code> 虚拟机）的简称，是 <code>Android</code> 平台的核心组成部分之一。<code>Android 4.4</code> 之前都是使用 <code>Dalvik</code>。</p><p>在 <code>Androd</code> 中，每一个应用都运行在一个 <code>Dalvik VM</code> 实例中，每一个 <code>Dalvik VM</code> 都运行在一个独立的进程空间，这种机制使得 <code>Dalvik</code> 运行在有限的内存中同时运行多个进程。</p><h2 id="4-1-Dalvik-与-JVM-的区别"><a href="#4-1-Dalvik-与-JVM-的区别" class="headerlink" title="4.1 Dalvik 与 JVM 的区别"></a>4.1 Dalvik 与 JVM 的区别</h2><p><code>Dalvik</code> 不是 <code>Java</code> 虚拟机，它并不是按照 Java 虚拟机规范实现的，两者之间并不兼容。</p><ol><li><p>架构</p><ul><li><p><code>JVM</code> 是基于栈的，需要在栈中读取数据，所需的指令会更多，这样会导致速度慢，不适合性能优先的移动设备。</p></li><li><p><code>Dalvik</code> 是基于寄存器的，指令更紧凑和简洁。</p></li></ul><p>由于显式指定了操作数，所以基于寄存器的指令会比基于栈的指令要大，但是由于指令数的减少，总的代码数不会增加多少。</p></li><li><p>执行代码不同</p><ul><li><p>在 <code>Java SE</code> 程序中，<code>Java</code> 类会被编译成一个或多个 <code>.class</code> 文件，然后打包成 <code>jar</code> 文件，<code>JVM</code> 会通过对应的 <code>.class</code> 文件和 <code>jar</code> 文件获取对应的字节码。</p></li><li><p>而 <code>Dalvik</code> 会用 <code>dx</code> 工具将所有的 .class 文件转换为一个 <code>.dex</code> 文件，然后会从该 <code>.dex</code> 文件读取指令和数据。</p></li></ul></li><li><p>共享机制</p><ul><li><p><code>Dalvik</code> 拥有预加载—共享机制，不同应用之间在运行时可以共享相同的类，拥有更高的效率。</p></li><li><p>而 <code>JVM</code> 不存在这种共享机制，不同的程序，打包后的程序都是彼此独立的，即使包中使用了同样的类，运行时也是单独加载和运行的，无法进行共享。</p></li></ul></li></ol><h2 id="4-2-Dalvik-堆大小"><a href="#4-2-Dalvik-堆大小" class="headerlink" title="4.2 Dalvik 堆大小"></a>4.2 Dalvik 堆大小</h2><p>每一个手机厂商都可以设定设备中每一个进程能够使用的堆大小，有关进程堆大小的值有下面三个。</p><p>如果我们想看堆内存大小应该怎么办呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell getprop dalvik.vm.heapsize</span><br></pre></td></tr></table></figure><ul><li><p>dalvik.vm.heapstartsize</p><p>堆分配的初始值大小，这个值越小，系统内存消耗越慢，但是当应用扩展这个堆，导致 <code>GC</code> 和堆调整时，应用会变慢。</p><p>这个值越大，应用越流畅，但是可运行的应用也会相对减少。</p></li><li><p>dalvik.vm.heapgrowthlimit</p><p>如果在清单文件中声明 <code>largeHeap</code> 为 <code>true</code>，则 <code>App</code> 使用的内存到 <code>heapsize</code> 才会 <code>OOM</code>，否则达到 <code>heapgrowthlimit</code> 就会 <code>OOM</code>。</p></li><li><p>dalvik.vm.heapsize</p><p>进程可用的堆内存最大值，一旦应用申请的内存超过这个值，就会 <code>OOM</code>。</p></li></ul><hr><h1 id="5-什么是-ART"><a href="#5-什么是-ART" class="headerlink" title="5 什么是 ART?"></a>5 什么是 ART?</h1><p><code>ART</code> 的全称是 <code>Android Runtime</code>，是从 <code>Android 4.4</code> 开始新增的 <strong>应用运行时环境</strong>，用于替代 <code>Dalvik</code> 虚拟机。</p><p><code>Dalvik VM</code> 和 <code>ART</code> 都可以支持已转换为 <code>.dex（Dalvik Executable）</code>格式的 <code>Java</code> 应用程序的运行。</p><p><code>Dalvik</code> 是为 32 位 <code>CPU</code> 设计的，而 <code>ART</code> 支持 64 位并兼容 32 位 <code>CPU</code>，这也是 <code>Dalvik</code> 被淘汰的主要原因。</p><h2 id="5-1-ART-与-Dalvik-的区别"><a href="#5-1-ART-与-Dalvik-的区别" class="headerlink" title="5.1 ART 与 Dalvik 的区别"></a>5.1 ART 与 Dalvik 的区别</h2><ol><li><p>预编译</p><ul><li><p><code>Dalvik</code> 中的应用每次运行时，字节码都需要通过即时编译器 JIT 转换为机器码，这会使得应用的运行效率降低。</p></li><li><p>在 <code>ART</code> 中，系统在安装应用时会进行一次预编译，将字节码预先编译成机器码并存储在本地，这样应用就不用在每次运行时执行编译了，运行效率也大大提高。</p></li></ul></li><li><p>GC</p><ul><li><p>在 <code>Dalvik</code> 采用的垃圾回收算法是标记-清除算法，启动垃圾回收机制会造成两次暂停（一次在遍历阶段，另一次在标记阶段）。</p></li><li><p>而在 <code>ART</code> 下，<code>GC</code> 速度比 <code>Dalvik</code> 要快，这是因为应用本身做了垃圾回收的一些工作，启动 <code>GC</code> 后，不再是两次暂停，而是一次暂停。</p><p>而且 <code>ART</code> 使用了一种新技术（<code>packard pre-cleaning</code>），在暂停前做了许多事情，减轻了暂停时的工作量。</p></li></ul></li></ol><hr><h1 id="6-内存引发的问题"><a href="#6-内存引发的问题" class="headerlink" title="6 内存引发的问题"></a>6 内存引发的问题</h1><ol><li>内存造成的第一个问题是<strong>异常</strong>。异常包括 <code>OOM</code>、内存分配失败这些崩溃，也包括因为整体内存不足导致应用被杀死、设备重启等问题。</li><li>内存造成的第二个问题是卡顿。<strong>内存泄漏</strong> 导致 <code>Java</code> 内存不足会频繁 <code>GC</code>，常见现象是 <strong>内存抖动</strong>，这个问题在 <code>Dalvik</code> 虚拟机会更加明显。而 ART 虚拟机在内存管理跟回收策略上都做大量优化</li><li>除了频繁 <code>GC</code> 造成卡顿之外，物理内存不足时系统会触发 <strong>low memory killer</strong> 机制，系统负载过高是造成卡顿的另外一个原因。</li></ol><h2 id="6-1-内存泄漏"><a href="#6-1-内存泄漏" class="headerlink" title="6.1 内存泄漏"></a>6.1 内存泄漏</h2><p>内存泄漏指的是，当一块内存没有被使用，但无法被 GC 时的情况。</p><p>内存泄漏的表现就是可用内存逐渐减少，无法被回收的内存逐渐累积，直到无更多可用内存可申请时，就会导致 <code>OOM</code>。</p><h3 id="6-1-1-常见的内存泄漏"><a href="#6-1-1-常见的内存泄漏" class="headerlink" title="6.1.1 常见的内存泄漏"></a>6.1.1 常见的内存泄漏</h3><ol><li><p><strong>非静态内部类</strong></p><ul><li><p><strong>泄漏场景</strong> </p><p>非静态内部类会持有外部类的实例，比如匿名内部类。</p><p>匿名内部类指的是一个对象名称的类，但是在字节码中，它还是会有构造函数的，而它的构造函数中会包含外部类的实例。</p><p>比如在 <code>Activity</code> 中以匿名内部类的方式声明 <code>Handler</code> 或 <code>AsyncTask</code>，当 <code>Activity</code> 关闭时，由于 <code>Handler</code> 持有 <code>Activity</code> 的强引用，导致 <code>GC</code> 无法对 <code>Activity</code> 进行回收。</p><p>当我们通过 <code>Handler</code> 发送消息时，消息会加入到 <code>MessageQueue</code> 队列中交给 <code>Looper</code> 处理，当有消息还没发送完毕时，<code>Looper</code> 会一直运行，在这个过程中会一直持有 <code>Handler</code>，而 <code>Handler</code> 又持有外部类 <code>Activity</code> 的实例，这就导致了 Activity 无法被释放。</p></li><li><p><strong>解决</strong></p><p>把 <code>Handler</code> 或 <code>AsyncTask</code> 声明为静态内部类，并且使用 <code>WeakReference</code> 包住 <code>Activity</code>，这样 <code>Handler</code> 拿到的就是一个 <code>Activity</code> 的弱引用，<code>GC</code> 就可以回收 <code>Activity</code>。这种方式适用于所有匿名内部类导致的内存泄漏问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    Activity activity;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyHandler</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">        activity = <span class="keyword">new</span> WeakReference&lt;&gt;(activity).get();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>静态变量</strong></p><ul><li><p><strong>泄漏场景</strong></p><p>静态变量导致内存泄漏的原因是因为 <strong>长生命周期对象</strong> 持有了 <strong>短生命周期对象</strong> 的引用，导致短生命周期对象无法被释放。</p><p>比如一个单例持有了 <code>Activity</code> 的引用，而 <code>Activity</code> 的生命周期可能很短，用户一打开就关闭了，但是单例的生命周期往往是与应用的生命周期相同的。</p></li><li><p><strong>解决</strong></p><p>如果单例需要 <code>Context</code>， 可以考虑使用 <code>ApplicationContext</code>，这样单例持有的 <code>Context</code> 引用就是与应用的生命周期相同的了。</p></li></ul></li><li><p><strong>资源未释放</strong></p><ul><li><p><strong>泄漏场景</strong></p><p>忘了注销 <code>BroadcastReceiver</code></p><p>打开了数据库游标（<code>Cursor</code>）忘了关闭</p><p>打开流忘了关闭</p><p>创建了 <code>Bitmap</code> 但是调用 <code>recycle</code> 方法回收 <code>Bitmap</code> 使用的内存</p><p>使用 <code>RxJava</code> 忘了在 <code>Activity</code> 退出时取消任务</p><p>使用协程忘了在 <code>Activity</code> 退出时取消任务</p></li></ul></li><li><p><strong>Webview</strong></p><ul><li><p><strong>泄漏场景</strong></p><p>不同的 <code>Android</code> 版本的 <code>Webview</code> 会有差异，加上不同厂商定制 <code>ROM</code> 的 <code>Webview</code> 的差异，导致 <code>Webview</code> 存在很大的兼容问题。</p><p>一般情况下，在应用中只要使用一次 <code>Webview</code>，它占用的内存就不会被释放。</p></li><li><p><strong>解决</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( mWebView!=<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果先调用destroy()方法，则会命中if (isDestroyed()) return;这一行代码，需要先onDetachedFromWindow()，再</span></span><br><span class="line">        <span class="comment">// destory()</span></span><br><span class="line">        ViewParent parent = mWebView.getParent();</span><br><span class="line">        <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ((ViewGroup) parent).removeView(mWebView);</span><br><span class="line">        &#125;</span><br><span class="line">        mWebView.stopLoading();</span><br><span class="line">        <span class="comment">// 退出时调用此方法，移除绑定的服务，否则某些特定系统会报错</span></span><br><span class="line">        mWebView.getSettings().setJavaScriptEnabled(<span class="keyword">false</span>);</span><br><span class="line">        mWebView.clearHistory();</span><br><span class="line">        mWebView.clearView();</span><br><span class="line">        mWebView.removeAllViews();</span><br><span class="line">        mWebView.destroy();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">super</span>.<span class="function">on <span class="title">Destroy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="6-2-低杀"><a href="#6-2-低杀" class="headerlink" title="6.2 低杀"></a>6.2 低杀</h2><p>在内存不足时，这种机制就会针对于所有进程进行回收(优先级由高到低，优先回收低优先级)</p><p>进程优先级：</p><ol><li><p><strong>前台进程</strong>：优先级最高的进程，是正在于用户交互的进程</p><ul><li>进程持有一个与用户交互的 Activity（该 Activity 的 onResume 方法被调用）</li><li>进程持有一个 Service，<code>[Service 与用户正在交互的 Activity 绑定]</code>  <code>[Service 调用了 startForeground() 方法(前台服务)]</code>  <code>[Service 正在执行以下生命周期函数（onCreate、onStart、onDestroy ）]</code></li><li>进程持有一个 <code>BroadcastReceiver</code>，这个 <code>BroadcastReceiver</code> 正在执行它的 <code>onReceive()</code> 方法</li></ul></li><li><p><strong>可见进程</strong>：不含有任何前台组件，但用户还能再屏幕上看见它</p><ul><li>进程持有一个 <code>Activity</code>，这个 <code>Activity</code> 处于 <code>pause</code> 状态</li><li>进程持有一个 <code>Service</code> 这个 <code>Service</code> 和一个可见的 <code>Activity</code> 绑定。</li><li>可见进程是非常重要的进程，除非前台进程已经把系统的可用内存耗光，否则系统不会终止可见进程。</li></ul></li><li><p><strong>服务进程</strong>：可能在播放音乐或在后台下载文件，除非系统内存不足，否则系统会尽量维持服务进程的运行。</p><ul><li>如果一个进程中运行着一个 <code>Service</code>，并且这个 <code>service</code> 是通过 <code>startService</code> 开启的，那这个进程就是一个服务进程。</li></ul></li><li><p><strong>后台进程</strong></p><p>系统会把后台进程（<code>Background Process</code>）保存在一个 <code>LruCache</code> 列表中，因为终止后台进程对用户体验影响不大，所以系统会酌情清理部分后台进程。</p><p>你可以在 <code>Activity</code> 的 <code>onSaveInstanceState()</code> 方法中保存一些数据，以免在应用在后台被系统清理掉后，用户已输入的信息被清空，导致要重新输入。</p><ul><li>当进程持有一个用户不可见的 <code>Activity</code>（<code>Activity</code> 的 <code>onStop()</code> 方法被调用），但是 <code>onDestroy</code> 方法没有被调用，这个进程就会被系统认定为后台进程。</li></ul></li><li><p><strong>空进程</strong>：当一个进程不包含任何活跃的应用组件，则被系统认定为是空进程。</p><p>系统保留空进程的目的是为了加快下次启动进程的速度。</p></li></ol><h2 id="6-3-内存抖动"><a href="#6-3-内存抖动" class="headerlink" title="6.3 内存抖动"></a>6.3 内存抖动</h2><p>当我们在短时间内频繁创建大量临时对象时，就会引起内存抖动，比如在一个 <code>for</code> 循环中创建临时对象实例。</p><p>内存检测表现如下<br><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/20200412160136.png" alt=""></p><p><strong>预防的方法</strong></p><ol><li>尽量避免在循环体中创建对象</li><li>尽量不要在自定义 <code>View</code> 的 <code>onDraw()</code> 方法中创建对象，因为这个方法会被频繁调用</li><li>对于能够复用的对象，可以考虑使用对象池把它们缓存起来</li></ol><hr><h1 id="7-Android-Bitmap-内存分配的变化"><a href="#7-Android-Bitmap-内存分配的变化" class="headerlink" title="7 Android Bitmap 内存分配的变化"></a>7 <strong>Android Bitmap 内存分配的变化</strong></h1><ul><li>在 <code>Android 3.0</code> 之前，<code>Bitmap</code> 对象放在 <code>Java</code> 堆，而像素数据是放在 <code>Native</code> 内存中。如果不手动调用 <code>recycle</code>，<code>Bitmap Native</code> 内存的回收完全依赖 <code>finalize</code> 函数回调，这个时机不太可控。</li><li><code>Android 3.0～Android 7.0</code> 将 <code>Bitmap</code> 对象和像素数据统一放到 <code>Java</code> 堆中，这样就算我们不调用 <code>recycle</code>，<code>Bitmap</code> 内存也会随着对象一起被回收。不过 <code>Bitmap</code> 是内存消耗的大户，把它的内存放到 <code>Java</code> 堆中似乎不是那么美妙。即使是华为 <code>Mate 20</code>，最大的 <code>Java</code> 堆限制也才到 512MB，可能我的物理内存还有 5GB，但是应用还是会因为<code>Java</code> 堆内存不足导致 <code>OOM</code>。<code>Bitmap</code> 放到 <code>Java</code> 堆的另外一个问题会引起大量的 <code>GC</code>，对系统内存也没有完全利用起来。</li><li>有没有一种实现，可以将 <code>Bitmap</code> 内存放到 <code>Nativ</code>e 中，也可以做到和对象一起快速释放，同时 <code>GC</code> 的时候也能考虑这些内存防止被滥用？<code>NativeAllocationRegistry</code> 可以一次满足你这三个要求，<code>Android 8.0</code> 正是使用这个辅助回收 <code>Native</code> 内存的机制，来实现像素数据放到 <code>Native</code> 内存中。<code>Android 8.0</code> 还新增了硬件位图 <code>Hardware Bitmap</code>，它可以减少图片内存并提升绘制效率。</li></ul><hr><h1 id="8-内存优化的两个误区"><a href="#8-内存优化的两个误区" class="headerlink" title="8 内存优化的两个误区"></a>8 内存优化的两个误区</h1><h2 id="8-1-内存占用越少越好。"><a href="#8-1-内存占用越少越好。" class="headerlink" title="8.1 内存占用越少越好。"></a>8.1 内存占用越少越好。</h2><ol><li>有些人认为内存是洪水猛兽，占用越少应用的性能越好，这种认识在具体的优化过程中很容易“用力过猛”。</li><li>应用是否占用了过多的内存，跟设备、系统和当时情况有关，而不是 <code>300MB</code>、<code>400MB</code> 这样一个绝对的数值。当系统内存充足的时候，我们可以多用一些获得更好的性能。当系统内存不足的时候，希望可以做到“用时分配，及时释放”</li></ol><h2 id="8-2-Native-内存不用管"><a href="#8-2-Native-内存不用管" class="headerlink" title="8.2 Native 内存不用管"></a>8.2 <code>Native</code> 内存不用管</h2><ol><li>虽然 <code>Android 8.0</code> 重新将 <code>Bitmap</code> 内存放回到 <code>Native</code> 中，那么我们是不是就可以随心所欲地使用图片呢？</li><li>答案当然是否定的。正如前面所说当系统物理内存不足时，<code>lmk</code> 开始杀进程，从后台、桌面、服务、前台，直到手机重启。</li></ol><hr><h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a><strong>感谢</strong></h1><blockquote><p><a href="https://time.geekbang.org/column/article/74044">极客时间 Android开发高手课</a>  </p><p><a href="https://coding.imooc.com/learn/list/308.html">慕课 Top团队大牛带你玩转Android性能分析与优化</a></p><p><a href="https://juejin.im/post/5d3ada056fb9a07eb94fd1bc#heading-3">探索 Android 内存优化方法</a></p><p><a href="https://juejin.im/post/5d3a870df265da1b855c9d41#heading-15">探索 Java 内存管理机制</a></p><p><a href="https://juejin.im/post/58b18e442f301e0068028a90">Android性能优化（三）之内存管理</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>App 初体验-启动优化💦</title>
      <link href="2019/performance-launch.html"/>
      <url>2019/performance-launch.html</url>
      
        <content type="html"><![CDATA[<p>Android 性能第一篇，随着项目功能的迭（zeng）代（jia），启动速度也会受到影响，性能优化之路的第一步，也就是启动优化，个人认为非常重要，它可以直接影响 <code>APP</code> 的留存率，没有人希望自己应用半天打不开。这篇文章就带你解决🌞用户初体验-启动优化🌞。</p><p><strong>注意：如果出现图片不显示问题请移步</strong> <a href="https://calmcenter.club/2019/PicNotShow.html">图片不显示问题</a></p><h1 id="本文主要记载"><a href="#本文主要记载" class="headerlink" title="本文主要记载"></a>本文主要记载</h1><ul><li><strong>1 启动</strong></li><li><strong>2 检测启动消耗<code>(敲黑板)</code></strong><ul><li>2.1 启动时间测量方式<ul><li>2.1.1 adb 命令启动时间测量方式</li><li>2.1.2 手动打点</li></ul></li><li>2.2 启动耗时检测方式<ul><li>2.2.1 TraceView</li><li>2.2.2 systrace</li><li>2.2.3 systrace + 函数插桩 AOP</li></ul></li></ul></li><li><strong>3 启动优化<code>(干货)</code></strong><ul><li>3.1 闪屏页展示</li><li>3.2 异步启动实践</li><li>3.3 数据重排</li><li>3.4 类的加载</li><li>3.5 延迟加载方案 IdleHandler</li><li>3.6 其他优化思路</li></ul></li></ul><hr><h1 id="1-启动"><a href="#1-启动" class="headerlink" title="1 启动"></a>1 启动</h1><p>Google官方文档 <a href="https://developer.android.com/topic/performance/launch-time.html">《Launch-Time Performance》</a> 对应用启动优化的概述</p><p>应用的启动分为冷启动、热启动、温启动，而启动最慢、挑战最大的就是冷启动：系统和App本身都有更多的工作要从头开始！我们只要知道我们处理的是冷启动的情况。</p><hr><h1 id="2-检测启动消耗-敲黑板"><a href="#2-检测启动消耗-敲黑板" class="headerlink" title="2 检测启动消耗(敲黑板)"></a>2 检测启动消耗<code>(敲黑板)</code></h1><p>“工欲善其事必先利其器”，我们需要先找到一款适合做启动优化分析的工具。</p><h2 id="2-1-启动时间测量方式"><a href="#2-1-启动时间测量方式" class="headerlink" title="2.1 启动时间测量方式"></a>2.1 启动时间测量方式</h2><h3 id="2-1-1-adb-命令启动时间测量方式"><a href="#2-1-1-adb-命令启动时间测量方式" class="headerlink" title="2.1.1 adb 命令启动时间测量方式"></a>2.1.1 adb 命令启动时间测量方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am start -W packagename&#x2F;packagename.Activity</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/20190829115742.png" alt=""></p><p>划掉的红色部分都是包名</p><table><thead><tr><th>字段</th><th>功能</th></tr></thead><tbody><tr><td>ThisTime</td><td>最后一个 Activity 启动耗时</td></tr><tr><td>TotalTIme</td><td>所有 Activity 启动耗时，比如添加启动页</td></tr><tr><td>WaitTime</td><td>AMS 启动 Activity 的总耗时</td></tr><tr><td>ThisTime ≤ TotalToime &lt; WaitTime</td><td></td></tr></tbody></table><p>线下方便使用、可以测量竞品、不能带到线上</p><h3 id="2-1-2-手动打点"><a href="#2-1-2-手动打点" class="headerlink" title="2.1.2 手动打点"></a>2.1.2 手动打点</h3><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LaunchTimer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> sTime;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startRecord</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sTime = System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">endRecord</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        endRecord(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">endRecord</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> cost = System.currentTimeMillis() - sTime;</span><br><span class="line">        LogUtils.e(<span class="string">&quot;LaunchTimer&quot;</span>, msg + <span class="string">&quot; cost &quot;</span> + cost);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在应用启动中，我们所能接收到最早的回调是 <code>Application</code> 中 <code>attachBaseContext(Context context)</code> ，所以只能将 <code>startRecord()</code> 写到这个回调中</p><p>应用启动的结束时间，是用户可操作的时间，先了解两个误区</p><p><code>onAttachedToWindow()</code> 这个方法是在 <code>onResume</code> 之后，只调用一次</p><p><code>onWindowFocusChanged(boolean hasFocus)</code> 这个方法是在获取焦点和失去焦点是调用，在 <code>onAttachedToWindow()</code> 之后调用</p><p>这两个方法，回调时，用户并不可以操作，计算启动耗时的最好的时机应该是某个数据被加载出来后，当然会掺杂一些网络因素，但这里不是为了数据，只是为了用户体验，可以使用一些监听方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mView.getViewTreeObserver().addOnPreDrawListener(<span class="keyword">new</span> ViewTreeObserver.OnPreDrawListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onPreDraw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mView.getViewTreeObserver().removeOnPreDrawListener(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">mView.getViewTreeObserver().addOnDrawListener(<span class="keyword">new</span> ViewTreeObserver.OnDrawListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mView.getViewTreeObserver().removeOnDrawListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在 View 将要绘制的时候去进行耗时的统计，<code>addOnDrawListener()</code> 需要 <code>API 16</code></p><h2 id="2-2-启动耗时检测方式"><a href="#2-2-启动耗时检测方式" class="headerlink" title="2.2 启动耗时检测方式"></a>2.2 启动耗时检测方式</h2><h3 id="2-2-1-TraceView"><a href="#2-2-1-TraceView" class="headerlink" title="2.2.1 TraceView"></a>2.2.1 TraceView</h3><p>图形化界面的形式展示出执行时间、调用栈，包含所有线程，信息全面</p><p>但是加入 <code>TraceView</code> 的代码后，运行时开销严重，整体都会变慢，可能会带骗优化方向</p><ul><li>通过代码跟踪💦</li></ul><p>只能用于某一个方法的检测</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Debug.startMethodTracing(&quot;xxx&quot;);</span><br><span class="line">...</span><br><span class="line">Debug.stopMethodTracing();</span><br></pre></td></tr></table></figure><p>默认生成文件在 <code>mnt/sdcard/Android/data/packagename/fils</code>  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb pull &#x2F;sdcard&#x2F;Android&#x2F;data&#x2F;packagename&#x2F;fils&#x2F;my.trace</span><br></pre></td></tr></table></figure><p>这样可以将 <code>trace</code> 文件拷贝到项目根目录</p><p>也可以通过 <code>Device File Explorer</code>(AS 右下角) 找到文件，右键点击 <code>Sava as…</code></p><ul><li>通过命令跟踪💦</li></ul><p>可用于整个开始结束的过程(内容会比较多~)</p><p>开始跟踪</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am start -n packagename&#x2F;packagename.Activity --start-profiler &#x2F;data&#x2F;local&#x2F;tmp&#x2F;my.trace --sampling 1000</span><br></pre></td></tr></table></figure><p>终止跟踪</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am profile stop</span><br></pre></td></tr></table></figure><p>拉取文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb pull &#x2F;data&#x2F;local&#x2F;tmp&#x2F;my.trace</span><br></pre></td></tr></table></figure><p>这种方法可以检测启动到调用终止期间的全部内容，但是有些手机出来的 <code>trace</code> 文件时 <code>0B</code>，这就需要在需要停止的地方写上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Debug.stopMethodTracing();</span><br></pre></td></tr></table></figure><p>然后调用开始追踪，会自动停止。文件会放在 <code>data/local/tmp</code> 下。</p><ul><li>查看 Trace 文件💦<br><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/20191126115732.png" alt=""></li></ul><p>这就是用 <code>AndroidStudio</code> 查看生成的 <code>TraceView</code> 文件</p><ol><li><p>范围选择</p><p>标有 <code>Cpu usage details unavailable</code> 的地方可以选择时间范围；标有 ·THREADS· 的地方可以选择某条线程，括号中的 <code>67</code> 表示检测全称有 <code>67</code> 条线程。选择时间或线程底部的 <code>Call Chart</code> 都会有相应的变化。</p></li><li><p>执行选择</p><p>在线程选择下有一个 <code>Wall Clock Time</code> 这个表示真正执行的时间，可以切换为 <code>Thread Time</code> 表示 <code>CPU</code> 执行的时间，<code>Thread Time</code> 始终小于 <code>Wall Clock Time</code>。</p></li><li><p>CallChart</p><p>从上到下，调用者在上方，被调用者在下方；<code>系统 API</code> 是橙色、<code>应用自身调用</code> 是绿色、<code>第三方 API</code> 是蓝色，看绿色的部分很直观的可以看出我们自己代码在哪里耗时了~</p></li><li><p>TopDown</p></li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/20191126121637.png" alt=""></p><table><thead><tr><th>标题</th><th>作用</th></tr></thead><tbody><tr><td><strong>Total</strong></td><td>整个函数执行时间</td></tr><tr><td><strong>Self</strong></td><td>函数代码内执行时间</td></tr><tr><td><strong>Children</strong></td><td>子函数耗时</td></tr></tbody></table><p>🌞举个栗子🌞：调用 <code>A</code> 函数整体时间是 <code>Total</code> ，在函数中执行了一行代码耗时 <code>Self</code> ，然后调用 <code>B</code> 函数耗时 <code>Children</code></p><p>这两个方式是比较常用的方式，如果是应用自身方法都可以点击右键进入源码所在位置。</p><ul><li>总结💦</li></ul><ol><li>运行时开销严重，整体都会变慢(因为 <code>TraceView</code> 要抓取所有线程的所有执行函数以及顺序)</li><li>可能会带偏优化方向(本来不好时间的函数可能加入 <code>TraceView</code> 后，变的非常耗时)</li></ol><h3 id="2-2-2-systrace"><a href="#2-2-2-systrace" class="headerlink" title="2.2.2 systrace"></a>2.2.2 systrace</h3><p>结合 Android 内核的数据，生成 HTML 报告，<code>API 18</code> 以上，推荐 <code>TraceCompat</code></p><ul><li>首先清空后台💦</li></ul><p>杀掉所有应用，防止出现莫名莫名方法。</p><ul><li>在需要检测的地方写入代码(可以不写，但是会少一些 tag 提示)💦</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TraceCompat.beginSection(&quot;AppOnCreate&quot;);</span><br><span class="line">...</span><br><span class="line">TraceCompat.endSection();</span><br></pre></td></tr></table></figure><ul><li>执行检测💦</li></ul><p>首先进入 <code>SDK</code> 目录，<code>Sdk\platform-tools\systrace\</code> 目录下有一个 <code>systrace.py</code> 文件，打开 <code>cmd</code> 输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python systrace.py -b 32768 -t 5 -a &lt;packagename&gt; -o test.log.html sched gfx view wm am</span><br></pre></td></tr></table></figure><p>这种方式是 <code>5</code> 秒后自动输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python systrace.py gfx view wm am pm ss dalvik sched -b 32768 -a &lt;packagename&gt; -o test.log.html</span><br></pre></td></tr></table></figure><p>这种方式可以在自己收集完后，点击 <code>Enter</code> 键停止收集</p><p>两种内容是不太一样的， <code>-t</code> 表示时间，<code>-a</code> 表示包名，<code>-o</code> 输出文件名，最终在当前目录打开文件即可看到，文件只能使用 <code>Chrome</code> 来打开，如果打开 <code>HTML</code> 出现 </p><p><code>Unable to select a master clock domain because no path can be found from &quot;SYSTRACE&quot; to &quot;LINUX_FTRACE_GLOBAL&quot;.</code></p><p>那就是命令出错了，命令我也是收集了好久，一定要注意必须是 <code>python 2.x</code>，而不是能 <code>3.x</code>，否则可能会出现问题。另外，<code>buffer</code> 大小不可过大，否则会出现 <code>oom</code> 异常。最终找到可用的，想了解更多的请查看 <a href="http://gityuan.com/2016/01/17/systrace/">Gityuan</a> 或 <a href="https://source.android.com/devices/tech/debug/systrace">官方文档</a> </p><ul><li>分析文件</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/20191212120416.png" alt=""></p><p>这里可以看到 <code>CPU</code> 核心数以及运行状态，还有各个线程。</p><p>在 <code>UI Thread</code> 中的 <code>AppOnCreate</code> 正是我们在之前的代码埋 <code>tag</code> 点，点击条目并按 <code>M</code> 键可以查看具体信息。右上角是可以搜索 <code>tag</code> 的。</p><p>具体信息中有 <code>Wall Duration</code> （代码执行时间） <code>CPU Duration</code> （代码消耗 CPU 的时间）两者出现差值的原因是同步锁冲突。 </p><p>这种方式不仅可以帮助监控启动过程中性能问题，卡顿优化的时候也可以用这种方式。因为它会把 <code>UI</code> 的渲染也检测到。</p><ul><li>总结💦</li></ul><ol><li>轻量级，开销小</li><li>直观的反应 CPU 利用率</li></ol><p>想要了解更多，全力推荐 <a href="https://www.androidperformance.com/2019/05/28/Android-Systrace-About/">Android Systrace</a> </p><h3 id="2-2-3-systrace-函数插桩-AOP-Aspect-Oriented-Programming"><a href="#2-2-3-systrace-函数插桩-AOP-Aspect-Oriented-Programming" class="headerlink" title="2.2.3 systrace + 函数插桩 AOP(Aspect Oriented Programming)"></a>2.2.3 systrace + 函数插桩 AOP(Aspect Oriented Programming)</h3><hr><p> 面向切面编程，针对同一类问题的统一处理，无侵入添加代码。</p><p>在根目录的 <code>build.gradle</code> 下，最新版本请查看 <a href="https://github.com/HujiangTechnology/gradle_plugin_android_aspectjx">AspectJX 开源地址</a></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classpath <span class="string">&#x27;com.hujiang.aspectjx:gradle-android-plugin-aspectjx:2.0.8&#x27;</span></span><br></pre></td></tr></table></figure><p>在 <code>app</code> 模块下添加如下，通过我的测试这些引用只能添加在 <code>app</code> 模块下，添加在其他子模块下不生效。最新版本请查看 <a href="http://www.eclipse.org/aspectj/downloads.php#stable_release">AspectJ官网</a></p><p>顶部</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;android-aspectjx&#x27;</span></span><br></pre></td></tr></table></figure><p><code>dependencies</code> 内</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">api <span class="string">&#x27;org.aspectj:aspectjrt:1.9.5&#x27;</span></span><br></pre></td></tr></table></figure><p>下面是通过注解的方式结合 <code>Systrace</code> 进行埋点。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AnnotationRetention.SOURCE：不存储在编译后的 Class 文件。</span></span><br><span class="line"><span class="comment"> * AnnotationRetention.BINARY：存储在编译后的 Class 文件，但是反射不可见。</span></span><br><span class="line"><span class="comment"> * AnnotationRetention.RUNTIME：存储在编译后的 Class 文件，反射可见。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Retention(AnnotationRetention.RUNTIME)</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AnnotationTarget.CLASS：类，接口或对象，注解类也包括在内。</span></span><br><span class="line"><span class="comment"> * AnnotationTarget.ANNOTATION_CLASS：只有注解类。</span></span><br><span class="line"><span class="comment"> * AnnotationTarget.TYPE_PARAMETER：Generic type parameter (unsupported yet)通用类型参数（还不支持）。</span></span><br><span class="line"><span class="comment"> * AnnotationTarget.PROPERTY：属性。</span></span><br><span class="line"><span class="comment"> * AnnotationTarget.FIELD：字段，包括属性的支持字段。</span></span><br><span class="line"><span class="comment"> * AnnotationTarget.LOCAL_VARIABLE：局部变量。</span></span><br><span class="line"><span class="comment"> * AnnotationTarget.VALUE_PARAMETER：函数或构造函数的值参数。</span></span><br><span class="line"><span class="comment"> * AnnotationTarget.CONSTRUCTOR：仅构造函数（主函数或者第二函数）。</span></span><br><span class="line"><span class="comment"> * AnnotationTarget.FUNCTION：方法（不包括构造函数）。</span></span><br><span class="line"><span class="comment"> * AnnotationTarget.PROPERTY_GETTER：只有属性的 getter。</span></span><br><span class="line"><span class="comment"> * AnnotationTarget.PROPERTY_SETTER：只有属性的 setter。</span></span><br><span class="line"><span class="comment"> * AnnotationTarget.TYPE：类型使用。</span></span><br><span class="line"><span class="comment"> * AnnotationTarget.EXPRESSION：任何表达式。</span></span><br><span class="line"><span class="comment"> * AnnotationTarget.FILE：文件。</span></span><br><span class="line"><span class="comment"> * AnnotationTarget.TYPEALIAS：<span class="doctag">@SinceKotlin</span>(&quot;1.1&quot;) 类型别名，Kotlin1.1已可用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(AnnotationTarget.FUNCTION)</span></span><br><span class="line"><span class="keyword">annotation</span> <span class="class"><span class="keyword">class</span> <span class="title">TraceCompat</span></span></span><br></pre></td></tr></table></figure><p>具体的切入代码，需要将 <code>packagename</code> 换成自己的路径名字</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TraceCompatAspect</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Pointcut(<span class="meta-string">&quot;execution(@packagename.TraceCompat * *(..))&quot;</span>)</span> <span class="comment">//方法切入点</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">methodAnnotated</span><span class="params">()</span></span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(<span class="meta-string">&quot;methodAnnotated()&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">aroundJoinPoint</span><span class="params">(joinPoint: <span class="type">ProceedingJoinPoint</span>)</span></span> &#123;</span><br><span class="line">        TraceCompat.beginSection(<span class="string">&quot;TraceCompat&quot;</span>)</span><br><span class="line">        <span class="comment">//执行原方法</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            joinPoint.proceed()</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            TraceCompat.endSection()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在需要埋点的加入注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TraceCompat</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就完成了 <code>AOP</code> 埋点辅助<code>systrace</code> 监控的方式。<code>AOP</code> 还有很多更强大更方便的用法，这里只是一种注解切入的方式。更多用法请查看其它文章。</p><p>由于我现在使用 <code>AOP</code> 还存在很多问题，还在研究中。。。(上面的例子是可以使用的)</p><h3 id="2-2-4-Nanoscope"><a href="#2-2-4-Nanoscope" class="headerlink" title="2.2.4 Nanoscope"></a>2.2.4 Nanoscope</h3><p>还未使用过 ~ </p><p>在<a href="https://time.geekbang.org/column/article/74044">极客时间 《Android开发高手课》</a>   中提到了 <a href="https://github.com/uber/nanoscope">Nanoscope</a> ，它是在 <code>instrument</code> 类型的性能分析工具中性能损耗比较小的。</p><p>它的实现原理是直接修改 <code>Android</code> 虚拟机源码，在 <code>ArtMethod</code> 执行入口和执行结束位置增加埋点代码，将所有的信息先写到内存，等到 <code>trace</code> 结束后才统一生成结果文件。在使用过程可以明显感觉到应用不会因为开启 <code>Nanoscope</code> 而感到卡顿，但是 <code>trace</code> 结束生成结果文件这一步需要的时间比较长。<strong>另一方面它可以支持分析任意一个应用，可用于做竞品分析。</strong></p><p>但是它也有不少限制：</p><ul><li>需要自己刷 <code>ROM</code>，并且当前只支持 <code>Nexus 6P</code>，或者采用其提供的 <code>x86</code> 架构的模拟器。</li><li>默认只支持主线程采集，其他线程需要 <a href="https://github.com/uber/nanoscope/wiki/Architecture%3A-Nanoscope-ROM#java-api">代码手动设置</a> 。考虑到内存大小的限制，每个线程的内存数组只能支持大约 <code>20</code> 秒左右的时间段。</li></ul><p><code>Uber</code> 写了一系列自动化脚本协助整个流程，使用起来还算简单。<code>Nanoscope</code> 作为基本没有性能损耗的 <code>instrument</code> 工具，它非常适合做启动耗时的自动化分析。</p><p><code>Nanoscope</code> 生成的是符合 <code>Chrome tracing</code> 规范的 <code>HTML</code> 文件。我们可以通过脚本来实现两个功能：</p><p>第一个是反混淆。通过 <code>mapping</code> 自动反混淆结果文件。</p><p>第二个是自动化分析。传入相同的起点和终点，实现两个结果文件的<code>diff</code>，自动分析差异点。</p><p>这样我们可以每天定期去跑自动化启动测试，查看是否存在新增的耗时点。</p><hr><h1 id="3-启动优化-干货"><a href="#3-启动优化-干货" class="headerlink" title="3 启动优化(干货)"></a>3 启动优化<code>(干货)</code></h1><h2 id="3-1-闪屏页展示"><a href="#3-1-闪屏页展示" class="headerlink" title="3.1 闪屏页展示"></a>3.1 闪屏页展示</h2><p>闪屏页是优化启动速度的一个小技巧，虽然对实际的启动速度没有任何帮助，但是能让用户感觉应用到应用在第一时间已经被打开。</p><p>合并闪屏和主页面的 Activity，减少一个 Activity 会给线上带来 100 毫秒左右的优化。但是如果这样做的话，管理时会非常复杂。</p><p>闪屏如果存在网络请求，一般都是提前准备好闪屏页的，在下一次生效。</p><p>具体操作文末参考中会有 ~ 这里不再说明。</p><h2 id="3-2-异步启动实践"><a href="#3-2-异步启动实践" class="headerlink" title="3.2 异步启动实践"></a>3.2 异步启动实践</h2><h3 id="3-2-1-启动器"><a href="#3-2-1-启动器" class="headerlink" title="3.2.1 启动器"></a>3.2.1 启动器</h3><p>微信内部使用的 <a href="https://mp.weixin.qq.com/s/6Q818XA5FaHd7jJMFBG60w?">mmkernel</a></p><p>阿里最近开源的 <a href="https://github.com/alibaba/alpha">Alpha</a> 启动框架</p><p><a href="https://yq.aliyun.com/articles/710466">历时1年，上百万行代码！首次揭秘手淘全链路性能优化（上）</a> </p><p>慕课网中学习到的 启动器 <code>Task</code> </p><p>它们为各个任务建立依赖关系，最终构成一个有向无环图。对于可以并发的任务，会通过线程池最大程度提升启动速度。</p><h3 id="3-2-1-异步Layout子线程预加载"><a href="#3-2-1-异步Layout子线程预加载" class="headerlink" title="3.2.1 异步Layout子线程预加载"></a>3.2.1 异步Layout子线程预加载</h3><p>参考文章 <a href="https://juejin.im/post/5d63cdf7f265da03ed195f68?utm_source=gold_browser_extension#comment">Android - 一种新奇的冷启动速度优化思路(Fragment极度懒加载 + Layout子线程预加载)</a> </p><p>遇到个点，如果 <code>xml</code> 中是 <code>com.google.android.material.appbar.AppBarLayout</code> 等 <code>google</code> 包里的，需要加上一条属性</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:theme=&quot;@style/Theme.AppCompat.Light.DarkActionBar&quot;</span><br></pre></td></tr></table></figure><p>这个属性与自己 <code>Activity</code> 的 <code>theme</code> 相对应。</p><p> <a href="https://github.com/luckybilly/PreLoader">预加载：页面启动速度优化利器 PreLoader</a></p><h2 id="3-3-数据重排"><a href="#3-3-数据重排" class="headerlink" title="3.3 数据重排"></a>3.3 数据重排</h2><p>支付宝 <a href="https://mp.weixin.qq.com/s/79tAFx6zi3JRG-ewoapIVQ">《通过安装包重排布优化 Android 端启动性能》</a></p><h2 id="3-4-类重排"><a href="#3-4-类重排" class="headerlink" title="3.4 类重排"></a>3.4 类重排</h2><p>本人费劲心血自己自己实现了一次~ <a href="https://calmcenter.club/2020/package-optimization.html#Redex-Ubuntu-具体实践">Redex Ubuntu 实现</a> </p><p>更多资料：</p><p><code>Facebook</code> 开源的 Dex 优化工具 <a href="https://github.com/facebook/redex/blob/master/docs/Interdex.md">ReDex</a> </p><p><a href="https://mp.weixin.qq.com/s/Bf41Kez_OLZTyty4EondHA?">Redex 初探与 Interdex：Andorid 冷启动优化</a></p><p><a href="https://mp.weixin.qq.com/s/Hquq8iJvZuN-gynVFxCCNA">都9102年了，Android 冷启动优化除了老三样还有哪些新招？</a></p><h2 id="3-5-延迟加载方案-IdleHandler"><a href="#3-5-延迟加载方案-IdleHandler" class="headerlink" title="3.5 延迟加载方案 IdleHandler"></a>3.5 延迟加载方案 IdleHandler</h2><p>利用 <code>IdleHandler</code> 特性，空闲时执行初始化。</p><p><strong><code>IdleHandler</code> 可以用来提升性能，主要用在我们希望能够在当前线程消息队列空闲时做些事情</strong> （譬如 <code>UI</code> 线程在显示完成后，如果线程空闲我们就可以提前准备其他内容）的情况下，不过最好不要做耗时操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Looper.myQueue().addIdleHandler(new IdleHandler() &#123;  </span><br><span class="line">    @Override  </span><br><span class="line">    public boolean queueIdle() &#123;  </span><br><span class="line">        &#x2F;&#x2F;你要处理的事情</span><br><span class="line">        return false;    </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果返回 <code>true</code>, 则会一直执行，如果返回 <code>false</code>，执行完一次后就会被移除消息队列。我们可以将从服务器获取推送 <code>Token</code> 的任务放在延迟 <code>IdleHandler</code>中执行，或者把一些不重要的 <code>View</code> 的加载放到 <code>IdleHandler</code> 中执行</p><h2 id="3-6-其他优化思路"><a href="#3-6-其他优化思路" class="headerlink" title="3.6 其他优化思路"></a>3.6 其他优化思路</h2><h3 id="AndroidX-App-Startup"><a href="#AndroidX-App-Startup" class="headerlink" title="AndroidX App Startup"></a>AndroidX App Startup</h3><p><code>App</code> 启动运行时会初始化一些逻辑，它们为了方便开发者使用，避免开发者手动调用，使用 <code>ContentProvider</code> 进行初始化</p><ul><li>多个 <code>ContentProvider</code> 会增加了 <code>App</code> 启动运行的时间。</li><li><code>ContentProvider</code> 的 <code>onCreate</code> 方法会先于 <code>Application</code> 的 <code>OnCreate</code> 方法执行，这是在冷启动阶段自动运行初始化的，</li></ul><p>这样只会增加 <code>App</code> 的加载时间，用户希望 <code>App</code> 加载得快，启动慢会带来糟糕的用户体验，<code>AndroidX App Startup</code> 正是为了解决这个问题而出现的。</p><p><a href="https://developer.android.com/topic/libraries/app-startup">App Startup</a>   <a href="https://juejin.im/post/5ee4bbe4f265da76b559bdfe?utm_source=gold_browser_extension#comment">Jetpack 最新成员 AndroidX App Startup 实践以及原理分析</a> </p><h3 id="5-0-以下机型-MultiDex-优化"><a href="#5-0-以下机型-MultiDex-优化" class="headerlink" title="5.0 以下机型 MultiDex 优化"></a><code>5.0</code> 以下机型 <code>MultiDex</code> 优化</h3><p><a href="https://juejin.im/post/5d95f4a4f265da5b8f10714b?utm_source=gold_browser_extension#comment">面试官：今日头条启动很快，你觉得可能是做了哪些优化？</a></p><h3 id="GC-优化"><a href="#GC-优化" class="headerlink" title="GC 优化"></a>GC 优化</h3><p>支付宝提出一种 <a href="https://mp.weixin.qq.com/s/ePjxcyF3N1vLYvD5dPIjUw">GC 抑制</a> 的方案</p><p>在启动过程，要尽量减少 <code>GC</code> 的次数，避免造成主线程长时间的卡顿。</p><p>特别是对 <code>Dalvik</code> 来说，我们可以通过 <code>systrace</code> 单独查看整个启动过程 <code>GC</code> 的时间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python systrace.py dalvik -b 90960 -a com.sample.gc</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GC使用的总耗时，单位是毫秒</span></span><br><span class="line">Debug.getRuntimeStat(<span class="string">&quot;art.gc.gc-time&quot;</span>);</span><br><span class="line"><span class="comment">// 阻塞式GC的总耗时</span></span><br><span class="line">Debug.getRuntimeStat(<span class="string">&quot;art.gc.blocking-gc-time&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>避免进行大量的字符串操作，特别是序列化和反序列化</li><li>频繁创建的对象需要考虑复用</li><li>转移到 Native 实现</li></ul><p>参考 <a href="https://juejin.im/post/5be1077d518825171140dbfa">支付宝客户端架构解析：Android 客户端启动速度优化之「垃圾回收」</a></p><h3 id="系统调用优化"><a href="#系统调用优化" class="headerlink" title="系统调用优化"></a>系统调用优化</h3><p>通过 <code>systrace</code> 的 System Service 类型，我们可以看到启动过程 <code>System Server</code> 的 CPU 工作情况。在启动过程，我们尽量不要做系统调用，例如 </p><ul><li><strong>启动过程中减少系统调用</strong>，避免与 <code>AMS</code>、<code>WMS</code> 竞争锁。启动过程中本身 <code>AMS</code> 和 <code>WMS</code> 的工作就很多，且 <code>AMS</code> 和 <code>WMS</code> 很多操作都是带锁的，如果此时 <code>App</code> 再有过多的 <code>Binder</code> 调用与 <code>AMS</code>、<code>WMS</code> 通信，<code>SystemServer</code> 就会出现大量的锁等待，阻塞关键操作</li><li><strong>启动过程中不要启动子进程</strong>，如果好几个进程同时启动，系统负担则会加倍，<code>SystemServer</code> 也会更繁忙</li><li><strong>启动过程中除了 Activity 之外的组件启动要谨慎</strong>，因为四大组件的启动都是在主线程的，如果组件启动慢，占用了 <code>Message</code> 通道，也会影响应用的启动速度</li><li><code>Application</code> 和主 <code>Activity</code> 的<code>onCreate</code> 中异步初始化某些代码</li></ul><p>在启动过程也不要过早地拉起应用的其他进程，System Server 和新的进程都会竞争 CPU 资源。</p><h3 id="线程优化"><a href="#线程优化" class="headerlink" title="线程优化"></a>线程优化</h3><p>线程优化就像做填空题和解锁题，我们希望能把所有的时间片都利用上，因此主线程和各个线程都是一直满载的。当然我们也希望每个线程都开足马力向前跑，而不是作为接力棒。所以线程的优化主要在于减少 CPU 调度带来的波动，让应用的启动时间更加稳定。</p><p>从具体的做法来看，线程的优化一方面是控制线程数量，线程数量太多会相互竞争 CPU 资源，因此要有统一的线程池，并且根据机器性能来控制数量。</p><p>3.2.1 启动器 提到，合理分配线程数量。</p><p>另一方面是检查线程间的锁。</p><h3 id="业务优化"><a href="#业务优化" class="headerlink" title="业务优化"></a>业务优化</h3><p>我们首先需要梳理清楚当前启动过程正在运行的每一个模块，哪些是一定需要的、哪些可以砍掉、哪些可以懒加载。</p><p>通过梳理之后，剩下的都是启动过程一定要用的模块。</p><p>这个时候，我们只能硬着头皮去做进一步的优化。优化前期需要“抓大放小”，先看看主线程究竟慢在哪里。</p><p>退而求其次，我们要考虑这些任务是不是可以通过异步线程预加载实现（上面有讲到），但需要注意的是过多的线程预加载会让我们的逻辑变得更加复杂。</p><h3 id="I-O-优化"><a href="#I-O-优化" class="headerlink" title="I/O 优化"></a>I/O 优化</h3><p>启动过程不建议出现网络 I/O</p><p>磁盘 I/O 是启动优化一定要抠的点</p><p>还有一个是数据结构的选择问题，我们在启动过程只需要读取 <code>Setting.sp</code> 的几项数据，不过 <code>SharedPreference</code> 在初始化的时候还是要全部数据一起解析。如果它的数据量超过 1000 条，启动过程解析时间可能就超过 100 毫秒。如果只解析启动过程用到的数据项则会很大程度减少解析时间，启动过程适合使用随机读写的数据结构。</p><h3 id="保活"><a href="#保活" class="headerlink" title="保活"></a>保活</h3><p>保活可以减少 Application 创建跟初始化的时间，让冷启动变成温启动。不过在 Target 26 之后，保活的确变得越来越难。</p><p>对于大厂来说，可能需要寻求厂商合作的机会，例如微信的 <a href="https://www.geekpark.net/news/233791">Hardcoder</a> 方案和 <code>OPPO</code> 推出的 <code>Hyper Boost</code> 方案。根据<code>OPPO</code> 的数据，对于手机 <code>QQ</code>、淘宝、微信启动场景会直接有 20% 以上的优化。</p><p>有的时候你问为什么微信可以保活？为什么它可以运行的那么流畅？这里可能不仅仅是技术上的问题，当应用体量足够大，就可以倒逼厂商去专门为它们做优化。</p><h3 id="插件化和热修复"><a href="#插件化和热修复" class="headerlink" title="插件化和热修复"></a>插件化和热修复</h3><p>大部分的框架在设计上都存在大量的 Hook 和私有 <code>API</code> 调用，带来的缺点主要有两个：</p><ul><li>稳定性差。虽然大家都号称兼容 100% 的机型，由于厂商的兼容性、安装失败、<code>dex2oat</code> 失败等原因，还是会有那么一些代码和资源的异常。Android P 推出的 <code>non-sdk-interface</code> 调用限制，以后适配只会越来越难，成本越来越高。</li><li>性能差。Android Runtime 每个版本都有很多的优化，因为插件化和热修复用到的一些黑科技，导致底层 Runtime 的优化我们是享受不到的。Tinker 框架在加载补丁后，应用启动速度会降低 5%～10%。</li></ul><p>应用加固对启动速度来说简直是灾难，有时候我们需要做一些权衡和选择。</p><h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a><strong>感谢</strong></h1><blockquote><p><a href="https://time.geekbang.org/column/article/74044">极客时间 Android开发高手课</a>  </p><p><a href="https://www.androidperformance.com/2019/11/18/Android-App-Lunch-Optimize/">Android App 启动优化全记录</a> </p><p><a href="https://juejin.im/post/5be1077d518825171140dbfa">支付宝客户端架构解析：Android 客户端启动速度优化之「垃圾回收」</a> </p><p>以及上文中的链接</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dalvik 寄存器</title>
      <link href="2019/dalvikbase.html"/>
      <url>2019/dalvikbase.html</url>
      
        <content type="html"><![CDATA[<h1 id="Dalvik-寄存器"><a href="#Dalvik-寄存器" class="headerlink" title="Dalvik 寄存器"></a>Dalvik 寄存器</h1><a id="more"></a><h2 id="寄存器命名法"><a href="#寄存器命名法" class="headerlink" title="寄存器命名法"></a>寄存器命名法</h2><h2 id="Dalvik-字节码"><a href="#Dalvik-字节码" class="headerlink" title="Dalvik 字节码"></a>Dalvik 字节码</h2><h2 id="Dalvik-指令集"><a href="#Dalvik-指令集" class="headerlink" title="Dalvik 指令集"></a>Dalvik 指令集</h2><p>Dalvik 指令在调用格式上模仿了 C 语言的调用约定。Dalvik 指令的语法与助记符有如下特点。</p><ul><li>参数采用从目标 (detination) 到 (source)的方式</li><li>根据字节码大小与类型的不同, 为一些字节码添加了名称后缀以消除歧义<ul><li>32 位常规类型的字节码未添加任何后缀。</li><li>64 位常规类型的字节码添加 -wide 后缀。</li><li>对特殊类型的字节码, 根据具体类型添加后缀, 可以使 -boolean、-byte、-char、-short、-int、-long、-float、-double、-object、-string、-class、-void中的一个</li></ul></li><li>根据字节码布局的选项不同, 为一些字节码添加了字节码后缀以消除歧义。这些后缀通过字节码主名称后添加斜杠来分割。</li><li>在指令集的描述中, 宽度值中的每个字母 都表示 4 位的宽度。</li></ul><h3 id="空操作指令"><a href="#空操作指令" class="headerlink" title="空操作指令"></a>空操作指令</h3><p>空操作指令的助记符为 nop, 它的值为 00。nop 指令通常用于对齐代码, 不进行实际操作。</p><h3 id="数据操作指令"><a href="#数据操作指令" class="headerlink" title="数据操作指令"></a>数据操作指令</h3><p>数据操作指令为 move, 其原型为 move destination, source。根据字节码大小与类型的不同, move 指令有不同的后缀, 如下：</p><table><thead><tr><th align="left"><strong>指令</strong></th><th align="left"><strong>描述</strong></th></tr></thead><tbody><tr><td align="left">move vA, vB</td><td align="left">指令用于将 vB 寄存器的值赋值给 vA 寄存器, <br/>源寄存器和目的寄存器都是 4 位</td></tr><tr><td align="left">move/from16 vAA, vBBBB</td><td align="left">指令用于将 vBBBB 寄存器的值赋值给 vAA 寄存器, <br/>源寄存器为 16 位, 目的寄存器为 8 位</td></tr><tr><td align="left">move/16 vAAAA, vBBBB</td><td align="left">指令用于将 vBBBB 寄存器的值赋值给 vAAAA 寄存器, <br>源寄存器和目的寄存器都是 16 位</td></tr><tr><td align="left">move-wide vA, vB</td><td align="left">指令用于为 4 位的寄存器对赋值, 源寄存器和目的寄存器都是 4 位</td></tr><tr><td align="left">move-wide/from16 vAA, vBBBB</td><td align="left">与 move-wide 相同</td></tr><tr><td align="left">move-wide/16 vAA, vBBBB</td><td align="left">与 move-wide 相同</td></tr><tr><td align="left">move-object vA,vB</td><td align="left">指令用于为对象赋值, 源寄存器和目的寄存器都是 4 位</td></tr><tr><td align="left">move-object/from16 vAA, vBBBB</td><td align="left">指令用于为对象赋值, 源寄存器为 16 位, 目的寄存器为 8 位</td></tr><tr><td align="left">move-object/16 vAAAA, vBBBB</td><td align="left">指令用于为对象赋值, 源寄存器和目的寄存器都是 16 位</td></tr><tr><td align="left">move-result vAA</td><td align="left">指令用于将上一个 invoke 类型指令操作的单字非对象结果赋给 vAA 寄存器</td></tr><tr><td align="left">move-result-wide vAA</td><td align="left">指令用于将上一个 invoke 类型指令操作的双字非对象结果赋给 vAA 寄存器</td></tr><tr><td align="left">move-result-object vAA</td><td align="left">指令用于将上一个 invoke 类型指令操作的对象结果赋给 vAA 寄存器</td></tr><tr><td align="left">move-exception vAA</td><td align="left">指令用于将一个在运行时发生的异常保存到 vAA 寄存器中。<br>这条指令必须在异常发生时由异常处理器使用, 否则指令无效</td></tr></tbody></table><h3 id="返回指令"><a href="#返回指令" class="headerlink" title="返回指令"></a>返回指令</h3><p>返回指令是指函数结束时运行的最后一条指令, 它的基础字节码为 return, 如下：  </p><table><thead><tr><th><strong>指令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>return-void</td><td>指令表示函数从一个 void 方法返回</td></tr><tr><td>return vAA</td><td>指令表示函数返回一个 32 位非对象类型的值, 返回值寄存器为 8 位的寄存器 vAA</td></tr><tr><td>return-wide vAA</td><td>指令表示函数返回一个 64 位非对象类型的值, 返回值寄存器为 8 位的寄存器对 vAA</td></tr><tr><td>return-object vAA</td><td>指令表示函数返回一个对象类型的值, 返回值为 8 位的寄存器 vAA</td></tr></tbody></table><h3 id="数据定义指令"><a href="#数据定义指令" class="headerlink" title="数据定义指令"></a>数据定义指令</h3><p>数据定义指令用来定义程序中用到的常量、字符串、类等数据, 它的基础字节码为 const, 如下：</p><table><thead><tr><th><strong>指令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>const/4 vA,#+B</td><td>指令用于将数值符号扩展为 32 位后赋给寄存器 vA</td></tr><tr><td>const/16 vAA,#+BBBB</td><td>指令用于将数值符号扩展为 32 位后赋给寄存器 vAA</td></tr><tr><td>const vAA,#+BBBBBBBB</td><td>指令用于将数值赋给寄存器 vAA</td></tr><tr><td>const/high16 vAA,#+BBBB0000</td><td>指令用于将数值右边零扩展为 32 位后赋给寄存器 vAA</td></tr><tr><td>const-wide/16 vAA,#+BBBB</td><td>指令用于将数值扩展为 64 位后赋给寄存器对 vAA</td></tr><tr><td>const-wide/32 vAA,#+BBBBBBBB</td><td>指令用于将数值扩展为 64 位后赋给寄存器对 vAA</td></tr><tr><td>const-wide vAA,#+BBBBBBBBBBBBBBBB</td><td>指令用于将数值赋给寄存器对 vAA</td></tr><tr><td>const-wide/hight16 vAA,#+BBBB000000000000</td><td>指令用于将数值右边零扩展为 64 位后赋给寄存器对 vAA</td></tr><tr><td>const-string vAA,string@BBBB</td><td>指令用于通过字符串索引构造一个字符串并赋给寄存器 vAA</td></tr><tr><td>const-string/jumbo vAA,string@BBBBBBBB</td><td>指令用于通过字符串索引(较大)构造一个字符串并赋给寄存器 vAA</td></tr><tr><td>const-class vAA,type@BBBB</td><td>指令用于通过类型索引获取一个类引用并赋给寄存器 vAA</td></tr><tr><td>const-class/jumbo vAAAA,type@BBBBBBBB</td><td>指令用于通过类型索引获取一个类引用并赋给寄存器 vAA<br>(这条指令占用两个字节, 值为 0x00ff)</td></tr></tbody></table><h3 id="锁指令"><a href="#锁指令" class="headerlink" title="锁指令"></a>锁指令</h3><p>锁指令多用在多线程中对同一对象的操作中, Dalvik 指令集中提供了如下两条锁指令：</p><table><thead><tr><th><strong>指令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>monitor-enter vAA</td><td>为指定的对象获取锁</td></tr><tr><td>monitor-exit vAA</td><td>释放指定对象的锁</td></tr></tbody></table><h3 id="实例操作指令"><a href="#实例操作指令" class="headerlink" title="实例操作指令"></a>实例操作指令</h3><p>与实例相关的操作包括实例的类型转换、检查及创建等。如下：</p><table><thead><tr><th><strong>指令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>check-cast vAA,type@BBBB</td><td>指令用于将 vAA 寄存器中的对象引用转换成指定的类型, <br/>如果失败会抛出 ClassCastException 异常, <br/>如果类型 B 指定的是基本类型, <br/>对于非基本类型的 A 来说, 运行时始终会失败。</td></tr><tr><td>instance-of vA,vB,type@CCCC</td><td>指令用于判断 vB 寄存器中的对象是否可以转换成指定的类型, <br/>如果可以 vA 赋给 1, 否则赋给 0。</td></tr><tr><td>new-instance vAA,type@BBBB</td><td>指令用于构造一个指定类型对象的新实例, 并将对象引用赋给 vAA,  <br/>类型符 type 指定的类型不是数组。</td></tr><tr><td>check-cast/jumbo vAAAA,type@BBBBBBBB</td><td>同 check-cast vAA,type@BBBB , <br>只是寄存器值和指令的索引取值返回更大 (android 4.0 新增)</td></tr><tr><td>instance-of/jumbo vAAAA,vBBBB,type@CCCCCCCC</td><td>同 instance-of vA,vB,type@CCCC , <br/>只是寄存器值和指令的索引取值返回更大 (android 4.0 新增)</td></tr><tr><td>new-instance/jumbo vAAAA,type@BBBBBBBB</td><td>同 new-instance vAA,type@BBBB , <br/>只是寄存器值和指令的索引取值返回更大 (android 4.0 新增)</td></tr></tbody></table><h3 id="数组操作指令"><a href="#数组操作指令" class="headerlink" title="数组操作指令"></a>数组操作指令</h3><p>数组操作包括获取数组长度、新建数组、数组赋值、数组元素取值与赋值等操作。如下：</p><table><thead><tr><th><strong>指令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>array-length vA, vB</td><td>获取给定 VB 寄存器中数组的长度并将值赋给 vA 寄存器</td></tr><tr><td>new-array vA, vB, type@CCCC</td><td>构造指定类型 (type@CCCC) 和大小 (vB) 的数组, 并将值赋给 vA</td></tr><tr><td>filled-new-array {vC, vD, vE, vF, vG}, type@BBBB</td><td>构造指定类型 (type@BBBB) 和大小 (vA) 的数组并填充数组内容。<br/>vA 寄存器是隐含使用的, 除了指定数组的大小外还指定了参数的个数, vC ~ vG 是使用到的参数寄存器序列</td></tr><tr><td>filled-new-array/range {vCCCC .. vNNNN}, type@BBBB</td><td>指令功能同 filled-new-array {vC,vD,vE,vF,vG},type@BBBB, <br/>只是参数寄存器使用 range 字节码后缀指定了取值范围, <br/>vC 是第一个参数寄存器,  N = A + C - 1</td></tr><tr><td>fill-array-data vAA, +BBBBBBBB</td><td>用指定的数据来填充数组, vAA 为数组引用, <br/>引用必须为基础类型的数组, 再指令后面会紧跟一个数据表</td></tr><tr><td>new-array/jumbo vAAAA, vBBBB, type@CCCCCCCC</td><td>同 new-array vA,vB,type@CCCC , <br/>只是寄存器值和指令的索引取值返回更大 (android 4.0 新增)</td></tr><tr><td>filled-new-array/jumbo {vCCCC .. vNNNN}, type@BBBBBBBB</td><td>同 filled-new-array/range {vCCCC … vNNNN},type@BBBB , <br/>只是索引取值返回更大 (android 4.0 新增)</td></tr><tr><td>arrayop vAA, vBB, vCC</td><td>对 vBB 寄存器指定的数组元素进行取值和赋值, <br/>vCC 指定数组元素索引, vAA 用来存放读取的或需要设置的数组元素的值, <br/>读取元素使用 aget 类指令, 元素赋值使用 aput 类指令, <br/>根据数组中存储的类型指令后面会紧跟不同的指令后缀, 指令列表有 <br/>( aget , aget-wide , aget-object , <br/>aget-boolean , aget-byte , aget-char , <br/>aget-short , aput , aput-wide , <br/>aput-object , aput-boolean , <br/>aput-byte , aput-char , aput-short )</td></tr></tbody></table><h3 id="异常指令"><a href="#异常指令" class="headerlink" title="异常指令"></a>异常指令</h3>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> delvik </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ViewPage滑动动画差值器</title>
      <link href="2019/viewpage-indicator-bezierindicator.html"/>
      <url>2019/viewpage-indicator-bezierindicator.html</url>
      
        <content type="html"><![CDATA[<p>很久以前看到一个这样的效果，很多文章都是只重点实现选择器，<code>ViewPager</code> 的差值器动画效果没有考虑，这里我努力做到最像，完成这个设计</p><img src= "/img/loading.gif" data-lazy-src="https://user-gold-cdn.xitu.io/2018/2/6/16169f802550c42e?imageslim" style="zoom:40%"><h2 id="本文知识点"><a href="#本文知识点" class="headerlink" title="本文知识点"></a>本文知识点</h2><ul><li></li><li><code>ViewPager</code>  滑动解析</li><li>自定义 <code>Scroller</code> </li><li>反射</li></ul><hr><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> ui </tag>
            
            <tag> viewpage </tag>
            
            <tag> ViewPageIndicator </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 网站管理</title>
      <link href="2019/hexo-website-management.html"/>
      <url>2019/hexo-website-management.html</url>
      
        <content type="html"><![CDATA[<p>目录请看  <a href="https://calmcenter.club/2019/Complete_works_of_hexo.html">Hexo 搭建博客大全</a></p><p><strong>注意：如果出现图片不显示问题请移步</strong> <a href="https://calmcenter.club/2019/PicNotShow.html">图片不显示问题</a></p><h1 id="本文主要记载"><a href="#本文主要记载" class="headerlink" title="本文主要记载"></a>本文主要记载</h1><ul><li>加入 <code>Coding</code> 服务器</li><li>个人域名</li><li><code>SEO</code>  推广</li></ul><hr><div class="note warning flat"><p>重点： <code>hexo</code> 根目录配置文件 <code>hexo/_config.yml</code>  下文用 <code>Hexo 配置文件</code> 表示，<code>NexT</code> 样式配置文件 <code>hexo/theme/next/_config.yml</code> 下文用 <code>NexT 配置文件</code> 表示一定要分清，它们都叫 <code>_comfig.yml</code></p></div><p><strong>本文章写于 <code>2019/5/5</code> 图片内容可能和您现在看的内容不太一样，但是功能大体是不会变的。</strong></p><hr><h1 id="加入-Coding-服务器"><a href="#加入-Coding-服务器" class="headerlink" title="加入 Coding 服务器"></a>加入 <code>Coding</code> 服务器</h1><p>这里加入<code>Coding</code> 服务器的作用主要是访问速度，其次就是由于 <code>github</code> 屏蔽百度的爬虫，所以使用 <code>github page</code> 服务的站点的链接无法被抓取，可用  <code>Coding</code>  的 <code>page</code> 服务。</p><ol><li><p>登录 <a href="https://dev.tencent.com/">Coding</a></p><p>登录 <a href="https://dev.tencent.com/">Coding</a> ，并创建项目<img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/20190505114135.png" style="zoom:50%"></p></li><li><p>个人设置</p><p>首先你需要点击头像，找到个人设置，在个人设置中设置 <strong>密码</strong> 和 <strong>邮箱</strong> 才能设置 <strong>SSH</strong> ，如果你之前设置过 <code>github</code> 的 <code>SSH</code> 你只需要执行以下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clip &lt; ~&#x2F;.ssh&#x2F;id_rsa.pub</span><br></pre></td></tr></table></figure><p>然后点击 <code>SSH</code>公钥 设置即可，如果没有设置过 <code>github</code> 请参考 <a href="https://calmcenter.club/2019/Hexo_bash.html#2-3-%E9%85%8D%E7%BD%AE-SSH-%E5%AF%86%E9%92%A5">Hexo 基础搭建 - 配置 SSH 秘钥部分</a></p></li><li><p>验证</p><p>输入以下命令，查看 <code>SSH</code> 配置是否成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@git.coding.net</span><br></pre></td></tr></table></figure></li><li><p>添加配置</p><p>在  <code>Hexo 配置文件</code> 中注释掉之前的，添加 <code>repo</code> 中的内容 <code>SSH</code> 路径 <code>,master</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Deployment</span></span><br><span class="line"><span class="comment">#Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">    <span class="comment">#repository: git@github.com:CalmCenter/calmcenter.github.io.git</span></span><br><span class="line">    <span class="comment">#branch: master</span></span><br><span class="line">    <span class="attr">repo:</span></span><br><span class="line">    <span class="attr">github:</span> <span class="string">git@github.com:CalmCenter/calmcenter.github.io.git,master</span></span><br><span class="line">    <span class="attr">coding:</span> <span class="string">git@git.dev.tencent.com:CalmCenter/calmcenter.coding.me.git,master</span></span><br></pre></td></tr></table></figure></li><li><p>提交</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure></li><li><p>打开 <code>Coding Pages</code> 服务</p><p><code>头像 -&gt; 我的主页 -&gt; 项目 -&gt; 代码 -&gt; Pages 服务</code> 打钩已阅读服务，点击开启即可</p><p>会告诉你访问地址，打开如果排版不正常，不要慌，可能是子文件目录问题，设置域名后可解决。</p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/20190508105842.png" style="zoom:50%"></li></ol><hr><h1 id="个人域名"><a href="#个人域名" class="headerlink" title="个人域名"></a>个人域名</h1><ol><li><p>获得域名</p><p>首先你得有你自己的域名，几块钱就好~  <a href="https://cloud.tencent.com/act/domainsales?fromSource=gwzcw.2211770.2211770.2211770&utm_medium=cpc&utm_id=gwzcw.2211770.2211770.2211770">腾讯云</a> 、<a href="https://wanwang.aliyun.com/domain/yumingheji">阿里云</a> ，然后需要进行实名认证。完成后就可以添加域名解析地址啦~ </p></li><li><p>添加解析</p><p>这是 <a href="https://cloud.tencent.com/act/domainsales?fromSource=gwzcw.2211770.2211770.2211770&utm_medium=cpc&utm_id=gwzcw.2211770.2211770.2211770">腾讯云</a> 的域名解析。</p><p><strong>注意：这里域名操作，每次操作完都会有一定缓冲时间，不会立即生效，每次操作完等待 10 分钟左右，再去配置域名</strong> </p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/20190508104813.png" style="zoom:50%"><p>这是添加的解析，因为添加了 <code>coding</code> ，所以有两条，分别将两个访问地址添加到域名解析中，<code>github</code> 用于境外访问，<code>coding</code> 本想着用于境内，但这里必须设置成默认才行。</p></li><li><p><code>github</code> 域名设置</p><p>点击你的博客项目的 <code>Setting</code> -&gt; <code>Options</code> 下滑找到 <code>GitHub Pages</code> </p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/20190508105420.png" style="zoom:50%"><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/20190508105344.png" style="zoom:50%"><p>这里会提示你站点发布在什么地方，记得开启 <code>HTTPS</code> 哦。</p></li><li><p><code>Coding</code> 域名设置</p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/20190508105715.png" style="zoom:50%"><p>自定义域名，将申请好的域名添加上去，点击绑定，然后刷新页面，知道 <code>SSL/TLS 安全证书</code> 出现结果，如果错误，请查看解析中 <code>coding</code> 线路类型配置是否是默认，如果是默认还不行，请将境外的 <code>github</code> 先暂停，再去重新绑定。记得开启 <code>HTTPS</code> 哦。</p><p><strong>操作时请留意 个人域名 开头说明的注意事项</strong></p></li></ol><hr><h1 id="SEO-推广"><a href="#SEO-推广" class="headerlink" title="SEO  推广"></a><code>SEO</code>  推广</h1><p>参考自作者 <a href="https://blog.enjoytoshare.club/article/hexo-do-optimization.html#5">EnjoyToShare</a> </p><h2 id="SEO-是什么"><a href="#SEO-是什么" class="headerlink" title="SEO 是什么"></a><code>SEO</code> 是什么</h2><p>刚搭建完博客，可能你会发现你发表的文章在谷歌或者百度都搜索不到，因为需要进行 <code>SEO</code> 优化的，什么是 <code>SEO</code> ，顾名思义，<code>SEO</code> 即 <code>(Search Engine Optimization)</code> : 汉译为搜索引擎优化，它可以让自己的博文能在谷歌百度上搜索到。</p><h2 id="生成-sitemap"><a href="#生成-sitemap" class="headerlink" title="生成 sitemap"></a>生成 <code>sitemap</code></h2><p><code>sitemap</code> 用于通知搜索引擎网站上有哪些可供抓取的网页，以便搜索引擎可以更加智能地抓取网站。<br>安装 <code>sitemap</code> 站点地图自动生成插件 <code>hexo-generator-sitemap</code> 和 <code>hexo-generator-baidu-sitemap</code> </p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure><p>然后修改  <code>Hexo 配置文件</code> ，<strong>添加</strong>如下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sitemap:</span><br><span class="line">  path: sitemap.xml</span><br><span class="line">baidusitemap:</span><br><span class="line">  path: baidusitemap.xml</span><br></pre></td></tr></table></figure><p>并<strong>修改</strong> <code>url</code> 为你的域名地址 如 <code>url: https://blog.calmcenter.club/</code> </p><p>然后编译代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><p>就会生成在 <code>hexo\public</code> 下生成 <code>sitemap.xml</code> 和 <code>baidusitemap.xml</code> 一个是给谷歌的，一个给是百度的。</p><h2 id="添加协议"><a href="#添加协议" class="headerlink" title="添加协议"></a>添加协议</h2><p>网站通过 <code>Robots协议</code> 告诉搜索引擎哪些页面可以抓取，哪些页面不能抓取。 <code>robots.txt</code> 通常存放于网站根目录 ( <code>public</code> 目录)。由于我们每次 <code>hexo clean</code> 都会清空 <code>public</code> ，着实不方便，我们都知道 <code>source</code> 目录下的文件通过 <code>hexo g</code> 命令会转换成 <code>public</code> 中的文件，所以为了方便起见，我们把 <code>robots.txt</code> 文件放在<code>source</code>目录下，我的 <code>robots.txt</code> 内容为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">User-agent: *</span><br><span class="line">Allow: &#x2F;</span><br><span class="line">Allow: &#x2F;archives&#x2F;</span><br><span class="line">Allow: &#x2F;categories&#x2F;</span><br><span class="line">Allow: &#x2F;tags&#x2F;</span><br><span class="line">Allow: &#x2F;links&#x2F;</span><br><span class="line">Disallow: &#x2F;js&#x2F;</span><br><span class="line">Disallow: &#x2F;css&#x2F;</span><br><span class="line">Disallow: &#x2F;fonts&#x2F;</span><br><span class="line">Disallow: &#x2F;vendors&#x2F;</span><br><span class="line">Disallow: &#x2F;fancybox&#x2F;</span><br><span class="line">Sitemap: https:&#x2F;&#x2F;你的域名&#x2F;sitemap.xml</span><br><span class="line">Sitemap: https:&#x2F;&#x2F;你的域名&#x2F;baidusitemap.xml</span><br></pre></td></tr></table></figure><p>其中Allow后面的就是你的menu</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 域名 </tag>
            
            <tag> coding </tag>
            
            <tag> seo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 功能样式配置</title>
      <link href="2019/hexo-functional-style.html"/>
      <url>2019/hexo-functional-style.html</url>
      
        <content type="html"><![CDATA[<p>目录请看  <a href="https://calmcenter.club/2019/Complete_works_of_hexo.html">Hexo 搭建博客大全</a></p><p><strong>注意：如果出现图片不显示问题请移步</strong> <a href="https://calmcenter.club/2019/PicNotShow.html">图片不显示问题</a></p><h1 id="本文主要记载"><a href="#本文主要记载" class="headerlink" title="本文主要记载"></a>本文主要记载</h1><ul><li><code>NexT</code> 主题设置</li><li>基础样式设置</li><li>图片相关</li><li>打赏、评论、复制功能</li><li><code>DaoVoice</code> 实现在线联系</li><li>文章置顶</li><li>搜索功能</li><li>细节美化</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">本文环境是 win10 或 win 7。mac 再执行 npm 时需要在前面添加 sudo</span><br><span class="line">本文整理于各大佬文章，文中会给出相应链接，如有侵权，请联系我修改或删除。</span><br></pre></td></tr></table></figure><hr><h1 id="功能样式配置"><a href="#功能样式配置" class="headerlink" title="功能样式配置"></a>功能样式配置</h1><h2 id="NexT-主题设置"><a href="#NexT-主题设置" class="headerlink" title="NexT 主题设置"></a><code>NexT</code> 主题设置</h2><p>*<em>重点标注：<code>hexo</code> 根目录配置文件 <code>hexo/_config.yml</code>  下文用 <code>Hexo 配置文件</code> 表示，<code>NexT</code> 样式配置文件 <code>hexo/theme/next/_config.yml</code> 下文用 <code>NexT 配置文件</code> 表示一定要分清，它们都叫 <code>_cpmfig.yml</code> *</em></p><p><a href="https://hexo.io/themes/">这里有很多主题</a> 这里主要说 <a href="https://github.com/theme-next/hexo-theme-next">NexT</a> </p><p>进入 <code>hexo</code> 文件目录 ，执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;hexo-theme-next themes&#x2F;next</span><br></pre></td></tr></table></figure><p>成功后，在 <code>Hexo 配置文件</code> 找到 <code>theme</code> 字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure><p>这样 <code>next</code> 样式就设置好了，快打开看看吧  <a href="http://localhost:4000/">http://localhost:4000/</a></p><p><strong>注意:如果你是 <code>git</code> 直接 <code>clone</code> 的，会自带 <code>.git</code> 和 <code>.github</code> 文件，需要删掉 <code>.git</code> 和 <code>.github</code> 文件，如果不删在 <a href="https://calmcenter.club/2019/Hexo_code_management.html">Hexo 管理代码</a> 一文中会出现 <code>them/next</code> 里的文件提交不上去的问题</strong></p><h2 id="设置语言、标题等"><a href="#设置语言、标题等" class="headerlink" title="设置语言、标题等"></a>设置语言、标题等</h2><p>在  <code>Hexo 配置文件</code> 找到 <code>Site</code> 字段 </p><table><thead><tr><th align="left">字段</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">title</td><td align="left">网站标题</td></tr><tr><td align="left">subtitle</td><td align="left">副标题</td></tr><tr><td align="left">description</td><td align="left">描述</td></tr><tr><td align="left">author</td><td align="left">作者(您的名字)</td></tr><tr><td align="left">language</td><td align="left">语言 (zh-CN，en等)</td></tr><tr><td align="left">timezone</td><td align="left">网站时区，默认使用您电脑的时区</td></tr></tbody></table><h2 id="NexT-样式"><a href="#NexT-样式" class="headerlink" title="NexT 样式"></a><code>NexT</code> 样式</h2><p>在 <code>Hexo 配置文件</code> 找到 <code>Schemes</code> 字段，这里有四种样式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Schemes</span><br><span class="line">#scheme: Muse</span><br><span class="line">#scheme: Mist</span><br><span class="line">#scheme: Pisces</span><br><span class="line">scheme: Gemini</span><br></pre></td></tr></table></figure><h2 id="图片上传-PicGo-GitHub-图床"><a href="#图片上传-PicGo-GitHub-图床" class="headerlink" title="图片上传 PicGo + GitHub 图床"></a>图片上传 <code>PicGo</code> + <code>GitHub</code> 图床</h2><p>参考自作者 <a href="https://blog.enjoytoshare.club/article/hexo-do-optimization-picture.html">EnjoyToShare 《PicGo+GitHub图床，让Markdown飞起》</a>  </p><ol><li><p>首先下载工具<br>下载地址 : <a href="https://github.com/Molunerfinn/PicGo/releases">PicGo</a> </p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/picturespicgo_down.png" style="zoom:50%"></li><li><p>登录 <code>GitHub</code> </p><p>创建 <code>Repository</code> 之前都讲过怎么创建，名字可以取成 <code>PicGo</code> 类似的名字，主要用于存放图片。</p></li><li><p>生成 Token  </p><p>点击头像 <code>Settings -&gt; Developer settings -&gt; Personal access tokens</code> 点击  <code>Generate new token</code>  </p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/picturesnew_token.png" style="zoom:80%"><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/picturesaccess_tokens.png" style="zoom:30%"><p>点击最下面的  <code>Generate token</code> ，会出现 <code>token</code> ，这个 <code>token</code> 只出现一次，所以要保存一下</p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/picturesaccess_token.png" style="zoom:50%"></li><li><p>配置 <code>PicGo</code> 客户端</p></li></ol><p>打开 <code>PicGo</code> ，输入相关信息</p><ul><li>仓库名 即你的仓库名</li><li>分支名 默认 master</li><li>Token 就是刚刚复制的那一串字符</li><li>存储路径 这个可以填也可以不填，填了的话图片就上传到这个文件夹，比如 <code>picture/</code> 图中少一个 <code>/</code></li><li>自定义域名 这个要改一下 格式： <code>https://raw.githubusercontent.com/[仓库名]/master</code> </li></ul><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/picturespic_go_token.png" style="zoom:50%"><p>然后点确定就OK了，不妨试试。</p><p>还有一个方便的操作就是 修改上传快捷键 ，快捷键直接上传，跳过拖入上传区</p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/20190426111300.png" style="zoom:50%"><h2 id="图片全屏查看"><a href="#图片全屏查看" class="headerlink" title="图片全屏查看"></a>图片全屏查看</h2><p>首先进入 <code>hexo/themes/next/source/lib</code> 目录，下载插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;theme-next-fancybox3 fancybox</span><br></pre></td></tr></table></figure><p>然后更改 <code>NexT 配置文件</code> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fancybox: true</span><br></pre></td></tr></table></figure><p>完成 ~ </p><p><strong>注意:如果你是 <code>git</code> 直接 <code>clone</code> 的，会自带 <code>.git</code> 和 <code>.github</code> 文件，需要删掉 <code>.git</code> 和 <code>.github</code> 文件，如果不删在 <a href="https://calmcenter.club/2019/Hexo_code_management.html">Hexo 管理代码</a> 一文中会出现 <code>them/next/source/lib/fancybox</code> 里的文件提交不上去的问题</strong></p><h2 id="打赏功能"><a href="#打赏功能" class="headerlink" title="打赏功能"></a>打赏功能</h2><p>参考自作者 <a href="https://blog.enjoytoshare.club/article/hexo-do-donate.html">EnjoyToShare 《Hexo的NexT主题打赏功能》</a>  </p><p>准备好收款二维码，放入 <code>hexo/themes/next/source/images</code> ，打开 <code>NexT 配置文件</code> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">reward_settings:</span><br><span class="line">  enable: true</span><br><span class="line">  animation: false</span><br><span class="line">  comment: 分享不易，可否赏杯咖啡钱</span><br><span class="line">reward:</span><br><span class="line">  wechatpay: &#x2F;images&#x2F;wechatpay.png</span><br><span class="line">  alipay: &#x2F;images&#x2F;alipay.png</span><br><span class="line">  #bitcoin: &#x2F;images&#x2F;bitcoin.png</span><br></pre></td></tr></table></figure><h2 id="评论功能"><a href="#评论功能" class="headerlink" title="评论功能"></a>评论功能</h2><p>参考自作者 <a href="https://blog.enjoytoshare.club/article/hexo-do-gitalk.html">EnjoyToShare 《Hexo NexT 加入评论功能gitalk》</a>  </p><p><code>Gitalk</code> :</p><ul><li>一个基于 <code>Github Issue</code> 和 <code>Preact</code> 开发的评论插件</li><li>详情 <code>Demo</code> 可见:  <a href="https://gitalk.github.io/">https://gitalk.github.io/</a></li></ul><p>增加评论区</p><ul><li>注册 <code>OAuth Application</code></li><li>在 <code>GitHub</code> 上注册新应用, 链接:  <a href="https://github.com/settings/applications/new">https://github.com/settings/applications/new</a> </li></ul><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">Application name</td><td align="left">应用名称, 可以任意填入</td></tr><tr><td align="left">Homepage URL</td><td align="left">网站URL, 注意用https://开头</td></tr><tr><td align="left">Application description</td><td align="left">应用描述, 可以任意填入</td></tr><tr><td align="left">Authorization callback URL</td><td align="left">网站URL, 注意用https://开头</td></tr></tbody></table><p>注册后记录 <code>Client ID</code> 和 <code>Client Secret</code> , 后续要使用到。</p><p>打开 <code>NexT 配置文件</code> ， <strong>根据自己信息</strong> 进行一下修改，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gitalk:</span><br><span class="line">  enable: true</span><br><span class="line">  github_id: CalmCenter</span><br><span class="line">  repo: calmcenter.github.io</span><br><span class="line">  client_id: ****</span><br><span class="line">  client_secret: ****</span><br><span class="line">  admin_user: CalmCenter  </span><br><span class="line">  distraction_free_mode: true </span><br><span class="line">  language:</span><br></pre></td></tr></table></figure><p> 集成过程中出现的错误 <a href="https://liujunzhou.top/2018/8/10/gitalk-error/#%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B">Junzhou Liu</a> 这里给出了很多，但是在我集成是发现有的 <code>NexT</code> 已经修正，所以这里说几点需要注意的地方。</p><ul><li>你的评论仓库或者 <code>GitHub Page</code> 仓库必须是 <code>public</code> ， <code>NexT 配置文件</code> 的 <code>reop</code> 指定的仓库名称也必须是 <code>public</code> ，否者可能出现 <code>404</code> 的错误</li><li><code>NexT</code> 中的字段配置 和 <code>Gitalk</code> 有两个不一样，需要用 <code>NexT</code> 指定的，否者会出现 <code>Erroe Not Found</code> </li></ul><p>如果错误修改后没反应，试一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure><p>重新编译运行。</p><p>成功后会提示你未找到相关 <code>issues</code>  ，需要你登录</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/20190426155441.png" alt=""></p><p><strong>如果有自己的域名记得把 Authorization callback URL 设置成自己的 域名地址</strong> <code>Authorization callback URL</code> 在 <a href="https://github.com/settings/developers">github setting</a> 点击自己绑定的进去修改</p><p><strong>2019/5/10 踩坑记录，文章的文件名，中文会有问题，导致一直跳转首页并登陆不上，title  可以是中文</strong></p><h2 id="代码块复制功能"><a href="#代码块复制功能" class="headerlink" title="代码块复制功能"></a>代码块复制功能</h2><p>在 <code>NexT 配置文件</code> 中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">codeblock:</span><br><span class="line">  border_radius:</span><br><span class="line">  copy_button:</span><br><span class="line">    enable: true</span><br><span class="line">    show_result: true</span><br><span class="line">    style:</span><br></pre></td></tr></table></figure><p><code>NexT</code> 随着版本的升级，省去了很多操作，基本都剩开关的设置了</p><h2 id="DaoVoice-实现在线联系"><a href="#DaoVoice-实现在线联系" class="headerlink" title="DaoVoice 实现在线联系"></a><code>DaoVoice</code> 实现在线联系</h2><ol><li><p>注册登录 <code>DaoVoice</code></p><p><a href="http://www.daovoice.io/">DaoVoice</a> 点击进行登录注册，邀请码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c1f73bd5</span><br></pre></td></tr></table></figure><p>登录成功后，你可能是这个目录</p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/20190428141105.png" style="zoom:50%"><p>这样的话你需要关掉这个页面，重新进入 <a href="http://www.daovoice.io/">DaoVoice</a> 点击登录，如果最后看到是这个目录</p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/20190428141212.png" style="zoom:50%"><p>那就可以继续下面的 ~ </p></li><li><p>集成 </p><p>找到你的 <code>app_id</code></p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/20190428141938.png" style="zoom:30%"><p>并将 <code>1</code> 和 <code>2</code> 的代码 粘贴到 <code>themes/next/layout/_partials/head.swig</code> </p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/20200516194622.png" style="zoom:70%"><p><strong>有两处需要填写你的 <code>appid</code> 并且要加 <code>if</code> 开始和结束代码</strong></p><p>然后再  <code>NexT 配置文件</code> 中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">daovoice: true</span><br><span class="line">daovoice_app_id: 你的appid</span><br></pre></td></tr></table></figure><p>编译并运行 <code>Hexo</code> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure><p>会发现 <code>DaoVoice</code> 官网会提示</p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/20190428143112.png" style="zoom:30%"></li><li><p>绑定微信</p><p>点击右上角头像，然后点击绑定微信</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/20190428143854.png" alt=""></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/20190428143916.png" alt=""></p><p>这样，可以同时在 <code>DaoVoice</code> 网页的对话页面，和微信小程序 <code>DaoVoice</code> 同时回复~ </p></li></ol><h2 id="文章置顶"><a href="#文章置顶" class="headerlink" title="文章置顶"></a>文章置顶</h2><ol><li><p>将 <code>node_modules/hexo-generator-index/lib/generator.js</code> 文件内的内容替换为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#39;use strict&#39;;</span><br><span class="line">var pagination &#x3D; require(&#39;hexo-pagination&#39;);</span><br><span class="line">module.exports &#x3D; function(locals)&#123;</span><br><span class="line">    var config &#x3D; this.config;</span><br><span class="line">    var posts &#x3D; locals.posts;</span><br><span class="line">    posts.data &#x3D; posts.data.sort(function(a, b) &#123;</span><br><span class="line">        if(a.top &amp;&amp; b.top) &#123; &#x2F;&#x2F; 两篇文章top都有定义</span><br><span class="line">            if(a.top &#x3D;&#x3D; b.top) return b.date - a.date; &#x2F;&#x2F; 若top值一样则按照文章日期降序排</span><br><span class="line">            else return b.top - a.top; &#x2F;&#x2F; 否则按照top值降序排</span><br><span class="line">        &#125;</span><br><span class="line">        else if(a.top &amp;&amp; !b.top) &#123; &#x2F;&#x2F; 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233）</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(!a.top &amp;&amp; b.top) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else return b.date - a.date; &#x2F;&#x2F; 都没定义按照文章日期降序排</span><br><span class="line">    &#125;);</span><br><span class="line">    var paginationDir &#x3D; config.pagination_dir || &#39;page&#39;;</span><br><span class="line">    return pagination(&#39;&#39;, posts, &#123;</span><br><span class="line">    perPage: config.index_generator.per_page,</span><br><span class="line">    layout: [&#39;index&#39;, &#39;archive&#39;],</span><br><span class="line">    format: paginationDir + &#39;&#x2F;%d&#x2F;&#39;,</span><br><span class="line">    data: &#123;</span><br><span class="line">      __index: true</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>在文章头部添加 <code>top</code> 值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">title: Hexo 搭建博客大全</span><br><span class="line">date: 2019-04-18 17:32:22</span><br><span class="line">categories: Hexo</span><br><span class="line">tags: [Hexo, NexT, 博客]</span><br><span class="line">top: 100</span><br></pre></td></tr></table></figure></li></ol><h2 id="搜索功能"><a href="#搜索功能" class="headerlink" title="搜索功能"></a>搜索功能</h2><ol><li><p>安装插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure></li><li><p>在 <code>Hexo 配置文件</code> 中添加 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#本地搜索</span><br><span class="line">search:</span><br><span class="line">    path: search.xml</span><br><span class="line">    field: post</span><br><span class="line">    format: html</span><br><span class="line">    limit: 10000</span><br></pre></td></tr></table></figure></li><li><p>在 <code>NexT 配置文件</code> 启动搜索功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">local_search:</span><br><span class="line">    enable: true</span><br><span class="line">    trigger: auto</span><br><span class="line">    top_n_per_article: 1</span><br><span class="line">    unescape: false</span><br></pre></td></tr></table></figure></li><li><p>完成，清理缓存编译运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure></li></ol><h2 id="隐藏特定文章"><a href="#隐藏特定文章" class="headerlink" title="隐藏特定文章"></a>隐藏特定文章</h2><p>比如说没写完的 ~ </p><p>首先修改 <code>/themes/next/layout/index.swig</code> 文件，把</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% for post in page.posts %&#125;</span><br><span class="line">  &#123;&#123; post_template.render(post, true) &#125;&#125;</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure><p>替换成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;% for post in page.posts %&#125;</span><br><span class="line">   &#123;% set hide &#x3D; false %&#125;</span><br><span class="line">   &#123;% if theme.hide.hide_post %&#125;</span><br><span class="line">     &#123;% if post.hide %&#125;</span><br><span class="line">       &#123;% set hide &#x3D; true %&#125;</span><br><span class="line">     &#123;% endif %&#125;</span><br><span class="line">   &#123;% endif %&#125;</span><br><span class="line">   &#123;% if !hide %&#125;</span><br><span class="line">     &#123;&#123; post_template.render(post, true) &#125;&#125;</span><br><span class="line">   &#123;% endif %&#125;</span><br><span class="line"> &#123;% endfor %&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在 <code>NexT 配置文件</code>  添加代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Hide single post</span><br><span class="line">hide:</span><br><span class="line">  hide_post: true</span><br></pre></td></tr></table></figure><h2 id="细节美化"><a href="#细节美化" class="headerlink" title="细节美化"></a>细节美化</h2><h3 id="头像"><a href="#头像" class="headerlink" title="头像"></a>头像</h3><p>在<code>NexT 配置文件</code> 中，找到 <code>avatar</code> 字段</p><table><thead><tr><th>字段</th><th>作用</th></tr></thead><tbody><tr><td>url</td><td>图片相对位置(/image/xxx.png)图片保存在  \hexo\themes\next\source\images 文件下</td></tr><tr><td>rounded</td><td>是否启用圆角</td></tr><tr><td>opacity</td><td>透明度</td></tr><tr><td>rotated</td><td>旋转动画</td></tr></tbody></table><h3 id="回到顶部"><a href="#回到顶部" class="headerlink" title="回到顶部"></a>回到顶部</h3><p>打开 <code>NexT 配置文件</code> 搜索 <code>back2top</code>  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">back2top:</span><br><span class="line">  enable: true</span><br><span class="line">  # 回到侧边栏顶部.</span><br><span class="line">  sidebar: true</span><br><span class="line">  # 滚动%标签.</span><br><span class="line">  scrollpercent: true</span><br></pre></td></tr></table></figure><h3 id="页面底部优化"><a href="#页面底部优化" class="headerlink" title="页面底部优化"></a>页面底部优化</h3><ul><li>跳动的心</li></ul><p>参考自作者 <a href="https://11.tt/posts/2018/set-up-hexo-with-coding-and-github/">十一種情緒的堆棧</a> 在这篇文章 1/2 处左右</p><p>效果就在本页面底部 ~ ，首先先去 <a href="https://fontawesome.com/v4.7.0/icons/">The Icons</a> 选择一张图片，例如搜索 <code>heartbeat</code> ，点击进去将图片代码 <code>fa-heartbeat</code> 复制下来，打开<code>NexT 配置文件</code> ，搜索 <code>footer</code> 关键字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">footer:</span><br><span class="line">  icon:</span><br><span class="line">    name: fas fa-heartbeat</span><br><span class="line">    animated: true</span><br><span class="line">    color: &quot;#ff0000&quot;</span><br></pre></td></tr></table></figure><p>需要将复制的图片代码粘贴到 <code>name</code> 字段，并且前面加上 fas ，如果需要动画的话，将 <code>animated</code> 设置为 <code>true</code> ，并将 <code>color</code> 修改为 <code>#ff0000</code> 。就和我底部效果一样了啦。</p><ul><li>访问统计</li></ul><p>还是在 <code>NexT 配置文件</code> ，搜索 <code>busuanzi_count</code> 字段。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">busuanzi_count:</span><br><span class="line">  enable: true</span><br><span class="line">  total_visitors: true</span><br><span class="line">  total_visitors_icon: user</span><br><span class="line">  total_views: true</span><br><span class="line">  total_views_icon: eye</span><br><span class="line">  post_views: true</span><br><span class="line">  post_views_icon: eye</span><br></pre></td></tr></table></figure><p>将 <code>enable</code> 设置为 <code>true</code> 就有和我底部一样的 访问统计 功能了</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/picturesvisit.png" alt=""></p><p>统计这块还可以添加一个字数和阅读时长统计，在<code>hexo</code> 根目录配置文件 <code>hexo/_config.yml</code> 搜索 <code>symbols_count_time</code> 如果没有则添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">symbols_count_time:</span><br><span class="line"> symbols: true </span><br><span class="line"> time: true </span><br><span class="line"> total_symbols: true </span><br><span class="line"> total_time: true</span><br></pre></td></tr></table></figure><p>在 <code>NexT 配置文件</code> 搜索 <code>symbols_count_time</code> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">symbols_count_time:</span><br><span class="line">  separated_meta: true</span><br><span class="line">  item_text_post: true</span><br><span class="line">  item_text_total: false</span><br><span class="line">  awl: 4</span><br><span class="line">  wpm: 275</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/picturesnumber.png" alt=""></p><p><strong>注: 格式很重要</strong> </p><h3 id="圆角布局"><a href="#圆角布局" class="headerlink" title="圆角布局"></a>圆角布局</h3><p>参考自作者 <a href="https://blog.enjoytoshare.club/article/hexo-do-optimization.html">EnjoyToShare</a> 在这篇文章 3.12，这篇里边还有好多好看的样式 ~</p><p>在 <code>/themes/next/source/css/_variables</code> 中的 <code>Gemini.styl</code> 文件添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 修改主题页面布局为圆角</span><br><span class="line">$border-radius-inner            &#x3D; 15px 15px 15px 15px;</span><br><span class="line">$border-radius                  &#x3D; 15px;</span><br></pre></td></tr></table></figure><h3 id="文章标签、分类"><a href="#文章标签、分类" class="headerlink" title="文章标签、分类"></a>文章标签、分类</h3><p>我们在用 <code>hexo new post</code> 创建文件时</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new post &quot;name&quot;</span><br></pre></td></tr></table></figure><p><code>hexo</code> 自动为我们的文章头部生成了如下的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">title: 标题</span><br><span class="line">date: 2019-04-18 17:32:22</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>首先添加分类</li></ul><p>在 <code>data</code> 下方添加 <code>categories</code> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">title: 标题</span><br><span class="line">date: 2019-04-18 17:32:22</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">categories: Hexo</span><br></pre></td></tr></table></figure><p><strong>注意：英文冒号，还有一个空格</strong></p><p>这样分类就添加上了，还需要给分类一个跳转页，创建一个 <code>categories.md</code> 用于跳转</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure><p>会提示我们输入目录 <code>/source/categories/index.md</code>  ，打开这个 <code>index.md</code> ，加入 <code>type</code> 这个页面用于做什么的，<code>comment</code> 是否开启评论，前提是你有评论功能的话。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">title: categories</span><br><span class="line">date: 2019-04-25 14:53:31</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type: categories</span><br><span class="line">comments: false</span><br></pre></td></tr></table></figure><p>这样分类就设置好了，检查一下 <code>Hexo 配置文件</code> ，搜索  <code>category_dir</code> 字段 <code>category_dir: categories</code> 这里已经设置了分类夹的名称，如果之前创建的文件夹完成和这个不一样，需要统一才行。</p><ul><li>添加标签</li></ul><p>同样在 <code>Hexo 配置文件</code> 搜索，<code>tag_dir</code> 可以知道 <code>tag</code> 设置好的文件夹名称，<code>tag_dir: tags</code>  ，我们可以在 <code>categories</code> 下添加 <code>tags</code> 来添加标签。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tags: [Hexo, NexT, 博客]</span><br></pre></td></tr></table></figure><p>然后添加跳转页面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure><p>创建完成后，为 <code>tags/index.md</code> 添加内容 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">title: categories</span><br><span class="line">date: 2019-04-25 15:34:07</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type: tags</span><br><span class="line">comments: false</span><br></pre></td></tr></table></figure><p>标签比分类多一步，我们需要安装一个插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-tag --save</span><br></pre></td></tr></table></figure><p>这样 <code>hexo g &amp;&amp; hexo s</code> 编译并运行，本地就可以看到了，标签在文章底部，发现它是 <code># xxx</code> 很难看，修改的 <code>#</code> 需要找到 <code>/themes/next/layout/_macro/post.swig</code> ，搜索 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rel&#x3D;&quot;tag&quot;&gt;#</span><br></pre></td></tr></table></figure><p>将 <code>#</code> 换成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;i class&#x3D;&quot;fa fa-tag&quot;&gt;&lt;&#x2F;i&gt;</span><br></pre></td></tr></table></figure><p>这里的 <code>fa-tag</code> 也是在 <a href="https://fontawesome.com/v4.7.0/icons/">The Icons</a> 中的图片。</p><ul><li>将标签、分类添加至做出菜单栏</li></ul><p>打开 <code>NexT 配置文件</code>   搜索 <code>menu</code> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: &#x2F; || home</span><br><span class="line">  #about: &#x2F;about&#x2F; || user</span><br><span class="line">  tags: &#x2F;tags&#x2F; || tags</span><br><span class="line">  categories: &#x2F;categories&#x2F; || th</span><br><span class="line">  archives: &#x2F;archives&#x2F; || archive</span><br><span class="line">  #schedule: &#x2F;schedule&#x2F; || calendar</span><br><span class="line">  #sitemap: &#x2F;sitemap.xml || sitemap</span><br><span class="line">  #commonweal: &#x2F;404&#x2F; || heartbeat</span><br></pre></td></tr></table></figure><p>将 <code>tags</code> 和 <code>categories</code> 打开，完成 ~ </p><h3 id="强调颜色"><a href="#强调颜色" class="headerlink" title="强调颜色"></a>强调颜色</h3><p>参考自作者 <a href="https://www.jianshu.com/p/f054333ac9e6">Moorez</a> </p><ul><li>‘’ 内容样式的修改</li></ul><p>打开 <code>/hemes/next/source/css/_custom/custom.styl</code> ，在里面加入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Custom styles.</span><br><span class="line">code &#123;</span><br><span class="line">    color: #ff7600;</span><br><span class="line">    background: #fbf7f8;</span><br><span class="line">    margin: 2px;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 大代码块的自定义样式</span><br><span class="line">.highlight, pre &#123;</span><br><span class="line">    margin: 5px 0;</span><br><span class="line">    padding: 5px;</span><br><span class="line">    border-radius: 3px;</span><br><span class="line">&#125;</span><br><span class="line">.highlight, code, pre &#123;</span><br><span class="line">    border: 1px solid #d6d6d6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>链接样式修改</li></ul><p>修改文件 <code>/themes/next/source/css/_common/components/post/post.styl</code>，在末尾添加如下css样式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 文章内链接文本样式</span><br><span class="line">.post-body p a&#123;</span><br><span class="line">  color: #0593d3;</span><br><span class="line">  border-bottom: none;</span><br><span class="line">  border-bottom: 1px solid #0593d3;</span><br><span class="line">  &amp;:hover &#123;</span><br><span class="line">    color: #fc6423;</span><br><span class="line">    border-bottom: none;</span><br><span class="line">    border-bottom: 1px solid #fc6423;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置网站图标</p><h3 id="设置网站图标"><a href="#设置网站图标" class="headerlink" title="设置网站图标"></a>设置网站图标</h3><p>参考自作者 <a href="https://www.jianshu.com/p/f054333ac9e6">Moorez</a> </p><p>首先找一张喜欢的图片，可以在 <a href="http://www.easyicon.net/">EasyIcon</a> 中或其他任意地方，分别下载 <code>32px</code> 和 <code>16px</code> 两张，然后放到 <code>/themes/next/source/images</code> 里，然后修改 <code>NexT 配置文件</code>  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">favicon:</span><br><span class="line">  small: &#x2F;images&#x2F;c_16.png</span><br><span class="line">  medium: &#x2F;images&#x2F;c_32.png</span><br><span class="line">  apple_touch_icon: &#x2F;images&#x2F;apple-touch-icon-next.png</span><br><span class="line">  safari_pinned_tab: &#x2F;images&#x2F;logo.svg</span><br></pre></td></tr></table></figure><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/picturesblog_title.png" style="zoom:100%"><h3 id="主页文章添加边框阴影效果"><a href="#主页文章添加边框阴影效果" class="headerlink" title="主页文章添加边框阴影效果"></a>主页文章添加边框阴影效果</h3><p>在 <code>theme/next/source/css/_custom/custom.styl</code>  文件下添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 主页文章添加阴影效果</span><br><span class="line">.posts-expand &#123; </span><br><span class="line">.post &#123;</span><br><span class="line">margin-top: 30px;</span><br><span class="line">margin-bottom: 30px;</span><br><span class="line">&#x2F;&#x2F;border-radius: 15px;</span><br><span class="line">-webkit-box-shadow: 5px 5px 20px rgba(119,118,118,.6);</span><br><span class="line">-moz-box-shadow: 5px 5px 20px rgba(119,118,118,.6);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很多博客上都没有 <code>posts-expand</code> 这一层，如果没有这一层，你的归档页面将会变得很丑~如果你用了之前的圆角布局，需要把 <code>border-radius: 15px;</code> 的注释删掉。</p><p>应用主要作用实在 <code>-webkit-box-shadow</code> 和 <code>-moz-box-shadow</code> 属性上。</p><p>基于主流浏览器上使用 <code>box-shadow</code> 属性时，我们需要将属性的名称写成 <code>-webkit-box-shadow</code> 的形式。Firefox浏览器则需要写成 <code>-moz-box-shadow</code> 的形式。</p><p>四个值分别为 <code>X轴</code>与 <code>Y轴</code> 移动 、<code>阴影值大小</code> 、<code>阴影颜色rgba</code></p><hr><h1 id="更多样式修改-💦💦"><a href="#更多样式修改-💦💦" class="headerlink" title="更多样式修改 💦💦"></a>更多样式修改 💦💦</h1><p><a href="https://bestzuo.cn/posts/1689445187.html">Sanarous Hexo博客界面美化2.0</a></p><p><a href="https://leafjame.github.io/posts/2114475547.html">Leaface Hexo NexT主题美化2.0</a></p><p><a href="https://walesexcitedmei.github.io/2018/08/30/HEXO-NexT-%E4%B8%BB%E9%A2%98%E6%8F%90%E9%AB%98%E5%8D%9A%E5%AE%A2%E9%A2%9C%E5%80%BC/">[HEXO] NexT 主题提高博客颜值</a></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> git </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Live2D 看板娘</title>
      <link href="2019/hexo-live2d.html"/>
      <url>2019/hexo-live2d.html</url>
      
        <content type="html"><![CDATA[<p>目录请看  <a href="https://calmcenter.club/2019/Complete_works_of_hexo.html">Hexo 搭建博客大全</a></p><p><strong>注意：如果出现图片不显示问题请移步</strong> <a href="https://calmcenter.club/2019/PicNotShow.html">图片不显示问题</a></p><h2 id="本文主要记载"><a href="#本文主要记载" class="headerlink" title="本文主要记载"></a>本文主要记载</h2><ul><li>使用 <code>hexo-helper-live2d</code> 完成看板娘</li><li>自定义看板娘(右下角那个~)<ul><li>运行、接入 <code>Demo</code></li><li>更换、修改模型</li></ul></li></ul><hr><h2 id="使用-hexo-helper-live2d-完成看板娘"><a href="#使用-hexo-helper-live2d-完成看板娘" class="headerlink" title="使用 hexo-helper-live2d 完成看板娘"></a>使用 <code>hexo-helper-live2d</code> 完成看板娘</h2><p>我的 <code>Live2D</code> 版本是 <code>3.1.1</code></p><p>首先安装配置 hexo-helper-live2d，在 <code>hexo</code> 根目录下执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-helper-live2d --save</span><br></pre></td></tr></table></figure><p>插件就安装完成了，你可一下选一个 <a href="https://huaji8.top/post/live2d-plugin-2.0/">模型</a> 这个给出了展示效果，但是不全， <a href="https://github.com/xiazeyu/live2d-widget-models">更多模型</a> 这个没有展示效果，比之前的全一点，可以自己试试效果 ~</p><p>在模型中记住自己选择模型的名字 <code>live2d-widget-model-你选中的模型名字</code> ，然后进行安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install live2d-widget-model-wanko --save</span><br></pre></td></tr></table></figure><p>然后再 <code>Hexo 配置文件</code> 中，添加如下代码，<strong>代码格式很重要！！！</strong> 有时候复制进去没有缩进，效果是出不来的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">live2d:</span><br><span class="line">  enable: true</span><br><span class="line">  scriptFrom: local</span><br><span class="line">  pluginRootPath: live2dw&#x2F;</span><br><span class="line">  pluginJsPath: lib&#x2F;</span><br><span class="line">  pluginModelPath: assets&#x2F;</span><br><span class="line">  tagMode: false</span><br><span class="line">  debug: false</span><br><span class="line">  model:</span><br><span class="line">    use: live2d-widget-model-wanko</span><br><span class="line">  display:</span><br><span class="line">    position: left</span><br><span class="line">    width: 150</span><br><span class="line">    height: 300</span><br><span class="line">  mobile:</span><br><span class="line">    show: true</span><br><span class="line">  react:</span><br><span class="line">    opacity: 0.7</span><br></pre></td></tr></table></figure><p>这样一只可爱的小白狗就出现了。</p><p>如果要加载自定义模型，需要在根目录新建文件夹 <code>live2d_models</code> 下，再新建一个文件夹 <code>kesshouban （此处自定义）</code> 然后将资源文件放入 <code>kesshouban</code> 内 。然后修改 <code>Hexo 配置文件</code> ，将 <code>model.use</code> 写成 <code>kesshouban</code> 。</p><h2 id="自定义看板娘"><a href="#自定义看板娘" class="headerlink" title="自定义看板娘"></a>自定义看板娘</h2><p>首先感谢 <a href="https://haokan.baidu.com/v?pd=wisenatural&vid=11405187949707723550">大佬</a> 提供的视屏教程，清晰易懂。</p><p>感谢 <a href="https://github.com/galnetwen">galnetwen</a> 提供的代码。</p><h3 id="1-运行-Demo"><a href="#1-运行-Demo" class="headerlink" title="1. 运行 Demo"></a>1. 运行 <code>Demo</code></h3><p>首先你需要将 <a href="https://github.com/galnetwen/Live2D">代码</a> 下载下来</p><p>解压代码并将 <code>Live2D-master</code> 里的内容 <code>live2d</code> 和 <code>demo.html</code> ，解压到 <code>hexo</code> 根目录的 <code>public</code> 的文件夹下。并运行且进入本地访问</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:4000&#x2F;demo.html</span><br></pre></td></tr></table></figure><p>如果出现 <a href="https://play.google.com/store/apps/details?id=com.sinsiroad.potionmaker&hl=zh_CN">药水制作师</a> 里的模型，就可以啦，如果出不来，证明你路径有问题，请检查路径， <code>live2d</code> 和 <code>demo.html</code> 文件在 <code>public</code> 文件夹下。</p><h3 id="2-接入-Demo"><a href="#2-接入-Demo" class="headerlink" title="2. 接入 Demo"></a>2. 接入 <code>Demo</code></h3><p>将 <code>live2d</code> 文件夹剪切到 <code>hexo/themes/next/source</code> , 文件夹内应该有三个文件夹 <code>css js model</code> 和一个文件 <code>message.json</code> 。</p><p>然后将 <code>demo.html</code> 中的代码整理出来</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/live2d/css/live2d.css&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;landlord&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;message&quot;</span> <span class="attr">style</span>=<span class="string">&quot;opacity:0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;live2d&quot;</span> <span class="attr">width</span>=<span class="string">&quot;280&quot;</span> <span class="attr">height</span>=<span class="string">&quot;250&quot;</span> <span class="attr">class</span>=<span class="string">&quot;live2d&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hide-button&quot;</span>&gt;</span>隐藏<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/jquery/2.2.4/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> message_Path = <span class="string">&#x27;/live2d/&#x27;</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> home_Path = <span class="string">&#x27;https://calmcenter.club/&#x27;</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/live2d/js/live2d.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/live2d/js/message.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">  loadlive2d(<span class="string">&quot;live2d&quot;</span>, <span class="string">&quot;/live2d/model/tia/model.json&quot;</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>粘贴到 <code>/theme/next/layout/layout.swig</code> 的 <code>&lt;footer&gt;</code> 标签下</p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/20190509151030.png" style="zoom:50%"><p>执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure><p>看板娘就到我们的博客上来啦~</p><h3 id="3-更换模型"><a href="#3-更换模型" class="headerlink" title="3. 更换模型"></a>3. 更换模型</h3><p>感谢 <a href="https://imjad.cn/">猫与向日葵</a> 提供血小板模型 <a href="https://cdn.imjad.cn/usr/uploads/kesshouban_v2.7z">下载地址</a></p><p>在 <code>hexo/next/source/live2d/model</code> 中新建一个文件夹，将压缩包里面的内容，也就是模型放到里面，然后修改 <code>model.json</code> </p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;Live2D Model Setting&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;model&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;version&quot;</span>:<span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;model&quot;</span>: <span class="string">&quot;model.moc&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;textures&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;model.2048/texture_00.png&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;layout&quot;</span>:&#123;</span><br><span class="line">      <span class="attr">&quot;center_x&quot;</span>:<span class="number">0.0</span>,</span><br><span class="line">      <span class="attr">&quot;center_y&quot;</span>:<span class="number">0.05</span>,</span><br><span class="line">      <span class="attr">&quot;width&quot;</span>:<span class="number">1.8</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;hit_areas_custom&quot;</span>:&#123;</span><br><span class="line">      <span class="attr">&quot;head_x&quot;</span>:[<span class="number">-0.35</span>, <span class="number">0.6</span>],</span><br><span class="line">      <span class="attr">&quot;head_y&quot;</span>:[<span class="number">0.19</span>, <span class="number">-0.2</span>],</span><br><span class="line">      <span class="attr">&quot;body_x&quot;</span>:[<span class="number">-0.3</span>, <span class="number">-0.25</span>],</span><br><span class="line">      <span class="attr">&quot;body_y&quot;</span>:[<span class="number">0.3</span>, <span class="number">-0.9</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;motions&quot;</span>:&#123;</span><br><span class="line">      <span class="attr">&quot;idle&quot;</span>:[</span><br><span class="line">        &#123;<span class="attr">&quot;file&quot;</span>:<span class="string">&quot;motions/Idle.mtn&quot;</span>&#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;sleepy&quot;</span>:[</span><br><span class="line">      &#123;<span class="attr">&quot;file&quot;</span>:<span class="string">&quot;motions/Nemui.mtn&quot;</span>&#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;flick_head&quot;</span>:[</span><br><span class="line">      &#123;<span class="attr">&quot;file&quot;</span>:<span class="string">&quot;motions/Anone_Synced.mtn&quot;</span>&#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;tap_body&quot;</span>:[</span><br><span class="line">      &#123;<span class="attr">&quot;file&quot;</span>:<span class="string">&quot;motions/Dance.mtn&quot;</span>&#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终成这样，一个标点都不能错 ！主要是 <code>layout(用于移动模型位置)</code> 和 <code>hit_areas_custom(用于声明点击事件范围)</code> </p><p>值的算法很简单(自己一点一点试的 = =)，以父布局中心为原点，做直角坐标系~ </p><p>这里感谢 <a href="https://www.jbblogs.cn/">jacob</a> 与我一起讨论相关内容</p><p>然后将  <code>/theme/next/layout/layout.swig</code> 的 <code>&lt;footer&gt;</code> 添加的那句话</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">loadlive2d(<span class="string">&quot;live2d&quot;</span>, <span class="string">&quot;/live2d/model/xxb/model.json&quot;</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>将 <code>xxb</code> 改成你新建的文件夹名字，编译运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure><h3 id="4-修改模型"><a href="#4-修改模型" class="headerlink" title="4. 修改模型"></a>4. 修改模型</h3><p><a href="https://imjad.cn/archives/lab/add-dynamic-poster-girl-with-live2d-to-your-blog-01">大佬链接</a></p>]]></content>
      
      
      <categories>
          
          <category> live2D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> live2D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 管理代码</title>
      <link href="2019/hexo-code-management.html"/>
      <url>2019/hexo-code-management.html</url>
      
        <content type="html"><![CDATA[<p>目录请看  <a href="https://calmcenter.club/2019/Complete_works_of_hexo.html">Hexo 搭建博客大全</a></p><p><strong>注意：如果出现图片不显示问题请移步</strong> <a href="https://calmcenter.club/2019/PicNotShow.html">图片不显示问题</a></p><h2 id="本文主要记载"><a href="#本文主要记载" class="headerlink" title="本文主要记载"></a>本文主要记载</h2><ul><li><code>git</code> 拉取代码</li><li><code>git</code> 创建分支</li><li><code>git</code> 提交分支代码</li><li>其他终端如何使用 <code>Hexo</code> 源码</li></ul><hr><a id="more"></a><h2 id="一、管理代码"><a href="#一、管理代码" class="headerlink" title="一、管理代码"></a>一、管理代码</h2><p>当我们需要在不同的终端去写博客的时候，发现 <code>github</code> 库中只有编译后的代码，所以我们需要将我们的 <code>hexo</code> 源码页放入 <code>github</code> 的分支中</p><p>首先我们需要拉取所有代码，选择一个空文件夹例如 <code>D:\blog\github_hexo</code> </p><h3 id="1-1-拉取主分支代码"><a href="#1-1-拉取主分支代码" class="headerlink" title="1.1 拉取主分支代码"></a>1.1 拉取主分支代码</h3><h4 id="1-1-1-初始化-git"><a href="#1-1-1-初始化-git" class="headerlink" title="1.1.1 初始化 git"></a>1.1.1 初始化 <code>git</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><h4 id="1-1-2-clone-远程代码，复制刚才的-SSH-路径-或者-HTTPS-路径"><a href="#1-1-2-clone-远程代码，复制刚才的-SSH-路径-或者-HTTPS-路径" class="headerlink" title="1.1.2 clone 远程代码，复制刚才的 SSH 路径 或者 HTTPS 路径"></a>1.1.2 clone 远程代码，复制刚才的 <code>SSH</code> 路径 或者 <code>HTTPS</code> 路径</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone &lt;SSH&#x2F;HTTPS&gt;</span><br></pre></td></tr></table></figure><h4 id="1-1-3-和远程仓库建立关联"><a href="#1-1-3-和远程仓库建立关联" class="headerlink" title="1.1.3 和远程仓库建立关联"></a>1.1.3 和远程仓库建立关联</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin &lt;SSH&#x2F;HTTPS&gt;</span><br></pre></td></tr></table></figure><p>如果 <code>falal：remote origin already exists.</code> ，执行下面命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rm origin</span><br></pre></td></tr></table></figure><p>然后再次建立关联 <code>git remote add origin &lt;SSH/HTTPS&gt;</code> </p><h3 id="1-2-创建分支"><a href="#1-2-创建分支" class="headerlink" title="1.2 创建分支"></a>1.2 创建分支</h3><h4 id="1-2-1-查看分支情况"><a href="#1-2-1-查看分支情况" class="headerlink" title="1.2.1 查看分支情况"></a>1.2.1 查看分支情况</h4><p>进入拉取下来的目录 <code>cd &lt;文件名&gt;</code></p><p>查看分支，查看本地分支包括远程分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure><h4 id="1-2-2-创建本地分支"><a href="#1-2-2-创建本地分支" class="headerlink" title="1.2.2 创建本地分支"></a>1.2.2 创建本地分支</h4><p>创建本地分支并切换到新分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b test</span><br></pre></td></tr></table></figure><p>等价于 <code>git branch test</code> 和 <code>git checkout test</code> </p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/picturesgit_branch1.png" style="zoom:100%"><p>这里会告诉你本地当前所处的分支，切换分支可以用，<strong>当你切换分支时，如果本地没有但是远程有这个分支，它会自动给你拉取远程分支，并切换</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout test </span><br></pre></td></tr></table></figure><h4 id="1-2-3-更新远程分支"><a href="#1-2-3-更新远程分支" class="headerlink" title="1.2.3 更新远程分支"></a>1.2.3 更新远程分支</h4><p>上图你可以看到本地分支比远程分支多一个 <code>test</code> 下一步就是将新分支推送至远程GitHub</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin test</span><br></pre></td></tr></table></figure><p>完成后，执行查看分支命令 <code>git branch -a</code> 会发现远程 多了 <code>test</code> 分支。</p><p><strong>如果想删掉分支</strong>，删除本地分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d &lt;分支名称&gt;</span><br></pre></td></tr></table></figure><p>提交删除到远程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin --delete &lt;分支名称&gt;</span><br></pre></td></tr></table></figure><h3 id="1-3-提交源码到远程分支"><a href="#1-3-提交源码到远程分支" class="headerlink" title="1.3 提交源码到远程分支"></a>1.3 提交源码到远程分支</h3><h4 id="1-3-1-本地操作代码"><a href="#1-3-1-本地操作代码" class="headerlink" title="1.3.1 本地操作代码"></a>1.3.1 本地操作代码</h4><p>在确保是 <code>test</code> 分支下，然后将 <code>.git</code> 以外的所有文件删掉，将 <code>hexo</code> 源码复制到  <code>D:\blog\github_hexo</code> 下，查看文件状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><p><strong>注意:如果你之前是 <code>git</code> 直接 <code>clone</code> 的 <code>NexT</code> ，在拉取目录会自带 <code>.git</code> 和 <code>.github</code> 文件，需要删掉 <code>.git</code> 和 <code>.github</code> 文件，如果不删会出现拉取目录里的文件提交不上去的问题</strong></p><h3 id="设置语言、标题等"><a href="#设置语言、标题等" class="headerlink" title="设置语言、标题等"></a>设置语言、标题等</h3><h4 id="1-3-2-添加到暂存区"><a href="#1-3-2-添加到暂存区" class="headerlink" title="1.3.2 添加到暂存区"></a>1.3.2 添加到暂存区</h4><p><strong>(最后是一个 . 或者 -A 表示所有)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure><h4 id="1-3-3-提交本地代码库"><a href="#1-3-3-提交本地代码库" class="headerlink" title="1.3.3 提交本地代码库"></a>1.3.3 提交本地代码库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;描述&quot;</span><br></pre></td></tr></table></figure><h4 id="1-3-4-提交到远程分支"><a href="#1-3-4-提交到远程分支" class="headerlink" title="1.3.4 提交到远程分支"></a>1.3.4 提交到远程分支</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure><p>如果提示没有关联，则用下面指令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push --set-upstream origin &lt;分支名&gt;</span><br></pre></td></tr></table></figure><h3 id="1-5-其他终端操作"><a href="#1-5-其他终端操作" class="headerlink" title="1.5 其他终端操作"></a>1.5 其他终端操作</h3><h4 id="1-5-1-hexo-环境搭建"><a href="#1-5-1-hexo-环境搭建" class="headerlink" title="1.5.1 hexo 环境搭建"></a>1.5.1 <code>hexo</code> 环境搭建</h4><p>首先创建一个空目录，初始化 <code>git</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>安装 <code>hexo-cli</code> 执行下面命令，如果该终端执行过可跳过，再次执行会报错，需要删除掉 <code>C:\Users\&lt;电脑名字&gt;\AppData\Roaming</code> 目录下 <code>npm-cache</code> 和 <code>npm</code> 文件，重新执行这个命令就好。<code>(个人多次实践出来的，不行就删。。。)</code> </p><p>如果 <code>hexo</code> 命令执行过程中报 <code>bash: hexo: command not found</code> 就是没有安装 <code>hexo</code> ，需要执行下面的命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure><h4 id="1-5-2-拉取远程分支代码"><a href="#1-5-2-拉取远程分支代码" class="headerlink" title="1.5.2 拉取远程分支代码"></a>1.5.2 拉取远程分支代码</h4><p>然后执行 5.1 的操作 <code>git clone &lt;SSH/HTTPS&gt;</code>、<code>git remote add origin &lt;SSH/HTTPS&gt;</code> ，将远程所有代码拉下来。当前状态你只有主分支代码，你还需要拉取你 <code>test</code> 分支的代码，进入拉取下来的目录 <code>cd &lt;文件名&gt;</code> 。</p><p><code>git branch -a</code> 查看分支情况。然后切换并拉取 <code>test</code> 分支。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout test</span><br></pre></td></tr></table></figure><h4 id="1-5-3-安装环境"><a href="#1-5-3-安装环境" class="headerlink" title="1.5.3 安装环境"></a>1.5.3 安装环境</h4><p>首先在文件目录下，安装 <code>hexo</code> 和 <code>deployer</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo --save</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>然后编译并运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure><p>这样本地就好了，发布 <code>github</code> 需要配置 <code>SSH</code> 和之前 4.3 操作是一样的。</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> git </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 基础搭建</title>
      <link href="2019/hexo-bash.html"/>
      <url>2019/hexo-bash.html</url>
      
        <content type="html"><![CDATA[<p>目录请看 <a href="https://calmcenter.club/2019/Complete_works_of_hexo.html">Hexo 搭建博客大全</a></p><p><strong>注意：如果出现图片不显示问题请移步</strong> <a href="https://calmcenter.club/2019/PicNotShow.html">图片不显示问题</a></p><h2 id="本文主要记载"><a href="#本文主要记载" class="headerlink" title="本文主要记载"></a>本文主要记载</h2><ul><li>搭建本地博客</li><li>部署到 <code>Github Pages</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">本文环境是 win10 或 win 7。mac 再执行 npm 时需要在前面添加 sudo</span><br><span class="line">本文整理于各大佬文章，文中会给出相应链接，如有侵权，请联系我修改或删除。</span><br></pre></td></tr></table></figure><hr><a id="more"></a><h2 id="一、-搭建本地博客"><a href="#一、-搭建本地博客" class="headerlink" title="一、 搭建本地博客"></a>一、 搭建本地博客</h2><h3 id="1-1-首先安装-Node-js"><a href="#1-1-首先安装-Node-js" class="headerlink" title="1.1 首先安装 Node.js"></a>1.1 首先安装 <code>Node.js</code></h3><p>首先去 <a href="https://nodejs.org/en/download/">官方页面</a> 下载安装文件，无脑安装就好 （<del>。</del>）</p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/picturesnode.png" style="zoom:20%"><p>图中绿色选择部分，安装完成后输入 <code>npm -v</code> , 会告诉你版本号，就证明你安装成功了</p><p>3.2 安装 <code>Git</code></p><p>去 <a href="https://git-scm.com/download/win">git官网</a> 下载电脑对应版本，进行安装，安装完成后，输入 <code>git version</code> ，会告诉你版本号，就证明你安装成功了。安装成功后，鼠标右键菜单里会多出 <code>Git GUI Here</code> 和 <code>Git Bash Here</code> 两个按钮。</p><p><strong><a href="https://www.cnblogs.com/wj-1314/p/7993819.html">Git安装教程</a>  这个是百度的，如果不会查看本链接或重新百度就好~</strong></p><p><strong>我管理代码都是在 <a href="https://www.sourcetreeapp.com/">Sourcetree</a> 上进行，后续会说，当然也是要 Git 的支持，这个还是很方便的，无脑操作~6</strong></p><h3 id="1-2-安装-Hexo"><a href="#1-2-安装-Hexo" class="headerlink" title="1.2 安装 Hexo"></a>1.2 安装 <code>Hexo</code></h3><p>*<em>注意执行命令期间 <code>WARN</code> 不管 只看 <code>ERR</code> *</em></p><p>在文件夹内如 <code>D:\blog</code> ，鼠标右键点击 <code>Git Bash Here</code> 一气呵成，来到了命令行界面。</p><p>首先安装 <code>hexo</code> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure><h4 id="1-2-1-镜像相关（如果-npm-可以正常使用这里跳过！）"><a href="#1-2-1-镜像相关（如果-npm-可以正常使用这里跳过！）" class="headerlink" title="1.2.1 镜像相关（如果 npm 可以正常使用这里跳过！）"></a>1.2.1 镜像相关（如果 npm 可以正常使用这里跳过！）</h4><p> 上面正常情况是没有问题的，但是由于国内访问官方 NPM 源速度较慢，为了一劳永逸，此处可以将 NPM 源更换为了淘宝 NPM 镜像源。<br><strong>请注意!!，如果你觉得你的 NPM 源速度够快，更换镜像源这部分可选择性使用</strong></p><p>在 <code>Git Bash Here</code> 中输入指令，将官方 npm 源更换为淘宝 npm 镜像源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>可以输入 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm config list</span><br></pre></td></tr></table></figure><p> 查看是否更换成功</p><p><strong>请注意，如需使用上方安装的淘宝源，需要在使用 npm 命令时将其改为 cnpm</strong>，但是如果用了 cnpm 再使用 npm 的话，好像有点问题，npm 一直报 err 。所以这里给出卸载镜像的命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall cnpm -g</span><br></pre></td></tr></table></figure><p>但是 npm 命令还是报错，还需要删除掉 <code>C:\Users\&lt;电脑名字&gt;\AppData\Roaming</code> 目录下  <code>npm-cache</code> 和 <code>npm</code> 文件，重新执行上面两个安装命令即可</p><h3 id="1-3-Hexo初始化"><a href="#1-3-Hexo初始化" class="headerlink" title="1.3 Hexo初始化"></a>1.3 Hexo初始化</h3><p>安装完成后，输入 <code>hexo -v</code> 会输出 hexo 版本号，证明安装成功。</p><p>然后在当前目录新建一个文件夹，比如 <code>D:\blog\hexos</code> ，在此目录下鼠标右键点击 <code>Git Bash Here</code> 执行，这条命令需要一个空文件夹所以新建一个。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><p>完成后，文件目录如下</p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/pictureshexo_file.png" style="zoom:100%"><p>这样就证明初始化完成了，然后我们继续要生成静态页面，用到的命令是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><p>其中，<code>g</code> 的全称是 <code>generate</code>，当然也可以用 <code>hexo generate</code> 这条命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-server --save</span><br></pre></td></tr></table></figure><p>然后就是运行了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>其中， <code>s</code> 的全称是 <code>server</code>，当然也可以用 <code>hexo server</code> 这条命令</p><p>然后，打开你的浏览器，输入<code>http://localhost:4000/</code> 即可看到本地静态博客</p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/pictureshexo_page.png" style="zoom:20%"><p>本地静态博客完成 ~ </p><p>如果出现 <code>Cannot GET/xxx</code> 等类似错误，意味着有文件未被找到。<code>Cannot GET/xxx</code> 错误本质是 <code>hexo server</code> 返回的一个404错误。</p><p>判断public目录下 <code>xxx</code> 文件是否存在。(我的错误是 <code>Cannot GET/</code> ，因此在public目录下寻找 <code>index.html</code> 是否存在。)</p><p>如果说 <code>index.html</code> 不存在，那么执行 <code>hexo clean</code>，<code>hexo g</code> 重新生成一次，回到步骤1。</p><p>步骤2执行完后 <code>index.html</code> 仍不存在，执行 <code>npm audit fix</code> ，查看是否少了什么组件，通过 <code>npm install hexo-xxx-xxx</code>  安装即可。</p><p>步骤3完成之后，执行 <code>hexo clean</code>，<code>hexo g</code> 重新生成静态文件。</p><p>仍然有问题，请再参考此文：<a href="https://www.cnblogs.com/Sroot/p/6305938.html">https://www.cnblogs.com/Sroot/p/6305938.html</a></p><p>感谢 <a href="https://www.jianshu.com/p/af83fc73e525">Cannot GET 错误解决方式 原文地址</a></p><hr><h2 id="二、部署到-Github-Pages"><a href="#二、部署到-Github-Pages" class="headerlink" title="二、部署到 Github Pages"></a>二、部署到 Github Pages</h2><h3 id="2-1-注册Github账户"><a href="#2-1-注册Github账户" class="headerlink" title="2.1 注册Github账户"></a>2.1 注册Github账户</h3><p>进入 <a href="https://github.com/">github首页</a> ，点击右上角 <a href="https://github.com/join?source=header-home">sign up</a> 进行注册。</p><h3 id="2-2-创建项目"><a href="#2-2-创建项目" class="headerlink" title="2.2 创建项目"></a>2.2 创建项目</h3><p>登录后，创建一个自己的 <code>GitHub Pages</code>。 点击头像中的 <a href="https://github.com/new">New repository</a> 。</p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/picturesnew_repository.png" style="zoom:50%"><p>*<em>敲黑板！！ 这里重点就是项目名称必须是 <code>自己名称.github.io</code>  *</em></p><h3 id="2-3-配置-SSH-密钥"><a href="#2-3-配置-SSH-密钥" class="headerlink" title="2.3 配置 SSH 密钥"></a>2.3 配置 <code>SSH</code> 密钥</h3><h4 id="2-3-1-查看是否存在-SSH-密钥"><a href="#2-3-1-查看是否存在-SSH-密钥" class="headerlink" title="2.3.1 查看是否存在 SSH 密钥"></a>2.3.1 查看是否存在 <code>SSH</code> 密钥</h4><p>首先通过输入命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~&#x2F;. ssh </span><br></pre></td></tr></table></figure><p>如果存在则会进入此目录,可以略过 4.3.2，否则会提示你不存在，那么继续 4.3.2</p><h4 id="2-3-2-创建新的-SSH-密钥"><a href="#2-3-2-创建新的-SSH-密钥" class="headerlink" title="2.3.2 创建新的 SSH 密钥"></a>2.3.2 创建新的 <code>SSH</code> 密钥</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;your_email@example.com&quot;</span><br></pre></td></tr></table></figure><p>这将按照你提供的邮箱地址，创建一对密钥，然后让你输入 密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Enter passphrase (empty for no passphrase): [Type a passphrase]</span><br><span class="line">Enter same passphrase again: [Type passphrase again]</span><br></pre></td></tr></table></figure><p>如果你放心，可以不用密码，直接回车，这样每次提交的时候比较方便。</p><h4 id="2-3-3-在-GitHub-添加你的公钥"><a href="#2-3-3-在-GitHub-添加你的公钥" class="headerlink" title="2.3.3 在 GitHub 添加你的公钥"></a>2.3.3 在 <code>GitHub</code> 添加你的公钥</h4><ol><li>首先拷贝公钥内容（ mac 可能用不了，需要手动找到这个文件复制内容）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clip &lt; ~&#x2F;.ssh&#x2F;id_rsa.pub</span><br></pre></td></tr></table></figure><ol start="2"><li>然后登陆 <a href="https://github.com/">GitHub</a> ，点击头像</li></ol><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/picturessetting.png" style="zoom:50%"><ol start="3"><li>进入设置页，选择 <code>SSH</code> </li></ol><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/picturessetting_list.png" style="zoom:50%"><ol start="4"><li>粘贴密钥，添加即可</li></ol><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/picturesssh_content.png" style="zoom:50%"><ol start="5"><li>测试</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/picturestest_ssh.png" style="zoom:100%"><ol start="6"><li>设置用户信息</li></ol><p><code>Git</code> 会根据用户的名字和邮箱来记录提交。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;name&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.email &quot;email&quot;</span><br></pre></td></tr></table></figure><p>这样就配置好了SSH</p><h3 id="2-4-将本地-Hexo-文件编译并上传-GitHub-的库中"><a href="#2-4-将本地-Hexo-文件编译并上传-GitHub-的库中" class="headerlink" title="2.4 将本地 Hexo 文件编译并上传 GitHub 的库中"></a>2.4 将本地 <code>Hexo</code> 文件编译并上传 <code>GitHub</code> 的库中</h3><ol><li>打开 <a href="https://github.com/">github首页</a> 登录，找到左上角自己的项目</li></ol><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/picturesgithub_list.png" style="zoom:70%"><ol start="2"><li><p>点击 clone 点击 Use SSH 并复制 <code>SSH</code> 路径</p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/picturesgithub_ssh_path.png" style="zoom:70%"></li><li><p>打开 <code>hexo</code> 目录，找到 <code>_config</code> 文件</p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/pictureshexo_catalog_config.png" style="zoom:70%"></li><li><p>打开并找到 <code>deploy</code> 关键字</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:CalmCenter&#x2F;calmcenter.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p><strong>注意: 引号 后有一个空格，repository 填写 ssh 地址，branch 如果没有特殊要求，写master</strong></p><ol start="5"><li>编译并提交</li></ol><p>部署前需要先装 <code>deployer</code> ，<code>deployer</code> 用于将 <code>hexo</code> 部署到  <code>git page</code> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>提交前，有时候提交了不生效，需要清理一下缓存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure><p>编译并提交</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure><p> 和 <code>hexo g</code> 、 <code>hexo d</code> 一样</p><p><strong>提交后线上会有延迟才会展现最新效果，特别是配置样式之后</strong></p><p>提交过程中会让你输入一次密码，完成后就可以在外网访问博客了。<a href="https://calmcenter.github.io/">https://calmcenter.github.io/</a> <code>https://用户名.github.io</code></p><p>假如这时候，报错 <code>ERROR Deployer not found: git</code>，那么就是你的 <code>deployer</code> 没有安装成功，你需要执行如下命令再安装一次：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>这样，你再执行 <code>hexo g -d</code> ，你的博客就部署到 <code>Github</code> 上了。</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> git </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 性能优化篇</title>
      <link href="2019/complete-works-of-android-performance.html"/>
      <url>2019/complete-works-of-android-performance.html</url>
      
        <content type="html"><![CDATA[<p>随着项目版本的迭代，<code>App</code> 的性能问题会逐渐暴露出来，而好的用户体验与性能表现紧密相关。 最近项目核心功能收尾，准备开启优化之路，打造一个高用户体验的 <code>APP</code> </p><p>技术不断更新，我将在边学习边实践的过程中进行分享，并将实践结果与大家分享，希望大家看到文章中有不足的地方及时给我留言，我将与大家积极讨论。</p><p><strong>注意：如果出现图片不显示问题请移步</strong> <a href="https://calmcenter.club/2019/PicNotShow.html">图片不显示问题</a> </p><hr><h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><p><a href="https://calmcenter.club/2019/performance-launch.html">App 初体验-启动优化 more  💦</a> </p><p><a href="https://calmcenter.club/2020/memory-optimization.html">App 内存知识介绍 more 💦</a> </p><p><a href="https://calmcenter.club/2020/memory-optimization2.html">App 内存检测优化 more 💦 </a> </p><p><a href="https://calmcenter.club/2020/ui-optimization.html">App UI 优化 more 💦</a> </p><p><a href="https://calmcenter.club/2020/hobble-optimization.html">App 直观感受-卡顿优化 more 🌈</a> </p><p><a href="https://calmcenter.club/2020/power-optimization.html">App 电量优化</a> </p><p><a href="https://calmcenter.club/2020/storage-optimization.html">App 存储优化💦</a> </p><p><a href="https://calmcenter.club/2020/network-optimization.html">App 网络优化🌞</a> </p><p><a href="https://calmcenter.club/2020/package-optimization.html">App 刷脂</a> </p><hr><p><a href="https://time.geekbang.org/column/article/74044">极客时间 Android开发高手课</a>  </p><p><a href="https://coding.imooc.com/learn/list/308.html">慕课 Top团队大牛带你玩转Android性能分析与优化</a> </p><hr><h1 id="微信-Matrix-源码解读"><a href="#微信-Matrix-源码解读" class="headerlink" title="微信 Matrix  源码解读"></a>微信 Matrix  源码解读</h1><p>首先了解 <code>Matrix</code> 的配置源码 <a href="https://www.jianshu.com/p/95dfe1f41971">腾讯 Apm 框架 Matrix 源码阅读 - gradle插件</a> 其中使用到了 <code>gradle</code> 中 <code>Transform</code> 和 <code>Task</code> 相关文章 <a href="https://www.jianshu.com/p/1b506e0f8a5b">Gradle自定义插件实现自定义Task</a> 、<a href="https://www.jianshu.com/p/49425d46ea4f">Android中Gradle插件和Transform</a> ，<code>Matrix</code> 在 <code>gradle</code> 的 <code>afterEvaluate</code> 时期 <code>hook</code> 系统 生成 <code>dex</code> 的 <code>Task</code> 为自定义的 <code>Task</code>，并在执行完相关流程后，再执行回原有 <code>Task</code> ，将控制权交还给系统。<code>Matrix</code> 使用 <code>Transform</code> 配合 <code>ASM</code> 完成侵入编译流程进行字节码插入操作。</p><p>然后了解 <code>Matrix</code> 代码架构 <a href="https://www.jianshu.com/p/d0f2164dd053">腾讯 Apm 框架 Matrix 源码阅读 - 架构解析</a> ，<code>Matrix</code>是整个框架的入口也是所有插件的管理者，所有的插件都需要继承<code>Plugin</code>，<code>Plugin</code>本身已经具备了问题上报和感知 <code>APP</code> 前后台状态的能力。</p><p>不论是 <code>gradle</code> 的使用还是架构设计都有很多地方值得去学习。 </p><h2 id="Matrix-Android-TraceCanary"><a href="#Matrix-Android-TraceCanary" class="headerlink" title="Matrix-Android-TraceCanary"></a><a href="https://github.com/Tencent/matrix/wiki/Matrix-Android-TraceCanary">Matrix-Android-TraceCanary</a></h2><p>先看看它的 <a href="https://www.jianshu.com/p/768b14dc0ffe">TracePlugin 架构</a> ，其中重点是 <code>UIThreadMonitor</code> 和 <code>UIThreadMonitor</code> 。</p><ul><li><code>UIThreadMonitor</code>配合 <code>LooperMonitor</code> 获得每个刷新帧的各个阶段的耗时时间。其中涉及到 <code>Choreographer</code>(主要是配合 <code>Vsync</code> ，给上层 <code>App</code> 的渲染提供一个稳定的 <code>Message</code> 处理的时机，即 <code>Vsync</code> 到来的时候 ，系统通过对 <code>Vsync</code> 信号周期的调整，来控制每一帧绘制操作的时机)，相关文章 <a href="https://www.jianshu.com/p/538df44171b1">Choreographer工作流程分析</a> 。</li><li><code>AppMethodBeat</code> 记录了 <code>Application</code> 的启动时间和结束，<code>hook ActivityThread</code> 中 <code>mH</code> 的 <code>Handler.Callback</code> 对象为自定义的<code>HackCallback</code>对象来记录最近一个 <code>Activity</code> 被打开的时间，每个方法的耗时时间。</li></ul><p><code>TracePlugin</code> 包含 <code>FrameTracer</code>、<code>StartupTracer</code>、<code>AnrTracer</code> </p><ul><li><strong>FrameTracer：</strong> 通过<code>UIThreadMonitor</code>提供的感知每帧耗时的能力。进行简单的整合再通知给各个<code>IDoFrameListener</code>。<code>Matrx</code> 中提供了两个 <code>IDoFrameListener</code> 一个就是 <code>FPSCollector</code> 用于上报 <code>FPS</code>，另一个是<code>FrameDecorator</code>用于直接显示 <code>FPS</code> 。当然也可以自己先 <code>IDoFrameListener</code> 自己实现分析逻辑。</li><li><strong>StartupTracer：</strong> 当 <code>onActivityFocused</code> 被回调时，进行各个时间点的计算，监控并上报 <code>App</code> 冷/暖启动时间，Activity启动时间，配合 <code>AppMethodBeat</code> 中记录的方法执行时间，筛选出导致启动时间长的方法并上报</li><li><strong>AnrTracer：</strong> 很好理解的一个 <code>Tracer</code> ，通过 <code>UIThreadMonitor</code> 感知 <code>Looper loop</code> 工作的开始，刷新帧，结束的时间，并在结束时分析是否超过阈值，如果超过就从 <code>AppMethodBeat</code> 中获取相关数据进行分析并上报。将上报<code>Task</code> 延迟发送，如果 <code>dispatchEnd</code> 在规定时间内没有回调，就发送上报 <code>Task</code> 。<code>Android</code> 源码中的 <code>ANR</code> 也是这么玩的 <a href="http://gityuan.com/2016/07/02/android-anr/">理解Android ANR的触发原理</a> </li></ul><p><a href="https://www.jianshu.com/u/aae493aa9810">原文作者 河里的枇杷树</a> </p><hr>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 搭建博客篇</title>
      <link href="2019/complete-works-of-hexo.html"/>
      <url>2019/complete-works-of-hexo.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、为什么要写这篇文章"><a href="#一、为什么要写这篇文章" class="headerlink" title="一、为什么要写这篇文章"></a>一、为什么要写这篇文章</h1><p>各大网站关于搭建博客的文章已经不是一篇两篇了，但是他们的文章也有坑~<code>(可能是版本问题)</code>也各有各的特点，这里带你踩坑，并带你实现他们的特点</p><blockquote><p>把无序的信息变的有序，本质上也是信息差，也是可以创造价值的。</p></blockquote><p>所以我准备整理一下各各博客的特点，尽力写成一本大全。</p><h1 id="二、本文主要记载"><a href="#二、本文主要记载" class="headerlink" title="二、本文主要记载"></a>二、本文主要记载</h1><ul><li><strong>Hexo</strong> 基础搭建</li><li>管理代码( <strong>git</strong> 基本操作)</li><li>装饰博客</li><li><strong>live2D</strong> 看板娘</li><li>网站管理<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">本文环境是 win10 或 win 7。mac 再执行 npm 时需要在前面添加 sudo</span><br><span class="line">本文整理于各大佬文章，文中会给出相应链接，如有侵权，请联系我修改或删除。</span><br></pre></td></tr></table></figure></li></ul><hr><a id="more"></a><h2 id="Hexo-基础搭建-more"><a href="#Hexo-基础搭建-more" class="headerlink" title="Hexo 基础搭建 more  "></a><a href="https://calmcenter.club/2019/hexo-bash.html">Hexo 基础搭建 more  </a></h2><ul><li>搭建本地博客</li><li>部署到 <strong>Github Pages</strong></li></ul><h2 id="管理代码-git-基本操作-more"><a href="#管理代码-git-基本操作-more" class="headerlink" title="管理代码( git 基本操作) more"></a><a href="https://calmcenter.club/2019/hexo-code-management.html">管理代码( git 基本操作) more</a></h2><ul><li><strong>git</strong> 拉取代码</li><li><strong>git</strong> 创建分支</li><li><strong>git</strong> 提交分支代码</li><li>其他终端如何使用 <strong>Hexo</strong> 源码</li></ul><h2 id="功能样式配置-more"><a href="#功能样式配置-more" class="headerlink" title="功能样式配置 more  "></a><a href="https://calmcenter.club/2019/hexo-functional-style.html">功能样式配置 more  </a></h2><ul><li><strong>NexT</strong> 主题设置</li><li>基础样式设置</li><li>图片相关</li><li>打赏、评论、复制功能</li><li><strong>DaoVoice</strong> 实现在线联系</li><li>文章置顶</li><li>搜索功能</li><li>细节美化</li></ul><h2 id="live2D-看板娘-more"><a href="#live2D-看板娘-more" class="headerlink" title="live2D 看板娘 more  "></a><a href="https://calmcenter.club/2019/hexo-live2d.html"><strong>live2D</strong> 看板娘 more  </a></h2><ul><li>使用 <strong>hexo-helper-live2d</strong> 完成看板娘</li><li>自定义看板娘(右下角那个~)<ul><li>运行、接入 <strong>Demo</strong></li><li>更换、修改模型</li></ul></li></ul><h2 id="网站管理-more"><a href="#网站管理-more" class="headerlink" title="网站管理 more  "></a><a href="https://calmcenter.club/2019/hexo-website-management.html">网站管理 more  </a></h2><ul><li>个人域名</li><li>加入 <strong>Coding</strong> 服务器</li><li><strong>SEO</strong>  推广</li></ul><hr><h1 id="来都来了-在评论留下你的足迹可否-？"><a href="#来都来了-在评论留下你的足迹可否-？" class="headerlink" title="来都来了 ~ 在评论留下你的足迹可否 ？"></a><code>来都来了 ~ 在评论留下你的足迹可否 ？</code></h1><p><strong>注意：如果出现图片不显示问题请移步</strong> <a href="https://calmcenter.club/2019/PicNotShow.html">图片不显示问题</a></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Next </tag>
            
            <tag> git </tag>
            
            <tag> github </tag>
            
            <tag> live2d </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitHub 博客图片不显示问题</title>
      <link href="2019/picnotshow.html"/>
      <url>2019/picnotshow.html</url>
      
        <content type="html"><![CDATA[<p>现在将图片都放在了 码云 上了，所以暂时不会出现图片问题~ 。</p><p>手机图片问题除了 翻 ，有知道的小伙伴可以留言。</p><p>因为我是自己上传的 <code>github</code> ，然后打不开了，所以查了一下 <code>ip</code> 和相关文章。网上文章都是在 <code>C:\Windows\System32\drivers\etc\hosts</code> 文件中复制固定内容，不同网段的用户查到的 <code>IP</code> 可能不一样，所以需要自己去查，而不是简单的copy。</p><ul><li>首先检测是哪个链接问题，这里我是调整好的。</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/20200330134722.png" alt=""></p><ul><li>打开 <a href="http://tool.chinaz.com/dns/">DNS查询网站</a> ，搜索 <code>avatars2.githubusercontent.com</code> </li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/20200330135205.png" alt=""></p><p>选择一个可以使用的 <code>IP</code>，在 <code>C:\Windows\System32\drivers\etc\hosts</code> 末尾 加上</p><p>在末尾加上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">151.101.108.133 avatars0.githubusercontent.com </span><br><span class="line">151.101.108.133 avatars1.githubusercontent.com </span><br><span class="line">151.101.108.133 avatars2.githubusercontent.com </span><br><span class="line">151.101.108.133 avatars3.githubusercontent.com </span><br><span class="line">151.101.108.133 avatars4.githubusercontent.com </span><br><span class="line">151.101.108.133 avatars5.githubusercontent.com </span><br><span class="line">151.101.108.133 avatars6.githubusercontent.com </span><br><span class="line">151.101.108.133 avatars7.githubusercontent.com </span><br><span class="line">151.101.108.133 avatars8.githubusercontent.com </span><br></pre></td></tr></table></figure><p>不同网段的用户查到的 <code>IP</code> 可能不一样，所以需要自己去查，而不是简单的copy，这是我最终的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># GitHub Start </span><br><span class="line">192.30.253.112 github.com </span><br><span class="line">192.30.253.119 gist.github.com </span><br><span class="line">185.199.111.154 github.githubassets.com </span><br><span class="line">185.199.108.154 github.githubassets.com </span><br><span class="line">185.199.109.154 github.githubassets.com </span><br><span class="line">185.199.110.154 github.githubassets.com </span><br><span class="line">151.101.108.133 assets-cdn.github.com </span><br><span class="line">151.101.108.133 raw.githubusercontent.com </span><br><span class="line">151.101.108.133 gist.githubusercontent.com </span><br><span class="line">151.101.108.133 cloud.githubusercontent.com </span><br><span class="line">151.101.108.133 camo.githubusercontent.com </span><br><span class="line">151.101.108.133 avatars0.githubusercontent.com </span><br><span class="line">151.101.108.133 avatars1.githubusercontent.com </span><br><span class="line">151.101.108.133 avatars2.githubusercontent.com </span><br><span class="line">151.101.108.133 avatars3.githubusercontent.com </span><br><span class="line">151.101.108.133 avatars4.githubusercontent.com </span><br><span class="line">151.101.108.133 avatars5.githubusercontent.com </span><br><span class="line">151.101.108.133 avatars6.githubusercontent.com </span><br><span class="line">151.101.108.133 avatars7.githubusercontent.com </span><br><span class="line">151.101.108.133 avatars8.githubusercontent.com </span><br><span class="line"> </span><br><span class="line"># GitHub End</span><br></pre></td></tr></table></figure><ul><li>刷新 <code>DNS</code></li></ul><p>在 <code>cmd</code> 中输入<code>ipconfig /flushdns</code> 即可刷新，不行的话再重启电脑，这样就能成功打开<code>github</code> 或博客了，所有图片和内容都能加载。</p>]]></content>
      
      
      <categories>
          
          <category> github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
