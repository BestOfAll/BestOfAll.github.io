<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>App 包体积优化</title>
      <link href="/2020/package-optimization.html"/>
      <url>/2020/package-optimization.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>App 电量优化</title>
      <link href="/2020/power-optimization.html"/>
      <url>/2020/power-optimization.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>App 存储优化💦</title>
      <link href="/2020/storage-optimization.html"/>
      <url>/2020/storage-optimization.html</url>
      
        <content type="html"><![CDATA[<p>本文记录开发过程中常见存储方法的优缺点，希望可以在日常工作中如何做出更好的选择。</p><p><strong>注意：如果出现图片不显示问题请移步</strong> <a href="https://calmcenter.club/2019/PicNotShow.html">图片不显示问题</a></p><h1 id="本文主要记载"><a href="#本文主要记载" class="headerlink" title="本文主要记载"></a>本文主要记载</h1><hr><h1 id="1-如何选择持久化存储方案？"><a href="#1-如何选择持久化存储方案？" class="headerlink" title="1 如何选择持久化存储方案？"></a>1 如何选择持久化存储方案？</h1><h2 id="1-1-考察存储关键要素"><a href="#1-1-考察存储关键要素" class="headerlink" title="1.1 考察存储关键要素"></a>1.1 考察存储关键要素</h2><ol><li><p><strong>正确性：</strong> 选择存储方案的时候，第一个需要判断它<strong>是否靠谱</strong>。这套存储方案<strong>设计是否完备</strong>，有没有支持<strong>多线程</strong>或者<strong>多进程</strong>操作。内部<strong>是否健壮</strong>，有没有考虑<strong>异常情况下数据的校验和恢复</strong>，比如采取双写或者备份文件策略，即使主文件因为系统底层导致损坏，也可以一定程度恢复大部分数据。</p></li><li><p><strong>时间开销：</strong>这里说的时间开销包括了 <code>CPU</code> 时间和 <code>I/O</code> 时间，在 <code>I/O</code> 优化中我就多次提到相比 <code>CPU</code> 和内存，<code>I/O</code> 存储的速度是非常慢的。但是如果存储方法中比如编解码或者加密/解密等设计的比较复杂，整个数据存储过程也会出现 <code>CPU</code> 时间变的更长的情况。</p></li><li><p><strong>控件开销：</strong>即使相同的数据如果使用不同的编码方式，最后占用的存储空间也会有所不同。举一个简单的例子，相同的数据所占的空间大小是 <code>XML&gt;JSON&gt;Protocol Buffer</code>。除了编码方式的差异，在一些场景我们可能还需要引入压缩策略来进一步减少存储空间，例如<code>zip</code>、<code>Izma</code> 等。数据存储的空间开销还需要考虑内存空间的占用量，整个存储过程会不会导致应用出现大量 <code>GC</code> 、<code>OOM</code> 等</p></li><li><p><strong>安全：</strong>应用中可能会有一些非常敏感的数据，即使它们存储在 <code>/data/data</code> 中，我们依然必须将它们加密。例如微信的聊天数据是存储在加密的数据库中，一些账号相关的数据我们也要单独做加密落地。根据加密强度的不同，可以选择 <code>RSA</code> 、<code>AES</code>、<code>chacha20</code>、<code>TEA</code>这些常用的加密算法</p></li><li><p><strong>开发成本：</strong>有些存储方案看起来非常高大上，但是需要业务做很大改造才能接入。这里我们当然希望能无缝的接入到业务中，在整个开发过程越简单越好</p></li><li><p><strong>兼容性：</strong>业务不停地向前演进，我们的存储字段或者格式有时候也会不得不有所变化。兼容性首先要考虑的是向前、向后的兼容性，老的数据在升级时能否迁移过来，新的数据在老版本能否降级使用。兼容性另外一个需要考虑的可能是多语言的问题，不同的语言是否支持转换</p></li></ol><p>数据存储方法不能脱离场景来考虑，我们不可能把这六个要素都做成最完美。如果首要考虑的是<strong>正确性</strong>，那我们可能需要采用冗余、双写等方案，那就要容忍对<strong>时间开销</strong>产生的额外影响。同样如果非常在意<strong>安全</strong>，加解密环节的<strong>开销</strong>也必不可小。如果想针对启动场景，我们希望选择在初始化时间和读取时间更有优势的方案。</p><hr><h2 id="1-2-SharedPreferences"><a href="#1-2-SharedPreferences" class="headerlink" title="1.2 SharedPreferences"></a>1.2 SharedPreferences</h2><p><code>SharedPreferences</code> 使用非常简便，但也是诟病比较多的存储方法。</p><ol><li><strong>跨进程不安全：</strong>由于没有使用跨进程的锁，就算使用 <code>MODE_MULTI_PROCESS</code>，<code>SharedPreferences</code> 在跨进程频繁读写有可能导致数据全部丢失。根据线上统计，<code>SP</code> 大约会有万分之一的损坏率。</li><li><strong>加载缓慢：</strong><code>SharedPreferences</code> 文件的加载使用了异步线程，而且加载线程并没有设置线程优先级，如果这个时候主线程读取数据就需要等待文件加载线程的结束。这就导致出现主线程等待低优先级线程锁的问题，比如一个 <code>100KB</code> 的 <code>SP</code> 文件读取等待时间大约需要 <code>50~100ms</code>，我建议提前用异步线程预加载启动过程用到的 SP 文件。</li><li><strong>全量写入：</strong>无论是调用 <code>commit()</code> 还是 <code>apply()</code>，即使我们只改动其中的一个条目，都会把整个内容全部写到文件。而且即使我们多次写入同一个文件，<code>SP</code> 也没有将多次修改合并为一次，这也是性能差的重要原因之一。</li><li><strong>卡顿：</strong>由于提供了异步落盘的 <code>apply</code> 机制，在崩溃或者其他一些异常情况可能会导致数据丢失。所以当应用收到系统广播，或者被调用 <code>onPause</code> 等一些时机，系统会强制把所有的 <code>SharedPreferences</code> 对象数据落地到磁盘。如果没有落地完成，这时候主线程会被一直阻塞。这样非常容易造成卡顿，甚至是 <code>ANR</code>，从线上数据来看 <code>SP</code> 卡顿占比一般会超过 <code>5%</code>。</li></ol><p>更多机制 <a href="https://juejin.im/entry/597446ed6fb9a06bac5bc630" target="_blank" rel="noopener">彻底搞懂 SharedPreferences</a></p><p>更好的替代 <code>SharedPreferences</code> 的存储方案微信的 <a href="https://github.com/Tencent/MMKV" target="_blank" rel="noopener">MMKV</a></p><hr><h2 id="1-3-ContentProvider"><a href="#1-3-ContentProvider" class="headerlink" title="1.3 ContentProvider"></a>1.3 ContentProvider</h2><p><code>ContentProvider</code> 作为 <code>Android</code> 四大组件中的一种，为我们提供了不同进程甚至是不同应用程序之间共享数据的机制。</p><p>为什么 <code>Android</code> 系统不把 <code>SharedPreferences</code> 设计成跨进程安全的呢？那是因为 <code>Android</code> 系统更希望我们在这个场景选择使用 <code>ContentProvider</code> 作为存储方式。</p><p><code>Android</code> 系统中比如相册、日历、音频、视频、通讯录等模块都提供了 <code>ContentProvider</code> 的访问支持。具体使用你可以参考其他文章。</p><p><code>ContentProvider</code> 的一些注意事项：</p><ol><li><p><strong>启动性能：</strong><code>ContentProvider</code> 的生命周期默认在 <code>Application onCreate()</code> 之前，而且都是在主线程创建的。我们自定义的 <code>ContentProvider</code> 类的构造函数、静态代码块、<code>onCreate</code> 函数都尽量不要做耗时的操作，会拖慢启动速度。</p></li><li><p><strong>稳定性：</strong><code>ContentProvider</code> 在进行跨进程数据传递时，利用了 <code>Android</code> 的 <code>Binder</code> 和匿名共享内存机制。就是通过 <code>Binder</code> 传递 <code>CursorWindow</code> 对象内部的匿名共享内存的文件描述符。这样在跨进程传输中，结果数据并不需要跨进程传输，而是在不同进程中通过传输的匿名共享内存文件描述符来操作同一块匿名内存，这样来实现不同进程访问相同数据的目的。</p><p>基于 <code>mmap</code> 的匿名共享内存机制也是有代价的。当传输的数据量非常小的时候，可能不一定划算。所以 <code>ContentProvider</code> 提供了一种 <code>call</code> 函数，它会直接通过 <code>Binder</code> 来传输数据。<code>Android</code> 的 <code>Binder</code> 传输是有大小限制的，一般来说限制是 <code>1~2MB</code>。<code>ContentProvider</code> 的接口调用参数和 call 函数调用并没有使用匿名共享机制，比如要批量插入很多数据，那么就会出现一个插入数据的数组，如果这个数组太大了，那么这个操作就可能会出现数据超大异常。</p></li><li><p><strong>安全性：</strong>虽然 <code>ContentProvider</code> 为应用程序之间的数据共享提供了很好的安全机制，但是如果 <code>ContentProvider</code> 是 <code>exported（是否可以被其他应用调用）</code>，当支持执行 <code>SQL</code> 语句时就需要注意 <code>SQL 注入</code> 的问题。另外如果我们传入的参数是一个文件路径，然后返回文件的内容，这个时候也要校验合法性，不然整个应用的私有数据都有可能被别人拿到，在 <code>intent</code>传递参数的时候可能经常会犯这个错误。</p></li></ol><p>总的来说，<code>ContentProvider</code> 这套方案实现相对比较笨重，适合传输大的数据。</p><hr><h2 id="1-4-SQLite-优化那些事儿"><a href="#1-4-SQLite-优化那些事儿" class="headerlink" title="1.4 SQLite 优化那些事儿"></a>1.4 SQLite 优化那些事儿</h2><h3 id="1-4-1-OCR"><a href="#1-4-1-OCR" class="headerlink" title="1.4.1 OCR"></a>1.4.1 OCR</h3><p>说到 <code>SQLite</code> Android 中最常用的开源库有 <a href="https://github.com/greenrobot/greenDAO" target="_blank" rel="noopener">greenDAO</a> 和 Google 官方的 <a href="https://developer.android.google.cn/topic/libraries/architecture/room" target="_blank" rel="noopener">Room</a> ，它们都是 <code>ORM 框架</code></p><p><code>ORM（Object Relational Mapping）</code>也就是对象关系映射，用面向对象的概念把数据库中表和对象关联起来，可以让我们不用关心数据库底层的实现。</p><p><code>ORM</code> 框架会带来什么问题?</p><p>使用 <code>ORM</code> 框架真的非常简单，但是简易性是需要牺牲部分执行效率为代价的，具体的损耗跟 <code>ORM</code> 框架写得好不好很有关系。但可能更大的问题是思维固化，最后可能连简单的 <code>SQL</code> 语句都不会写了。</p><p>这里推荐微信的 <a href="https://github.com/Tencent/wcdb/wiki" target="_blank" rel="noopener">WCDB</a> </p><p><code>SQLite</code> 优化：</p><h3 id="1-4-2-并发"><a href="#1-4-2-并发" class="headerlink" title="1.4.2 并发"></a>1.4.2 并发</h3><p><a href="http://huili.github.io/lockandimplement/machining.html" target="_blank" rel="noopener">SQLite 锁机制简介</a> <a href="https://www.cnblogs.com/cchust/p/4761814.html" target="_blank" rel="noopener">SQLite 封锁机制</a></p><p>为了进一步提高并发性能，我们还可以打开 <a href="https://www.sqlite.org/wal.html" target="_blank" rel="noopener">WAL</a>（Write-Ahead Logging）模式。<code>WAL</code> 模式会将修改的数据单独写到一个 <code>WAL</code> 文件中，同时也会引入了 <code>WAL</code> 日志文件锁。通过 <code>WAL</code> 模式读和写可以完全地并发执行，不会互相阻塞。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mSQLiteDataBase.rawExecSQL(&quot;PRAGMA schema.journal_mode &#x3D; WAL;&quot;)</span><br></pre></td></tr></table></figure><p>通过 <code>连接池</code> 与 <code>WAL</code> 模式，我们可以很大程度上增加 <code>SQLite</code> 的读写并发，大大减少由于并发导致的等待耗时。</p><h3 id="1-4-3-索引查询优化"><a href="#1-4-3-索引查询优化" class="headerlink" title="1.4.3 索引查询优化"></a>1.4.3 索引查询优化</h3><p><a href="https://www.cnblogs.com/huahuahu/p/sqlite-suo-yin-de-yuan-li-ji-ying-yong.html" target="_blank" rel="noopener">SQLite 索引的原理</a> <a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">MySQL 索引背后的数据结构及算法原理</a> <a href="https://www.sqlite.org/queryplanner.html#searching" target="_blank" rel="noopener">官方文档 Query Planning</a></p><p>这里的关键在于如何正确的建立索引，很多时候我们以为已经建立了索引，但事实上并没有真正生效。例如使用了 <code>BETWEEN</code>、<code>LIKE</code>、<code>OR</code> 这些操作符、使用表达式或者 <code>case when</code> 等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BETWEEN：myfiedl索引无法生效</span><br><span class="line">SELECT * FROM mytable WHERE myfield BETWEEN 10 and 20;</span><br><span class="line">转换成：myfiedl索引可以生效</span><br><span class="line">SELECT * FROM mytable WHERE myfield &gt;&#x3D; 10 AND myfield &lt;&#x3D; 20;</span><br></pre></td></tr></table></figure><p>建立索引是有代价的，需要一直维护索引表的更新。比如对于一个很小的表来说就没必要建索引；如果一个表经常是执行插入更新操作，那么也需要节制的建立索引。总的来说有几个原则：</p><ul><li>建立正确的索引。这里不仅需要确保索引在查询中真正生效，我们还希望可以选择最高效的索引。如果一个表建立太多的索引，那么在查询的时候 <code>SQLite</code> 可能不会选择最好的来执行。</li><li>单列索引、多列索引与复合索引的选择。索引要综合数据表中不同的查询与排序语句一起考虑，如果查询结果集过大，还是希望可以通过复合索引直接在索引表返回查询结果。</li><li>索引字段的选择。整型类型索引效率会远高于字符串索引，而对于主键 <code>SQLite</code> 会默认帮我们建立索引，所以主键尽量不要用复杂字段。</li></ul><p>总的来说索引优化是 <code>SQLite</code> 优化中最简单同时也是最有效的，但是它并不是简单的建一个索引就可以了，有的时候我们需要进一步调整查询语句甚至是表的结构，这样才能达到最好的效果。</p><h3 id="1-4-4-页大小与缓存大小"><a href="#1-4-4-页大小与缓存大小" class="headerlink" title="1.4.4 页大小与缓存大小"></a>1.4.4 页大小与缓存大小</h3><p>在 <code>I/O</code> 文件系统中，数据库就像一个小文件系统一样，事实上它内部也有页和缓存的概念。</p><p>跟文件系统的页缓存（Page Cache）一样，<code>SQLite</code> 会将读过的页缓存起来，用来加快下一次读取速度。页大小默认是 <code>1024Byte</code>，缓存大小默认是 <code>1000</code> 页。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mSQLiteDataBase.rawExecSQL(&quot;PRAGMA page_size &#x3D; 1024;&quot;)</span><br><span class="line">mSQLiteDataBase.rawExecSQL(&quot;PRAGMA cache_size &#x3D; 1000;&quot;)</span><br></pre></td></tr></table></figure><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://static001.geekbang.org/resource/image/f2/1c/f232cbaff34236a1933182a02c685a1c.png" alt="图片来源于 Android 开发高手课"></p><p><strong>注意：</strong>在微信的内部测试中，如果使用 <code>4KB</code> 的 <code>page size</code> 性能提升可以在 <code>5%～10%</code>。但是考虑到历史数据的迁移成本，最终还是使用 <code>1024Byte</code>。所以这里建议大家在新建数据库的时候，就提前选择 <code>4KB</code> 作为默认的 <code>page size</code> 以获得更好的性能。</p><h3 id="1-4-5-其他优化"><a href="#1-4-5-其他优化" class="headerlink" title="1.4.5 其他优化"></a>1.4.5 其他优化</h3><ul><li>慎用 <code>select*</code>，需要使用多少列，就选取多少列。</li><li>正确地使用事务。</li><li>预编译与参数绑定，缓存被编译后的 <code>SQL</code> 语句。</li><li>定期整理或者清理无用或可删除的数据，例如朋友圈数据库会删除比较久远的数据，如果用户访问到这部分数据，重新从网络拉取即可。</li></ul><p><strong>总结：通过引进 <code>ORM</code>，可以大大的提升我们的开发效率。通过正确的建立索引，可以提升 <code>SQLite</code> 的查询速度。通过 <code>WAL</code> 模式和连接池，可以提高 <code>SQLite</code> 的并发性能。通过调整默认的页大小和缓存大小，可以提升 <code>SQLite</code> 的整体性能。</strong></p><hr><h2 id="1-5-SQLite-的其他特征"><a href="#1-5-SQLite-的其他特征" class="headerlink" title="1.5 SQLite 的其他特征"></a>1.5 SQLite 的其他特征</h2><p>除了 <code>SQLite</code> 的优化经验，还有一些其他的</p><h3 id="1-5-1-损坏与恢复"><a href="#1-5-1-损坏与恢复" class="headerlink" title="1.5.1 损坏与恢复"></a>1.5.1 损坏与恢复</h3><p><a href="https://mp.weixin.qq.com/s/N1tuHTyg3xVfbaSd4du-tw" target="_blank" rel="noopener">微信 SQLite 数据库修复实践</a></p><p><a href="https://mp.weixin.qq.com/s/Ln7kNOn3zx589ACmn5ESQA" target="_blank" rel="noopener">微信移动端数据库组件WCDB系列（二） — 数据库修复三板斧</a></p><p><a href="https://github.com/Tencent/wcdb/wiki/Android数据库修复" target="_blank" rel="noopener">WCDB Android 数据库修复</a></p><h3 id="1-5-2-加密与安全"><a href="#1-5-2-加密与安全" class="headerlink" title="1.5.2 加密与安全"></a>1.5.2 加密与安全</h3><p>数据库的安全主要有两个方面，一个是防注入，一个是加密。防注入可以通过静态安全扫描的方式，而加密一般会使用 <code>SQLCipher</code> 支持。</p><p><code>SQLite</code> 的加解密都是以页为单位，默认会使用 <code>AES</code> 算法加密，加 / 解密的耗时跟选用的密钥长度有关。</p><p><a href="https://mp.weixin.qq.com/s/NFnYEXSxAaHBqpi7WofSPQ" target="_blank" rel="noopener">WCDB 加解密的使用</a></p><h3 id="1-5-3-全文搜索"><a href="#1-5-3-全文搜索" class="headerlink" title="1.5.3 全文搜索"></a>1.5.3 全文搜索</h3><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://static001.geekbang.org/resource/image/d2/d9/d2a09d040d0d915e78d7598457d6d1d9.png" alt="图片来源于 Android 开发高手课"></p><p><a href="https://mp.weixin.qq.com/s/AhYECT3HVyn1ikB0YQ-UVg" target="_blank" rel="noopener">微信全文搜索优化之路</a></p><p><a href="https://mp.weixin.qq.com/s/GCznwCtjJ2XUszyMcbNz8Q" target="_blank" rel="noopener">移动客户端多音字搜索</a> </p><p><strong>总结：</strong>关于 <code>SQLite</code>的这些特性，我们需要根据自己的项目情况综合考虑。假如某个数据库存储的数据并不重要，这个时候万分之一的数据损坏率我们并不会关心。同样是否需要使用数据库加密，也要根据存储的数据是不是敏感内容。</p><p><a href="http://huili.github.io/sqlite/sqliteintro.html" target="_blank" rel="noopener">SQLite 源码分析</a></p><p><a href="https://github.com/AndroidAdvanceWithGeektime/Chapter14/blob/master/全面解析SQLite.pdf" target="_blank" rel="noopener">全面解析 SQLite</a></p><hr><h1 id="2-如何优化数据存储？"><a href="#2-如何优化数据存储？" class="headerlink" title="2 如何优化数据存储？"></a>2 如何优化数据存储？</h1><h2 id="2-1-对象的序列化"><a href="#2-1-对象的序列化" class="headerlink" title="2.1 对象的序列化"></a>2.1 对象的序列化</h2><p>应用程序中的对象存储在内存中，如果我们想把对象存储下来或者在网络上传输，这个时候就需要用到对象的序列化和反序列化。</p><p>对象序列化就是把一个 <code>Object</code> 对象所有的信息表示成一个字节序列，这包括 <code>Class</code> 信息、继承关系信息、访问权限、变量类型以及数值信息等。</p><h3 id="2-1-1-Serializable"><a href="#2-1-1-Serializable" class="headerlink" title="2.1.1 Serializable"></a>2.1.1 Serializable</h3><p><code>Serializable</code> 是 <code>Java</code> 原生的序列化机制，在 <code>Android</code> 中也有被广泛使用。我们可以通过 <code>Serializable</code> 将对象持久化存储，也可以通过 <code>Bundle</code> 传递 <code>Serializable</code> 的序列化数据。</p><h4 id="Serializable-的原理"><a href="#Serializable-的原理" class="headerlink" title="Serializable 的原理"></a><strong>Serializable 的原理</strong></h4><p><code>Serializable</code> 的原理是通过 <code>ObjectInputStream</code> 和 <code>ObjectOutputStream</code> 来实现的，以 Android 6.0 的源码为例，可以看到 <a href="http://androidxref.com/6.0.0_r1/xref/libcore/luni/src/main/java/java/io/ObjectOutputStream.java#927" target="_blank" rel="noopener">ObjectOutputStream</a> 的部分源码实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private void writeFieldValues(Object obj, ObjectStreamClass classDesc)  &#123;</span><br><span class="line">    for (ObjectStreamField fieldDesc : classDesc.fields()) &#123;</span><br><span class="line">        ...</span><br><span class="line">        Field field &#x3D; classDesc.checkAndGetReflectionField(fieldDesc);</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>整个序列化过程使用了大量的反射和临时变量，而且在序列化对象的时候，不仅会序列化当前对象本身，还需要递归序列化对象引用的其他对象。</p><p>整个过程计算非常复杂，而且因为存在大量反射和 <code>GC</code> 的影响，序列化的性能会比较差。另外一方面因为序列化文件需要包含的信息非常多，导致它的大小比 Class 文件本身还要大很多，这样又会导致 I/O 读写上的性能问题。</p><h4 id="Serializable-的进阶"><a href="#Serializable-的进阶" class="headerlink" title="Serializable 的进阶"></a><strong>Serializable 的进阶</strong></h4><p>既然 <code>Serializable</code> 性能那么差，那它有哪些优势呢？可能很多同学都不知道它还有一些进阶的用法，你可以参考<a href="https://www.ibm.com/developerworks/cn/java/j-5things1/index.html" target="_blank" rel="noopener">《Java 对象序列化，您不知道的 5 件事》</a> 这篇文章。</p><p>自定义序列化：</p><ul><li><code>writeObject</code> 和 <code>readObject</code> 方法。<code>Serializable</code> 序列化支持替代默认流程，它会先反射判断是否存在我们自己实现的序列化方法 <code>writeObject</code> 或反序列化方法 <code>readObject</code> 。<strong>通过这两个方法，我们可以对某些字段做一些特殊修改，也可以实现序列化的加密功能。</strong></li><li><code>writeReplace</code> 和 <code>readResolve</code> 方法。这两个方法代理序列化的对象，可以实现自定义返回的序列化实例。那它有什么用呢？我们可以通过它们实现对象序列化的版本兼容，例如通过 <code>readResolve</code> 方法可以把老版本的序列化对象转换成新版本的对象类型。</li></ul><p><code>Serializable</code> 的序列化与反序列化的调用流程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 序列化</span><br><span class="line">E&#x2F;test:SerializableTestData writeReplace</span><br><span class="line">E&#x2F;test:SerializableTestData writeObject</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 反序列化</span><br><span class="line">E&#x2F;test:SerializableTestData readObject</span><br><span class="line">E&#x2F;test:SerializableTestData readResolve</span><br></pre></td></tr></table></figure><h4 id="Serializable-的注意事项"><a href="#Serializable-的注意事项" class="headerlink" title="Serializable 的注意事项"></a><strong>Serializable 的注意事项</strong></h4><p><code>Serializable</code> 虽然使用非常简单，但是也有一些需要注意的事项字段。</p><ul><li><p><strong>不被序列化的字段。</strong>类的 <code>static</code> 变量以及被声明为 <code>transient</code> 的字段，默认的序列化机制都会忽略该字段，不会进行序列化存储。当然我们也可以使用进阶的 <code>writeReplace</code> 和 <code>readResolve</code> 方法做自定义的序列化存储。</p></li><li><p><strong>serialVersionUID。</strong>在类实现了 <code>Serializable</code> 接口后，我们需要添加一个 <code>Serial Version ID</code>，它相当于类的版本号。这个 <code>ID</code> 我们可以显式声明也可以让编译器自己计算。通常我建议显式声明会更加稳妥，因为隐式声明假如类发生了一点点变化，进行反序列化都会由于 <code>serialVersionUID</code> 改变而导致 <code>InvalidClassException</code> 异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1234567890L</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>构造方法。</strong><code>Serializable</code> 的反序列默认是不会执行构造函数的，它是根据数据流中对 <code>Object</code> 的描述信息创建对象的。如果一些逻辑依赖构造函数，就可能会出现问题，例如一个静态变量只在构造函数中赋值，当然我们也可以通过进阶方法做自定义的反序列化修改。</p></li></ul><h3 id="2-1-2-Parcelable"><a href="#2-1-2-Parcelable" class="headerlink" title="2.1.2 Parcelable"></a>2.1.2 Parcelable</h3><p>由于 <code>Java</code> 的<code>Serializable</code> 的性能较低，<code>Android</code> 需要重新设计一套更加轻量且高效的对象序列化和反序列化机制。<code>Parcelable</code> 正是在这个背景下产生的，它核心的作用就是为了解决 <code>Android</code> 中大量跨进程通信的性能问题。</p><h4 id="Parcelable-的永久存储"><a href="#Parcelable-的永久存储" class="headerlink" title="Parcelable 的永久存储"></a>Parcelable 的永久存储</h4><p>Parcelable 的原理十分简单，它的核心实现都在 <a href="http://androidxref.com/6.0.0_r1/xref/frameworks/native/libs/binder/Parcel.cpp" target="_blank" rel="noopener">Parcel.cpp</a> 。 </p><p>你可以发现 <code>Parcel</code> 序列化和 <code>Java</code> 的 <code>Serializable</code> 序列化差别还是比较大的，<code>Parcelable</code> 只会在内存中进行序列化操作，并不会将数据存储到磁盘里。</p><p>当然我们也可以通过 <a href="http://androidxref.com/6.0.0_r1/xref/frameworks/base/core/java/android/os/Parcel.java" target="_blank" rel="noopener">Parcel.java</a> 的 <code>marshall</code> 方法获取 <code>byte</code> 数组，然后存在文件中从而实现 <code>Parcelable</code> 的永久存储。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Returns the raw bytes of the parcel.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] marshall() &#123;</span><br><span class="line">    <span class="keyword">return</span> nativeMarshall(mNativePtr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Set the bytes in data to be the raw bytes of this Parcel.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">unmarshall</span><span class="params">(<span class="keyword">byte</span>[] data, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    nativeUnmarshall(mNativePtr, data, offset, length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ProcessCpuTracker pct=<span class="keyword">new</span> ProcessCpuTracker();</span><br><span class="line">Parcel parcel = Parcel.obtain();</span><br><span class="line">parcel.writeValue(pct);</span><br><span class="line"><span class="keyword">byte</span>[] bytes = parcel.marshall();</span><br><span class="line">parcel.recycle();</span><br><span class="line"></span><br><span class="line">Parcel thatParcel = Parcel.obtain();</span><br><span class="line">thatParcel.unmarshall(bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">thatParcel.setDataPosition(<span class="number">0</span>);</span><br><span class="line">ProcessCpuTracker that = (ProcessCpuTracker)thatParcel.readValue(ProcessCpuTracker<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>())</span>;</span><br><span class="line">thatParcel.recycle();</span><br></pre></td></tr></table></figure><h4 id="Parcelable-的注意事项"><a href="#Parcelable-的注意事项" class="headerlink" title="Parcelable 的注意事项"></a>Parcelable 的注意事项</h4><p>在时间开销和使用成本的权衡上，<code>Parcelable</code> 机制选择的是性能优先。</p><p>所以它在写入和读取的时候都需要手动添加自定义代码，使用起来相比 <code>Serializable</code> 会复杂很多。但是正因为这样，<code>Parcelable</code> 才不需要采用反射的方式去实现序列化和反序列化。</p><p>虽然通过取巧的方法可以实现 <code>Parcelable</code> 的永久存储，但是它也存在两个问题。</p><ul><li>系统版本的兼容性。由于 <code>Parcelable</code> 设计本意是在内存中使用的，我们无法保证所有 <code>Android</code> 版本的 Parcel.cpp 实现都完全一致。如果不同系统版本实现有所差异，或者有厂商修改了实现，可能会存在问题。</li><li>数据前后兼容性。<code>Parcelable</code> 并没有版本管理的设计，如果我们类的版本出现升级，写入的顺序及字段类型的兼容都需要格外注意，这也带来了很大的维护成本。</li></ul><p>一般来说，如果需要持久化存储的话，一般还是不得不选择性能更差的 Serializable 方案。</p><h3 id="2-1-3-Serial"><a href="#2-1-3-Serial" class="headerlink" title="2.1.3 Serial"></a>2.1.3 Serial</h3><p>直击痛点的方案，<code>Twitter</code> 开源的 <a href="https://github.com/twitter/Serial/blob/master/README-CHINESE.rst/" target="_blank" rel="noopener">Serial</a> </p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://static001.geekbang.org/resource/image/71/df/71e3e58ed10ecc09646101ec22e360df.png" alt="图片来源于 Android 开发高手课"></p><p>从图中数据上看来，<code>Serial</code> 在序列化与反序列化耗时，以及落地的文件大小都有很大的优势。从实现原理上看，<code>Serial</code> 就像是把 <code>Parcelable</code> 和 <code>Serializable</code> 的优点集合在一起的方案。</p><ul><li>由于没有使用反射，相比起传统的反射序列化方案更加高效，具体你可以参考上面的测试数据。</li><li>开发者对于序列化过程的控制较强，可定义哪些 <code>Object</code>、<code>Field</code> 需要被序列化。</li><li>有很强的 <code>debug</code> 能力，可以调试序列化的过程。</li><li>有很强的版本管理能力，可以通过版本号和 <code>OptionalFieldException</code> 做兼容。</li></ul><h2 id="2-2-数据的序列化"><a href="#2-2-数据的序列化" class="headerlink" title="2.2 数据的序列化"></a>2.2 数据的序列化</h2><p><code>Serial</code> 性能看起来还不错，但是对象的序列化要记录的信息还是比较多，在操作比较频繁的时候，对应用的影响还是不少的，这个时候我们可以选择使用数据的序列化。</p><h3 id="2-2-1-Json"><a href="#2-2-1-Json" class="headerlink" title="2.2.1 Json"></a>2.2.1 Json</h3><p><code>JSON</code> 是一种轻量级的数据交互格式，它被广泛使用在网络传输中，很多应用与服务端的通信都是使用 <code>JSON</code> 格式进行交互。</p><p>JSON 的确有很多得天独厚的优势，主要有：</p><ul><li>相比对象序列化方案，速度更快，体积更小。</li><li>相比二进制的序列化方案，结果可读，易于排查问题。</li><li>使用方便，支持跨平台、跨语言，支持嵌套引用。</li></ul><p>因为每个应用基本都会用到 <code>JSON</code>，所以每个大厂也基本都有自己的 “ 轮子 ” 。例如 <code>Android</code> 自带的 <code>JSON</code> 库、<code>Google</code> 的 <code>Gson</code> 、阿里巴巴的 <code>Fastjson</code> 、美团的 <code>MSON</code> 。</p><p>各个自研的 JSON 方案主要在下面两个方面进行优化：</p><ul><li><strong>便利性。</strong>例如支持 JSON 转换成 JavaBean 对象，支持注解，支持更多的数据类型等。</li><li><strong>性能。</strong>减少反射，减少序列化过程内存与 CPU 的使用，特别是在数据量比较大或者嵌套层级比较深的时候效果会比较明显。</li></ul><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://static001.geekbang.org/resource/image/98/78/984bb5dc6300f25ba142c208bdca3178.png" alt="图片来源于 Android 开发高手课"></p><p>在数据量比较少的时候，系统自带的 <code>JSON</code> 库还稍微有一些优势。但在数据量大了之后，差距逐渐被拉开。总的来说，<code>Gson</code> 的兼容性最好，一般情况下它的性能与 <code>Fastjson</code> 相当。但是在数据量极大的时候，<code>Fastjson</code> 的性能更好。</p><h3 id="2-2-2-Protocol-Buffers"><a href="#2-2-2-Protocol-Buffers" class="headerlink" title="2.2.2 Protocol Buffers"></a>2.2.2 Protocol Buffers</h3><p>相比对象序列化方案，<code>JSON</code> 的确速度更快、体积更小。不过为了保证 <code>JSON</code> 的中间结果是可读的，它并没有做二进制的压缩，也因此 <code>JSON</code> 的性能还没有达到极致。</p><p>如果应用的数据量非常大，又或者对性能有更高的要求，此时 <a href="https://developers.google.com/protocol-buffers/docs/overview" target="_blank" rel="noopener">Protocol Buffers</a> 是一个非常好的选择。它是 <code>Google</code> 开源的跨语言编码协议，<code>Google</code> 内部的几乎所有 <code>RPC</code> 都在使用这个协议。</p><p>下面我来总结一下它的优缺点。</p><ul><li><strong>性能。</strong>使用了二进制编码压缩，相比 JSON 体积更小，编解码速度也更快，感兴趣的同学可以参考protocol-buffers 编码规则。</li><li><strong>兼容性。</strong>跨语言和前后兼容性都不错，也支持基本类型的自动转换，但是不支持继承与引用类型。</li><li><strong>使用成本。</strong><code>Protocol Buffers</code> 的开发成本很高，需要定义 <code>.proto</code> 文件，并用工具生成对应的辅助类。辅助类特有一些序列化的辅助方法，所有要序列化的对象，都需要先转化为辅助类的对象，这让序列化代码跟业务代码大量耦合，是侵入性较强的一种方式。</li></ul><p>对于 <code>Android</code> 来说，官方的 <code>Protocol Buffers</code> 会导致生成的方法数很多。我们可以修改它的自动代码生成工具，例如在微信中，每个 <code>.proto</code> 生成的类文件只会包含一个方法即 <code>op</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestProtocal</span> <span class="keyword">extends</span>  <span class="title">com</span>.<span class="title">tencent</span>.<span class="title">mm</span>.<span class="title">protocal</span>.<span class="title">protobuf</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">op</span><span class="params">(<span class="keyword">int</span> opCode, Object ...objs)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (opCode == OPCODE_WRITEFIELDS) &#123;</span><br><span class="line">           ... </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (opCode == OPCODE_COMPUTESIZE) &#123;</span><br><span class="line">           ...</span><br></pre></td></tr></table></figure><p><code>Google</code> 后面还推出了压缩率更高的 <code>FlatBuffers</code>，对于它的使用你可以参考<a href="https://www.race604.com/flatbuffers-intro/" target="_blank" rel="noopener">《FlatBuffers 体验》</a>。最后，我再结合 “六要素”，综合对比一下 <code>Serial</code>、<code>JSON</code>、<code>Protocol Buffers</code> 这三种序列化方案。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://static001.geekbang.org/resource/image/1a/28/1afba11681441b6a8ab8f0d86337ea28.png" alt="图片来源于 Android 开发高手课"></p><h1 id="3-Demo-相关练习"><a href="#3-Demo-相关练习" class="headerlink" title="3 Demo 相关练习"></a>3 Demo 相关练习</h1><h2 id="3-1-重写-SharedPreferencesImpl"><a href="#3-1-重写-SharedPreferencesImpl" class="headerlink" title="3.1 重写 SharedPreferencesImpl"></a>3.1 重写 <code>SharedPreferencesImpl</code></h2><p><a href="https://github.com/AndroidAdvanceWithGeektime/Chapter12" target="_blank" rel="noopener">Chapter12 SharedPreferencesImpl</a> 这是一个简单的示例。</p><p>通过继承 <code>SharedPreferences</code> 重写 <code>SharedPreferencesImpl</code> ，并通过 <code>Application</code> 的 <code>getSharedPreferences</code> 方法，替换系统 <code>SharedPreferences</code> 的具体实现。还可以替换它的存储结构、增加加密等其他自定义功能。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>App 网络优化</title>
      <link href="/2020/network-optimization.html"/>
      <url>/2020/network-optimization.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>App 直观感受-卡顿优化💦</title>
      <link href="/2020/hobble-optimization.html"/>
      <url>/2020/hobble-optimization.html</url>
      
        <content type="html"><![CDATA[<p>对用户来说，<strong>内存占用高</strong>、<strong>耗费电量</strong>、<strong>耗费流量</strong> 可能不容易被发现，但是用户对 <strong>卡顿</strong> 特别敏感，很容易直观感受到。</p><p><strong>注意：如果出现图片不显示问题请移步</strong> <a href="https://calmcenter.club/2019/PicNotShow.html">图片不显示问题</a></p><h1 id="本文主要记载"><a href="#本文主要记载" class="headerlink" title="本文主要记载"></a>本文主要记载</h1><ul><li><strong>1 如何定义卡顿？</strong></li><li><strong>2 如何排查卡顿？</strong><ul><li>2.1 Linux 命令组合排查</li><li>2.2 使用 top 命令查看进程信息</li></ul></li><li>3 有没有方便的 Android 卡顿排查工具？<ul><li>3.1 TraceView</li><li>3.2 Nanoscope</li><li>3.3 systrace</li><li>3.4 Simpleperf</li><li>3.5 可视化方法(Android Studio Profiler)</li><li>3.6 Android Performance Montitor(BlockCanary)</li><li>3.7 Profilo</li></ul></li><li>总结</li></ul><hr><h1 id="1-如何定义卡顿？"><a href="#1-如何定义卡顿？" class="headerlink" title="1 如何定义卡顿？"></a>1 如何定义卡顿？</h1><p><code>60帧</code> 每秒是目前最合适的图像显示速度，也是绝大部分 <code>Android</code> 设备设置的调试频率，如果在 <code>16ms</code> 内顺利完成界面刷新操作可以展示出流畅的画面，而由于任何原因导致接收到 <code>VSYNC</code> 信号的时候无法完成本次刷新操作，就会产生掉帧的现象，刷新帧率自然也就跟着下降(假定刷新帧率由正常的 <code>60fps</code> 降到 <code>30fps</code> ，用户就会明显感知到卡顿)。</p><p>卡顿的原因可以定义为 <code>UI 复杂度问题</code> ，<code>没有提前或异步初始化问题</code> ， <code>内存泄漏频繁 GC 的问题</code> 等，卡顿的解决思路是集结了 启动优化、内存优化、UI 优化 的所有知识点，所以这篇也是对之前的扩展补充。</p><p>造成卡顿的原因可能有千百种，不过最终都会反映到 CPU 时间上。</p><p>我们可以把 CPU 时间分为两种：</p><ol><li>用户时间：执行用户态应用程序代码所消耗的时间</li><li>系统时间：执行内核态系统调用所消耗的时间，包括 I/O、锁、中断以及其他系统调用的时间。</li></ol><hr><h1 id="2-如何排查卡顿"><a href="#2-如何排查卡顿" class="headerlink" title="2 如何排查卡顿"></a>2 如何排查卡顿</h1><h2 id="2-1-Linux-命令组合排查"><a href="#2-1-Linux-命令组合排查" class="headerlink" title="2.1 Linux 命令组合排查"></a>2.1 Linux 命令组合排查</h2><ol><li><strong>获取 <code>CPU</code> 核心数</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;possible</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>获取某个 <code>CPU</code> 的频率</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpu0&#x2F;cpufreq&#x2F;cpuinfo_max_freq</span><br></pre></td></tr></table></figure><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://raw.githubusercontent.com/CalmCenter/picGo/master/pictures/20200420172904.png" style="zoom:50%"><p>我们需要根据设备 <code>CPU</code> 性能来 “看菜下饭” ，例如线程池使用线程数根据 <code>CPU</code> 的核心数，一些高级的 <code>AI</code> 功能只在主频比较高或者带有 <code>NPU</code> 的设备开启。</p><ol start="3"><li><strong>查看 <code>CPU</code> 的使用率</strong></li></ol><p><strong>整个系统的 CPU 使用情况</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;proc&#x2F;stat</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;adb shell</span><br><span class="line">cat &#x2F;proc&#x2F;stat</span><br><span class="line">cpu  166492 36473 149538 7550789 34852 0 9110 0 0 0</span><br><span class="line">cpu0 31858 4048 34220 808812 5172 0 4604 0 0 0</span><br><span class="line">cpu1 22897 4439 25504 894380 7874 0 1514 0 0 0</span><br><span class="line">cpu2 29068 6317 27063 908505 7657 0 673 0 0 0</span><br><span class="line">cpu3 25916 6157 23508 931591 6625 0 259 0 0 0</span><br><span class="line">cpu4 28689 5321 22388 971414 2544 0 1030 0 0 0</span><br><span class="line">cpu5 10136 3778 6687 1009482 1551 0 606 0 0 0</span><br><span class="line">cpu6 8074 3398 5163 1014162 1489 0 218 0 0 0</span><br><span class="line">cpu7 9854 3015 5005 1012443 1940 0 206 0 0 0</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>第一行的数据表示的是 <code>CPU</code> 总的使用情况</p><ol><li><p>这些数值的单位都是 <code>jiffies</code>。<code>jiffies</code> 是内核中的一个全局变量，用来记录系统启动以来产生的节拍数，在 <code>Linux</code> 中，一个节拍大致可以理解为操作系统进程调度的最小时间片，不同的 <code>Linux</code> 系统内核这个值可能不同，通常在 <code>1ms</code> 到 <code>10ms</code> 之间。</p></li><li><p>cpu  166492 36473 149538 7550789 34852 0 9110 0 0 0</p><ul><li><code>user</code>(166492) 从系统启动开始累积到当前时刻，处于用户态的运行时间，不包含 nice 值为负的进程。</li><li><code>nice</code>(36473) 从系统启动开始累积到当前时刻，nice 值为负的进程所占用的 CPU 时间。</li><li><code>system</code>(149538) 从系统启动开始累积到当前时刻，处于核心态的运行时间。</li><li><code>idle</code>(7550789) 从系统启动开始累积到当前时刻，除 IO 等待时间以外的其他等待时间。</li><li><code>iowait</code>(34852) 从系统启动开始累积到当前时刻，IO 等待时间。(since 2.5.41)</li><li><code>irq</code>(0) 从系统启动开始累积到当前时刻，硬中断时间。(since 2.6.0-test4)</li><li><code>softirq</code>(9110) 从系统启动开始累积到当前时刻，软中断时间。(since 2.6.0-test4)</li><li><code>stealstolen</code>(0) 这是在虚拟环境中运行时在其他操作系统中花费的时间。(since 2.6.11)</li><li><code>guest</code>(0) 这是运行 Linux 内核控制下的来宾操作系统的虚拟 CPU 所花费的时间。(since 2.6.24)</li><li><code>guest_nice</code>(0) 运行 niced 客户端的时间( Linux 内核控制下的客户操作系统的虚拟CPU)。(since Linux 2.6.33)</li></ul><p>具体使用率计算请查看 <a href="https://time.geekbang.org/column/article/71982" target="_blank" rel="noopener">《Linux环境下进程的CPU占用率》</a> 还是有点麻烦的 ~ </p></li></ol><h2 id="2-2-使用-top-命令查看进程信息"><a href="#2-2-使用-top-命令查看进程信息" class="headerlink" title="2.2 使用 top 命令查看进程信息"></a>2.2 使用 top 命令查看进程信息</h2><ol><li>直接输入 <code>top</code> 可查看所有进程的 <code>cpu</code> 使用情况</li></ol><p>几个常用的参数：</p><ul><li><code>-d</code>: 后面接秒数，就是整个进程画面更新的频率。默认是 5 秒。</li><li><code>-b</code>: 以批处理的方式执行 top，还有更多的参数可用。通常会搭配数据流重导向，将批处理的结果输出为文件。</li><li><code>-n</code>: 与 -b 搭配，意义是，需要进行几次 top 的输出结果。</li><li><code>-p</code>: 指定某个 PID 来进行观察监测。</li><li>在 top 执行过程中可以使用的按键命令：</li><li><code>?</code>: 显示在 top 中可以输入的按键命令。</li><li><code>P</code>: 按照 CPU 的使用资源排序显示。</li><li><code>M</code>: 按内存（Memory）的使用资源排序显示。</li><li><code>N</code>: 按 PID 来排序。</li><li><code>T</code>: 按该进程使用的 CPU 时间积累（TIME+）排序。</li><li><code>k</code>: 给某个 PID 一个信号（signal）。</li><li><code>r</code>: 给某个 PID 重新确定一个值。</li><li><code>1</code>: 显示所有 CPU 占用信息。</li></ul><ol start="2"><li>监测进程 13620</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -d 2 -p 13620</span><br></pre></td></tr></table></figure><p>会一直输出进程 13620 的信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">top - 16:27:35 up 4 days, 7:43, 2 users, load average: 0.35, 0.47, 0.44</span><br><span class="line">Tasks: 1 total, 1 running, 0 sleeping, 0 stopped, 0 zombie</span><br><span class="line">Cpu(s): 0.1%us, 3.1%sy, 0.0%ni, 96.5%id, 0.0%wa, 0.0%hi, 0.3%si, 0.0%st</span><br><span class="line">Mem: 16320632k total, 1790796k used, 14529836k free, 233168k buffers</span><br><span class="line">Swap: 8232952k total, 0k used, 8232952k free, 941540k cached</span><br><span class="line"> </span><br><span class="line">PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND</span><br><span class="line">13620 test1370 20 0 11060 944 760 R 53.4 0.0 0:04.78 netperf</span><br></pre></td></tr></table></figure><hr><h1 id="3-有没有方便的-Android-卡顿排查工具？"><a href="#3-有没有方便的-Android-卡顿排查工具？" class="headerlink" title="3 有没有方便的 Android 卡顿排查工具？"></a>3 有没有方便的 Android 卡顿排查工具？</h1><p>日常开发中比较熟悉的工具分为两个流派：</p><ul><li><p>instrument 流派</p><p>获取一段时间内所有函数的调用过程，可以通过分析这段时间内的函数调用流程，再进一步分析待优化的点。</p></li><li><p>sample 流派</p><p>有选择性或者采用抽样的方式观察某些函数调用过程，可以通过这些有限的信息推测出流程中的可疑点，然后再继续细化分析。</p></li></ul><h2 id="3-1-Traceview"><a href="#3-1-Traceview" class="headerlink" title="3.1 Traceview"></a>3.1 Traceview</h2><p>我在 <a href="https://calmcenter.club/2019/start-optimization.html#toc-heading-7">《App 初体验-启动优化 2.2.1 TraceView》</a> 中讲过 <code>TraceView</code>  的基本使用方法。<code>Traceview</code> 属于 <code>instrument</code> 类型，它利用 Android Runtime 函数调用的 event 事件，将函数运行的耗时和调用关系写入 trace 文件中，它可以用来查看整个过程有哪些函数调用。</p><p>工具本身带来的性能开销过大，有时无法反映真实的情况。在 <code>Android 5.0</code> 之后，新增了<code>startMethodTracingSampling</code> 方法，可以使用基于样本的方式进行分析，以减少分析对运行时的性能影响。新增了 sample 类型后，就需要我们在开销和信息丰富度之间做好权衡。</p><h2 id="3-2-Nanoscope"><a href="#3-2-Nanoscope" class="headerlink" title="3.2 Nanoscope"></a>3.2 Nanoscope</h2><p> <a href="https://calmcenter.club/2019/start-optimization.html#toc-heading-10">《App 初体验-启动优化 2.2.4 Nanoscope》</a> 查看原理即项目地址。它是在 <code>instrument</code> 类型的性能分析工具中性能损耗比较小的。</p><h2 id="3-3-systrace"><a href="#3-3-systrace" class="headerlink" title="3.3 systrace"></a>3.3 systrace</h2><p> <a href="https://calmcenter.club/2019/start-optimization.html#toc-heading-8">《App 初体验-启动优化 2.2.2 systrace》</a> 查看具体使用方法。其中还讲到了 <code>systrace + 函数插桩 AOP</code></p><p><code>systrace</code> 工具只能监控特定系统调用的耗时情况，所以它是属于 <code>sample</code> 类型，而且性能开销非常低。但是它不支持应用程序代码的耗时分析，所以在使用时有一些局限性。</p><h2 id="3-4-Simpleperf"><a href="#3-4-Simpleperf" class="headerlink" title="3.4 Simpleperf"></a>3.4 Simpleperf</h2><p>分析 <code>Native</code> 函数时使用的工具，在 <code>Android Studio 3.2</code> 也在 <code>Profiler</code> 中直接支持 <code>Simpleperf</code>。</p><p><code>Simpleperf</code> 属于 <code>sample</code> 类型，它的性能开销非常低，使用火焰图展示分析结果。</p><p><strong>总结：</strong></p><p>选择哪种工具，需要看具体的场景。如果需要分析 <code>Native</code> 代码的耗时，可以选择 <code>Simpleperf</code>；如果想分析系统调用，可以选择 <code>systrace</code>；如果想分析整个程序执行流程的耗时，可以选择 <code>Traceview</code> 或者<code>插桩版本的 systrace</code>。<br><code>systrace</code> 利用了 <code>Linux</code> 的 <a href="http://source.android.com/devices/tech/debug/ftrace" target="_blank" rel="noopener">ftrace</a> 调试工具，相当于在系统各个关键位置都添加了一些性能探针，也就是在代码里加了一些性能监控的埋点。<code>Android</code> 在 <code>ftrace</code> 的基础上封装了<code>atrace</code>，并增加了更多特有的探针，例如 <code>Graphics</code>、<code>Activity Manager</code>、<code>Dalvik VM</code>、<code>System Server</code> 等。</p><h2 id="3-5-可视化方法（Android-Studio-Profiler）"><a href="#3-5-可视化方法（Android-Studio-Profiler）" class="headerlink" title="3.5 可视化方法（Android Studio Profiler）"></a>3.5 可视化方法（Android Studio Profiler）</h2><p>在 <code>Android Studio 3.2</code> 的 <code>CPU Profiler</code> 中直接集成了几种性能分析工具</p><ul><li><strong>Sample Java Methods</strong> 的功能类似于 <code>Traceview</code> 的 <code>sample</code> 类型。</li><li><strong>Trace Java Methods</strong> 的功能类似于 <code>Traceview</code> 的 <code>instrument</code> 类型。</li><li><strong>Trace System Calls</strong> 的功能类似于 <code>systrace</code>。</li><li><strong>SampleNative</strong> (API Level 26+) 的功能类似于 <code>Simpleperf</code>。</li></ul><p>这些分析工具都支持了 <code>Call Chart</code> 和 <code>Flame Chart</code> 两种展示方式。</p><ol><li><strong>Call Chart</strong></li></ol><p><code>Call Chart</code> 是 <code>Traceview</code> 和 <code>systrace</code> 默认使用的展示方式。它按照应用程序的函数执行顺序来展示，适合用于分析整个流程的调用。举一个最简单的例子，A 函数调用 B 函数，B 函数调用 C 函数，循环三次，就得到了下面的 <code>Call Chart</code>。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://static001.geekbang.org/resource/image/db/3e/db3612f661d29efe59854df2e6c2383e.jpg" alt="图片来源于 Android开发高手课"></p><p><code>Call Chart</code> 就像给应用程序做一个心电图，我们可以看到在这一段时间内，各个线程的具体工作，比如是否存在线程间的锁、主线程是否存在长时间的 <code>I/O</code> 操作、是否存在空闲等。</p><ol start="2"><li><strong>Flame Chart</strong></li></ol><p>Flame Chart 也就是<strong>火焰图</strong>。它跟 Call Chart 不同的是，Flame Chart 以一个全局的视野来看待一段时间的调用分布，它就像给应用程序拍 X 光片，可以很自然地把时间和空间两个维度上的信息融合在一张图上。</p><p>上面函数调用的例子，换成火焰图的展示结果如下。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://static001.geekbang.org/resource/image/6c/01/6ca232173daf9e71f06ac22252d65d01.jpg" alt="图片来源于 Android开发高手课"></p><p>当我们不想知道应用程序的整个调用流程，只想直观看出哪些代码路径花费的 <code>CPU</code> 时间较多时，火焰图就是一个非常好的选择。</p><p>火焰图还可以使用在各种各样的维度，例如内存、I/O 的分析。有些内存可能非常缓慢地泄漏，通过一个内存的火焰图，我们就知道哪些路径申请的内存最多，有了火焰图我们根本不需要分析源代码，也不需要分析整个流程。</p><h2 id="3-6-Android-Performance-Monitor（BlockCanary）"><a href="#3-6-Android-Performance-Monitor（BlockCanary）" class="headerlink" title="3.6 Android Performance Monitor（BlockCanary）"></a>3.6 Android Performance Monitor（BlockCanary）</h2><p><a href="https://github.com/markzhai/AndroidPerformanceMonitor" target="_blank" rel="noopener">AndroidPerformanceMonitor</a> 是一个Android平台的一个非侵入式的性能监控组件，应用只需要实现一个抽象类，提供一些该组件需要的上下文环境，就可以在平时使用应用的时候检测主线程上的各种卡慢问题，并通过组件提供的各种信息分析出原因并进行修复。</p><h2 id="3-7-Profilo"><a href="#3-7-Profilo" class="headerlink" title="3.7 Profilo"></a>3.7 Profilo</h2><p>2018 年 3 月，<code>Facebook</code> 开源了一个叫 <a href="https://github.com/facebookincubator/profilo" target="_blank" rel="noopener">Profilo</a> 的库， 它收集了各大方案的优点。</p><ol><li><p><strong>集成 atrace 功能</strong>。</p><p>这样所有 <code>systrace</code> 的探针我们都可以拿到，例如四大组件生命周期、锁等待时间、类校验、<code>GC</code> 时间等。</p></li><li><p><strong>快速获取 Java 堆栈</strong></p><p>这里有一个误区，大家都觉得在某个线程不断地获取主线程堆栈是不耗时的。但是事实上获取堆栈的代价是巨大的，它要暂停主线程的运行。</p><p>而 <code>profilo</code> 巧妙的解决的这个问题，可以实现线程一边继续跑步，我们还可以帮它做检查，而且耗时基本忽略不计。</p></li></ol><p>不用插桩、性能基本没有影响、捕捉信息还全，那 <code>Profilo</code> 不就是完美的化身吗？当然由于它利用了大量的黑科技，兼容性是需要注意的问题。它内部实现有大量函数的 <code>Hook</code>，<code>unwind</code> 也需要强依赖 <code>Android Runtime</code> 实现。<code>Facebook</code> 已经将 <code>Profilo</code> 投入到线上使用，但由于目前 <code>Profilo</code> 快速获取堆栈功能依然不支持 <code>Android 8.0</code> 和 <code>Android 9.0</code>，鉴于稳定性问题，建议采取抽样部分用户的方式来开启该功能。</p><p><strong>帮助理解</strong></p><ul><li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-ftrace/index.html" target="_blank" rel="noopener">ftrace 简介</a>、<a href="https://www.ibm.com/developerworks/cn/linux/l-cn-ftrace1/index.html" target="_blank" rel="noopener">ftrace 使用（上）</a>、<a href="https://www.ibm.com/developerworks/cn/linux/l-cn-ftrace2/index.html" target="_blank" rel="noopener">frace 使用（下）</a></li><li><a href="http://source.android.com/devices/tech/debug/ftrace" target="_blank" rel="noopener">atrace 介绍</a>、<a href="http://android.googlesource.com/platform/frameworks/native/+/master/cmds/atrace/atrace.cpp" target="_blank" rel="noopener">atrace 实现</a></li></ul><p>每个工具都可以生成不同的展示方式，我们需要根据不同的使用场景选择合适的方式。</p><hr><h1 id="4-卡顿现场"><a href="#4-卡顿现场" class="headerlink" title="4 卡顿现场"></a>4 卡顿现场</h1><h2 id="4-1-获取-java-线程状态"><a href="#4-1-获取-java-线程状态" class="headerlink" title="4.1 获取 java 线程状态"></a>4.1 获取 java 线程状态</h2><p>通过 <code>Thread</code> 的 <code>getState</code> 方法可以获取线程状态，<strong>WAITING</strong>、<strong>TIME_WAITING</strong> 和 <strong>BLOCKED</strong> 都是需要特别注意的状态。</p><p>BLOCKED: 是指线程正在等待获取锁，对应的是下面代码中的情况一；</p><p>WAITING: 是指线程正在等待其他线程的“唤醒动作”，对应的是代码中的情况二。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized (object)  &#123;     &#x2F;&#x2F; 情况一：在这里卡住 --&gt; BLOCKED</span><br><span class="line">    object.wait();           &#x2F;&#x2F; 情况二：在这里卡住 --&gt; WAITING</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过当一个线程进入 WAITING 状态时，它不仅会释放 CPU 资源，还会将持有的 object 锁也同时释放。</p><p>更多相关资料 <a href="https://juejin.im/post/5b31b510e51d4558a426f7e9" target="_blank" rel="noopener">《Java 线程 Dump 分析》</a></p><h2 id="4-2-获得所有线程堆栈"><a href="#4-2-获得所有线程堆栈" class="headerlink" title="4.2 获得所有线程堆栈"></a>4.2 获得所有线程堆栈</h2><p>当我们发现有个线程导致主线程 <code>BLOCKED</code> ，需要通过 <code>Thread.getAllStackTraces()</code> 拿所有线程的堆栈，需要注意的是在 <code>Android 7.0</code>，<code>getAllStackTraces</code>是不会返回主线程的堆栈的。</p><h2 id="4-4-SIGQUIT-信号实现"><a href="#4-4-SIGQUIT-信号实现" class="headerlink" title="4.4 SIGQUIT 信号实现"></a>4.4 SIGQUIT 信号实现</h2><p>注：需要 <code>root</code> </p><p><code>Android</code> 应用发生 <code>ANR</code> 时，系统会发出 <code>SIGQUIT</code> 信号给发生 <code>ANR</code> 进程。系统信号捕捉线程触发输出<code>/data/anr/traces.txt</code> 文件，记录问题产生虚拟机、线程堆栈相关信息。这个 <code>trace</code> 文件中包含了线程信息和锁的信息，借助这个 <code>trace</code> 文件可以分析卡死的原因。</p><p>由此，如果利用这个系统原有的机制，自己在线程卡死时候触发traces文件的形成进行上报，便可以把线程卡死的关键进行进行上报。本监控方案便是<strong>利用系统机制进行卡死信息的抓取</strong>：</p><ol><li><p>当监控线程发现被监控线程卡死时，主动向系统发送 <code>SIGQUIT</code> 信号。</p></li><li><p>等待 <code>/data/anr/traces.txt</code> 文件生成。</p></li><li><p>文件生成以后进行上报。</p></li></ol><p>分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程名称; 优先级; 线程id; 线程状态</span></span><br><span class="line"><span class="string">"main"</span> prio=<span class="number">5</span> tid=<span class="number">1</span> Suspended</span><br><span class="line">  <span class="comment">// 线程组;  线程suspend计数; 线程debug suspend计数; </span></span><br><span class="line">  | group=<span class="string">"main"</span> sCount=<span class="number">1</span> dsCount=<span class="number">0</span> obj=<span class="number">0x74746000</span> self=<span class="number">0xf4827400</span></span><br><span class="line">  <span class="comment">// 线程native id; 进程优先级; 调度者优先级;</span></span><br><span class="line">  | sysTid=<span class="number">28661</span> nice=-<span class="number">4</span> cgrp=<span class="keyword">default</span> sched=<span class="number">0</span>/<span class="number">0</span> handle=<span class="number">0xf72cbbec</span></span><br><span class="line">  <span class="comment">// native线程状态; 调度者状态; 用户时间utime; 系统时间stime; 调度的CPU</span></span><br><span class="line">  | state=D schedstat=( <span class="number">3137222937</span> <span class="number">94427228</span> <span class="number">5819</span> ) utm=<span class="number">218</span> stm=<span class="number">95</span> core=<span class="number">2</span> HZ=<span class="number">100</span></span><br><span class="line">  <span class="comment">// stack相关信息</span></span><br><span class="line">  | stack=<span class="number">0xff717000</span>-<span class="number">0xff719000</span> stackSize=<span class="number">8</span>MB</span><br></pre></td></tr></table></figure><p>其中 <code>utm</code> 代表 <code>utime</code>，<code>HZ</code> 代表 <code>CPU</code> 的时钟频率，将 <code>utime</code> 转换为毫秒的公式是 <code>time * 1000/HZ</code>。例子中 <code>utm=218</code>，也就是 <code>218*1000/100=2180</code> 毫秒。</p><h2 id="4-5-Hook-实现"><a href="#4-5-Hook-实现" class="headerlink" title="4.5 Hook 实现"></a>4.5 Hook 实现</h2><p>用 <code>SIGQUIT</code> 信号量获取 <code>ANR</code> 日志，从而拿到所有线程的各种信息，这套方案看起来很美好。但事实上，它存在这几个问题：</p><ol><li><strong>可行性。</strong> 高版本系统已经没有权限读取 <code>/data/anr/traces.txt</code> 文件。需要 <code>root</code> 手机</li><li><strong>性能。</strong>获取所有线程堆栈以及各种信息非常耗时，对于卡顿场景不一定合适，它可能会进一步加剧用户的卡顿。</li></ol><h1 id="5-Demo-相关-Demo-学习"><a href="#5-Demo-相关-Demo-学习" class="headerlink" title="5 Demo 相关 Demo 学习"></a>5 Demo 相关 Demo 学习</h1><h2 id="5-1-抓取-CPU-数据"><a href="#5-1-抓取-CPU-数据" class="headerlink" title="5.1 抓取 CPU 数据"></a>5.1 抓取 CPU 数据</h2><p><a href="https://github.com/AndroidAdvanceWithGeektime/Chapter05" target="_blank" rel="noopener">Chapter05</a> </p><p>模仿 <a href="http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/java/com/android/internal/os/ProcessCpuTracker.java" target="_blank" rel="noopener">ProcessCpuTracker.java</a> 拿到一段时间内各个线程的耗时占比</p><p>示例的日志数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">usage: CPU usage <span class="number">5000</span>ms(from <span class="number">23</span>:<span class="number">23</span>:<span class="number">33.000</span> to <span class="number">23</span>:<span class="number">23</span>:<span class="number">38.000</span>):</span><br><span class="line">System TOTAL: <span class="number">2.1</span>% user + <span class="number">16</span>% kernel + <span class="number">9.2</span>% iowait + <span class="number">0.2</span>% irq + <span class="number">0.1</span>% softirq + <span class="number">72</span>% idle</span><br><span class="line">CPU Core: <span class="number">8</span></span><br><span class="line">Load Average: <span class="number">8.74</span> / <span class="number">7.74</span> / <span class="number">7.36</span></span><br><span class="line"></span><br><span class="line">Process:com.sample.app </span><br><span class="line">  <span class="number">50</span>% <span class="number">23468</span>/com.sample.app(S): <span class="number">11</span>% user + <span class="number">38</span>% kernel faults:<span class="number">4965</span></span><br><span class="line"></span><br><span class="line">Threads:</span><br><span class="line">  <span class="number">43</span>% <span class="number">23493</span>/singleThread(R): <span class="number">6.5</span>% user + <span class="number">36</span>% kernel faults：<span class="number">3094</span></span><br><span class="line">  <span class="number">3.2</span>% <span class="number">23485</span>/RenderThread(S): <span class="number">2.1</span>% user + <span class="number">1</span>% kernel faults：<span class="number">329</span></span><br><span class="line">  <span class="number">0.3</span>% <span class="number">23468</span>/.sample.app(S): <span class="number">0.3</span>% user + <span class="number">0</span>% kernel faults：<span class="number">6</span></span><br><span class="line">  <span class="number">0.3</span>% <span class="number">23479</span>/HeapTaskDaemon(S): <span class="number">0.3</span>% user + <span class="number">0</span>% kernel faults：<span class="number">982</span></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><ol><li>在 <code>System Total</code> 部分 <code>user</code> 占用不多，<code>CPU idle</code> 很高，消耗多在 <code>kernel</code> 和 <code>iowait</code>。</li><li><code>CPU</code> 是 8 核的，<code>Load Average</code> 大约也是 8，表示 <code>CPU</code> 并不处于高负载情况。</li><li>在 <code>Process</code> 里展示了这段时间内 <code>sample app</code> 的 <code>CPU</code> 使用情况：<code>user</code> 低，<code>kernel</code> 高，并且有 <code>4965</code> 次 <code>page faults</code>。<ol><li><code>page faluts</code> 分为三种：<code>minor page fault</code>、<code>major page fault</code> 和 <code>invalid page fault</code></li></ol></li><li>在 <code>Threads</code> 里展示了每个线程的 <code>usage</code> 情况，当前只有 <code>singleThread</code> 处于 <code>R</code> 状态，并且当前线程产生了 3096 次 <code>page faults</code>，其他的线程包括主线程（<code>Sample</code> 日志里可见的）都是处于 <code>S</code>状态。<ol><li><code>R</code>：代表线程处于 <code>Running</code> 或者 <code>Runnable</code> 状态。<code>Running</code> 状态说明线程当前被某个 <code>Core</code> 执行，<code>Runnable</code> 状态说明线程当前正在处于等待队列中等待某个 <code>Core</code> 空闲下来去执行。</li><li><code>S</code>： <code>TASK_INTERRUPTIBLE（可中断）</code>  发生这种状态是线程主动让出了 <code>CPU</code>，如果线程调用了 <code>sleep</code> 或者其他情况导致了自愿式的上下文切换就会处于 <code>S</code> 状态。</li></ol></li></ol><p><code>Demo</code> 中执行 <code>Test</code> 抓取数据如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CPU usage from <span class="number">5137</span>ms to <span class="number">81</span><span class="function">ms <span class="title">ago</span> <span class="params">(<span class="number">2020</span><span class="number">-05</span><span class="number">-13</span> <span class="number">21</span>:<span class="number">57</span>:<span class="number">32.764</span> to <span class="number">2020</span><span class="number">-05</span><span class="number">-13</span> <span class="number">21</span>:<span class="number">57</span>:<span class="number">37.819</span>)</span>:</span></span><br><span class="line"><span class="function">16% 15921/com.sample.<span class="title">processtracker</span><span class="params">(R)</span>: 6.3% user + 9.6% kernel / faults: 3332 minor</span></span><br><span class="line"><span class="function">thread stats:</span></span><br><span class="line"><span class="function">15% 16145/<span class="title">SingleThread</span><span class="params">(S)</span>: 1.9% user + 13% kernel / faults: 3014 minor</span></span><br><span class="line"><span class="function">13% 17088/<span class="title">SingleThread</span><span class="params">(S)</span>: 1.3% user + 12% kernel / faults: 3016 minor</span></span><br><span class="line"><span class="function">1.3% 15921/.<span class="title">processtracker</span><span class="params">(R)</span>: 0.9% user + 0.3% kernel / faults: 40 minor</span></span><br><span class="line"><span class="function">0.5% 16002/<span class="title">RenderThread</span><span class="params">(S)</span>: 0.1% user + 0.3% kernel / faults: 37 minor</span></span><br><span class="line"><span class="function">0.1% 15942/Jit thread <span class="title">pool</span><span class="params">(S)</span>: 0.1% user + 0% kernel / faults: 222 minor</span></span><br><span class="line"><span class="function">0% 15949/<span class="title">HeapTaskDaemon</span><span class="params">(S)</span>: 0% user + 0% kernel</span></span><br><span class="line"><span class="function">...</span></span><br><span class="line"><span class="function">0% <span class="title">TOTAL</span><span class="params">()</span>: 0% user + 0% kernel</span></span><br><span class="line"><span class="function">Load: 0.0 / 0.0 / 0.0</span></span><br></pre></td></tr></table></figure><p>这里不太清楚为什么后面的数据都是 0 ，最后应该输出 <code>iowait</code> 才对。</p><p>极客时间原文例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CPU usage from <span class="number">5187</span>ms to <span class="number">121</span><span class="function">ms <span class="title">ago</span> <span class="params">(<span class="number">2018</span><span class="number">-12</span><span class="number">-28</span> <span class="number">08</span>:<span class="number">28</span>:<span class="number">27.186</span> to <span class="number">2018</span><span class="number">-12</span><span class="number">-28</span> <span class="number">08</span>:<span class="number">28</span>:<span class="number">32.252</span>)</span>:</span></span><br><span class="line"><span class="function">40% 24155/com.sample.<span class="title">processtracker</span><span class="params">(R)</span>: 14% user + 26% kernel / faults: 5286 minor</span></span><br><span class="line"><span class="function">thread stats:</span></span><br><span class="line"><span class="function">35% 24184/<span class="title">SingleThread</span><span class="params">(S)</span>: 11% user + 24% kernel / faults: 3055 minor</span></span><br><span class="line"><span class="function">2.1% 24174/<span class="title">RenderThread</span><span class="params">(S)</span>: 1.3% user + 0.7% kernel / faults: 384 minor</span></span><br><span class="line"><span class="function">1.5% 24155/.<span class="title">processtracker</span><span class="params">(R)</span>: 1.1% user + 0.3% kernel / faults: 95 minor</span></span><br><span class="line"><span class="function">0.1% 24166/<span class="title">HeapTaskDaemon</span><span class="params">(S)</span>: 0.1% user + 0% kernel / faults: 1070 minor</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">100% <span class="title">TOTAL</span><span class="params">()</span>: 3.8% user + 7.8% kernel + 11% iowait + 0.1% irq + 0% softirq + 76% idle</span></span><br><span class="line"><span class="function">Load: 6.31 / 6.52 / 6.66</span></span><br></pre></td></tr></table></figure><p>如果有大佬知道原因，还请告知。</p><p>如果产生大量的 <code>faults</code> 其实是不太正常的，或者 <code>iowait</code> 过高就需要关注是否有很密集的 <code>I/O</code> 操作。</p><p><a href="https://yq.aliyun.com/articles/55820" target="_blank" rel="noopener">《page fault 带来的性能问题》</a> </p><p><a href="http://oenhan.com/iowait-wa-vmstat" target="_blank" rel="noopener">《iowait 的形成原因和内核分析》</a></p><h2 id="5-2-PLTHook-监控-Thread-的创建"><a href="#5-2-PLTHook-监控-Thread-的创建" class="headerlink" title="5.2 PLTHook 监控 Thread 的创建"></a>5.2 PLTHook 监控 Thread 的创建</h2><p><a href="https://github.com/AndroidAdvanceWithGeektime/Chapter06-plus" target="_blank" rel="noopener">Chapter06-plus</a> 这个 <code>Demo</code> 与 <a href="https://www.jianshu.com/p/a26d11502ec8" target="_blank" rel="noopener">Android线程的创建过程</a>  结合，了解 <code>PLTHook</code> 的使用，以及 <code>Thread</code> 状态知识、如何创建的。</p><h2 id="5-3-Loop-监控卡顿"><a href="#5-3-Loop-监控卡顿" class="headerlink" title="5.3 Loop 监控卡顿"></a>5.3 Loop 监控卡顿</h2><p>在 <code>Android UI</code> 线程中有个 <code>Looper</code>，在其 <code>loop</code> 方法中会不断取出 <code>Message</code>，调用其绑定的 <code>Handler</code> 在 <code>UI</code> 线程进行执行。</p><p>部分代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Looper me = myLooper();</span><br><span class="line">    <span class="keyword">final</span> MessageQueue queue = me.mQueue;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Message msg = queue.next(); <span class="comment">// might block</span></span><br><span class="line">        <span class="comment">// This must be in a local variable, in case a UI event sets the logger</span></span><br><span class="line">        <span class="keyword">final</span> Printer logging = me.mLogging;</span><br><span class="line">        <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">            logging.println(<span class="string">"&gt;&gt;&gt;&gt;&gt; Dispatching to "</span> + msg.target + <span class="string">" "</span> +</span><br><span class="line">                            msg.callback + <span class="string">": "</span> + msg.what);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            msg.target.dispatchMessage(msg);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">            logging.println(<span class="string">"&lt;&lt;&lt;&lt;&lt; Finished to "</span> + msg.target + <span class="string">" "</span> + msg.callback);</span><br><span class="line">        &#125;</span><br><span class="line">        msg.recycleUnchecked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在执行此代码前后，如果设置了 <code>logging</code>，会分别打印出 <code>&gt;&gt;&gt;&gt;&gt; Dispatching to</code>和 <code>&lt;&lt;&lt;&lt;&lt; Finished to</code> 这样的<code>log</code> 。</p><p>我们可以通过计算两次 <code>log</code> 之间的时间差值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Looper.getMainLooper().setMessageLogging(<span class="keyword">new</span> Printer() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String START = <span class="string">"&gt;&gt;&gt;&gt;&gt; Dispatching"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String END = <span class="string">"&lt;&lt;&lt;&lt;&lt; Finished"</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(String x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x.startsWith(START)) &#123;</span><br><span class="line">            LogMonitor.getInstance().startMonitor();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x.startsWith(END)) &#123;</span><br><span class="line">            LogMonitor.getInstance().removeMonitor();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>假设我们的阈值是 <code>1000ms</code>，当我在匹配到 <code>&gt;&gt;&gt;&gt;&gt; Dispatching</code> 时，我会在 <code>1000ms</code> 毫秒后执行一个任务（打印出 <code>UI</code> 线程的堆栈信息，会在非 <code>UI</code> 线程中进行）；</p><p>正常情况下，肯定是低于 <code>1000ms</code> 执行完成的，所以当我匹配到 <code>&lt;&lt;&lt;&lt;&lt; Finished</code> ，会移除该任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogMonitor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LogMonitor sInstance = <span class="keyword">new</span> LogMonitor();</span><br><span class="line">    <span class="keyword">private</span> Handler mIoHandler;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> TIME_BLOCK = <span class="number">1000L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LogMonitor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HandlerThread mLogThread = <span class="keyword">new</span> HandlerThread(<span class="string">"log"</span>);</span><br><span class="line">        mLogThread.start();</span><br><span class="line">        mIoHandler = <span class="keyword">new</span> Handler(mLogThread.getLooper());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Runnable mLogRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            StackTraceElement[] stackTrace = Looper.getMainLooper().getThread().getStackTrace();</span><br><span class="line">            <span class="keyword">for</span> (StackTraceElement s : stackTrace) &#123;</span><br><span class="line">                sb.append(s.toString() + <span class="string">"\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Log.e(<span class="string">"TAG"</span>,sb.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LogMonitor <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMonitor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; handlerClass = Class.forName(<span class="string">"android.os.Handler"</span>);</span><br><span class="line">            java.lang.reflect.Method method = handlerClass.getMethod(<span class="string">"hasCallbacks"</span>, Runnable<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            Boolean ret = (Boolean) method.invoke(mIoHandler, mLogRunnable);</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startMonitor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        mIoHandler.postDelayed(mLogRunnable,TIME_BLOCK);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeMonitor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        mIoHandler.removeCallbacks(mLogRunnable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们利用了 <code>HandlerThread</code> 这个类，同样利用了 <code>Looper</code> 机制，只不过在非UI线程中，如果执行耗时达到我们设置的阈值，则会执行 <code>mLogRunnable</code> ，打印出 <code>UI</code> 线程当前的堆栈信息；如果你阈值时间之内完成，则会 <code>remove</code> 掉该 <code>runnable</code>。</p><h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h1><blockquote><p><a href="https://time.geekbang.org/column/article/71982" target="_blank" rel="noopener">《Linux环境下进程的CPU占用率》</a></p><p><a href="http://man7.org/linux/man-pages/man5/proc.5.html" target="_blank" rel="noopener">《Linux 文档》</a></p><p><a href="https://juejin.im/post/5b31b510e51d4558a426f7e9" target="_blank" rel="noopener">《Java线程Dump分析》</a></p><p><a href="https://cloud.tencent.com/developer/article/1064396" target="_blank" rel="noopener">《手Q Android线程死锁监控与自动化分析实践》</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&mid=2650822205&idx=1&sn=6b8e78bc1d71eb79a199667cf132acf7&chksm=80b782a3b7c00bb5c12437556fca68136c75409855e9252e395b545621319edf23959942b67c&scene=21#wechat_redirect" target="_blank" rel="noopener">Android UI性能优化 检测应用中的UI卡顿</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>App UI优化💦</title>
      <link href="/2020/ui-optimization.html"/>
      <url>/2020/ui-optimization.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>每个做 UI 的 Android 开发，上辈子都是折翼的天使。</p></blockquote><h1 id="本文主要记载"><a href="#本文主要记载" class="headerlink" title="本文主要记载"></a>本文主要记载</h1><ul><li><strong>1 UI 优化究竟指的是什么呢？</strong></li><li><strong>2 屏幕适配？？？</strong></li><li><strong>3 如何测量、监控 UI 需要优化？</strong><ul><li>3.1 过度绘制</li><li>3.2 Profile GPU Rendering</li><li>3.3 测量 setContentView 具体耗时<ul><li>3.3.1 AOP</li><li>3.3.2 Factory2</li></ul></li><li>3.4 问题定位 systrace</li></ul></li><li><strong>4 UI 优化常用手段</strong><ul><li>4.1 尽量使用硬件加速</li><li>4.2 Create View 优化<ul><li>4.2.1 使用代码创建</li><li>4.2.2 异步创建</li></ul></li><li>4.3. measure/layout 优化</li><li>4.4 其他<ul><li>4.4.1 Litho：异步布局</li><li>4.4.2 Flutter：自己的布局 + 渲染引擎</li><li>4.4.3 RenderThread 与 RenderScript</li></ul></li></ul></li><li><strong>5 总结</strong></li></ul><hr><h1 id="1-UI-优化究竟指的是什么呢？"><a href="#1-UI-优化究竟指的是什么呢？" class="headerlink" title="1 UI 优化究竟指的是什么呢？"></a>1 UI 优化究竟指的是什么呢？</h1><p>我认为所谓的 <code>UI</code> 优化，应该包含两个方面</p><ol><li>一个是效率的提升，我们可以非常高效地把 <code>UI</code> 的设计图转化成应用界面，并且保证 <code>UI</code> 界面在不同尺寸和分辨率的手机上都是一致的</li><li>另一个是性能的提升，在正确实现复杂、炫酷的 <code>UI</code> 设计的同时，需要保证用户有流畅的体验。</li></ol><hr><h1 id="2-屏幕适配？？？"><a href="#2-屏幕适配？？？" class="headerlink" title="2 屏幕适配？？？"></a>2 屏幕适配？？？</h1><p><code>Android</code> 的碎片化问题令人痛心疾首，屏幕的差异正是碎片化问题的 “中心” ，多年来，有那么一群苦逼的 <code>Android</code> 开发，他们饱受碎片化之苦，面对着各式各样的手机屏幕尺寸和分辨率，还要与“凶残”的产品和 <code>UI</code> 设计师过招，日复一日、年复一年的做着 <code>UI</code> 适配和优化工作，蹉跎着青春的岁月。更加不幸的是，最近两年这个趋势似乎还愈演愈烈：刘海屏、全面屏，还有即将推出的柔性折叠屏，<code>UI</code> 适配将变得越来越复杂。</p><p>对于屏幕碎片化的问题，<code>Android</code> 推荐使用 <code>dp</code> 作为尺寸单位来适配 <code>UI</code>，因此每个 <code>Android</code> 开发都应该很清楚 <code>px</code>、<code>dp</code>、<code>dpi</code>、<code>ppi</code>、<code>density</code> 这些概念。</p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://raw.githubusercontent.com/CalmCenter/picGo/master/pictures/20200416135354.png" style="zoom:70%"><p>通过 <code>dp</code> 加上自适应布局可以基本解决屏幕碎片化的问题。</p><ul><li>不一致性。因为 dpi 与实际 ppi 的差异性，导致在相同分辨率的手机上，控件的实际大小会有所不同。</li><li>效率。设计师的设计稿都是以 px 为单位的，开发人员为了 UI 适配，需要手动通过百分比估算出 dp 值。</li></ul><p>除了直接 dp 适配之外，目前业界比较常用的 UI 适配方法主要有下面几种：</p><p>限制符适配方案。主要有宽高限定符与 smallestWidth 限定符适配方案，具体可以参考<a href="https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&mid=2650826034&idx=1&sn=5e86768d7abc1850b057941cdd003927&chksm=80b7b1acb7c038ba8912b9a09f7e0d41eef13ec0cea19462e47c4e4fe6a08ab760fec864c777&scene=21#wechat_redirect" target="_blank" rel="noopener">《Android 目前稳定高效的 UI 适配方案》</a><a href="https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&mid=2650826381&idx=1&sn=5b71b7f1654b04a55fca25b0e90a4433&chksm=80b7b213b7c03b0598f6014bfa2f7de12e1f32ca9f7b7fc49a2cf0f96440e4a7897d45c788fb&scene=21#wechat_redirect" target="_blank" rel="noopener">《smallestWidth 限定符适配方案》</a>。今日头条适配方案。通过反射修正系统的 density 值，具体可以参考<a href="https://mp.weixin.qq.com/s?__biz=MzI1MzYzMjE0MQ==&mid=2247484502&idx=2&sn=a60ea223de4171dd2022bc2c71e09351&scene=21#wechat_redirect" target="_blank" rel="noopener">《一种极低成本的 Android 屏幕适配方式》</a><a href="https://mp.weixin.qq.com/s/oSBUA7QKMWZURm1AHMyubA" target="_blank" rel="noopener">《今日头条适配方案》</a>。</p><hr><h1 id="3-如何测量、监控-UI-需要优化？"><a href="#3-如何测量、监控-UI-需要优化？" class="headerlink" title="3 如何测量、监控 UI 需要优化？"></a>3 如何测量、监控 UI 需要优化？</h1><h2 id="3-1-过度绘制"><a href="#3-1-过度绘制" class="headerlink" title="3.1 过度绘制"></a>3.1 过度绘制</h2><blockquote><p><strong>理论上一个像素每次只绘制一次是最优的，但是由于重叠的布局导致一些像素会被多次绘制，Overdraw由此产生。</strong></p></blockquote><p>我们可以通过调试工具来检测 <code>Overdraw</code> ：<code>设置——&gt;开发者选项——&gt;调试 GPU 过度绘制——&gt;显示过度绘制区域</code>。</p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://raw.githubusercontent.com/CalmCenter/picGo/master/pictures/20200416164642.png" style="zoom:50%"><blockquote><p>原色 – 没有过度绘制 – 这部分的像素点只在屏幕上绘制了一次。<br>蓝色 – 1次过度绘制   – 这部分的像素点只在屏幕上绘制了两次。<br>绿色 – 2次过度绘制   – 这部分的像素点只在屏幕上绘制了三次。<br>粉色 – 3次过度绘制   – 这部分的像素点只在屏幕上绘制了四次。<br>红色 – 4次过度绘制   – 这部分的像素点只在屏幕上绘制了五次。</p></blockquote><p><strong>在实际项目中，一般认为蓝色即是可以接受的颜色。</strong></p><p><strong>具体优化点：</strong></p><ol><li>各种控件背景颜色</li><li><code>Activity</code> 的 <code>Theme</code> 中的背景颜色</li></ol><p><strong>备注：有些过度绘制都是不可避免的，需要结合具体的布局场景具体分析。</strong></p><h2 id="3-2-Profile-GPU-Rendering"><a href="#3-2-Profile-GPU-Rendering" class="headerlink" title="3.2 Profile GPU Rendering"></a>3.2 Profile GPU Rendering</h2><p><code>设置——&gt;开发者选项——&gt;GPU 呈现模式分析——&gt;条形图</code></p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://raw.githubusercontent.com/CalmCenter/picGo/master/pictures/20200416171116.png" style="zoom:40%"><p>如果我们把上面的步骤转化线程模型，可以得到下面的流水线模型。<code>CPU</code> 将数据同步（<code>sync</code>）给 <code>GPU</code> 之后，一般不会阻塞等待<code>GPU</code> 渲染完毕，而是通知结束后就返回。而 <code>RenderThread</code> 承担了比较多的绘制工作，分担了主线程很多压力，提高了 <code>UI</code> 线程的响应速度。</p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://raw.githubusercontent.com/CalmCenter/picGo/master/pictures/20200416173431.png" style="zoom:30%"><h2 id="3-3-测量-setContentView-具体耗时"><a href="#3-3-测量-setContentView-具体耗时" class="headerlink" title="3.3 测量 setContentView 具体耗时"></a>3.3 测量 <code>setContentView</code> 具体耗时</h2><h3 id="3-3-1-AOP"><a href="#3-3-1-AOP" class="headerlink" title="3.3.1 AOP"></a>3.3.1 AOP</h3><p>我们可以通过 <code>AOP</code> 将代码切入到 <code>android.app.Activity.setContentView(..)</code> 中。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around</span>(<span class="string">"execution(* android.app.Activity.setContentView(..))"</span>) <span class="comment">//方法切入点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodAnnotated</span><span class="params">(ProceedingJoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">Signature signature = joinPoint.getSignature();</span><br><span class="line">String name = signature.toShortString();</span><br><span class="line"><span class="keyword">long</span> time = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">joinPoint.proceed();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">throwable.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">LogUtils.i(name + <span class="string">" cost "</span> + (System.currentTimeMillis() - time));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-2-Factory2"><a href="#3-3-2-Factory2" class="headerlink" title="3.3.2 Factory2"></a>3.3.2 Factory2</h3><p><code>View</code> 的绘制源码中，在生成我们 <code>xml</code> 所对应的 <code>View</code> 的时候有一个 <code>mFactory2</code> 的判断，我们可以在创建的时候做一些事情。</p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://raw.githubusercontent.com/CalmCenter/picGo/master/pictures/20200416180108.png" style="zoom:50%"><p>作用：</p><ol><li>定制生成控件的过程，全局替换，比如将 <code>TextView</code> 替换为 <code>CustomTextView</code>。</li><li>监控控件的生成时间，自己调用系统创建方法并且在方法前后记录时间。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">LayoutInflaterCompat.setFactory2(getLayoutInflater(), <span class="keyword">new</span> LayoutInflater.Factory2() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(View parent, String name, Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (name.equals(<span class="string">"TextView"</span>)) &#123;</span><br><span class="line">            <span class="comment">//创建 CustomTextView</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        View view = getDelegate().createView(parent,name,context,attrs);</span><br><span class="line">        LogUtils.i(name + <span class="string">" cost "</span> + (System.currentTimeMillis() - startTime));</span><br><span class="line">        <span class="keyword">return</span> view;<span class="comment">//返回生成后的 View</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(String name, Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="3-4-问题定位-systrace"><a href="#3-4-问题定位-systrace" class="headerlink" title="3.4 问题定位 systrace"></a>3.4 问题定位 systrace</h2><p>在 <code>Android 4.1</code>，新增了 <code>Systrace</code> 性能数据采样和分析工具。在启动优化中，已经用过 Systrace 了，这里也可以用它来检测每一帧的渲染情况。</p><p>结合 Android 内核的数据，生成 HTML 报告，<code>API 18</code> 以上，推荐 <code>TraceCompat</code></p><ul><li><strong>首先清空后台💦</strong></li></ul><p>杀掉所有应用，防止出现莫名莫名方法。</p><ul><li><strong>在需要检测的地方写入代码(可以不写，但是会少一些 tag 提示)💦</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TraceCompat.beginSection(&quot;AppOnCreate&quot;);</span><br><span class="line">...</span><br><span class="line">TraceCompat.endSection();</span><br></pre></td></tr></table></figure><ul><li><strong>执行检测💦</strong></li></ul><p>首先进入 <code>SDK</code> 目录，<code>Sdk\platform-tools\systrace\</code> 目录下有一个 <code>systrace.py</code> 文件，打开 <code>cmd</code> 输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python systrace.py -b 90960 -t 5 -a packagename -o test.log.html sched gfx view wm am app</span><br></pre></td></tr></table></figure><p>这种方式是 <code>5</code> 秒后自动输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python systrace.py gfx view wm am pm ss dalvik app sched -b 90960 -a packagename -o test.log.html</span><br></pre></td></tr></table></figure><p>这种方式可以在自己收集完后，点击 <code>Enter</code> 键停止收集</p><p>两种内容是不太一样的， <code>-t</code> 表示时间，<code>-a</code> 表示包名，<code>-o</code> 输出文件名，最终在当前目录打开文件即可看到，文件只能使用 <code>Chrome</code> 来打开，如果打开 <code>HTML</code> 出现 </p><p><code>Unable to select a master clock domain because no path can be found from &quot;SYSTRACE&quot; to &quot;LINUX_FTRACE_GLOBAL&quot;.</code></p><p>那就是命令出错了，命令我也是收集了好久，最终找到可用的，想了解更多的请查看 <a href="http://gityuan.com/2016/01/17/systrace/" target="_blank" rel="noopener">Gityuan</a> 或 <a href="https://source.android.com/devices/tech/debug/systrace" target="_blank" rel="noopener">官方文档</a> </p><ul><li><strong>分析文件</strong></li></ul><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://raw.githubusercontent.com/CalmCenter/picGo/master/pictures/20200416163431.png" style="zoom:40%"><p>在每个 <code>app</code> 进程，都有一个 <code>Frames</code> 行，正常情况以绿色的圆点表示。当圆点颜色为黄色或者红色时，意味着这一帧超过 <code>16.6ms</code> （即发现丢帧），这时需要通过放大那一帧进一步分析问题。对于 <code>Android 5.0(API level 21)</code> 或者更高的设备，该问题主要聚焦在 <code>UI Thread</code> 和 <code>Render Thread</code> 这两个线程当中。对于更早的版本，则所有工作在 <code>UI Thread</code> 。</p><ul><li><strong>Alerts</strong></li></ul><p><code>Systrace</code> 能自动分析 <code>trace</code> 中的事件，并能自动高亮性能问题作为一个 <code>Alerts</code> ，建议调试人员下一步该怎么做。</p><p>比如对于丢帧是，点击黄色或红色的 <code>Frames</code> 圆点便会在下方有相关的提示信息；另外，在 <code>systrace</code> 的最右上方，有一个 <code>Alerts tab</code> 可以展开，这里记录着所有的的警告提示信息。</p><p>总的来说，UI 渲染的优化必然会朝着两个方向。一个是进一步压榨硬件的性能，让 UI 可以更加流畅。一个是改进或者增加更多的分析工具，帮助我们更容易地发现以及定位问题。</p><hr><h1 id="4-UI-优化常用手段"><a href="#4-UI-优化常用手段" class="headerlink" title="4 UI 优化常用手段"></a>4 UI 优化常用手段</h1><h2 id="4-1-尽量使用硬件加速"><a href="#4-1-尽量使用硬件加速" class="headerlink" title="4.1 尽量使用硬件加速"></a>4.1 尽量使用硬件加速</h2><p>硬件加速绘制的性能是远远高于软件绘制的。所以说 <code>UI</code> 优化的第一个手段就是保证渲染尽量使用硬件加速。</p><p>有哪些情况我们不能使用硬件加速呢？之所以不能使用硬件加速，是因为硬件加速不能支持所有的 <code>Canvas API</code>。如果使用了不支持的 <code>API</code>，系统就需要通过 <code>CPU</code> 软件模拟绘制，这也是渐变、磨砂、圆角等效果渲染性能比较低的原因。</p><p><code>SVG</code> 也是一个非常典型的例子，<code>SVG</code> 有很多指令硬件加速都不支持。但我们可以用一个取巧的方法，提前将这些 <code>SVG</code> 转换成 <code>Bitmap</code> 缓存起来，这样系统就可以更好地使用硬件加速绘制。</p><h2 id="4-2-Create-View-优化"><a href="#4-2-Create-View-优化" class="headerlink" title="4.2 Create View 优化"></a>4.2 Create View 优化</h2><p><code>View</code> 的创建是在 <code>UI</code> 线程里，对于一些非常复杂的界面，这部分的耗时不容忽视。</p><h3 id="4-2-1-使用代码创建"><a href="#4-2-1-使用代码创建" class="headerlink" title="4.2.1 使用代码创建"></a>4.2.1 使用代码创建</h3><p>使用 <code>XML</code> 进行 <code>UI</code> 编写可以说是十分方便，可以在 <code>Android Studio</code> 中实时预览到界面。如果我们要对一个界面进行极致优化，就可以使用代码进行编写界面。</p><p>但是这种方式对开发效率来说简直是灾难，因此我们可以使用一些开源的 <code>XML</code> 转换为 <code>Java</code> 代码的工具，例如 <a href="https://github.com/iReaderAndroid/X2C" target="_blank" rel="noopener">X2C</a> 。但坦白说，还是有不少情况是不支持直接转换的，有时候需要修改源码。</p><p>所以我们需要兼容性能与开发效率，我建议只在对性能要求非常高，但修改又不非常频繁的场景才使用这个方式。</p><h3 id="4-2-2-异步创建"><a href="#4-2-2-异步创建" class="headerlink" title="4.2.2 异步创建"></a>4.2.2 异步创建</h3><p>之前在 <a href="http://localhost:4000/2019/start-optimization.html" target="_blank" rel="noopener">启动优化</a> 中提到的参考文章 <a href="https://juejin.im/post/5d63cdf7f265da03ed195f68?utm_source=gold_browser_extension#comment" target="_blank" rel="noopener">Android - 一种新奇的冷启动速度优化思路(Fragment极度懒加载 + Layout子线程预加载)</a> </p><p>遇到个点，如果 <code>xml</code> 中是 <code>com.google.android.material.appbar.AppBarLayout</code> 等 <code>google</code> 包里的，需要加上一条属性</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:theme="@style/Theme.AppCompat.Light.DarkActionBar"</span><br></pre></td></tr></table></figure><p>这个属性与自己 <code>Activity</code> 的 <code>theme</code> 相对应。</p><p>即刻时间中还提到一个错误 ：<code>java.lang.RuntimeException: Can&#39;t create handler inside thread that has not called Looper.prepare() at android.os.Handler.(Handler.java:121)</code> </p><p>这个问题在异步初始化 <code>WebView</code> 是有出现过。</p><p>解决办法：通过又一个非常取巧的方式来实现。在使用线程创建 UI 的时候，先把线程的 Looper 的 MessageQueue 替换成 UI 线程 Looper 的 Queue。</p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://raw.githubusercontent.com/CalmCenter/picGo/master/pictures/20200417114544.png" style="zoom:40%"><p>不过需要注意的是，在创建完 View 后我们需要把线程的 Looper 恢复成原来的。</p><blockquote><p>x5WebView 中异步调用会报错，还在研究中。。。</p></blockquote><h2 id="4-3-measure-layout-优化"><a href="#4-3-measure-layout-优化" class="headerlink" title="4.3. measure/layout 优化"></a>4.3. measure/layout 优化</h2><p>渲染流程中 <code>measure</code> 和 <code>layout</code> 也是需要 <code>CPU</code> 在主线程执行的，对于这块内容网上有很多优化的文章，一般的常规方法有：</p><ul><li><strong>减少 UI 布局层次</strong>。例如尽量扁平化，使用 等优化。</li><li><strong>优化 layout 的开销</strong>。尽量不使用 <code>RelativeLayout</code> 或者基于 <code>weighted LinearLayout</code>，它们 layout 的开销非常巨大。这里我推荐使用 <code>ConstraintLayout</code> 替代 <code>RelativeLayout</code> 或者 <code>weighted LinearLayout</code>。</li><li><strong>背景优化</strong>。尽量不要重复去设置背景，这里需要注意的是主题背景（<code>theme</code>)， <code>theme</code> 默认会是一个纯色背景，如果我们自定义了界面的背景，那么主题的背景我们来说是无用的。但是由于主题背景是设置在 <code>DecorView</code> 中，所以这里会带来重复绘制，也会带来绘制性能损耗。</li></ul><p>对于 <code>measure</code> 和 <code>layout</code>，我们可以像 <code>Create View</code> 一样实现异步创建，这样可以大大地提升首次显示的性能。</p><p><code>Textview</code> 是系统控件中非常强大也非常重要的一个控件，强大的背后就代表着需要做很多计算。在 <code>2018</code> 年的 <code>Google I/O</code> 大会，发布了 <code>PrecomputedText</code> 并已经集成在 <code>Jetpack</code> 中，它给我们提供了接口，可以异步进行 <code>measure</code> 和 <code>layout</code>，不必在主线程中执行。</p><p><strong>PrecomputedText</strong></p><p>在 <code>xml</code> 布局中使用 <code>AppCompatTextView</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">androidx.appcompat.widget.AppCompatTextView</span></span></span><br></pre></td></tr></table></figure><p>赋值的时候</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;PrecomputedTextCompat&gt; future = PrecomputedTextCompat.getTextFuture(</span><br><span class="line">                <span class="string">"content xxx"</span>, mTextView.getTextMetricsParamsCompat(), <span class="keyword">null</span>);</span><br><span class="line"> </span><br><span class="line">mTextView.setTextFuture(future);</span><br></pre></td></tr></table></figure><p>如果使用 <code>kotlin</code> ，那么利用拓展方法会更加酸爽。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> AppCompatTextView.<span class="title">setTextFuture</span><span class="params">(charSequence: <span class="type">CharSequence</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.setTextFuture(PrecomputedTextCompat.getTextFuture(</span><br><span class="line">            charSequence,</span><br><span class="line">            TextViewCompat.getTextMetricsParams(<span class="keyword">this</span>),</span><br><span class="line">            <span class="literal">null</span></span><br><span class="line">    ))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">textView.setTextFuture(“text”)</span><br></pre></td></tr></table></figure><h2 id="4-4-其他"><a href="#4-4-其他" class="headerlink" title="4.4 其他"></a>4.4 其他</h2><h3 id="4-4-1-Litho：异步布局"><a href="#4-4-1-Litho：异步布局" class="headerlink" title="4.4.1 Litho：异步布局"></a>4.4.1 Litho：异步布局</h3><p><a href="https://github.com/facebook/litho" target="_blank" rel="noopener">Litho</a> 是 <code>Facebook</code> 开源的声明式 <code>Android UI</code> 渲染框架，它是基于另外一个 <code>Facebook</code> 开源的布局引擎 <a href="https://github.com/facebook/yoga" target="_blank" rel="noopener">Yoga</a> 开发的。</p><p><code>Litho 如何优化的</code></p><ol><li><p><strong>异步布局</strong></p><p>一般来说的 Android 所有的控件绘制都要遵守 measure -&gt; layout -&gt; draw 的流水线，并且这些都发生在主线程中。</p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://raw.githubusercontent.com/CalmCenter/picGo/master/pictures/20200417165148.png" style="zoom:40%"><p><code>Litho</code> 如我前面提到的 <code>PrecomputedText</code> 一样，把 <code>measure</code> 和 <code>layout</code> 都放到了后台线程，只留下了必须要在主线程完成的 <code>draw</code>，这大大降低了 <code>UI</code> 线程的负载。它的渲染流水线如下：</p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://raw.githubusercontent.com/CalmCenter/picGo/master/pictures/20200417165357.png" style="zoom:40%"></li><li><p><strong>界面扁平化</strong></p><p>前面也提到过，降低 <code>UI</code> 的层级是一个非常通用的优化方法。<code>Litho</code> 就给了我们一种方案，由于 <code>Litho</code> 使用了自有的布局引擎（<code>Yoga</code>)，在布局阶段就可以检测不必要的层级、减少 <code>ViewGroups</code>，来实现 <code>UI</code> 扁平化。</p></li><li><p><strong>优化 RecyclerView</strong></p><p><code>Litho</code> 还优化了 <code>RecyclerView</code> 中 <code>UI</code>组件的缓存和回收方法。原生的 <code>RecyclerView</code> 或者 <code>ListView</code> 是按照 <code>viewType</code> 来进行缓存和回收，但如果一个<code>RecyclerView/ListView</code> 中出现 <code>viewType</code> 过多，会使缓存形同虚设。但 <code>Litho</code> 是按照 <code>text</code>、<code>image</code> 和 <code>video</code> 独立回收的，这可以提高缓存命中率、降低内存使用率、提高滚动帧率。</p><p><code>Litho</code> 虽然强大，但也有自己的缺点。它为了实现 <code>measure/layout</code> 异步化，使用了类似 <code>react</code> 单向数据流设计，这一定程度上加大了 <code>UI</code> 开发的复杂性。并且 <code>Litho</code> 的 <code>UI</code>代码是使用 <code>Java/Kotlin</code> 来进行编写，无法做到在 <code>AS</code> 中预览。如果你没有计划完全迁移到 <code>Litho</code>，我建议可以优先使用 <code>Litho</code> 中的 <code>RecyclerCollectionComponent</code> 和 <code>Sections</code> 来优化自己的 <code>RecyelerView</code> 的性能。</p></li></ol><h3 id="4-4-2-Flutter：自己的布局-渲染引擎"><a href="#4-4-2-Flutter：自己的布局-渲染引擎" class="headerlink" title="4.4.2 Flutter：自己的布局 + 渲染引擎"></a>4.4.2 <strong>Flutter：自己的布局 + 渲染引擎</strong></h3><p>如下图所示，<code>Litho</code> 虽然通过使用自己的布局引擎 <code>Yoga</code>，一定程度上突破了系统的一些限制，但是在 <code>draw</code> 之后依然走的系统的渲染机制。</p><p><a href="https://github.com/flutter/flutter" target="_blank" rel="noopener">Flutter</a> 把 <code>Skia</code> 引擎直接集成进了 <code>App</code> 中，这使得 <code>Flutter App</code> 就像一个游戏 <code>App</code>。并且直接使用了 <code>Dart</code> 虚拟机，可以说是一套跳脱出 <code>Android</code> 的方案，所以 <code>Flutter</code> 也可以很容易实现跨平台。</p><p><a href="https://tech.meituan.com/2018/08/09/waimai-flutter-practice.html" target="_blank" rel="noopener">《Flutter 原理与实践》</a></p><h3 id="4-4-3-RenderThread-与-RenderScript"><a href="#4-4-3-RenderThread-与-RenderScript" class="headerlink" title="4.4.3 RenderThread 与 RenderScript"></a>4.4.3 RenderThread 与 RenderScript</h3><p>在 <code>Android 5.0</code>，系统增加了 <code>RenderThread</code>，对于 <code>ViewPropertyAnimator</code> 和 <code>CircularReveal</code> 动画，我们可以使用 <a href="https://mp.weixin.qq.com/s?__biz=MzUyMDAxMjQ3Ng==&mid=2247489230&idx=1&sn=adc193e35903ab90a4c966059933a35a&source=41#wechat_redirect" target="_blank" rel="noopener">RenderThead 实现动画的异步渲染</a>。当主线程阻塞的时候，普通动画会出现明显的丢帧卡顿，而使用 <code>RenderThread</code> 渲染的动画即使阻塞了主线程仍不受影响。</p><p>我们可以通过 <code>RenderScript</code>，它是 <code>Android</code> 操作系统上的一套 <code>API</code>。它基于异构计算思想，专门用于密集型计算。<code>RenderScript</code> 提供了三个基本工具：一个硬件无关的通用计算 <code>API</code>；一个类似于 <code>CUDA</code>、<code>OpenCL</code> 和 <code>GLSL</code> 的计算 <code>API</code>；一个类 <code>C99</code> 的脚本语言。允许开发者以较少的代码实现功能复杂且性能优越的应用程序。</p><ul><li><a href="https://www.jianshu.com/p/b72da42e1463" target="_blank" rel="noopener">RenderScript 渲染利器</a></li><li><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2016/0504/4205.html?utm_source=itdadao&utm_medium=referral" target="_blank" rel="noopener">RenderScript : 简单而快速的图像处理</a></li><li>…<br>说</li></ul><hr><h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h1><ol><li><strong>在系统的框架下优化。</strong>布局优化、使用代码创建、<code>View</code> 缓存等都是这个思路，我们希望减少甚至省下渲染流水线里某个阶段的耗时。</li><li><strong>利用系统新的特性。</strong>使用硬件加速、<code>RenderThread</code>、<code>RenderScript</code> 都是这个思路，通过系统一些新的特性，最大限度压榨出性能。</li><li><strong>突破系统的限制。</strong>由于 <code>Android</code> 系统碎片化非常严重，很多好的特性可能低版本系统并不支持。而且系统需要支持所有的场景，在一些特定场景下它无法实现最优解。这个时候，我们希望可以突破系统的条条框框，例如 <code>Litho</code> 突破了布局，<code>Flutter</code> 则更进一步，把渲染也接管过来了。</li></ol><p>对于 <code>UI</code> 优化的另一个思考是效率，目前 <code>Android Studio</code> 对设计并不友好，例如不支持 <code>Sketch</code> 插件和 <code>AE</code> 插件。<a href="https://github.com/airbnb/lottie-android" target="_blank" rel="noopener">Lottie</a> 是一个非常好的案例，它很大提升了开发人员写动画的效率。</p><blockquote><p>“设计师和产品，你们长大了，要学会自己写 UI 了”。在未来，我们希望 UI 界面与适配可以实现自动化，或者干脆把它交还给设计师和产品。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客图片不显示问题</title>
      <link href="/2020/picnotshow.html"/>
      <url>/2020/picnotshow.html</url>
      
        <content type="html"><![CDATA[<p>因为我是自己上传的 github ，然后打不开了，所以查了一下 ip 和相关文章。网上文章都是在 <code>C:\Windows\System32\drivers\etc\hosts</code> 文件中复制固定内容，不同网段的用户查到的IP可能不一样，所以需要自己去查，而不是简单的copy。</p><ul><li>首先检测是哪个链接问题，这里我是调整好的。</li></ul><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://raw.githubusercontent.com/CalmCenter/picGo/master/pictures/20200330134722.png" alt=""></p><ul><li>打开 <a href="http://tool.chinaz.com/dns/" target="_blank" rel="noopener">DNS查询网站</a> ，搜索 <code>avatars2.githubusercontent.com</code> </li></ul><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://raw.githubusercontent.com/CalmCenter/picGo/master/pictures/20200330135205.png" alt=""></p><p>选择一个可以使用的 <code>IP</code>，在 <code>C:\Windows\System32\drivers\etc\hosts</code> 末尾 加上</p><p>在末尾加上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">151.101.108.133 avatars0.githubusercontent.com </span><br><span class="line">151.101.108.133 avatars1.githubusercontent.com </span><br><span class="line">151.101.108.133 avatars2.githubusercontent.com </span><br><span class="line">151.101.108.133 avatars3.githubusercontent.com </span><br><span class="line">151.101.108.133 avatars4.githubusercontent.com </span><br><span class="line">151.101.108.133 avatars5.githubusercontent.com </span><br><span class="line">151.101.108.133 avatars6.githubusercontent.com </span><br><span class="line">151.101.108.133 avatars7.githubusercontent.com </span><br><span class="line">151.101.108.133 avatars8.githubusercontent.com</span><br></pre></td></tr></table></figure><p>不同网段的用户查到的 <code>IP</code> 可能不一样，所以需要自己去查，而不是简单的copy，这是我最终的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># GitHub Start </span><br><span class="line">192.30.253.112 github.com </span><br><span class="line">192.30.253.119 gist.github.com </span><br><span class="line">185.199.111.154 github.githubassets.com </span><br><span class="line">185.199.108.154 github.githubassets.com </span><br><span class="line">185.199.109.154 github.githubassets.com </span><br><span class="line">185.199.110.154 github.githubassets.com </span><br><span class="line">151.101.108.133 assets-cdn.github.com </span><br><span class="line">151.101.108.133 raw.githubusercontent.com </span><br><span class="line">151.101.108.133 gist.githubusercontent.com </span><br><span class="line">151.101.108.133 cloud.githubusercontent.com </span><br><span class="line">151.101.108.133 camo.githubusercontent.com </span><br><span class="line">151.101.108.133 avatars0.githubusercontent.com </span><br><span class="line">151.101.108.133 avatars1.githubusercontent.com </span><br><span class="line">151.101.108.133 avatars2.githubusercontent.com </span><br><span class="line">151.101.108.133 avatars3.githubusercontent.com </span><br><span class="line">151.101.108.133 avatars4.githubusercontent.com </span><br><span class="line">151.101.108.133 avatars5.githubusercontent.com </span><br><span class="line">151.101.108.133 avatars6.githubusercontent.com </span><br><span class="line">151.101.108.133 avatars7.githubusercontent.com </span><br><span class="line">151.101.108.133 avatars8.githubusercontent.com </span><br><span class="line"> </span><br><span class="line"># GitHub End</span><br></pre></td></tr></table></figure><ul><li>刷新 DNS</li></ul><p>在 <code>cmd</code> 中输入<code>ipconfig /flushdns</code> 即可刷新，不行的话再重启电脑，这样就能成功打开<code>github</code> 或博客了，所有图片和内容都能加载。</p>]]></content>
      
      
      <categories>
          
          <category> github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>App 内存检测优化💦</title>
      <link href="/2020/memory-optimization2.html"/>
      <url>/2020/memory-optimization2.html</url>
      
        <content type="html"><![CDATA[<p>🌞一个好的架构可以减少甚至避免我们犯错，而一个好的监控可以帮助我们及时发现问题🌞内存优化的重点在于监控，和平时代码规范。这篇文章带你了解监控工具 Memory Profiler、MAT、LeakCanary 的使用以及分析。</p><h1 id="本文主要记载"><a href="#本文主要记载" class="headerlink" title="本文主要记载"></a>本文主要记载</h1><ul><li><strong>1 什么是 Memory Profiler？</strong><ul><li>1.1 使用介绍<ul><li>1.1.1 启用高级分析</li><li>1.1.2 计算内存(每个内存类别当前使用多少内存)</li><li>1.1.3 查看内存分配(分配的对象数)</li><li>1.1.4 在分析时提高应用性能</li><li>1.1.5 捕获堆转储</li><li>1.1.6 将堆转储另存为 HPROF 文件</li></ul></li></ul></li><li><strong>2 什么是 MAT？</strong><ul><li>2.1 使用前提</li><li>2.2 使用介绍</li></ul></li><li><strong>3 什么是 LeakCanary？</strong><ul><li>3.1 LeakCanary 原理</li><li>3.2 LeakCanary 使用</li></ul></li><li><strong>4 自定义实现 Demo</strong><ul><li>4.1 自动化监测 Demo</li><li>4.2 重复图片监测 Demo</li></ul></li><li><strong>5 优化思路</strong><ul><li>5.1 设备分级</li><li>5.2 Bitmap 优化</li></ul></li><li><strong>6 更多</strong></li></ul><hr><blockquote><p>一个好的架构可以减少甚至避免我们犯错，而一个好的监控可以帮助我们及时发现问题。</p></blockquote><p>检测工具常见的有 <code>Memory Profiler</code> <code>MAT</code> <code>LeakCanary</code></p><h1 id="1-什么是-Memory-Profiler"><a href="#1-什么是-Memory-Profiler" class="headerlink" title="1  什么是 Memory Profiler?"></a>1  什么是 Memory Profiler?</h1><p><code>Profiler</code> 是 <code>Android Studio</code> 为我们提供的性能分析工具，它包含了 <code>CPU</code>、<code>内存</code>、<code>网络</code>以及 <code>电量</code> 的分析信息，而 <code>Memory Profiler</code> 则是 <code>Profiler</code> 中的其中一个版块。</p><p>打开 <code>Profiler</code>  方式</p><ol><li>View &gt; Tool Windows &gt; Android Profiler</li><li>下方的 Profiler 标签</li><li>双击 shift 搜索 profiler</li></ol><h2 id="1-1-使用介绍"><a href="#1-1-使用介绍" class="headerlink" title="1.1 使用介绍"></a>1.1 使用介绍</h2><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://raw.githubusercontent.com/CalmCenter/picGo/master/pictures/20200413144637.png" style="zoom:70%"><ol><li><p>用于强制执行垃圾回收事件的按钮（强制 <code>GC</code> ）。</p></li><li><p>用于 <code>1.1.5 捕获堆转储</code> 的按钮。</p><p><strong>注意</strong>：只有在连接到搭载 <code>Android 7.1</code>（<code>API</code> 级别 25）或更低版本的设备时，才会在堆转储按钮右侧显示用于 <code>记录内存分配</code> 的按钮。</p></li><li><p>用于指定分析器多久捕获一次内存分配的下拉菜单。选择适当的选项可 <code>1.1.4 在分析时提高应用性能</code>。</p></li><li><p>用于缩放时间轴的按钮。</p></li><li><p>用于跳转到实时内存数据的按钮。</p></li><li><p>事件时间轴，显示活动状态、用户输入事件和屏幕旋转事件。</p></li><li><p>内存使用量时间轴，它会显示以下内容：</p><ul><li>一个堆叠图表，显示 <code>1.1.2 每个内存类别当前使用多少内存</code> ，如左侧的 y 轴以及顶部的彩色键所示。</li><li>一条虚线，表示 <code>1.1.3 分配的对象数</code>，如右侧的 y 轴所示。</li><li>每个垃圾回收事件的图标。</li></ul></li></ol><p>如果使用的是搭载 Android 7.1 或更低版本的设备，则并非所有分析数据在默认情况下都可见。如果看到一条消息，显示“Advanced profiling is unavailable for the selected process”，需要 <code>1.1.1 启用高级分析</code> 才能看到以下内容：</p><ul><li>事件时间轴</li><li>分配的对象数</li><li>垃圾回收事件</li></ul><p>在 Android 8.0 及更高版本上，始终为可调试应用启用高级分析。</p><h3 id="1-1-1-启用高级分析"><a href="#1-1-1-启用高级分析" class="headerlink" title="1.1.1  启用高级分析"></a>1.1.1  启用高级分析</h3><ol><li>依次选择 <strong>Run &gt; Edit Configurations</strong>。</li><li>在左侧窗格中选择本应用模块。</li><li>点击 <strong>Profiling</strong> 标签，然后勾选 <strong>Enable advanced profiling</strong>。</li><li>重新编译并运行应用。</li></ol><h3 id="1-1-2-计算内存-每个内存类别当前使用多少内存"><a href="#1-1-2-计算内存-每个内存类别当前使用多少内存" class="headerlink" title="1.1.2 计算内存(每个内存类别当前使用多少内存)"></a>1.1.2 计算内存(每个内存类别当前使用多少内存)</h3><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://raw.githubusercontent.com/CalmCenter/picGo/master/pictures/20200414112438.png" style="zoom:90%"><p>内存计数中的类别如下：</p><ul><li><p><strong>Java</strong>：从 <code>Java</code> 或 <code>Kotlin</code> 代码分配的对象的内存。</p></li><li><p><strong>Native</strong>：从 <code>C</code> 或 <code>C++</code> 代码分配的对象的内存。</p><p>即使应用中不使用 <code>C++</code>，也可能会看到此处使用的一些原生内存，因为 <code>Android</code> 框架使用原生内存处理各种任务，如处理图像资源和其他图形时。</p></li><li><p><strong>Graphics</strong>：图形缓冲区队列向屏幕显示像素（包括 <code>GL</code> 表面、<code>GL</code> 纹理等等）所使用的内存。（请注意，这是与 <code>CPU</code> 共享的内存，不是 <code>GPU</code> 专用内存。）</p></li><li><p><strong>Stack</strong>：应用中的原生堆栈和 <code>Java</code> 堆栈使用的内存。这通常与应用运行多少线程有关。</p></li><li><p><strong>Code</strong>：应用用于处理代码和资源（如 <code>dex</code> 字节码、经过优化或编译的 <code>dex</code> 代码、<code>.so</code> 库和字体）的内存。</p></li><li><p><strong>Others</strong>：应用使用的系统不确定如何分类的内存。</p></li><li><p><strong>Allocated</strong>：应用分配的 <code>Java/Kotlin</code> 对象数。此数字没有计入 C 或 C++ 中分配的对象。</p><p>如果连接到搭载 <code>Android 7.1</code> 及更低版本的设备，只有在 <code>Memory Profiler</code> 连接到运行的应用时，才开始此分配计数。因此，开始分析之前分配的任何对象都不会被计入。不过，<code>Android 8.0</code> 及更高版本附带一个设备内置分析工具，该工具可跟踪所有分配，因此，在 <code>Android 8.0</code> 及更高版本上，此数字始终表示应用中待处理的 Java 对象总数。</p></li></ul><p><strong>注意：</strong>高级分析配置会使编译过程变慢，所以仅在想要开始分析应用时，才应启用该配置。</p><h3 id="1-1-3-查看内存分配-分配的对象数"><a href="#1-1-3-查看内存分配-分配的对象数" class="headerlink" title="1.1.3 查看内存分配(分配的对象数)"></a>1.1.3 查看内存分配(分配的对象数)</h3><p>对于 <code>Android 8.0</code> 及更高版本，选择一个现有时间轴区域以查看对象分配</p><p>对于 <code>Android 7.1</code> 及更低版本，必须明确记录内存分配，点击 <code>Memory Profiler</code> 工具栏中的 <code>Record memory allocations</code> 图标或者 一个 <code>Record</code> 的按钮。记录时，<code>Memory Profiler</code> 会跟踪应用中发生的所有分配。完成后，请点击 <code>Stop recording</code> 图标或者一个 <code>Stop</code> 的按钮，查看分配。</p><p><strong>注意</strong>：在 <code>Android 7.1</code> 及更低版本上，最多可以记录 <code>65535</code> 个分配。 如果记录会话超出此限制，则记录中仅保存最新的 <code>65535</code> 个分配。（在 <code>Android 8.0</code> 及更高版本上，则没有实际的限制。）</p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://raw.githubusercontent.com/CalmCenter/picGo/master/pictures/20200414135710.png" style="zoom:70%"><ol><li>浏览列表以查找堆计数异常大且可能存在泄露的对象。为帮助查找已知类，点击 <code>Class Name</code> 列标题以按字母顺序排序。然后，点击一个类名称。此时右侧将出现 <code>Instance View</code> 窗格，显示该类的每个实例。</li><li>在 <code>Instance View</code> 窗格中，点击一个实例。此时下方将出现 <code>Call Stack</code> 标签页，显示该实例被分配到何处以及在哪个线程中。</li><li>在 <code>Call Stack</code> 标签页中，右键点击任意行并选择 <code>Jump to Source</code>，以在编辑器中打开该代码。</li></ol><p><code>Live Allocation</code> 第一个选择框是选择要检查的堆：</p><ul><li><strong>default heap</strong>：当系统未指定堆时。</li><li><strong>image heap</strong>：系统启动映像，包含启动期间预加载的类。此处的分配保证绝不会移动或消失。</li><li><strong>zygote heap</strong>：写时复制堆，其中的应用进程是从 <code>Android</code> 系统中派生的。</li><li><strong>app heap</strong>：您的应用在其中分配内存的主堆。</li><li><strong>JNI heap</strong>：显示 Java 原生接口 (<code>JNI</code>) 引用被分配和释放到什么位置的堆。</li></ul><p>第二个选择框选择如何安排分配：</p><ul><li><strong>Arrange by class</strong>：根据类名称对所有分配进行分组。这是默认选项。</li><li><strong>Arrange by package</strong>：根据软件包名称对所有分配进行分组。</li><li><strong>Arrange by callstack</strong>：将所有分配分组到其对应的调用堆栈。只有在记录分配期间 <code>捕获堆转储</code> 时，此选项才有效。即便如此，堆中也很可能有在开始记录之前分配的对象，所以会先显示这些分配，直接按类名称列出它们。</li></ul><h3 id="1-1-4-在分析时提高应用性能"><a href="#1-1-4-在分析时提高应用性能" class="headerlink" title="1.1.4 在分析时提高应用性能"></a>1.1.4 在分析时提高应用性能</h3><p>为了在分析时提高应用性能，<code>Memory Profiler</code> 在默认情况下会定期对内存分配进行采样。在运行 <code>API</code> 级别 <code>26</code> 或更高级别的设备上进行测试时，可以使用 <code>Allocation Tracking</code> 下拉菜单来更改此行为。可用选项如下：</p><ul><li><strong>Full</strong>：捕获内存中的所有对象分配。这是 <code>Android Studio 3.2</code> 及更低版本中的默认行为。如果您有一个分配了大量对象的应用，则可能会在分析时观察到应用的运行速度明显减慢。</li><li><strong>Sampled</strong>：定期对内存中的对象分配进行采样。这是默认选项，在分析时对应用性能的影响较小。在短时间内分配大量对象的应用仍可能会表现出明显的速度减慢。</li><li><strong>Off</strong>：停止跟踪应用的内存分配。</li></ul><h3 id="1-1-5-捕获堆转储"><a href="#1-1-5-捕获堆转储" class="headerlink" title="1.1.5 捕获堆转储"></a>1.1.5 捕获堆转储</h3><p>堆转储显示在捕获堆转储时应用中哪些对象正在使用内存。特别是在长时间的用户会话后，堆转储会显示认为不应再位于内存中却仍在内存中的对象，从而帮助识别内存泄露。</p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://raw.githubusercontent.com/CalmCenter/picGo/master/pictures/20200414161957.png" style="zoom:40%"><p>要捕获堆转储，请点击 Memory Profiler 工具栏中的 <strong>Dump Java heap</strong> 图标 <img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://developer.android.google.cn/studio/images/buttons/profiler-heap-dump.png" style="zoom:70%">  在转储堆期间，Java 内存量可能会暂时增加。 这很正常，因为堆转储与您的应用发生在同一进程中，并需要一些内存来收集数据。</p><ul><li><p><strong>Allocations</strong>：堆中的分配数。</p></li><li><p><strong>Native Size</strong>：此对象类型使用的原生内存总量（以字节为单位）。只有在使用 <code>Android 7.0</code> 及更高版本时，才会看到此列。</p><p>您会在此处看到采用 <code>Java</code> 分配的某些对象的内存，因为 <code>Android</code> 对某些框架类（如 <code>Bitmap</code>）使用原生内存。</p></li><li><p><strong>Shallow Size</strong>：此对象类型使用的 Java 内存总量（以字节为单位）。</p></li><li><p><strong>Retained Size</strong>：为此类的所有实例而保留的内存总大小（以字节为单位）。</p></li></ul><p>点击一个类名称可在右侧打开 <strong>Instance View</strong> 窗口。</p><ul><li><strong>Depth</strong>：从任意 <code>GC</code> 根到选定实例的最短跳数。</li><li><strong>Native Size</strong>：原生内存中此实例的大小。 只有在使用 Android 7.0 及更高版本时，才会看到此列。</li><li><strong>Shallow Size</strong>：<code>Java</code> 内存中此实例的大小。</li><li><strong>Retained Size</strong>：此实例所支配内存的大小。</li></ul><p>如果你 <code>ClassName</code> 选中的是 <code>Bitmap</code> ,在 <code>7.1</code> 及以下版本的设备中 <code>Call Sack</code>位置会出现 <code>Bitmap Preview</code> 功能，来预览是哪张图片</p><p><code>References</code> 标签页，显示对该对象的每个引用，如果发现某个引用可能在泄露内存，右键点击它并选择 <code>Go to Instance</code>。这样会从堆转储中选择相应的实例，从而显示它自己的实例数据。</p><h3 id="1-1-6-将堆转储另存为-HPROF-文件"><a href="#1-1-6-将堆转储另存为-HPROF-文件" class="headerlink" title="1.1.6 将堆转储另存为 HPROF 文件"></a>1.1.6 将堆转储另存为 HPROF 文件</h3><p>在 Android Studio 3.1 及更低版本中，<code>Export capture to file</code> 按钮 <img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://developer.android.google.cn/studio/images/buttons/profiler-export-hprof.png" alt="img"> 位于时间轴下方工具栏的左侧</p><p>在 Android Studio 3.2 及更高版本中，<code>Sessions</code> 窗格中每个 <code>Heap Dump</code>条目的右侧都有一个 <code>Export Heap Dump</code> 按钮。在随即显示的 <code>Export As</code> 对话框中，使用 <code>.hprof</code>  文件扩展名保存文件。</p><hr><h1 id="2-什么是-MAT"><a href="#2-什么是-MAT" class="headerlink" title="2 什么是 MAT?"></a>2 什么是 MAT?</h1><p>对于内存泄漏问题，Memory Profiler 只能给我们提供一个简单的分析，不能够帮我们确认具体发生问题的地方。</p><p>而 MAT 就可以帮我们做到这一点，MAT 的全称是 Memory Analyzer Tool，它是一款功能强大的 Java 堆内存分析工具，可以用于查找内存泄漏以及查看内存消耗情况。</p><h2 id="2-1-使用前提"><a href="#2-1-使用前提" class="headerlink" title="2.1 使用前提"></a>2.1 使用前提</h2><ol><li><p>到 MAT 的官网 <a href="https://www.eclipse.org/mat/downloads.php" target="_blank" rel="noopener">下载 MAT</a>。</p></li><li><p>使用 <code>Memory Profiler</code> 的堆转储功能，导出 <code>hprof（Heap Profile）</code>文件。</p></li><li><p>配置 <code>platform-tools</code> 环境变量</p></li><li><p>使用命令将 <code>Memory Profiler</code> 中导出来的 <code>hprof</code> 文件转换为 MAT 可以解析的 hprof 文件，命令如下</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hprof-conv ..&#x2F;原始文件.hprof ..&#x2F;输出文件.hprof</span><br></pre></td></tr></table></figure><ol start="5"><li>打开 MAT</li></ol><p><code>File &gt; open Heap dump</code> ，选择我们转换后的文件</p><h2 id="2-2-使用介绍"><a href="#2-2-使用介绍" class="headerlink" title="2.2 使用介绍"></a>2.2 使用介绍</h2><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://raw.githubusercontent.com/CalmCenter/picGo/master/pictures/20200414173426.png" style="zoom:60%"><ul><li><p><strong>Overview</strong>：概览信息</p><ul><li><strong>Unreachable Objects Histogram</strong>：可被回收的对象，但是仍在内存当中</li></ul></li><li><p><strong>Histogram</strong>：直方图，基于类来分析，会显示该类有多少个实例</p><p>第一行输入可以搜索，<code>Tool Bar</code> 中会多出一个 <code>Group by...</code>  选择 <code>package</code> 会变成已报名的形式来进行分类。</p><ul><li><strong>Object</strong>：有多少实例</li><li><strong>Shallow Heap</strong>：自己占了多少内存</li><li><strong>Retained Heap</strong>：应用链总共占了多少内存</li><li>选择一个类条目右键会出现 <code>List objects</code><ul><li><strong>with outgoing references</strong>：引用了些什么</li><li><strong>with incoming references</strong>：被谁引用着</li></ul></li></ul></li><li><p><strong>dominator_tree</strong>：基于实例来分析，会显示具体的实例是哪个</p><p>第一行输入可以搜索，<code>Tool Bar</code> 中会多出一个 <code>Group by...</code>  选择 <code>package</code> 会变成已报名的形式来进行分类。</p><ul><li><strong>Percentage</strong>：当前所有对象中，此对象内存占用百分比，可以发现那些内存占用过大的对象</li><li>右键点击会出现 <code>List objects</code> ，会显示出具体事例</li></ul></li><li><p><strong>OQL</strong>：对象查询语言</p><ul><li>例如 <code>slect * from com.package.Activity</code> ，会查询出该类所有的实例</li></ul></li><li><p><strong>thread_overview</strong>：<code>dump</code> 内存这个时刻的所有线程</p></li><li><p><strong>top_consumers</strong>：用图形列出占用内存比较大的实例</p><ul><li><strong>Biggest Objects</strong>：详细信息，点击出现 <code>List objects</code></li></ul></li><li><p><strong>Leak Suspects</strong>：更详细的分析，可以从这里找到可以的泄漏点</p><ul><li><strong>Probleam Suspect (x)</strong> ：点击 <code>Details</code> 会出现可疑的 引用链，找到泄漏点</li></ul></li></ul><hr><h1 id="3-什么是-LeakCanary？"><a href="#3-什么是-LeakCanary？" class="headerlink" title="3 什么是 LeakCanary？"></a>3 什么是 LeakCanary？</h1><p>如果使用 MAT 来分析内存问题，会有一些难度，而且效率也不是很高。</p><p>为了能迅速发现内存泄漏，Square 公司基于 MAT 开源了 <a href="https://square.github.io/leakcanary" target="_blank" rel="noopener">LeakCanary</a>。</p><p><code>LeakCanary</code> 是一个内存泄漏检测框架。</p><h2 id="3-1-LeakCanary-原理"><a href="#3-1-LeakCanary-原理" class="headerlink" title="3.1 LeakCanary 原理"></a>3.1 LeakCanary 原理</h2><ol><li><p><strong>检测保留的实例</strong></p><p><code>LeakCanary</code> 是基于 <code>LeakSentry</code> 开发的，<code>LeakSentry</code> 会 <code>hook Android</code> 生命周期，自动检测当 <code>Activity</code> 或 <code>Fragment</code> 被销毁时，它们的实例是否被回收了。</p><p>销毁的实例会传给 <code>RefWatcher</code>，<code>RefWatcher</code> 会持有它们的弱引用。</p><p>你也可以观察所有不再需要的实例，比如一个不再使用的 <code>View</code>，不再使用的 <code>Presenter</code> 等。</p><p>如果等待了 5 秒，并且 <code>GC</code> 触发了之后，弱引用还没有被清理，那么 <code>RefWatcher</code> 观察的实例就可能处于内存泄漏状态了。</p></li><li><p><strong>堆转储</strong></p><p>当保留对象的数量达到阈值时，<code>LeakCanary</code> 将 <code>Java</code> 堆转储到<code>.hprof</code> 存储在 <code>Android</code> 文件系统中的文件中。</p><p>当应用程序可见时，默认的阈值是5个被保留的对象，当应用程序不可见时，默认的阈值是 1 个被保留的对象。如果您看到保留的对象通知，然后将应用程序放在后台(例如通过按Home按钮)，那么阈值将从 5 更改为 1 ，<code>LeakCanary</code> 将在 5 秒内转储堆。点击通知将迫使<code>LeakCanary</code> 立即转储堆。</p></li><li><p><strong>分析堆</strong></p><p><code>LeakCanary</code>  <code>.hprof</code>使用 <a href="https://square.github.io/leakcanary/shark/" target="_blank" rel="noopener">Shark</a> 解析文件，并在该堆转储中找到保留的对象。</p><p>对于每个保留的对象，<code>LeakCanary</code> 会找到引用的路径，以防止对该保留的对象进行垃圾回收：其<strong>泄漏跟踪</strong>。泄漏跟踪是<em>从垃圾回收根到保留对象</em>的<em>最佳强引用路径的</em>另一个名称。</p></li><li><p><strong>泄漏分组</strong></p><p>当有两个泄漏分析结果相同时，<code>LeakCanary</code> <strong>为每个泄漏跟踪</strong>创建一个<strong>签名</strong>，并将具有相同签名的泄漏（即，由同一 <code>bug</code> 引起的泄漏）组合在一起，以免重复显示同样的泄漏信息。</p></li></ol><h2 id="3-2-LeakCanary-使用"><a href="#3-2-LeakCanary-使用" class="headerlink" title="3.2 LeakCanary 使用"></a>3.2 LeakCanary 使用</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  debugImplementation <span class="string">'com.squareup.leakcanary:leakcanary-android:2.2'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>2.2</code> 不需要初始化，如果你添加了</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">'android-aspectjx'</span></span><br></pre></td></tr></table></figure><p>需要在文章添加</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">aspectjx &#123; </span><br><span class="line">    exclude <span class="string">'com.squareup'</span> </span><br><span class="line">    exclude <span class="string">'leakcanary'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>否则会报 <code>Unable to get provider leakcanary.internal.LeakCanaryFileProvider: java.lang.ClassNotFoundException: Didn&#39;t find class &quot;leakcanary.internal.LeakCanaryFileProvider&quot;</code></p><h1 id="4-自定义实现-Demo"><a href="#4-自定义实现-Demo" class="headerlink" title="4 自定义实现 Demo"></a>4 自定义实现 Demo</h1><p><code>Profiler</code> 中使用了 <code>Allocation Tracker</code> 技术，<a href="https://mp.weixin.qq.com/s/b_lFfL1mDrNVKj_VAcA2ZA?" target="_blank" rel="noopener">Android内存申请分析</a> 这篇文章讲述了 <code>Allocation Tracker</code> 的使用方式，并且讲解了 <code>Android Studio</code> 是如何使用 <code>Allocation Tracker</code> 的。可以让我们更加熟悉 <code>Android Studio</code> 中 <code>Profiler</code> 各种工具的实现原理后。</p><p>文中提到了 <code>Allocation Tracker</code> 的三个缺点。</p><ul><li>获取的信息过于分散，中间夹杂着不少其他的信息，很多信息不是应用申请的，可能需要进行不少查找才能定位到具体的问题。</li><li>跟 <code>Traceview</code> 一样，无法做到自动化分析，每次都需要开发者手工开始 / 结束，这对于某些问题的分析可能会造成不便，而且对于批量分析来说也比较困难。</li><li>虽然在 <code>Allocation Tracking</code> 的时候，不会对手机本身的运行造成过多的性能影响，但是在停止的时候，直到把数据 <code>dump</code> 出来之前，经常会把手机完全卡死，如果时间过长甚至会直接 <code>ANR</code>。</li></ul><p>因此我们希望可以做到脱离 <code>Android Studio</code>，实现一个自定义的 <code>Allocation Tracker</code>，实现对象内存的自动化分析。通过这个工具可以获取所有对象的申请信息（大小、类型、堆栈等），可以找到一段时间内哪些对象占用了大量的内存。</p><p>我们可以用自定义的 <code>Allocation Tracker</code> 来监控 Java 内存的监控，也可以拓展成实时监控 <code>Java</code> 内存泄漏。不过任何一个工具如果只需要做到线下自动化测试，实现起来会相对简单，但想要移植到线上使用，那就要更加关注兼容性、稳定性和性能。</p><h2 id="4-1-自动化检测Demo"><a href="#4-1-自动化检测Demo" class="headerlink" title="4.1 自动化检测Demo"></a>4.1 自动化检测Demo</h2><p>这是一个自定义 <code>Allocation Tracker</code> 的 <code>Demo</code> <a href="https://github.com/AndroidAdvanceWithGeektime/Chapter03" target="_blank" rel="noopener">极客时间 Android 高手课 Chapter03</a></p><blockquote><p>项目使用了 inline hook 来拦截内存对象分配时候的 RecordAllocation 函数，通过拦截该接口可以快速获取到当时分配对象的类名和分配的内存大小。<br>在初始化的时候我们设置了一个分配对象数量的最大值，如果从 start 开始对象分配数量超过最大值就会触发内存 dump，然后清空 alloc 对象列表，重新计算。该功能和 Android Studio 里的 Allocation Tracker 类似，只不过可以在代码级别更细粒度的进行控制。可以精确到方法级别。</p></blockquote><ul><li><code>ndk_dlopen</code> 用来获取动态链接库</li><li><code>ndk_dlsym</code> 通过动态链接库和函数签名拿到函数地址</li><li><code>Substrate</code> <a href="http://www.cydiasubstrate.com/api/c/MSHookFunction/" target="_blank" rel="noopener">MSHookFunction</a>  一款经典的 <code>hook</code> 框架，支持 <code>hook C/C++</code> 代码 </li><li><a href="https://github.com/facebookincubator/profilo/tree/master/deps/fbjni" target="_blank" rel="noopener">fbjni</a> 是从 <code>Facebook</code> 开源的一款jni工具类库，主要提供了工具类，ref utils ，Global JniEnv。</li><li><code>native-lib</code> 中 <code>JNI_OnLoad</code>  在 <code>System.loadLibrary(&quot;xxx&quot;);</code> 时执行</li></ul><p>代码运行流程：</p><ol><li><p>在 <code>MainActivity</code> 中调用 <code>AllocTracker.initForArt</code> 去初始化，然后通过 <code>ndk_dlopen</code> 和<code>ndk_dlsym</code> 拿到所有需要的函数，只是拿到函数并没有调用</p></li><li><p><code>JNI_OnLoad</code> 调用 <code>hookFunc();</code>这个方法就是真正的把系统的 <code>tracking</code> 函数 <code>hook</code> 住的地方</p><ol><li>通过 <code>ndk_dlsym</code> 拿到函数地址。</li><li>通过 <code>MSHookFunction</code> 把 <code>newArtRecordAllocation26</code> <code>hook</code> 进原函数地址里，同时拿到旧函数的实现并导向 <code>oldArtRecordAllocation26</code> 。这样做可以保留旧函数。</li><li>在新函数中有一句 <code>allocObjectCount &gt; setAllocRecordMax</code> ，当分配对象数量大于初始化时设置的最大值，就把数据保存在 <code>log</code> 文件中。</li></ol></li></ol><p><code>C/C++</code> 的 <code>hook</code> 和 <code>java</code> 反射一样，如果系统在新版本把函数名，或者函数签名改了那就无法使用了，所以在文件中出现了很多版本适配的地方。</p><p><code>Logcat</code> 中 <code>saveARTAllocationData write file to XXXX</code> 能找到对应的日志文件路径</p><p>看不到日志的输出情况，每个人设备内存情况不一样，<code>GC</code> 回收的频率也不一致，在你不停生产对象的时候，<code>GC</code> 不断的跟随回收，导致无法达到设置的最大的数据量，所以一直没有日志的写入。</p><p><strong>总结：</strong></p><p>这个 <code>Demo</code>  主要学习了 <code>Substrate</code> <a href="https://github.com/facebookincubator/profilo/tree/master/deps/fbjni" target="_blank" rel="noopener">fbjni</a> <code>ndk_dlopen</code> 这几个库的简单使用，<code>CmakeList</code>  的很多写法，以及 <code>native</code> 函数简写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define JNI_METHOD_DECL(ret_type, method_name) \</span><br><span class="line">     extern &quot;C&quot; JNIEXPORT ret_type JNICALL Java_##com_dodola_alloctrack##_##AllocTracker##_##method_name</span><br></pre></td></tr></table></figure><p>还了解了一些 <code>hook</code> 点以及 <code>hook</code> 方法。</p><h2 id="4-2-重复图片检测Demo"><a href="#4-2-重复图片检测Demo" class="headerlink" title="4.2 重复图片检测Demo"></a>4.2 重复图片检测Demo</h2><p><a href="https://github.com/simplezhli/Chapter04" target="_blank" rel="noopener">极客时间 Android 高手课 Chapter04</a> 已完成的 <code>Demo</code> </p><blockquote><p>通过分析内存文件 hprof 快速判断内存中是否存在重复的图片，并且将这些重复图片的 PNG 、堆栈等信息输出。</p><p><strong>需要注意的是需要使用8.0以下的机器，因为8.0以后Bitmap中的buffer已经放到native内存中了</strong></p></blockquote><p>代码在开始加载了两张相同的图片。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Bitmap bitmap1 &#x3D; BitmapFactory.decodeResource(getResources(), R.mipmap.test); </span><br><span class="line">Bitmap bitmap2 &#x3D; BitmapFactory.decodeResource(getResources(), R.mipmap.test);</span><br><span class="line">imageView1.setImageBitmap(bitmap1); </span><br><span class="line">imageView2.setImageBitmap(bitmap2);</span><br></pre></td></tr></table></figure><p>然后手动 <code>GC</code> 生成 <code>hprof</code> 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 手动触发GC</span><br><span class="line">Runtime.getRuntime().gc();</span><br><span class="line">System.runFinalization();</span><br><span class="line">&#x2F;&#x2F; 生成Hprof文件</span><br><span class="line">Debug.dumpHprofData(file.getAbsolutePath());</span><br></pre></td></tr></table></figure><p>接下来在<code>DuplicatedBitmapAnalyzer</code> 的一个 <code>java</code> 项目里，利用 <a href="https://github.com/square/haha" target="_blank" rel="noopener">HAHA</a> 库进行文件分析，并输入重复图片。</p><p>作者已经将代码打成 <code>JAR</code> 包，可以直接调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar tools&#x2F;DuplicatedBitmapAnalyzer-1.0.jar hprof文件路径</span><br></pre></td></tr></table></figure><p>对于更多的信息，可以参看 <a href="https://github.com/square/leakcanary" target="_blank" rel="noopener">LeakCanary</a> 源码</p><p><strong>总结：</strong></p><p>这个 <code>Demo</code> 主要学到了如何主动生成 <code>hprof</code> 文件，以及如何用 <a href="https://github.com/square/haha" target="_blank" rel="noopener">HAHA</a> 这个库解析 <code>hprof</code> 文件。</p><p>联想：可以在特定场合去 <code>dump</code> 文件，比如内存大于最大内存 80%，因为 <code>hprof</code> 文件可能会很大，所以在用户 <code>wifi</code> 情况下回传。</p><p><a href="https://github.com/Tencent/matrix#matrix_android_cn" target="_blank" rel="noopener">Tencent/matrix</a> 这个框架拥有更丰富的检测方式。</p><hr><h1 id="5-优化思路"><a href="#5-优化思路" class="headerlink" title="5 优化思路"></a>5 优化思路</h1><h2 id="5-1-设备分级"><a href="#5-1-设备分级" class="headerlink" title="5.1 设备分级"></a>5.1 设备分级</h2><p>内存优化首先需要根据设备环境来综合考虑</p><ul><li><strong>设备分级</strong>。使用类似 <a href="http://github.com/facebook/device-year-class" target="_blank" rel="noopener">device-year-class</a> 的策略对设备分级，对于低端机用户可以关闭复杂的动画，或者是某些功能；使用 565 格式的图片，使用更小的缓存内存等。<ul><li><code>device-year-class</code> 会根据手机的内存、CPU 核心数和频率等信息决定设备属于哪一个年份，这个示例表示对于 2013 年之后的设备可以使用复杂的动画，对于 2010 年之前的低端设备则不添加任何动画。</li><li>565 格式图片：一张图片中每一个像素的大小取决于它的解码选项，而 Android 中能够选择的 Bitmap 解码选项有四种。<ul><li>ARGB_8888 ：ARGB 四个通道的值都是 8 位，加起来 32 位，也就是每个像素占 4 个字节</li><li>ARGB_4444： ARGB 四个通道的值都是 4 位，加起来 16 位，也就是每个像素占 2 个字节</li><li>RGB_565： RGB 三个通道分别是 5 位、6 位、5 位，加起来 16 位，也就是每个像素占 2 个字节</li><li>ALPHA_8：只有 A 通道，占 8 位，也就是每个像素占 1 个字节</li></ul></li></ul></li><li><strong>缓存管理</strong>。我们需要有一套统一的缓存管理机制，可以适当地使用内存；当“系统有难”时，也要义不容辞地归还。我们可以使用 <code>OnTrimMemory(本文 4.1.1 会讲到)</code> 回调，根据不同的状态决定释放多少内存。</li><li><strong>进程模型</strong>。一个空的进程也会占用 10MB 的内存，而有些应用启动就有十几个进程，甚至有些应用已经从双进程保活升级到四进程保活，所以减少应用启动的进程数、减少常驻进程、有节操的保活，对低端机内存优化非常重要。</li><li><strong>安装包大小</strong>。安装包中的代码、资源、图片以及 so 库的体积，跟它们占用的内存有很大的关系。一个 80MB 的应用很难在 512MB 内存的手机上流畅运行。这种情况我们需要考虑针对低端机用户推出 4MB 的轻量版本，例如 <code>Facebook Lite</code>、今日头条极速版都是这个思路。</li></ul><h2 id="5-2-Bitmap-优化"><a href="#5-2-Bitmap-优化" class="headerlink" title="5.2 Bitmap 优化"></a>5.2 Bitmap 优化</h2><p><code>Bitmap</code> 内存一般占应用总内存很大一部分，所以做内存优化永远无法避开图片内存这个“永恒主题”。</p><ol><li><p>统一图片库</p><p>图片内存优化的前提是收拢图片的调用，这样我们可以做整体的控制策略。就如设备分级中说的，低端设备策略等。</p></li><li><p>统一监控</p><ol><li><strong>大图片监控</strong>。我们需要注意某张图片内存占用是否过大，例如长宽远远大于 View 甚至是屏幕的长宽。在开发过程中，如果检测到不合规的图片使用，应该立即弹出对话框提示图片所在的 Activity 和堆栈，让开发同学更快发现并解决问题。<code>Glide</code> 可以有效的解决此类问题，因为 <code>Glide</code> 会根据 <code>ImageView</code> 的大小把图片大小调整成<code>ImageView</code> 的大小加载图片，并且 <code>Glide</code> 有三级缓存，在内存缓存中，<code>Glide</code> 会根据屏幕大小选择合适的大小作为图片内存缓存区的大小。</li><li><strong>重复图片监控</strong>。重复图片指的是 <code>Bitmap</code> 的像素数据完全一致，但是有多个不同的对象存在。这个监控不需要太多的样本量，一般只在内部使用。在检测模块中实现过一个内存 <code>Hprof</code> 的分析工具，它可以自动将重复 <code>Bitmap</code> 的图片和引用链输出。<ol><li><strong>图片总内存</strong>。通过收拢图片使用，我们还可以统计应用所有图片占用的内存，这样在线上就可以按不同的系统、屏幕分辨率等维度去分析图片内存的占用情况。在 <code>OOM</code> 崩溃的时候，也可以把图片占用的总内存、Top N 图片的内存都写到崩溃日志中，帮助我们排查问题。</li></ol></li></ol></li></ol><hr><h1 id="6-更多"><a href="#6-更多" class="headerlink" title="6 更多"></a>6 更多</h1><h2 id="6-1-监听系统内存状态"><a href="#6-1-监听系统内存状态" class="headerlink" title="6.1 监听系统内存状态"></a>6.1 监听系统内存状态</h2><p>Android 提供了两种方式让我们可以监听系统内存状态</p><h3 id="6-1-1-ComponentCallback2"><a href="#6-1-1-ComponentCallback2" class="headerlink" title="6.1.1 ComponentCallback2"></a>6.1.1 ComponentCallback2</h3><p>在 <code>Android 4.0</code> 后，<code>Android</code> 应用可以通过在 <code>Activity</code> 中实现 <code>ComponentCallback2</code> 接口获取系统内存的相关事件，这样就能在系统内存不足时提前知道这件事，提前做出释放内存的操作，避免我们自己的应用被系统干掉。</p><p><code>ComponentCallnback2</code> 提供了 <code>onTrimMemory(level)</code> 回调方法，在这个方法里我们可以针对不同的警告等级做出不同的释放内存操作。</p><p>原文是 <code>kotlin</code> 版，这里给出一个 <code>java</code> 版</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity2 extends AppCompatActivity implements ComponentCallbacks2 &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onTrimMemory(int level) &#123;</span><br><span class="line">        super.onTrimMemory(level);</span><br><span class="line">        switch (level) &#123;</span><br><span class="line">            case ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN:</span><br><span class="line">                &#x2F;&#x2F; 应用界面处于后台</span><br><span class="line">                &#x2F;&#x2F; 可以在这里释放 UI 对象</span><br><span class="line">                break;</span><br><span class="line">            case ComponentCallbacks2.TRIM_MEMORY_RUNNING_MODERATE:</span><br><span class="line">                &#x2F;&#x2F; 应用正常运行中，不会被杀掉，但是系统内存已经有点低了</span><br><span class="line">                break;</span><br><span class="line">            case ComponentCallbacks2.TRIM_MEMORY_RUNNING_LOW:</span><br><span class="line">                &#x2F;&#x2F; 应用正常运行中，不会被杀掉，但是系统内存已经非常低了，</span><br><span class="line">                &#x2F;&#x2F; 这时候应该释放一些不必要的资源以提升系统性能</span><br><span class="line">                break;</span><br><span class="line">            case ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL:</span><br><span class="line">                &#x2F;&#x2F; 应用正常运行，但是系统内存非常紧张，</span><br><span class="line">                &#x2F;&#x2F; 系统已经开始根据 LRU 缓存杀掉了大部分缓存的进程</span><br><span class="line">                &#x2F;&#x2F; 这时候我们要释放所有不必要的资源，不然系统可能会继续杀掉所有缓存中的进程</span><br><span class="line">                break;</span><br><span class="line">            case ComponentCallbacks2.TRIM_MEMORY_BACKGROUND:</span><br><span class="line">                &#x2F;&#x2F; 系统内存很低，系统准备开始根据 LRU 缓存清理进程，</span><br><span class="line">                &#x2F;&#x2F; 这时我们的程序在 LRU 缓存列表的最近位置，不太可能被清理掉，</span><br><span class="line">                &#x2F;&#x2F; 但是也要去释放一些比较容易恢复的资源，让系统内存变得充足</span><br><span class="line">                break;</span><br><span class="line">            case ComponentCallbacks2.TRIM_MEMORY_MODERATE:</span><br><span class="line">                &#x2F;&#x2F; 系统内存很低，并且我们的应用处于 LRU 列表的中间位置，</span><br><span class="line">                &#x2F;&#x2F; 这时候如果还不释放一些不必要资源，那么我们的应用可能会被系统干掉</span><br><span class="line">                break;</span><br><span class="line">            case ComponentCallbacks2.TRIM_MEMORY_COMPLETE:</span><br><span class="line">                &#x2F;&#x2F; 系统内存非常低，并且我们的应用处于 LRU 列表的最边缘位置，</span><br><span class="line">                &#x2F;&#x2F; 系统会有限考虑干掉我们的应用，如果想活下来，就要把所有能释放的资源都释放了</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                &#x2F;&#x2F; 应用从系统接收到一个无法识别的内存等级值，</span><br><span class="line">                &#x2F;&#x2F; 跟一般的低内存消息提醒一样对待这个事件</span><br><span class="line">                &#x2F;&#x2F; 释放所有不重要的数据结构。</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-1-2-ActivityManager-getMemoryInfo"><a href="#6-1-2-ActivityManager-getMemoryInfo" class="headerlink" title="6.1.2 ActivityManager.getMemoryInfo()"></a>6.1.2 ActivityManager.getMemoryInfo()</h3><p>Android 提供了一个 <code>ActivityManager.getMemoryInfo()</code> 方法给我们查询内存信息，这个方法会返回一个 <code>ActivityManager.MemoryInfo</code> 对象，这个对象包含了系统当前内存状态，这些状态信息包括可用内存、总内存以及低杀内存阈值。</p><p><code>MemoryInfo</code> 中包含了一个 <code>lowMemory</code> 布尔值，这个布尔值用于表明系统是否处于低内存状态。</p><p>原文是 <code>kotlin</code> 版，这里给出一个 <code>java</code> 版</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void doSomethingMemoryIntensive() &#123;</span><br><span class="line">        &#x2F;&#x2F; 在做一些需要很多内存的任务前，</span><br><span class="line">        &#x2F;&#x2F; 检查设备是否处于低内存状态、</span><br><span class="line">        if (!getAvailableMemory().lowMemory) &#123;</span><br><span class="line">            &#x2F;&#x2F; 做需要很多内存的任务</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private ActivityManager.MemoryInfo getAvailableMemory() &#123;</span><br><span class="line">        ActivityManager activityManager &#x3D; (ActivityManager) getSystemService(Context.ACTIVITY_SERVICE);</span><br><span class="line">        ActivityManager.MemoryInfo MemoryInfo &#x3D; new ActivityManager.MemoryInfo();</span><br><span class="line">        activityManager.getMemoryInfo(MemoryInfo);</span><br><span class="line">        return MemoryInfo;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="6-2-内存优化技巧"><a href="#6-2-内存优化技巧" class="headerlink" title="6.2 内存优化技巧"></a>6.2 内存优化技巧</h2><h3 id="6-2-1-谨慎使用-Service"><a href="#6-2-1-谨慎使用-Service" class="headerlink" title="6.2.1 谨慎使用 Service"></a>6.2.1 谨慎使用 Service</h3><p>让一个没用的 <code>Service</code> 在后台运行对于一个应用的内存管理来说是一件最糟糕的事情。</p><p>要在 <code>Service</code> 的任务完成后停止它，不然 <code>Service</code> 占用的这块内存会泄漏。</p><p>当你的应用中运行着一个 <code>Service</code>，除非系统内存不足，否则它不会被干掉。</p><p>这就导致对于系统来说 <code>Service</code> 的运行成本很高，因为 <code>Service</code> 占用的内存其他的进程是不能使用的。</p><p><code>Android</code> 有一个缓存进程列表，当可用内存减少时，这个列表也会随之缩小，这就会导致应用间的切换变得很慢。</p><p>如果我们是用 <code>Service</code> 监听一些系统广播，希望在特定情况下再启动事务，可以考虑使用 <code>JobScheduler</code>。</p><p>如果你真的要用 <code>Service</code>，可以考虑使用 <code>IntentService</code>，<code>IntentService</code> 是 <code>Service</code> 的一个子类，在它的内部有一个工作线程来处理耗时任务，当任务执行完后，<code>IntentService</code> 就会自动停止。</p><h3 id="6-2-2-选择优化后的数据容器"><a href="#6-2-2-选择优化后的数据容器" class="headerlink" title="6.2.2 选择优化后的数据容器"></a>6.2.2 选择优化后的数据容器</h3><p><code>Java</code> 提供的部分数据容器并不适合 <code>Android</code>，比如 <code>HashMap</code>，<code>HashMap</code> 需要中存储每一个键值对都需要一个额外的 <code>Entry</code> 对象。</p><p>Android 提供了几个优化后的数据容器，包括 <code>SparseArray</code>、<code>SparseBooleanArray</code> 以及 <code>LongSparseArray</code>。</p><p><code>SparseArray</code> 之所以更高效，是因为它的设计是只能使用整型作为 <code>key</code>，这样就避免了自动装箱的开销。</p><h3 id="6-2-3-小心代码抽象"><a href="#6-2-3-小心代码抽象" class="headerlink" title="6.2.3 小心代码抽象"></a>6.2.3 小心代码抽象</h3><p>抽象可以优化代码的灵活性和可维护性，但是抽象也会带来其他成本。</p><p>抽象会导致更多的代码需要被执行，也就是需要更多的时间和把更多的代码映射到内存中。</p><p>如果某段抽象代码带来的好处不大，比如一个地方可以直接实现而不需要用到接口的，那就不用接口。</p><h3 id="6-2-4-使用-protobuf-作为序列化数据"><a href="#6-2-4-使用-protobuf-作为序列化数据" class="headerlink" title="6.2.4 使用 protobuf 作为序列化数据"></a>6.2.4 使用 protobuf 作为序列化数据</h3><p><code>Protocol buffers</code> 是 <code>Google</code> 设计的，它可以对结构化的数据序列化，与<code>XML</code> 类似，不过比<code>XML</code> 更小，更快，而且更简单。</p><p>如果你决定使用 <code>protobuf</code> 作为序列化数据格式，那在客户端代码中应该使用轻量级的 <code>protobuf</code>。</p><p>因为一般的 <code>protobuf</code> 会生成冗长的代码，这样会导致内存增加、<code>APK</code> 大小增加，执行速度变慢等问题。</p><p>更多关于 <code>protobuf</code> 的信息可以查看 <a href="https://android.googlesource.com/platform/external/protobuf/+/master/java/README.md#installation-lite-version-with-maven" target="_blank" rel="noopener">protobuf readme</a> 中的 “轻量级版本”  。</p><h3 id="6-2-5-Apk-瘦身"><a href="#6-2-5-Apk-瘦身" class="headerlink" title="6.2.5 Apk 瘦身"></a>6.2.5 Apk 瘦身</h3><p>有些资源和第三方库会在我们不知情的情况下大量消耗内存。</p><p><code>Bitmap</code> 大小、资源、动画以及第三方库会影响到 <code>APK</code> 的大小，<code>Android Studio</code> 提供了 <code>R8</code> 和 <code>ProGuard</code> 帮助我们缩小 <code>Apk</code>，去掉不必要的资源。</p><p>如果你使用的 <code>Android Studio</code> 版本是 3.3 以下的，可以使用 <code>ProGuard</code>，3.3 及以上版本的可以使用 <code>R8</code>。</p><h3 id="6-2-6-使用-Dagger2-进行依赖注入"><a href="#6-2-6-使用-Dagger2-进行依赖注入" class="headerlink" title="6.2.6 使用 Dagger2 进行依赖注入"></a>6.2.6 使用 Dagger2 进行依赖注入</h3><p>依赖注入框架不仅可以简化我们的代码，而且能让我们在测试代码的时候更方便。</p><p>如果我们想在应用中使用依赖注入，可以考虑使用 <code>Dagger2</code>。</p><p><code>Dagger2</code> 是在编译期生成代码，而不是用反射实现的，这样就避免了反射带来的内存开销，而是在编译期生成代码，</p><h3 id="6-2-7-谨慎使用第三方库"><a href="#6-2-7-谨慎使用第三方库" class="headerlink" title="6.2.7 谨慎使用第三方库"></a>6.2.7 谨慎使用第三方库</h3><p>当你决定使用一个不是为移动平台设计的第三方库时，你需要对它进行优化，让它能更好地在移动设备上运行。</p><p>这些第三方库包括日志、分析、图片加载、缓存以及其他框架，都有可能带来性能问题。</p><h3 id="6-2-8-使用-IntDef-和-StringDef-替代枚举类型"><a href="#6-2-8-使用-IntDef-和-StringDef-替代枚举类型" class="headerlink" title="6.2.8 使用  IntDef 和 StringDef 替代枚举类型"></a>6.2.8 使用  IntDef 和 StringDef 替代枚举类型</h3><p>使用枚举类型的 <code>dex size</code> 是普通常量定义的 <code>dex size</code> 的 13 倍以上，同时，运行时的内存分配，一个 <code>enum</code> 值的声明会消耗至少 <code>20 bytes</code> 。</p><p>枚举最大的优点是类型安全，但在Android平台上，枚举的内存开销是直接定义常量的三倍以上。所以Android提供了注解的方式检查类型安全。目前提供了int型和String型两种注解方式：<code>IntDef</code> 和 <code>StringDef</code> ，用来提供编译期的类型检查。</p><p>使用 <code>IntDef</code>和 <code>StringDef</code> 需要在 <code>Gradle</code> 配置中引入相应的依赖包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile &#39;com.android.support:support-annotations:22.0.0&#39;</span><br></pre></td></tr></table></figure><hr><h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a><strong>感谢</strong></h1><blockquote><p><a href="https://time.geekbang.org/column/article/74044" target="_blank" rel="noopener">极客时间 Android开发高手课</a>  </p><p><a href="https://coding.imooc.com/learn/list/308.html" target="_blank" rel="noopener">慕课 Top团队大牛带你玩转Android性能分析与优化</a></p><p><a href="https://juejin.im/post/5d3ada056fb9a07eb94fd1bc#heading-3" target="_blank" rel="noopener">探索 Android 内存优化方法</a></p><p><a href="https://square.github.io/leakcanary" target="_blank" rel="noopener">LeakCanary</a></p><p><a href="https://developer.android.google.cn/studio/profile/memory-profiler" target="_blank" rel="noopener">AndroidDeveloper</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>App 内存知识介绍💦</title>
      <link href="/2020/memory-optimization.html"/>
      <url>/2020/memory-optimization.html</url>
      
        <content type="html"><![CDATA[<p>Android 性能优化第二篇， 内存优化是减少崩溃率工作中非常关键的一部分，由于Android有垃圾自动回收机制不需要手动干预，但也因此，经常出现内存问题如内存泄漏、内存泄漏引发 <code>GC</code> 频繁导致页面卡顿和内存溢出等问题，如果不了解内存是如何管理的以及如何优化，会难以排查问题。</p><p>这篇文章集结了很多文章精华部分(个人认为)，在这里整理分享出更多更完整内存知识，所以这篇文章会很长，目录我会分的很细，方便查找，文末会贴出参考文章。</p><p><strong>注意：如果出现图片不显示问题请移步</strong> <a href="https://calmcenter.club/2019/PicNotShow.html">图片不显示问题</a></p><h1 id="本文主要记载"><a href="#本文主要记载" class="headerlink" title="本文主要记载"></a>本文主要记载</h1><ul><li><strong>1 什么是内存？</strong></li><li><strong>2 JVM 如何分配内存？</strong><ul><li>2.1 所有线程共享的数据区域</li><li>2.2 线程私有的数据区域</li></ul></li><li><strong>3 JVM 如何管理内存？</strong><ul><li>3.1 引用计数算法</li><li>3.2 可达性算法</li><li>3.3 引用介绍</li><li>3.4 垃圾回收器<ul><li>3.4.1 标记-清除算法（Mark-Sweep）</li><li>3.4.2 复制算法（Copying）</li><li>3.4.3 标记-整理算法（Mark-Compact）</li><li>3.4.4 分代收集算法（Generational Collection）</li></ul></li></ul></li><li><strong>4 什么是 Dalvik?</strong><ul><li>4.1 Dalvik 与 JVM 的区别</li><li>4.2 Dalvik 堆大小</li></ul></li><li><strong>5 什么是 ART?</strong><ul><li>5.1 ART 与 Dalvik 的区别</li></ul></li><li><strong>6 内存引发的问题</strong><ul><li>6.1 内存泄漏<ul><li>6.1.1 常见的内存泄漏</li></ul></li><li>6.2 低杀</li><li>6.3 内存抖动</li></ul></li><li><strong>7 Android Bitmap 内存分配的变化</strong></li><li><strong>8 内存优化的两个误区</strong><ul><li>8.1 内存占用越少越好</li><li>8.2 Native 内存不用管</li></ul></li></ul><hr><h1 id="1-什么是内存？"><a href="#1-什么是内存？" class="headerlink" title="1 什么是内存？"></a>1 什么是内存？</h1><p>内存是计算机中重要的部件之一，是与 CPU 进行沟通的桥梁，是 CPU 能直接寻址的存储空间，由半导体器件制成。</p><blockquote><p>如果说数据是商品，那硬盘就是商店的仓库，内存就是商店的货架，仓库里的商品你是不能直接买的，你只能买货架上的商品。</p><p>每一个程序中使用的内存区域相当于是不同的货架，当一个货架上需要摆放的商品超过这个货架所能容纳的最大值，就会出现放不下的情况，也就是内存溢出。</p></blockquote><hr><h1 id="2-JVM-如何分配内存？"><a href="#2-JVM-如何分配内存？" class="headerlink" title="2 JVM 如何分配内存？"></a>2 JVM 如何分配内存？</h1><h2 id="2-1-所有线程共享的数据区域"><a href="#2-1-所有线程共享的数据区域" class="headerlink" title="2.1 所有线程共享的数据区域"></a>2.1 <strong>所有线程共享的数据区域</strong></h2><ul><li><strong>堆</strong>（Java Heap）<ul><li><code>Java</code> 堆是 <code>JVM</code> 管理的内存中最大的一块内存区域。</li><li>几乎所有的对象实例都是在堆中分配内存。</li><li>此区域也是垃圾回收器（<code>Garbage Collection</code>）主要的作用区域，内存泄漏就发生在这个区域。</li></ul></li><li><strong>方法区</strong>（Method Area）<ul><li>方法区存放的是 <strong>类信息、常量、静态变量</strong></li><li>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机会抛出内存溢出异常 <code>OutOfMemoryError</code>。</li></ul></li></ul><h2 id="2-2-线程私有的数据区域"><a href="#2-2-线程私有的数据区域" class="headerlink" title="2.2 线程私有的数据区域"></a>2.2 <strong>线程私有的数据区域</strong></h2><ul><li><p><strong>程序计数器</strong>（Program Counter Register）</p></li><li><p>一块较小的内存空间，可看做是当前线程所执行的字节码的行号指示器。</p></li><li><p>为了线程切换后能恢复到正确的执行位置，每条线程都有一个私有的程序计数器。</p><ul><li>如果线程在执行Java方法，这个计数器记录的是正在执行的虚拟机字节码指令地址；</li><li>如果执行的是Native方法，这个计数器的值为空（Undefined）。</li><li>程序计数器是唯一一个在 Java 虚拟机规范中没有规定任何 <code>OOM</code> 情况的区域。</li></ul></li><li><p><strong>本地方法栈</strong>（Native Method Stack）</p><ul><li>本地方法栈与虚拟机栈的区别是虚拟机栈为 <code>Java</code> 方法服务，而本地方法栈为 <code>Native</code> 方法服务。</li><li>与虚拟机栈一样，本地方法栈也会抛出 <code>StackOverflowError</code> 和 <code>OutOfMemoryError</code> 异常。</li></ul></li><li><p><strong>虚拟机栈</strong>（Virtual Machine Stack ）</p><ul><li>每个方法在执行的同时都会创建一个<strong>栈帧（Stack Frame）</strong>用于存储局部变量表、操作数栈、动态链接、方法出口等信息。</li><li>虚拟机栈生命周期与线程相同。</li><li>当执行 Java 方法时会进行压栈的操作，在栈中会保存局部变量、操作数栈和方法出口等信息。<code>JVM</code> 规定了栈的最大深度，如果线程请求执行方法时栈的深度大于规定的深度，就会抛出栈溢出异常 <code>StackOverflowError</code>。</li><li>如果虚拟机在扩展时无法申请到足够的内存，就会抛出内存溢出异常 <code>OutOfMemoryError</code>。</li></ul><div class="note default no-icon">            <p><strong>栈帧（Stack Frame）</strong></p><p>当 <code>Java</code> 程序出现异常时，程序会打印出对应的异常堆栈，通过这个堆栈我们可以知道方法的调用链路，而这个调用链路就是由一个个 Java 方法栈帧组成的。</p><ol><li><p><strong>局部变量表</strong>（Local Variable Table）：里面的变量只在当前函数调用中有效，当函数调用结束后，随着函数栈帧的销毁，局部变量表也会随之销毁。</p><p>局部变量表中存放的<strong>编译期</strong>可知的各种数据有：</p><ul><li><p>基本数据类型：如 boolean、char、int 等。</p></li><li><p>对象引用：reference 类型，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置。</p></li><li><p><code>returnAddress</code>类型：指向一条虚拟机指令的操作码。与前面介绍的那些数值类的原生类型不同，<code>returnAddress</code> 类型在 <code>Java</code> 语言之中并不存在相应的类型，也无法在程序运行期间更改 <code>returnAddress</code> 类型的值。</p></li></ul></li><li><p><strong>操作数栈</strong>（Operand Stack）：操作数栈（Operand Stack）也叫操作栈，它主要用于保存计算过程的中间结果，同时作为计算过程中临时变量的存储空间。</p></li><li><p><strong>动态连接</strong>（Dynamic Linking）：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接</p></li><li><p><strong>方法返回地址</strong>：当一个方法开始执行后，只有两种方式可以退出这个方法，一种是正常完成出口，另一种是异常完成出口。</p><ul><li>正常完成出口（Normal Method Invocation Completion）：执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者。是否有返回值和返回值的类型将根据遇到哪种方法返回指令来决定，这种退出方法的方式称为正常完成出口。</li><li>异常完成出口（Abrupt Method Invocation Completion）：在方法执行过程中遇到异常，并且这个异常没有在方法体内得到处理，就会导致方法退出，这种退出方式称为异常完成出口。一个方法使用异常完成出口的方式退出，任何值都不会返回给它的调用者。</li></ul><p>无论采用哪种退出方式，在方法退出后，都需要返回到方法被调用的位置，程序才能继续执行。</p></li></ol>          </div></li></ul><hr><h1 id="3-JVM-如何管理内存？"><a href="#3-JVM-如何管理内存？" class="headerlink" title="3 JVM 如何管理内存？"></a>3 JVM 如何管理内存？</h1><p>JVM 的管理主要有 <strong>引用计数算法</strong>、<strong>可达性算法</strong>、<strong>Java 引用</strong> 以及 <strong>垃圾回收器</strong> 知识点。</p><h2 id="3-1-引用计数算法"><a href="#3-1-引用计数算法" class="headerlink" title="3.1 引用计数算法"></a>3.1 引用计数算法</h2><p>给对象中添加一个引用计数器，每当有一个地方引用该对象时，计数器值加1；引用失效时，计数器值减1；任意时刻计数器为0的对象就是不可能再被使用的，表示该对象不存在引用关系。</p><p>优点：实现简单，判定效率也很高；<br>缺点：难以解决对象之间相互循环引用导致计数器值不等于0的问题。</p><h2 id="3-2-可达性算法"><a href="#3-2-可达性算法" class="headerlink" title="3.2 可达性算法"></a>3.2 可达性算法</h2><p>判定对象是否是存活的</p><p>这个算法的基本思路就是通过一系列 <code>GC Roots</code> 对象作为起始点，从这些节点开始向下搜索，搜索走过的路径就叫引用链。<br>当一个对象到 <code>GC Roots</code> 没有任何引用链相连时（<code>GC Roots</code> 到这个对象不可达），则证明此对象是不可用的。</p><p>比如下图中的 <code>object5、object6、object7</code>，虽然它们互有关联，但是它们到 <code>GC Roots</code> 是不可达的，所以它们会被判定为可回收对象。</p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://raw.githubusercontent.com/CalmCenter/picGo/master/pictures/20200330171812.png" style="zoom:90%"><p>那么那些点可以作为 <code>GC Roots</code> 呢？一般来说，如下情况的对象可以作为 <code>GC Roots</code> ：</p><ol><li><p>虚拟机栈</p><p>虚拟机栈的栈帧中的局部变量表中引用的对象，比如某个方法正在使用的类字段。</p></li><li><p>方法区</p><ul><li><p>类静态属性引用的对象</p></li><li><p>常量引用的对象</p></li></ul></li><li><p>本地方法栈</p><p>本地方法栈中 <code>Native</code> 方法引用的对象。</p></li></ol><h2 id="3-3-引用介绍"><a href="#3-3-引用介绍" class="headerlink" title="3.3 引用介绍"></a>3.3 引用介绍</h2><p>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判定对象是否存活都与引用有关。</p><p>在 <code>JDK 1.2</code> 之后，<code>Java</code> 对引用的概念进行了扩充，将引用分为<strong>强引用</strong>、<strong>软引用</strong>、<strong>弱引用</strong>和<strong>虚引用</strong>四种，这四种引用强度按顺序依次减弱。如果没有指定对象引用类型，默认是<strong>强引用</strong>。</p><ol><li><strong>强引用</strong>：<ul><li>强引用是指代码中普遍存在的，比如 <code>Object obj = new Object()</code> 这类引用。</li><li>强引用可以直接访问目标对象。</li><li>强引用指向的对象在任何时候都不会被系统回收，虚拟机即使抛出 <code>OOM</code> 异常，也不会回收强引用指向的对象。<br>使用 <code>obj = null</code> 不会触发 <code>GC</code>，但是在下次 <code>GC</code> 的时候这个强引用对象就可以被回收了。</li><li>强引用可能导致内存泄漏。</li></ul></li><li><strong>软引用</strong>：<ul><li>软引用用于描述一些还有用但非必需的对象。</li><li>对于软引用关联的对象，在系统即将发生内存溢出前，会把这些对象列入回收范围中进行二次回收。</li><li>如果二次回收后还没有足够的内存，就会抛出内存溢出异常。</li><li>在 <code>JDK 1.2</code> 后，<code>Java</code> 提供了 <code>SoftReference</code> 类来实现软引用。</li></ul></li><li><strong>弱引用</strong>：<ul><li>弱引用的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次 <code>GC</code> 前。</li><li>在 <code>GC</code> 时，只要发现弱引用，不管系统堆空间使用情况如何，都会将对象进行回收。</li><li>软引用、弱引用适合保存可有可无的缓存数据。</li><li><code>JDK 1.2</code> 后，提供了 <code>WeakReference</code> 类来实现弱引用。</li></ul></li><li><strong>虚引用</strong>：<ul><li>一个对象是否有虚引用的存在，都不会对其生存时间构成影响，也无法通过虚引用取得一个对象实例。</li><li>为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</li><li>在 <code>JDK 1.2</code> 后，提供了 <code>PhantomReference</code> 类来实现虚引用。</li></ul></li></ol><h2 id="3-4-垃圾回收器"><a href="#3-4-垃圾回收器" class="headerlink" title="3.4 垃圾回收器"></a>3.4 垃圾回收器</h2><p>垃圾回收器就是我们经常说到的 <code>GC（Garbage Collector）</code>，当我们操作不当导致某块内存泄漏时，<code>GC</code> 就不能对这块内存进行回收。</p><p>拿 <code>Android</code> 来说，进行 <code>GC</code> 时，所有线程都要暂停，包括主线程，<code>16ms</code> 是 <code>Android</code> 要求的每帧绘制时间，而当 <code>GC</code> 的时间超过 <code>16ms</code>，就会造成丢帧的情况，也就是界面卡顿。</p><p>垃圾回收器回收资源的方式就是垃圾回收算法</p><h3 id="3-4-1-标记-清除算法（Mark-Sweep）"><a href="#3-4-1-标记-清除算法（Mark-Sweep）" class="headerlink" title="3.4.1 标记-清除算法（Mark-Sweep）"></a>3.4.1 标记-清除算法（Mark-Sweep）</h3><p>最基础的收集算法：分为 <strong>标记</strong> 和 <strong>清除</strong> 两个阶段，首先，标记出所有需要回收的对象，然后统一回收所有被标记的对象。<br>这种方法有两个不足点：</p><ol><li>标记和清除的效率都不高</li><li>标记清除后会产生大量不连续的内存碎片，内存碎片太多会导致当程序需要分配较大的对象时，无法找到足够的连续内存而不得不提前触发 ·<code>GC</code></li></ol><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://raw.githubusercontent.com/CalmCenter/picGo/master/pictures/20200330181053.png" style="zoom:90%"><h3 id="3-4-2-复制算法（Copying）"><a href="#3-4-2-复制算法（Copying）" class="headerlink" title="3.4.2 复制算法（Copying）"></a>3.4.2 复制算法（Copying）</h3><p>为了解决 <strong>标记-清除算法</strong> 效率问题，<strong>复制收集算法</strong> 出现了。</p><p>将内存按容量划分为大小相等的两块，每次只使用其中的一块，当这一块内存将用完了，就将还存活着的对象复制到另一块内存上面，然后再把已使用过的内存空间一次清理掉。</p><ul><li>优点：实现简单，运行高效；每次都是对整个半区进行内存回收，内存分配时也不需要考虑内存碎片等情况，只要移动堆顶指针，按顺序分配内存即可；</li><li>缺点：粗暴的将内存一分为二，代价有点高。在对象存活率高时，要进行较多的复制操作，这时效率就变低了</li></ul><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://raw.githubusercontent.com/CalmCenter/picGo/master/pictures/20200330181822.png" style="zoom:60%"><h3 id="3-4-3-标记-整理算法（Mark-Compact）"><a href="#3-4-3-标记-整理算法（Mark-Compact）" class="headerlink" title="3.4.3 标记-整理算法（Mark-Compact）"></a>3.4.3 标记-整理算法（Mark-Compact）</h3><p><strong>标记-整理算法</strong> 的标记过程与 <strong>标记-清除算法</strong> 一样，但后续步骤是让所有存活的对象向一端移动，然后直接清理掉边界外的内存。</p><ul><li>避免了 <strong>标记-清除算法</strong> 内存碎片；</li><li>避免了 <strong>复制算法</strong> 50%的空间浪费；</li><li>主要针对对象存活率高的老年代。</li></ul><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://raw.githubusercontent.com/CalmCenter/picGo/master/pictures/20200403112950.png" style="zoom:60%"><h3 id="3-4-4-分代收集算法（Generational-Collection）"><a href="#3-4-4-分代收集算法（Generational-Collection）" class="headerlink" title="3.4.4 分代收集算法（Generational Collection）"></a>3.4.4 分代收集算法（Generational Collection）</h3><p>现代商业虚拟机的垃圾回收都采用 <strong>分代收集算法</strong> ，这种算法会根据对象存活周期的不同将内存划分为几块，这样就可以根据各个区域的特点采用最适当的收集算法。</p><p>堆内存可分为 <strong>新生区</strong> 、<strong>养老区</strong> 和 <strong>永久存</strong> 储区三个区域。</p><ul><li><p><strong>新生区（Young Generation Space）</strong></p><p>由 <strong>一个伊甸区（Eden space）</strong> 和 <strong>两个幸存者区（Survivor space）区</strong> 组成。<br>每次垃圾收集都有大批对象死去，只有少量存活，所以可以用复制算法。</p><ul><li><strong>伊甸区</strong></li></ul><p>大多数情况下，对象都是在伊甸区中分配的，当伊甸区没有足够的空间进行分配时，虚拟机将发起一次 <code>Minor GC</code>。<br><code>Minor GC</code> 是指发生在新生区的垃圾收集动作，<code>Minor GC</code> 非常频繁，回收速度也比较快。<br>当伊甸区的空间用完时，<code>GC</code> 会对伊甸区进行垃圾回收，然后把伊甸区剩下的对象移动到幸存 0 区。</p><ul><li><strong>幸存 0 区</strong></li></ul><p>如果幸存 0 区满了，<code>GC</code> 会对该区域进行垃圾回收，然后再把该区剩下的对象移动到幸存 1 区。</p><ul><li><strong>幸存 1 区</strong></li></ul><p>如果幸存 1 区满了，<code>GC</code> 会对该区域进行垃圾回收，然后把幸存 1 区中的对象移动到养老区。</p></li><li><p><strong>养老区（Tenure Generation Space）</strong></p></li></ul><p>对象存活率高、没有额外空间对它进行担保，就必须使用 <strong>标记-清理</strong> 或 <strong>标记-整理算法</strong> 进行回收。</p><p>用于保存从新生区筛选出来的 <code>Java</code> 对象。<br>当幸存 1 区移动尝试对象到养老区，但是发现空间不足时，虚拟机会发起一次 <code>Major GC</code>。<br><code>Major GC</code> 的速度一般比 <code>Minor GC</code> 慢 10 倍以上。<br>大对象会直接进入养老区，比如很大的数字和很长的字符串。</p><ul><li><strong>永久存储区（Permanent Space）</strong></li></ul><p>一个常驻内存区域，用于存放 <code>JDK</code> 自身携带的 <code>Class Interface</code> 元数据。<br>永久存储区存储的是运行环境必需的类信息，被装载进该区域的数据是不会被垃圾回收器回收掉的，只有 <code>JVM</code> 关闭时才会释放此区域的内存。</p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://raw.githubusercontent.com/CalmCenter/picGo/master/pictures/20200403114531.png" style="zoom:80%"><hr><h1 id="4-什么是-Dalvik"><a href="#4-什么是-Dalvik" class="headerlink" title="4 什么是 Dalvik?"></a>4 什么是 Dalvik?</h1><p><code>Dalvik</code> 是 <code>Dalvik Virtual Machine</code>（<code>Dalvik</code> 虚拟机）的简称，是 <code>Android</code> 平台的核心组成部分之一。<code>Android 4.4</code> 之前都是使用 <code>Dalvik</code>。</p><p>在 <code>Androd</code> 中，每一个应用都运行在一个 <code>Dalvik VM</code> 实例中，每一个 <code>Dalvik VM</code> 都运行在一个独立的进程空间，这种机制使得 <code>Dalvik</code> 运行在有限的内存中同时运行多个进程。</p><h2 id="4-1-Dalvik-与-JVM-的区别"><a href="#4-1-Dalvik-与-JVM-的区别" class="headerlink" title="4.1 Dalvik 与 JVM 的区别"></a>4.1 Dalvik 与 JVM 的区别</h2><p><code>Dalvik</code> 不是 <code>Java</code> 虚拟机，它并不是按照 Java 虚拟机规范实现的，两者之间并不兼容。</p><ol><li><p>架构</p><ul><li><p><code>JVM</code> 是基于栈的，需要在栈中读取数据，所需的指令会更多，这样会导致速度慢，不适合性能优先的移动设备。</p></li><li><p><code>Dalvik</code> 是基于寄存器的，指令更紧凑和简洁。</p></li></ul><p>由于显式指定了操作数，所以基于寄存器的指令会比基于栈的指令要大，但是由于指令数的减少，总的代码数不会增加多少。</p></li><li><p>执行代码不同</p><ul><li><p>在 <code>Java SE</code> 程序中，<code>Java</code> 类会被编译成一个或多个 <code>.class</code> 文件，然后打包成 <code>jar</code> 文件，<code>JVM</code> 会通过对应的 <code>.class</code> 文件和 <code>jar</code> 文件获取对应的字节码。</p></li><li><p>而 <code>Dalvik</code> 会用 <code>dx</code> 工具将所有的 .class 文件转换为一个 <code>.dex</code> 文件，然后会从该 <code>.dex</code> 文件读取指令和数据。</p></li></ul></li><li><p>共享机制</p><ul><li><p><code>Dalvik</code> 拥有预加载—共享机制，不同应用之间在运行时可以共享相同的类，拥有更高的效率。</p></li><li><p>而 <code>JVM</code> 不存在这种共享机制，不同的程序，打包后的程序都是彼此独立的，即使包中使用了同样的类，运行时也是单独加载和运行的，无法进行共享。</p></li></ul></li></ol><h2 id="4-2-Dalvik-堆大小"><a href="#4-2-Dalvik-堆大小" class="headerlink" title="4.2 Dalvik 堆大小"></a>4.2 Dalvik 堆大小</h2><p>每一个手机厂商都可以设定设备中每一个进程能够使用的堆大小，有关进程堆大小的值有下面三个。</p><p>如果我们想看堆内存大小应该怎么办呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell getprop dalvik.vm.heapsize</span><br></pre></td></tr></table></figure><ul><li><p>dalvik.vm.heapstartsize</p><p>堆分配的初始值大小，这个值越小，系统内存消耗越慢，但是当应用扩展这个堆，导致 <code>GC</code> 和堆调整时，应用会变慢。</p><p>这个值越大，应用越流畅，但是可运行的应用也会相对减少。</p></li><li><p>dalvik.vm.heapgrowthlimit</p><p>如果在清单文件中声明 <code>largeHeap</code> 为 <code>true</code>，则 <code>App</code> 使用的内存到 <code>heapsize</code> 才会 <code>OOM</code>，否则达到 <code>heapgrowthlimit</code> 就会 <code>OOM</code>。</p></li><li><p>dalvik.vm.heapsize</p><p>进程可用的堆内存最大值，一旦应用申请的内存超过这个值，就会 <code>OOM</code>。</p></li></ul><hr><h1 id="5-什么是-ART"><a href="#5-什么是-ART" class="headerlink" title="5 什么是 ART?"></a>5 什么是 ART?</h1><p><code>ART</code> 的全称是 <code>Android Runtime</code>，是从 <code>Android 4.4</code> 开始新增的 <strong>应用运行时环境</strong>，用于替代 <code>Dalvik</code> 虚拟机。</p><p><code>Dalvik VM</code> 和 <code>ART</code> 都可以支持已转换为 <code>.dex（Dalvik Executable）</code>格式的 <code>Java</code> 应用程序的运行。</p><p><code>Dalvik</code> 是为 32 位 <code>CPU</code> 设计的，而 <code>ART</code> 支持 64 位并兼容 32 位 <code>CPU</code>，这也是 <code>Dalvik</code> 被淘汰的主要原因。</p><h2 id="5-1-ART-与-Dalvik-的区别"><a href="#5-1-ART-与-Dalvik-的区别" class="headerlink" title="5.1 ART 与 Dalvik 的区别"></a>5.1 ART 与 Dalvik 的区别</h2><ol><li><p>预编译</p><ul><li><p><code>Dalvik</code> 中的应用每次运行时，字节码都需要通过即时编译器 JIT 转换为机器码，这会使得应用的运行效率降低。</p></li><li><p>在 <code>ART</code> 中，系统在安装应用时会进行一次预编译，将字节码预先编译成机器码并存储在本地，这样应用就不用在每次运行时执行编译了，运行效率也大大提高。</p></li></ul></li><li><p>GC</p><ul><li><p>在 <code>Dalvik</code> 采用的垃圾回收算法是标记-清除算法，启动垃圾回收机制会造成两次暂停（一次在遍历阶段，另一次在标记阶段）。</p></li><li><p>而在 <code>ART</code> 下，<code>GC</code> 速度比 <code>Dalvik</code> 要快，这是因为应用本身做了垃圾回收的一些工作，启动 <code>GC</code> 后，不再是两次暂停，而是一次暂停。</p><p>而且 <code>ART</code> 使用了一种新技术（<code>packard pre-cleaning</code>），在暂停前做了许多事情，减轻了暂停时的工作量。</p></li></ul></li></ol><hr><h1 id="6-内存引发的问题"><a href="#6-内存引发的问题" class="headerlink" title="6 内存引发的问题"></a>6 内存引发的问题</h1><ol><li>内存造成的第一个问题是<strong>异常</strong>。异常包括 <code>OOM</code>、内存分配失败这些崩溃，也包括因为整体内存不足导致应用被杀死、设备重启等问题。</li><li>内存造成的第二个问题是卡顿。<strong>内存泄漏</strong> 导致 <code>Java</code> 内存不足会频繁 <code>GC</code>，常见现象是 <strong>内存抖动</strong>，这个问题在 <code>Dalvik</code> 虚拟机会更加明显。而 ART 虚拟机在内存管理跟回收策略上都做大量优化</li><li>除了频繁 <code>GC</code> 造成卡顿之外，物理内存不足时系统会触发 <strong>low memory killer</strong> 机制，系统负载过高是造成卡顿的另外一个原因。</li></ol><h2 id="6-1-内存泄漏"><a href="#6-1-内存泄漏" class="headerlink" title="6.1 内存泄漏"></a>6.1 内存泄漏</h2><p>内存泄漏指的是，当一块内存没有被使用，但无法被 GC 时的情况。</p><p>内存泄漏的表现就是可用内存逐渐减少，无法被回收的内存逐渐累积，直到无更多可用内存可申请时，就会导致 <code>OOM</code>。</p><h3 id="6-1-1-常见的内存泄漏"><a href="#6-1-1-常见的内存泄漏" class="headerlink" title="6.1.1 常见的内存泄漏"></a>6.1.1 常见的内存泄漏</h3><ol><li><p><strong>非静态内部类</strong></p><ul><li><p><strong>泄漏场景</strong> </p><p>非静态内部类会持有外部类的实例，比如匿名内部类。</p><p>匿名内部类指的是一个对象名称的类，但是在字节码中，它还是会有构造函数的，而它的构造函数中会包含外部类的实例。</p><p>比如在 <code>Activity</code> 中以匿名内部类的方式声明 <code>Handler</code> 或 <code>AsyncTask</code>，当 <code>Activity</code> 关闭时，由于 <code>Handler</code> 持有 <code>Activity</code> 的强引用，导致 <code>GC</code> 无法对 <code>Activity</code> 进行回收。</p><p>当我们通过 <code>Handler</code> 发送消息时，消息会加入到 <code>MessageQueue</code> 队列中交给 <code>Looper</code> 处理，当有消息还没发送完毕时，<code>Looper</code> 会一直运行，在这个过程中会一直持有 <code>Handler</code>，而 <code>Handler</code> 又持有外部类 <code>Activity</code> 的实例，这就导致了 Activity 无法被释放。</p></li><li><p><strong>解决</strong></p><p>把 <code>Handler</code> 或 <code>AsyncTask</code> 声明为静态内部类，并且使用 <code>WeakReference</code> 包住 <code>Activity</code>，这样 <code>Handler</code> 拿到的就是一个 <code>Activity</code> 的弱引用，<code>GC</code> 就可以回收 <code>Activity</code>。这种方式适用于所有匿名内部类导致的内存泄漏问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static class MyHandler extends Handler &#123;</span><br><span class="line">    Activity activity;</span><br><span class="line">    public MyHandler(Activity activity) &#123;</span><br><span class="line">        activity &#x3D; new WeakReference&lt;&gt;(activity).get();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    @Override</span><br><span class="line">    public void handleMessage(Message message) &#123;</span><br><span class="line">       &#x2F;&#x2F; ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>静态变量</strong></p><ul><li><p><strong>泄漏场景</strong></p><p>静态变量导致内存泄漏的原因是因为 <strong>长生命周期对象</strong> 持有了 <strong>短生命周期对象</strong> 的引用，导致短生命周期对象无法被释放。</p><p>比如一个单例持有了 <code>Activity</code> 的引用，而 <code>Activity</code> 的生命周期可能很短，用户一打开就关闭了，但是单例的生命周期往往是与应用的生命周期相同的。</p></li><li><p><strong>解决</strong></p><p>如果单例需要 <code>Context</code>， 可以考虑使用 <code>ApplicationContext</code>，这样单例持有的 <code>Context</code> 引用就是与应用的生命周期相同的了。</p></li></ul></li><li><p><strong>资源未释放</strong></p><ul><li><p><strong>泄漏场景</strong></p><p>忘了注销 <code>BroadcastReceiver</code></p><p>打开了数据库游标（<code>Cursor</code>）忘了关闭</p><p>打开流忘了关闭</p><p>创建了 <code>Bitmap</code> 但是调用 <code>recycle</code> 方法回收 <code>Bitmap</code> 使用的内存</p><p>使用 <code>RxJava</code> 忘了在 <code>Activity</code> 退出时取消任务</p><p>使用协程忘了在 <code>Activity</code> 退出时取消任务</p></li></ul></li><li><p><strong>Webview</strong></p><ul><li><p><strong>泄漏场景</strong></p><p>不同的 <code>Android</code> 版本的 <code>Webview</code> 会有差异，加上不同厂商定制 <code>ROM</code> 的 <code>Webview</code> 的差异，导致 <code>Webview</code> 存在很大的兼容问题。</p><p>一般情况下，在应用中只要使用一次 <code>Webview</code>，它占用的内存就不会被释放。</p></li><li><p><strong>解决</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onDestroy() &#123;</span><br><span class="line">    if( mWebView!&#x3D;null) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果先调用destroy()方法，则会命中if (isDestroyed()) return;这一行代码，需要先onDetachedFromWindow()，再</span><br><span class="line">        &#x2F;&#x2F; destory()</span><br><span class="line">        ViewParent parent &#x3D; mWebView.getParent();</span><br><span class="line">        if (parent !&#x3D; null) &#123;</span><br><span class="line">            ((ViewGroup) parent).removeView(mWebView);</span><br><span class="line">        &#125;</span><br><span class="line">        mWebView.stopLoading();</span><br><span class="line">        &#x2F;&#x2F; 退出时调用此方法，移除绑定的服务，否则某些特定系统会报错</span><br><span class="line">        mWebView.getSettings().setJavaScriptEnabled(false);</span><br><span class="line">        mWebView.clearHistory();</span><br><span class="line">        mWebView.clearView();</span><br><span class="line">        mWebView.removeAllViews();</span><br><span class="line">        mWebView.destroy();</span><br><span class="line">    &#125;</span><br><span class="line">    super.on Destroy();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="6-2-低杀"><a href="#6-2-低杀" class="headerlink" title="6.2 低杀"></a>6.2 低杀</h2><p>在内存不足时，这种机制就会针对于所有进程进行回收(优先级由高到低，优先回收低优先级)</p><p>进程优先级：</p><ol><li><p><strong>前台进程</strong>：优先级最高的进程，是正在于用户交互的进程</p><ul><li>进程持有一个与用户交互的 Activity（该 Activity 的 onResume 方法被调用）</li><li>进程持有一个 Service，<code>[Service 与用户正在交互的 Activity 绑定]</code>  <code>[Service 调用了 startForeground() 方法(前台服务)]</code>  <code>[Service 正在执行以下生命周期函数（onCreate、onStart、onDestroy ）]</code></li><li>进程持有一个 <code>BroadcastReceiver</code>，这个 <code>BroadcastReceiver</code> 正在执行它的 <code>onReceive()</code> 方法</li></ul></li><li><p><strong>可见进程</strong>：不含有任何前台组件，但用户还能再屏幕上看见它</p><ul><li>进程持有一个 <code>Activity</code>，这个 <code>Activity</code> 处于 <code>pause</code> 状态</li><li>进程持有一个 <code>Service</code> 这个 <code>Service</code> 和一个可见的 <code>Activity</code> 绑定。</li><li>可见进程是非常重要的进程，除非前台进程已经把系统的可用内存耗光，否则系统不会终止可见进程。</li></ul></li><li><p><strong>服务进程</strong>：可能在播放音乐或在后台下载文件，除非系统内存不足，否则系统会尽量维持服务进程的运行。</p><ul><li>如果一个进程中运行着一个 <code>Service</code>，并且这个 <code>service</code> 是通过 <code>startService</code> 开启的，那这个进程就是一个服务进程。</li></ul></li><li><p><strong>后台进程</strong></p><p>系统会把后台进程（<code>Background Process</code>）保存在一个 <code>LruCache</code> 列表中，因为终止后台进程对用户体验影响不大，所以系统会酌情清理部分后台进程。</p><p>你可以在 <code>Activity</code> 的 <code>onSaveInstanceState()</code> 方法中保存一些数据，以免在应用在后台被系统清理掉后，用户已输入的信息被清空，导致要重新输入。</p><ul><li>当进程持有一个用户不可见的 <code>Activity</code>（<code>Activity</code> 的 <code>onStop()</code> 方法被调用），但是 <code>onDestroy</code> 方法没有被调用，这个进程就会被系统认定为后台进程。</li></ul></li><li><p><strong>空进程</strong>：当一个进程不包含任何活跃的应用组件，则被系统认定为是空进程。</p><p>系统保留空进程的目的是为了加快下次启动进程的速度。</p></li></ol><h2 id="6-3-内存抖动"><a href="#6-3-内存抖动" class="headerlink" title="6.3 内存抖动"></a>6.3 内存抖动</h2><p>当我们在短时间内频繁创建大量临时对象时，就会引起内存抖动，比如在一个 <code>for</code> 循环中创建临时对象实例。</p><p>内存检测表现如下</p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://raw.githubusercontent.com/CalmCenter/picGo/master/pictures/20200412160136.png" style="zoom:80%"><p><strong>预防的方法</strong></p><ol><li>尽量避免在循环体中创建对象</li><li>尽量不要在自定义 <code>View</code> 的 <code>onDraw()</code> 方法中创建对象，因为这个方法会被频繁调用</li><li>对于能够复用的对象，可以考虑使用对象池把它们缓存起来</li></ol><hr><h1 id="7-Android-Bitmap-内存分配的变化"><a href="#7-Android-Bitmap-内存分配的变化" class="headerlink" title="7 Android Bitmap 内存分配的变化"></a>7 <strong>Android Bitmap 内存分配的变化</strong></h1><ul><li>在 <code>Android 3.0</code> 之前，<code>Bitmap</code> 对象放在 <code>Java</code> 堆，而像素数据是放在 <code>Native</code> 内存中。如果不手动调用 <code>recycle</code>，<code>Bitmap Native</code> 内存的回收完全依赖 <code>finalize</code> 函数回调，这个时机不太可控。</li><li><code>Android 3.0～Android 7.0</code> 将 <code>Bitmap</code> 对象和像素数据统一放到 <code>Java</code> 堆中，这样就算我们不调用 <code>recycle</code>，<code>Bitmap</code> 内存也会随着对象一起被回收。不过 <code>Bitmap</code> 是内存消耗的大户，把它的内存放到 <code>Java</code> 堆中似乎不是那么美妙。即使是华为 <code>Mate 20</code>，最大的 <code>Java</code> 堆限制也才到 512MB，可能我的物理内存还有 5GB，但是应用还是会因为<code>Java</code> 堆内存不足导致 <code>OOM</code>。<code>Bitmap</code> 放到 <code>Java</code> 堆的另外一个问题会引起大量的 <code>GC</code>，对系统内存也没有完全利用起来。</li><li>有没有一种实现，可以将 <code>Bitmap</code> 内存放到 <code>Nativ</code>e 中，也可以做到和对象一起快速释放，同时 <code>GC</code> 的时候也能考虑这些内存防止被滥用？<code>NativeAllocationRegistry</code> 可以一次满足你这三个要求，<code>Android 8.0</code> 正是使用这个辅助回收 <code>Native</code> 内存的机制，来实现像素数据放到 <code>Native</code> 内存中。<code>Android 8.0</code> 还新增了硬件位图 <code>Hardware Bitmap</code>，它可以减少图片内存并提升绘制效率。</li></ul><hr><h1 id="8-内存优化的两个误区"><a href="#8-内存优化的两个误区" class="headerlink" title="8 内存优化的两个误区"></a>8 内存优化的两个误区</h1><h2 id="8-1-内存占用越少越好。"><a href="#8-1-内存占用越少越好。" class="headerlink" title="8.1 内存占用越少越好。"></a>8.1 内存占用越少越好。</h2><ol><li>有些人认为内存是洪水猛兽，占用越少应用的性能越好，这种认识在具体的优化过程中很容易“用力过猛”。</li><li>应用是否占用了过多的内存，跟设备、系统和当时情况有关，而不是 <code>300MB</code>、<code>400MB</code> 这样一个绝对的数值。当系统内存充足的时候，我们可以多用一些获得更好的性能。当系统内存不足的时候，希望可以做到“用时分配，及时释放”</li></ol><h2 id="8-2-Native-内存不用管"><a href="#8-2-Native-内存不用管" class="headerlink" title="8.2 Native 内存不用管"></a>8.2 <code>Native</code> 内存不用管</h2><ol><li>虽然 <code>Android 8.0</code> 重新将 <code>Bitmap</code> 内存放回到 <code>Native</code> 中，那么我们是不是就可以随心所欲地使用图片呢？</li><li>答案当然是否定的。正如前面所说当系统物理内存不足时，<code>lmk</code> 开始杀进程，从后台、桌面、服务、前台，直到手机重启。</li></ol><hr><h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a><strong>感谢</strong></h1><blockquote><p><a href="https://time.geekbang.org/column/article/74044" target="_blank" rel="noopener">极客时间 Android开发高手课</a>  </p><p><a href="https://coding.imooc.com/learn/list/308.html" target="_blank" rel="noopener">慕课 Top团队大牛带你玩转Android性能分析与优化</a></p><p><a href="https://juejin.im/post/5d3ada056fb9a07eb94fd1bc#heading-3" target="_blank" rel="noopener">探索 Android 内存优化方法</a></p><p><a href="https://juejin.im/post/5d3a870df265da1b855c9d41#heading-15" target="_blank" rel="noopener">探索 Java 内存管理机制</a></p><p><a href="https://juejin.im/post/58b18e442f301e0068028a90" target="_blank" rel="noopener">Android性能优化（三）之内存管理</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生财有术日历</title>
      <link href="/2020/sheng-cai-you-zhu-ri-li.html"/>
      <url>/2020/sheng-cai-you-zhu-ri-li.html</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>日期</th><th align="left">内容</th><th>完整原文链接<br/>(有可能需要付费加入才能观看)</th></tr></thead><tbody><tr><td>1.1</td><td align="left">有钱赚的时候，要集中所有的资源和精力，All in，不要小富即安。<br/>过几年你会拍大腿，那么好的捡钱的机会，为什么错过了。<br/>居安思危才能活得足够长久，富一次的人很多，富一辈子的人很少。</td><td><a href="https://t.zsxq.com/3rrRbMR" target="_blank" rel="noopener">https://t.zsxq.com/3rrRbMR</a></td></tr><tr><td>1.2</td><td align="left">引流也好、裂变也罢，核心仍然是提供价值。<br/>总会有认同价值的，也总会有怀疑价值的，我们不能因为50%的怀疑价值的人，而放弃为剩下的50%的人提供价值的机会。<br/>引流、裂变、发售、势能都是术而已，掌握术容易，术也能带来更快的收益，但不变的是道：核心价值。</td><td><a href="https://t.zsxq.com/2zNrNNr" target="_blank" rel="noopener">https://t.zsxq.com/2zNrNNr</a></td></tr><tr><td>1.3</td><td align="left">我现在创业，期待越轻越好，越产品化越好，最好把内容环节都省掉才觉得好，把增长模块都做到产品中去，只要第一波倒入流量，后面就可以自发增长和变现了。</td><td><a href="https://t.zsxq.com/rVzvzVb" target="_blank" rel="noopener">https://t.zsxq.com/rVzvzVb</a></td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>App 初体验-启动优化💦</title>
      <link href="/2019/start-optimization.html"/>
      <url>/2019/start-optimization.html</url>
      
        <content type="html"><![CDATA[<p>Android 性能第一篇，随着项目功能的迭（zeng）代（jia），启动速度也会受到影响，性能优化之路的第一步，也就是启动优化，个人认为非常重要，它可以直接影响 <code>APP</code> 的留存率，没有人希望自己应用半天打不开。这篇文章就带你解决🌞用户初体验-启动优化🌞。</p><p><strong>注意：如果出现图片不显示问题请移步</strong> <a href="https://calmcenter.club/2019/PicNotShow.html">图片不显示问题</a></p><h1 id="本文主要记载"><a href="#本文主要记载" class="headerlink" title="本文主要记载"></a>本文主要记载</h1><ul><li><strong>1 启动</strong></li><li><strong>2 检测启动消耗<code>(敲黑板)</code></strong><ul><li>2.1 启动时间测量方式<ul><li>2.1.1 adb 命令启动时间测量方式</li><li>2.1.2 手动打点</li></ul></li><li>2.2 启动耗时检测方式<ul><li>2.2.1 TraceView</li><li>2.2.2 systrace</li><li>2.2.3 systrace + 函数插桩 AOP</li></ul></li></ul></li><li><strong>3 启动优化<code>(干货)</code></strong><ul><li>3.1 闪屏页展示</li><li>3.2 异步启动实践</li><li>3.3 数据重排</li><li>3.4 类的加载</li><li>3.5 延迟加载方案 IdleHandler</li><li>3.6 其他优化思路</li></ul></li><li><strong>4 启动监控</strong></li></ul><hr><h1 id="1-启动"><a href="#1-启动" class="headerlink" title="1 启动"></a>1 启动</h1><p>Google官方文档 <a href="https://developer.android.com/topic/performance/launch-time.html" target="_blank" rel="noopener">《Launch-Time Performance》</a> 对应用启动优化的概述</p><p>应用的启动分为冷启动、热启动、温启动，而启动最慢、挑战最大的就是冷启动：系统和App本身都有更多的工作要从头开始！我们只要知道我们处理的是冷启动的情况。</p><hr><h1 id="2-检测启动消耗-敲黑板"><a href="#2-检测启动消耗-敲黑板" class="headerlink" title="2 检测启动消耗(敲黑板)"></a>2 检测启动消耗<code>(敲黑板)</code></h1><p>“工欲善其事必先利其器”，我们需要先找到一款适合做启动优化分析的工具。</p><h2 id="2-1-启动时间测量方式"><a href="#2-1-启动时间测量方式" class="headerlink" title="2.1 启动时间测量方式"></a>2.1 启动时间测量方式</h2><h3 id="2-1-1-adb-命令启动时间测量方式"><a href="#2-1-1-adb-命令启动时间测量方式" class="headerlink" title="2.1.1 adb 命令启动时间测量方式"></a>2.1.1 adb 命令启动时间测量方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am start -W packagename&#x2F;packagename.Activity</span><br></pre></td></tr></table></figure><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://raw.githubusercontent.com/CalmCenter/picGo/master/pictures/20190829115742.png" alt=""></p><p>划掉的红色部分都是包名</p><table><thead><tr><th>字段</th><th>功能</th></tr></thead><tbody><tr><td>ThisTime</td><td>最后一个 Activity 启动耗时</td></tr><tr><td>TotalTIme</td><td>所有 Activity 启动耗时，比如添加启动页</td></tr><tr><td>WaitTime</td><td>AMS 启动 Activity 的总耗时</td></tr><tr><td>ThisTime ≤ TotalToime &lt; WaitTime</td><td></td></tr></tbody></table><p>线下方便使用、可以测量竞品、不能带到线上</p><h3 id="2-1-2-手动打点"><a href="#2-1-2-手动打点" class="headerlink" title="2.1.2 手动打点"></a>2.1.2 手动打点</h3><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LaunchTimer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> sTime;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startRecord</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sTime = System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">endRecord</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        endRecord(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">endRecord</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> cost = System.currentTimeMillis() - sTime;</span><br><span class="line">        LogUtils.e(<span class="string">"LaunchTimer"</span>, msg + <span class="string">" cost "</span> + cost);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在应用启动中，我们所能接收到最早的回调是 <code>Application</code> 中 <code>attachBaseContext(Context context)</code> ，所以只能将 <code>startRecord()</code> 写到这个回调中</p><p>应用启动的结束时间，是用户可操作的时间，先了解两个误区</p><p><code>onAttachedToWindow()</code> 这个方法是在 <code>onResume</code> 之后，只调用一次</p><p><code>onWindowFocusChanged(boolean hasFocus)</code> 这个方法是在获取焦点和失去焦点是调用，在 <code>onAttachedToWindow()</code> 之后调用</p><p>这两个方法，回调时，用户并不可以操作，计算启动耗时的最好的时机应该是某个数据被加载出来后，当然会掺杂一些网络因素，但这里不是为了数据，只是为了用户体验，可以使用一些监听方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mView.getViewTreeObserver().addOnPreDrawListener(<span class="keyword">new</span> ViewTreeObserver.OnPreDrawListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onPreDraw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mView.getViewTreeObserver().removeOnPreDrawListener(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">mView.getViewTreeObserver().addOnDrawListener(<span class="keyword">new</span> ViewTreeObserver.OnDrawListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mView.getViewTreeObserver().removeOnDrawListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在 View 将要绘制的时候去进行耗时的统计，<code>addOnDrawListener()</code> 需要 <code>API 16</code></p><h2 id="2-2-启动耗时检测方式"><a href="#2-2-启动耗时检测方式" class="headerlink" title="2.2 启动耗时检测方式"></a>2.2 启动耗时检测方式</h2><h3 id="2-2-1-TraceView"><a href="#2-2-1-TraceView" class="headerlink" title="2.2.1 TraceView"></a>2.2.1 TraceView</h3><p>图形化界面的形式展示出执行时间、调用栈，包含所有线程，信息全面</p><p>但是加入 <code>TraceView</code> 的代码后，运行时开销严重，整体都会变慢，可能会带骗优化方向</p><ul><li>通过代码跟踪💦</li></ul><p>只能用于某一个方法的检测</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Debug.startMethodTracing(&quot;xxx&quot;);</span><br><span class="line">...</span><br><span class="line">Debug.stopMethodTracing();</span><br></pre></td></tr></table></figure><p>默认生成文件在 <code>mnt/sdcard/Android/data/packagename/fils</code>  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb pull &#x2F;sdcard&#x2F;Android&#x2F;data&#x2F;packagename&#x2F;fils&#x2F;my.trace</span><br></pre></td></tr></table></figure><p>这样可以将 <code>trace</code> 文件拷贝到项目根目录</p><p>也可以通过 <code>Device File Explorer</code>(AS 右下角) 找到文件，右键点击 <code>Sava as…</code></p><ul><li>通过命令跟踪💦</li></ul><p>可用于整个开始结束的过程(内容会比较多~)</p><p>开始跟踪</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am start -n packagename&#x2F;packagename.Activity --start-profiler &#x2F;data&#x2F;local&#x2F;tmp&#x2F;my.trace --sampling 1000</span><br></pre></td></tr></table></figure><p>终止跟踪</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am profile stop</span><br></pre></td></tr></table></figure><p>拉取文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb pull &#x2F;data&#x2F;local&#x2F;tmp&#x2F;my.trace</span><br></pre></td></tr></table></figure><p>这种方法可以检测启动到调用终止期间的全部内容，但是有些手机出来的 <code>trace</code> 文件时 <code>0B</code>，这就需要在需要停止的地方写上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Debug.stopMethodTracing();</span><br></pre></td></tr></table></figure><p>然后调用开始追踪，会自动停止。文件会放在 <code>data/local/tmp</code> 下。</p><ul><li>查看 Trace 文件💦</li></ul><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://raw.githubusercontent.com/CalmCenter/picGo/master/pictures/20191126115732.png" style="zoom:50%"><p>这就是用 <code>AndroidStudio</code> 查看生成的 <code>TraceView</code> 文件</p><ol><li><p>范围选择</p><p>标有 <code>Cpu usage details unavailable</code> 的地方可以选择时间范围；标有 ·THREADS· 的地方可以选择某条线程，括号中的 <code>67</code> 表示检测全称有 <code>67</code> 条线程。选择时间或线程底部的 <code>Call Chart</code> 都会有相应的变化。</p></li><li><p>执行选择</p><p>在线程选择下有一个 <code>Wall Clock Time</code> 这个表示真正执行的时间，可以切换为 <code>Thread Time</code> 表示 <code>CPU</code> 执行的时间，<code>Thread Time</code> 始终小于 <code>Wall Clock Time</code>。</p></li><li><p>CallChart</p><p>从上到下，调用者在上方，被调用者在下方；<code>系统 API</code> 是橙色、<code>应用自身调用</code> 是绿色、<code>第三方 API</code> 是蓝色，看绿色的部分很直观的可以看出我们自己代码在哪里耗时了~</p></li><li><p>TopDown</p></li></ol><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://raw.githubusercontent.com/CalmCenter/picGo/master/pictures/20191126121637.png" style="zoom:50%"><table><thead><tr><th>标题</th><th>作用</th></tr></thead><tbody><tr><td><strong>Total</strong></td><td>整个函数执行时间</td></tr><tr><td><strong>Self</strong></td><td>函数代码内执行时间</td></tr><tr><td><strong>Children</strong></td><td>子函数耗时</td></tr></tbody></table><p>🌞举个栗子🌞：调用 <code>A</code> 函数整体时间是 <code>Total</code> ，在函数中执行了一行代码耗时 <code>Self</code> ，然后调用 <code>B</code> 函数耗时 <code>Children</code></p><p>这两个方式是比较常用的方式，如果是应用自身方法都可以点击右键进入源码所在位置。</p><ul><li>总结💦</li></ul><ol><li>运行时开销严重，整体都会变慢(因为 <code>TraceView</code> 要抓取所有线程的所有执行函数以及顺序)</li><li>可能会带偏优化方向(本来不好时间的函数可能加入 <code>TraceView</code> 后，变的非常耗时)</li></ol><h3 id="2-2-2-systrace"><a href="#2-2-2-systrace" class="headerlink" title="2.2.2 systrace"></a>2.2.2 systrace</h3><p>结合 Android 内核的数据，生成 HTML 报告，<code>API 18</code> 以上，推荐 <code>TraceCompat</code></p><ul><li>首先清空后台💦</li></ul><p>杀掉所有应用，防止出现莫名莫名方法。</p><ul><li>在需要检测的地方写入代码(可以不写，但是会少一些 tag 提示)💦</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TraceCompat.beginSection(&quot;AppOnCreate&quot;);</span><br><span class="line">...</span><br><span class="line">TraceCompat.endSection();</span><br></pre></td></tr></table></figure><ul><li>执行检测💦</li></ul><p>首先进入 <code>SDK</code> 目录，<code>Sdk\platform-tools\systrace\</code> 目录下有一个 <code>systrace.py</code> 文件，打开 <code>cmd</code> 输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python systrace.py -b 90960 -t 5 -a packagename -o test.log.html sched gfx view wm am app</span><br></pre></td></tr></table></figure><p>这种方式是 <code>5</code> 秒后自动输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python systrace.py gfx view wm am pm ss dalvik app sched -b 90960 -a packagename -o test.log.html</span><br></pre></td></tr></table></figure><p>这种方式可以在自己收集完后，点击 <code>Enter</code> 键停止收集</p><p>两种内容是不太一样的， <code>-t</code> 表示时间，<code>-a</code> 表示包名，<code>-o</code> 输出文件名，最终在当前目录打开文件即可看到，文件只能使用 <code>Chrome</code> 来打开，如果打开 <code>HTML</code> 出现 </p><p><code>Unable to select a master clock domain because no path can be found from &quot;SYSTRACE&quot; to &quot;LINUX_FTRACE_GLOBAL&quot;.</code></p><p>那就是命令出错了，命令我也是收集了好久，最终找到可用的，想了解更多的请查看 <a href="http://gityuan.com/2016/01/17/systrace/" target="_blank" rel="noopener">Gityuan</a> 或 <a href="https://source.android.com/devices/tech/debug/systrace" target="_blank" rel="noopener">官方文档</a> </p><ul><li>分析文件</li></ul><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://raw.githubusercontent.com/CalmCenter/picGo/master/pictures/20191212120416.png" style="zoom:50%"><p>这里可以看到 <code>CPU</code> 核心数以及运行状态，还有各个线程。</p><p>在 <code>UI Thread</code> 中的 <code>AppOnCreate</code> 正是我们在之前的代码埋 <code>tag</code> 点，点击条目并按 <code>M</code> 键可以查看具体信息。右上角是可以搜索 <code>tag</code> 的。</p><p>具体信息中有 <code>Wall Duration</code> （代码执行时间） <code>CPU Duration</code> （代码消耗 CPU 的时间）两者出现差值的原因是同步锁冲突。 </p><p>这种方式不仅可以帮助监控启动过程中性能问题，卡顿优化的时候也可以用这种方式。因为它会把 <code>UI</code> 的渲染也检测到。</p><ul><li>总结💦</li></ul><ol><li>轻量级，开销小</li><li>直观的反应 CPU 利用率</li></ol><h3 id="2-2-3-systrace-函数插桩-AOP-Aspect-Oriented-Programming"><a href="#2-2-3-systrace-函数插桩-AOP-Aspect-Oriented-Programming" class="headerlink" title="2.2.3 systrace + 函数插桩 AOP(Aspect Oriented Programming)"></a>2.2.3 systrace + 函数插桩 AOP(Aspect Oriented Programming)</h3><hr><p> 面向切面编程，针对同一类问题的统一处理，无侵入添加代码。</p><p>在根目录的 <code>build.gradle</code> 下，最新版本请查看 <a href="https://github.com/HujiangTechnology/gradle_plugin_android_aspectjx" target="_blank" rel="noopener">AspectJX 开源地址</a></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classpath <span class="string">'com.hujiang.aspectjx:gradle-android-plugin-aspectjx:2.0.8'</span></span><br></pre></td></tr></table></figure><p>在 <code>app</code> 模块下添加如下，通过我的测试这些引用只能添加在 <code>app</code> 模块下，添加在其他子模块下不生效。最新版本请查看 <a href="http://www.eclipse.org/aspectj/downloads.php#stable_release" target="_blank" rel="noopener">AspectJ官网</a></p><p>顶部</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">'android-aspectjx'</span></span><br></pre></td></tr></table></figure><p><code>dependencies</code> 内</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">api <span class="string">'org.aspectj:aspectjrt:1.9.5'</span></span><br></pre></td></tr></table></figure><p>下面是通过注解的方式结合 <code>Systrace</code> 进行埋点。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AnnotationRetention.SOURCE：不存储在编译后的 Class 文件。</span></span><br><span class="line"><span class="comment"> * AnnotationRetention.BINARY：存储在编译后的 Class 文件，但是反射不可见。</span></span><br><span class="line"><span class="comment"> * AnnotationRetention.RUNTIME：存储在编译后的 Class 文件，反射可见。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Retention(AnnotationRetention.RUNTIME)</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AnnotationTarget.CLASS：类，接口或对象，注解类也包括在内。</span></span><br><span class="line"><span class="comment"> * AnnotationTarget.ANNOTATION_CLASS：只有注解类。</span></span><br><span class="line"><span class="comment"> * AnnotationTarget.TYPE_PARAMETER：Generic type parameter (unsupported yet)通用类型参数（还不支持）。</span></span><br><span class="line"><span class="comment"> * AnnotationTarget.PROPERTY：属性。</span></span><br><span class="line"><span class="comment"> * AnnotationTarget.FIELD：字段，包括属性的支持字段。</span></span><br><span class="line"><span class="comment"> * AnnotationTarget.LOCAL_VARIABLE：局部变量。</span></span><br><span class="line"><span class="comment"> * AnnotationTarget.VALUE_PARAMETER：函数或构造函数的值参数。</span></span><br><span class="line"><span class="comment"> * AnnotationTarget.CONSTRUCTOR：仅构造函数（主函数或者第二函数）。</span></span><br><span class="line"><span class="comment"> * AnnotationTarget.FUNCTION：方法（不包括构造函数）。</span></span><br><span class="line"><span class="comment"> * AnnotationTarget.PROPERTY_GETTER：只有属性的 getter。</span></span><br><span class="line"><span class="comment"> * AnnotationTarget.PROPERTY_SETTER：只有属性的 setter。</span></span><br><span class="line"><span class="comment"> * AnnotationTarget.TYPE：类型使用。</span></span><br><span class="line"><span class="comment"> * AnnotationTarget.EXPRESSION：任何表达式。</span></span><br><span class="line"><span class="comment"> * AnnotationTarget.FILE：文件。</span></span><br><span class="line"><span class="comment"> * AnnotationTarget.TYPEALIAS：<span class="doctag">@SinceKotlin</span>("1.1") 类型别名，Kotlin1.1已可用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(AnnotationTarget.FUNCTION)</span></span><br><span class="line"><span class="keyword">annotation</span> <span class="class"><span class="keyword">class</span> <span class="title">TraceCompat</span></span></span><br></pre></td></tr></table></figure><p>具体的切入代码，需要将 <code>packagename</code> 换成自己的路径名字</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TraceCompatAspect</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Pointcut(<span class="meta-string">"execution(@packagename.TraceCompat * *(..))"</span>)</span> <span class="comment">//方法切入点</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">methodAnnotated</span><span class="params">()</span></span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(<span class="meta-string">"methodAnnotated()"</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">aroundJoinPoint</span><span class="params">(joinPoint: <span class="type">ProceedingJoinPoint</span>)</span></span> &#123;</span><br><span class="line">        TraceCompat.beginSection(<span class="string">"TraceCompat"</span>)</span><br><span class="line">        <span class="comment">//执行原方法</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            joinPoint.proceed()</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            TraceCompat.endSection()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在需要埋点的加入注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TraceCompat</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就完成了 <code>AOP</code> 埋点辅助<code>systrace</code> 监控的方式。<code>AOP</code> 还有很多更强大更方便的用法，这里只是一种注解切入的方式。更多用法请查看其它文章。</p><p>由于我现在使用 <code>AOP</code> 还存在很多问题，还在研究中。。。(上面的例子是可以使用的)</p><h3 id="2-2-4-Nanoscope"><a href="#2-2-4-Nanoscope" class="headerlink" title="2.2.4 Nanoscope"></a>2.2.4 Nanoscope</h3><p>还未使用过 ~ </p><p>在<a href="https://time.geekbang.org/column/article/74044" target="_blank" rel="noopener">极客时间 《Android开发高手课》</a>   中提到了 <a href="https://github.com/uber/nanoscope" target="_blank" rel="noopener">Nanoscope</a> ，它是在 <code>instrument</code> 类型的性能分析工具中性能损耗比较小的。</p><p>它的实现原理是直接修改 <code>Android</code> 虚拟机源码，在 <code>ArtMethod</code> 执行入口和执行结束位置增加埋点代码，将所有的信息先写到内存，等到 <code>trace</code> 结束后才统一生成结果文件。在使用过程可以明显感觉到应用不会因为开启 <code>Nanoscope</code> 而感到卡顿，但是 <code>trace</code> 结束生成结果文件这一步需要的时间比较长。<strong>另一方面它可以支持分析任意一个应用，可用于做竞品分析。</strong></p><p>但是它也有不少限制：</p><ul><li>需要自己刷 <code>ROM</code>，并且当前只支持 <code>Nexus 6P</code>，或者采用其提供的 <code>x86</code> 架构的模拟器。</li><li>默认只支持主线程采集，其他线程需要 <a href="https://github.com/uber/nanoscope/wiki/Architecture%3A-Nanoscope-ROM#java-api" target="_blank" rel="noopener">代码手动设置</a> 。考虑到内存大小的限制，每个线程的内存数组只能支持大约 <code>20</code> 秒左右的时间段。</li></ul><p><code>Uber</code> 写了一系列自动化脚本协助整个流程，使用起来还算简单。<code>Nanoscope</code> 作为基本没有性能损耗的 <code>instrument</code> 工具，它非常适合做启动耗时的自动化分析。</p><p><code>Nanoscope</code> 生成的是符合 <code>Chrome tracing</code> 规范的 <code>HTML</code> 文件。我们可以通过脚本来实现两个功能：</p><p>第一个是反混淆。通过 <code>mapping</code> 自动反混淆结果文件。</p><p>第二个是自动化分析。传入相同的起点和终点，实现两个结果文件的<code>diff</code>，自动分析差异点。</p><p>这样我们可以每天定期去跑自动化启动测试，查看是否存在新增的耗时点。</p><hr><h1 id="3-启动优化-干货"><a href="#3-启动优化-干货" class="headerlink" title="3 启动优化(干货)"></a>3 启动优化<code>(干货)</code></h1><h2 id="3-1-闪屏页展示"><a href="#3-1-闪屏页展示" class="headerlink" title="3.1 闪屏页展示"></a>3.1 闪屏页展示</h2><p>闪屏页是优化启动速度的一个小技巧，虽然对实际的启动速度没有任何帮助，但是能让用户感觉应用到应用在第一时间已经被打开。</p><p>合并闪屏和主页面的 Activity，减少一个 Activity 会给线上带来 100 毫秒左右的优化。但是如果这样做的话，管理时会非常复杂。</p><p>闪屏如果存在网络请求，一般都是提前准备好闪屏页的，在下一次生效。</p><p>具体操作文末参考中会有 ~ 这里不再说明。</p><h2 id="3-2-异步启动实践"><a href="#3-2-异步启动实践" class="headerlink" title="3.2 异步启动实践"></a>3.2 异步启动实践</h2><h3 id="3-2-1-启动器"><a href="#3-2-1-启动器" class="headerlink" title="3.2.1 启动器"></a>3.2.1 启动器</h3><p>微信内部使用的 <a href="https://mp.weixin.qq.com/s/6Q818XA5FaHd7jJMFBG60w?" target="_blank" rel="noopener">mmkernel</a></p><p>阿里最近开源的 <a href="https://github.com/alibaba/alpha" target="_blank" rel="noopener">Alpha</a> 启动框架</p><p>慕课网中学习到的 启动器 <code>Task</code> </p><p>它们为各个任务建立依赖关系，最终构成一个有向无环图。对于可以并发的任务，会通过线程池最大程度提升启动速度。</p><h3 id="3-2-1-异步Layout子线程预加载"><a href="#3-2-1-异步Layout子线程预加载" class="headerlink" title="3.2.1 异步Layout子线程预加载"></a>3.2.1 异步Layout子线程预加载</h3><p>参考文章 <a href="https://juejin.im/post/5d63cdf7f265da03ed195f68?utm_source=gold_browser_extension#comment" target="_blank" rel="noopener">Android - 一种新奇的冷启动速度优化思路(Fragment极度懒加载 + Layout子线程预加载)</a> </p><p>遇到个点，如果 <code>xml</code> 中是 <code>com.google.android.material.appbar.AppBarLayout</code> 等 <code>google</code> 包里的，需要加上一条属性</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:theme="@style/Theme.AppCompat.Light.DarkActionBar"</span><br></pre></td></tr></table></figure><p>这个属性与自己 <code>Activity</code> 的 <code>theme</code> 相对应。</p><h2 id="3-3-数据重排"><a href="#3-3-数据重排" class="headerlink" title="3.3 数据重排"></a>3.3 数据重排</h2><p>Facebook 开源的 Dex 优化工具 <a href="https://github.com/facebook/redex/blob/master/docs/Interdex.md" target="_blank" rel="noopener">ReDex</a></p><p><a href="https://mp.weixin.qq.com/s/Hquq8iJvZuN-gynVFxCCNA" target="_blank" rel="noopener">都9102年了，Android 冷启动优化除了老三样还有哪些新招？</a></p><p>支付宝 <a href="https://mp.weixin.qq.com/s/79tAFx6zi3JRG-ewoapIVQ" target="_blank" rel="noopener">《通过安装包重排布优化 Android 端启动性能》</a></p><h2 id="3-4-类的加载"><a href="#3-4-类的加载" class="headerlink" title="3.4 类的加载"></a>3.4 类的加载</h2><p>加载类的过程有一个 verify class 的步骤，它需要校验方法的每一个指令，是一个比较耗时的操作。我们可以通过 Hook 来去掉 verify 这个步骤，这对启动速度有几十毫秒的优化。最大的优化场景在于首次和覆盖安装时。</p><p>这个黑科技可以大大降低首次启动的速度，代价是对后续运行会产生轻微的影响。同时也要考虑兼容性问题，暂时不建议在 ART 平台使用。</p><h2 id="3-5-延迟加载方案-IdleHandler"><a href="#3-5-延迟加载方案-IdleHandler" class="headerlink" title="3.5 延迟加载方案 IdleHandler"></a>3.5 延迟加载方案 IdleHandler</h2><p>利用 <code>IdleHandler</code> 特性，空闲时执行初始化。</p><p><strong><code>IdleHandler</code> 可以用来提升性能，主要用在我们希望能够在当前线程消息队列空闲时做些事情</strong> </p><h2 id="3-6-其他优化思路"><a href="#3-6-其他优化思路" class="headerlink" title="3.6 其他优化思路"></a>3.6 其他优化思路</h2><h3 id="5-0-以下机型-MultiDex-优化"><a href="#5-0-以下机型-MultiDex-优化" class="headerlink" title="5.0 以下机型 MultiDex 优化"></a><code>5.0</code> 以下机型 <code>MultiDex</code> 优化</h3><p><a href="https://juejin.im/post/5d95f4a4f265da5b8f10714b?utm_source=gold_browser_extension#comment" target="_blank" rel="noopener">面试官：今日头条启动很快，你觉得可能是做了哪些优化？</a></p><h3 id="GC-优化"><a href="#GC-优化" class="headerlink" title="GC 优化"></a>GC 优化</h3><p>支付宝提出一种 <a href="https://mp.weixin.qq.com/s/ePjxcyF3N1vLYvD5dPIjUw" target="_blank" rel="noopener">GC 抑制</a> 的方案</p><p>在启动过程，要尽量减少 GC 的次数，避免造成主线程长时间的卡顿。</p><p>特别是对 Dalvik 来说，我们可以通过 systrace 单独查看整个启动过程 GC 的时间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python systrace.py dalvik -b 90960 -a com.sample.gc</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; GC使用的总耗时，单位是毫秒</span><br><span class="line">Debug.getRuntimeStat(&quot;art.gc.gc-time&quot;);</span><br><span class="line">&#x2F;&#x2F; 阻塞式GC的总耗时</span><br><span class="line">Debug.getRuntimeStat(&quot;art.gc.blocking-gc-time&quot;);</span><br></pre></td></tr></table></figure><p>启动过程避免进行大量的字符串操作，特别是序列化跟反序列化过程。一些频繁创建的对象，例如网络库和图片库中的 Byte 数组、Buffer 可以复用。</p><h3 id="系统调用优化"><a href="#系统调用优化" class="headerlink" title="系统调用优化"></a>系统调用优化</h3><p>通过 systrace 的 System Service 类型，我们可以看到启动过程 System Server 的 CPU 工作情况。在启动过程，我们尽量不要做系统调用，例如 PackageManagerService 操作、Binder 调用等待。</p><p>在启动过程也不要过早地拉起应用的其他进程，System Server 和新的进程都会竞争 CPU 资源。</p><h3 id="线程优化"><a href="#线程优化" class="headerlink" title="线程优化"></a>线程优化</h3><p>线程优化就像做填空题和解锁题，我们希望能把所有的时间片都利用上，因此主线程和各个线程都是一直满载的。当然我们也希望每个线程都开足马力向前跑，而不是作为接力棒。所以线程的优化主要在于减少 CPU 调度带来的波动，让应用的启动时间更加稳定。</p><p>从具体的做法来看，线程的优化一方面是控制线程数量，线程数量太多会相互竞争 CPU 资源，因此要有统一的线程池，并且根据机器性能来控制数量。</p><p>3.2.1 启动器 提到，合理分配线程数量。</p><p>另一方面是检查线程间的锁。</p><h3 id="业务优化"><a href="#业务优化" class="headerlink" title="业务优化"></a>业务优化</h3><p>我们首先需要梳理清楚当前启动过程正在运行的每一个模块，哪些是一定需要的、哪些可以砍掉、哪些可以懒加载。</p><p>通过梳理之后，剩下的都是启动过程一定要用的模块。</p><p>这个时候，我们只能硬着头皮去做进一步的优化。优化前期需要“抓大放小”，先看看主线程究竟慢在哪里。</p><p>退而求其次，我们要考虑这些任务是不是可以通过异步线程预加载实现（上面有讲到），但需要注意的是过多的线程预加载会让我们的逻辑变得更加复杂。</p><h3 id="I-O-优化"><a href="#I-O-优化" class="headerlink" title="I/O 优化"></a>I/O 优化</h3><p>启动过程不建议出现网络 I/O</p><p>磁盘 I/O 是启动优化一定要抠的点（敬请期待）</p><p>还有一个是数据结构的选择问题，我们在启动过程只需要读取 Setting.sp 的几项数据，不过 SharedPreference 在初始化的时候还是要全部数据一起解析。如果它的数据量超过 1000 条，启动过程解析时间可能就超过 100 毫秒。如果只解析启动过程用到的数据项则会很大程度减少解析时间，启动过程适合使用随机读写的数据结构。（敬请期待）</p><h3 id="保活"><a href="#保活" class="headerlink" title="保活"></a>保活</h3><p>保活可以减少 Application 创建跟初始化的时间，让冷启动变成温启动。不过在 Target 26 之后，保活的确变得越来越难。</p><p>对于大厂来说，可能需要寻求厂商合作的机会，例如微信的 <a href="https://www.geekpark.net/news/233791" target="_blank" rel="noopener">Hardcoder</a> 方案和 OPPO 推出的Hyper Boost方案。根据 OPPO 的数据，对于手机 QQ、淘宝、微信启动场景会直接有 20% 以上的优化。</p><p>有的时候你问为什么微信可以保活？为什么它可以运行的那么流畅？这里可能不仅仅是技术上的问题，当应用体量足够大，就可以倒逼厂商去专门为它们做优化。</p><h3 id="插件化和热修复"><a href="#插件化和热修复" class="headerlink" title="插件化和热修复"></a>插件化和热修复</h3><p>大部分的框架在设计上都存在大量的 Hook 和私有 API 调用，带来的缺点主要有两个：</p><ul><li>稳定性差。虽然大家都号称兼容 100% 的机型，由于厂商的兼容性、安装失败、dex2oat 失败等原因，还是会有那么一些代码和资源的异常。Android P 推出的 non-sdk-interface 调用限制，以后适配只会越来越难，成本越来越高。</li><li>性能差。Android Runtime 每个版本都有很多的优化，因为插件化和热修复用到的一些黑科技，导致底层 Runtime 的优化我们是享受不到的。Tinker 框架在加载补丁后，应用启动速度会降低 5%～10%。</li></ul><p>应用加固对启动速度来说简直是灾难，有时候我们需要做一些权衡和选择。</p><hr><h1 id="4-启动监控"><a href="#4-启动监控" class="headerlink" title="4 启动监控"></a>4 启动监控</h1><p><a href="https://developer.android.google.cn/topic/performance/vitals/launch-time#av" target="_blank" rel="noopener">Android Vitals</a> </p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dalvik 寄存器</title>
      <link href="/2019/dalvikbase.html"/>
      <url>/2019/dalvikbase.html</url>
      
        <content type="html"><![CDATA[<h1 id="Dalvik-寄存器"><a href="#Dalvik-寄存器" class="headerlink" title="Dalvik 寄存器"></a>Dalvik 寄存器</h1><a id="more"></a><h2 id="寄存器命名法"><a href="#寄存器命名法" class="headerlink" title="寄存器命名法"></a>寄存器命名法</h2><h2 id="Dalvik-字节码"><a href="#Dalvik-字节码" class="headerlink" title="Dalvik 字节码"></a>Dalvik 字节码</h2><h2 id="Dalvik-指令集"><a href="#Dalvik-指令集" class="headerlink" title="Dalvik 指令集"></a>Dalvik 指令集</h2><p>Dalvik 指令在调用格式上模仿了 C 语言的调用约定。Dalvik 指令的语法与助记符有如下特点。</p><ul><li>参数采用从目标 (detination) 到 (source)的方式</li><li>根据字节码大小与类型的不同, 为一些字节码添加了名称后缀以消除歧义<ul><li>32 位常规类型的字节码未添加任何后缀。</li><li>64 位常规类型的字节码添加 -wide 后缀。</li><li>对特殊类型的字节码, 根据具体类型添加后缀, 可以使 -boolean、-byte、-char、-short、-int、-long、-float、-double、-object、-string、-class、-void中的一个</li></ul></li><li>根据字节码布局的选项不同, 为一些字节码添加了字节码后缀以消除歧义。这些后缀通过字节码主名称后添加斜杠来分割。</li><li>在指令集的描述中, 宽度值中的每个字母 都表示 4 位的宽度。</li></ul><h3 id="空操作指令"><a href="#空操作指令" class="headerlink" title="空操作指令"></a>空操作指令</h3><p>空操作指令的助记符为 nop, 它的值为 00。nop 指令通常用于对齐代码, 不进行实际操作。</p><h3 id="数据操作指令"><a href="#数据操作指令" class="headerlink" title="数据操作指令"></a>数据操作指令</h3><p>数据操作指令为 move, 其原型为 move destination, source。根据字节码大小与类型的不同, move 指令有不同的后缀, 如下：</p><table><thead><tr><th align="left"><strong>指令</strong></th><th align="left"><strong>描述</strong></th></tr></thead><tbody><tr><td align="left">move vA, vB</td><td align="left">指令用于将 vB 寄存器的值赋值给 vA 寄存器, <br/>源寄存器和目的寄存器都是 4 位</td></tr><tr><td align="left">move/from16 vAA, vBBBB</td><td align="left">指令用于将 vBBBB 寄存器的值赋值给 vAA 寄存器, <br/>源寄存器为 16 位, 目的寄存器为 8 位</td></tr><tr><td align="left">move/16 vAAAA, vBBBB</td><td align="left">指令用于将 vBBBB 寄存器的值赋值给 vAAAA 寄存器, <br>源寄存器和目的寄存器都是 16 位</td></tr><tr><td align="left">move-wide vA, vB</td><td align="left">指令用于为 4 位的寄存器对赋值, 源寄存器和目的寄存器都是 4 位</td></tr><tr><td align="left">move-wide/from16 vAA, vBBBB</td><td align="left">与 move-wide 相同</td></tr><tr><td align="left">move-wide/16 vAA, vBBBB</td><td align="left">与 move-wide 相同</td></tr><tr><td align="left">move-object vA,vB</td><td align="left">指令用于为对象赋值, 源寄存器和目的寄存器都是 4 位</td></tr><tr><td align="left">move-object/from16 vAA, vBBBB</td><td align="left">指令用于为对象赋值, 源寄存器为 16 位, 目的寄存器为 8 位</td></tr><tr><td align="left">move-object/16 vAAAA, vBBBB</td><td align="left">指令用于为对象赋值, 源寄存器和目的寄存器都是 16 位</td></tr><tr><td align="left">move-result vAA</td><td align="left">指令用于将上一个 invoke 类型指令操作的单字非对象结果赋给 vAA 寄存器</td></tr><tr><td align="left">move-result-wide vAA</td><td align="left">指令用于将上一个 invoke 类型指令操作的双字非对象结果赋给 vAA 寄存器</td></tr><tr><td align="left">move-result-object vAA</td><td align="left">指令用于将上一个 invoke 类型指令操作的对象结果赋给 vAA 寄存器</td></tr><tr><td align="left">move-exception vAA</td><td align="left">指令用于将一个在运行时发生的异常保存到 vAA 寄存器中。<br>这条指令必须在异常发生时由异常处理器使用, 否则指令无效</td></tr></tbody></table><h3 id="返回指令"><a href="#返回指令" class="headerlink" title="返回指令"></a>返回指令</h3><p>返回指令是指函数结束时运行的最后一条指令, 它的基础字节码为 return, 如下：  </p><table><thead><tr><th><strong>指令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>return-void</td><td>指令表示函数从一个 void 方法返回</td></tr><tr><td>return vAA</td><td>指令表示函数返回一个 32 位非对象类型的值, 返回值寄存器为 8 位的寄存器 vAA</td></tr><tr><td>return-wide vAA</td><td>指令表示函数返回一个 64 位非对象类型的值, 返回值寄存器为 8 位的寄存器对 vAA</td></tr><tr><td>return-object vAA</td><td>指令表示函数返回一个对象类型的值, 返回值为 8 位的寄存器 vAA</td></tr></tbody></table><h3 id="数据定义指令"><a href="#数据定义指令" class="headerlink" title="数据定义指令"></a>数据定义指令</h3><p>数据定义指令用来定义程序中用到的常量、字符串、类等数据, 它的基础字节码为 const, 如下：</p><table><thead><tr><th><strong>指令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>const/4 vA,#+B</td><td>指令用于将数值符号扩展为 32 位后赋给寄存器 vA</td></tr><tr><td>const/16 vAA,#+BBBB</td><td>指令用于将数值符号扩展为 32 位后赋给寄存器 vAA</td></tr><tr><td>const vAA,#+BBBBBBBB</td><td>指令用于将数值赋给寄存器 vAA</td></tr><tr><td>const/high16 vAA,#+BBBB0000</td><td>指令用于将数值右边零扩展为 32 位后赋给寄存器 vAA</td></tr><tr><td>const-wide/16 vAA,#+BBBB</td><td>指令用于将数值扩展为 64 位后赋给寄存器对 vAA</td></tr><tr><td>const-wide/32 vAA,#+BBBBBBBB</td><td>指令用于将数值扩展为 64 位后赋给寄存器对 vAA</td></tr><tr><td>const-wide vAA,#+BBBBBBBBBBBBBBBB</td><td>指令用于将数值赋给寄存器对 vAA</td></tr><tr><td>const-wide/hight16 vAA,#+BBBB000000000000</td><td>指令用于将数值右边零扩展为 64 位后赋给寄存器对 vAA</td></tr><tr><td>const-string vAA,string@BBBB</td><td>指令用于通过字符串索引构造一个字符串并赋给寄存器 vAA</td></tr><tr><td>const-string/jumbo vAA,string@BBBBBBBB</td><td>指令用于通过字符串索引(较大)构造一个字符串并赋给寄存器 vAA</td></tr><tr><td>const-class vAA,type@BBBB</td><td>指令用于通过类型索引获取一个类引用并赋给寄存器 vAA</td></tr><tr><td>const-class/jumbo vAAAA,type@BBBBBBBB</td><td>指令用于通过类型索引获取一个类引用并赋给寄存器 vAA<br>(这条指令占用两个字节, 值为 0x00ff)</td></tr></tbody></table><h3 id="锁指令"><a href="#锁指令" class="headerlink" title="锁指令"></a>锁指令</h3><p>锁指令多用在多线程中对同一对象的操作中, Dalvik 指令集中提供了如下两条锁指令：</p><table><thead><tr><th><strong>指令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>monitor-enter vAA</td><td>为指定的对象获取锁</td></tr><tr><td>monitor-exit vAA</td><td>释放指定对象的锁</td></tr></tbody></table><h3 id="实例操作指令"><a href="#实例操作指令" class="headerlink" title="实例操作指令"></a>实例操作指令</h3><p>与实例相关的操作包括实例的类型转换、检查及创建等。如下：</p><table><thead><tr><th><strong>指令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>check-cast vAA,type@BBBB</td><td>指令用于将 vAA 寄存器中的对象引用转换成指定的类型, <br/>如果失败会抛出 ClassCastException 异常, <br/>如果类型 B 指定的是基本类型, <br/>对于非基本类型的 A 来说, 运行时始终会失败。</td></tr><tr><td>instance-of vA,vB,type@CCCC</td><td>指令用于判断 vB 寄存器中的对象是否可以转换成指定的类型, <br/>如果可以 vA 赋给 1, 否则赋给 0。</td></tr><tr><td>new-instance vAA,type@BBBB</td><td>指令用于构造一个指定类型对象的新实例, 并将对象引用赋给 vAA,  <br/>类型符 type 指定的类型不是数组。</td></tr><tr><td>check-cast/jumbo vAAAA,type@BBBBBBBB</td><td>同 check-cast vAA,type@BBBB , <br>只是寄存器值和指令的索引取值返回更大 (android 4.0 新增)</td></tr><tr><td>instance-of/jumbo vAAAA,vBBBB,type@CCCCCCCC</td><td>同 instance-of vA,vB,type@CCCC , <br/>只是寄存器值和指令的索引取值返回更大 (android 4.0 新增)</td></tr><tr><td>new-instance/jumbo vAAAA,type@BBBBBBBB</td><td>同 new-instance vAA,type@BBBB , <br/>只是寄存器值和指令的索引取值返回更大 (android 4.0 新增)</td></tr></tbody></table><h3 id="数组操作指令"><a href="#数组操作指令" class="headerlink" title="数组操作指令"></a>数组操作指令</h3><p>数组操作包括获取数组长度、新建数组、数组赋值、数组元素取值与赋值等操作。如下：</p><table><thead><tr><th><strong>指令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>array-length vA, vB</td><td>获取给定 VB 寄存器中数组的长度并将值赋给 vA 寄存器</td></tr><tr><td>new-array vA, vB, type@CCCC</td><td>构造指定类型 (type@CCCC) 和大小 (vB) 的数组, 并将值赋给 vA</td></tr><tr><td>filled-new-array {vC, vD, vE, vF, vG}, type@BBBB</td><td>构造指定类型 (type@BBBB) 和大小 (vA) 的数组并填充数组内容。<br/>vA 寄存器是隐含使用的, 除了指定数组的大小外还指定了参数的个数, vC ~ vG 是使用到的参数寄存器序列</td></tr><tr><td>filled-new-array/range {vCCCC .. vNNNN}, type@BBBB</td><td>指令功能同 filled-new-array {vC,vD,vE,vF,vG},type@BBBB, <br/>只是参数寄存器使用 range 字节码后缀指定了取值范围, <br/>vC 是第一个参数寄存器,  N = A + C - 1</td></tr><tr><td>fill-array-data vAA, +BBBBBBBB</td><td>用指定的数据来填充数组, vAA 为数组引用, <br/>引用必须为基础类型的数组, 再指令后面会紧跟一个数据表</td></tr><tr><td>new-array/jumbo vAAAA, vBBBB, type@CCCCCCCC</td><td>同 new-array vA,vB,type@CCCC , <br/>只是寄存器值和指令的索引取值返回更大 (android 4.0 新增)</td></tr><tr><td>filled-new-array/jumbo {vCCCC .. vNNNN}, type@BBBBBBBB</td><td>同 filled-new-array/range {vCCCC … vNNNN},type@BBBB , <br/>只是索引取值返回更大 (android 4.0 新增)</td></tr><tr><td>arrayop vAA, vBB, vCC</td><td>对 vBB 寄存器指定的数组元素进行取值和赋值, <br/>vCC 指定数组元素索引, vAA 用来存放读取的或需要设置的数组元素的值, <br/>读取元素使用 aget 类指令, 元素赋值使用 aput 类指令, <br/>根据数组中存储的类型指令后面会紧跟不同的指令后缀, 指令列表有 <br/>( aget , aget-wide , aget-object , <br/>aget-boolean , aget-byte , aget-char , <br/>aget-short , aput , aput-wide , <br/>aput-object , aput-boolean , <br/>aput-byte , aput-char , aput-short )</td></tr></tbody></table><h3 id="异常指令"><a href="#异常指令" class="headerlink" title="异常指令"></a>异常指令</h3>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> delvik </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ViewPage滑动动画差值器</title>
      <link href="/2019/viewpage-indicator-bezierindicator.html"/>
      <url>/2019/viewpage-indicator-bezierindicator.html</url>
      
        <content type="html"><![CDATA[<p>很久以前看到一个这样的效果，很多文章都是只重点实现选择器，<code>ViewPager</code> 的差值器动画效果没有考虑，这里我努力做到最像，完成这个设计</p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://user-gold-cdn.xitu.io/2018/2/6/16169f802550c42e?imageslim" style="zoom:40%"><h2 id="本文知识点"><a href="#本文知识点" class="headerlink" title="本文知识点"></a>本文知识点</h2><ul><li></li><li><code>ViewPager</code>  滑动解析</li><li>自定义 <code>Scroller</code> </li><li>反射</li></ul><hr><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> ui </tag>
            
            <tag> viewpage </tag>
            
            <tag> ViewPageIndicator </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 网站管理</title>
      <link href="/2019/hexo-website-management.html"/>
      <url>/2019/hexo-website-management.html</url>
      
        <content type="html"><![CDATA[<p>目录请看  <a href="https://calmcenter.club/2019/Complete_works_of_hexo.html">Hexo 搭建博客大全</a></p><p><strong>注意：如果出现图片不显示问题请移步</strong> <a href="https://calmcenter.club/2019/PicNotShow.html">图片不显示问题</a></p><h1 id="本文主要记载"><a href="#本文主要记载" class="headerlink" title="本文主要记载"></a>本文主要记载</h1><ul><li>加入 <code>Coding</code> 服务器</li><li>个人域名</li><li><code>SEO</code>  推广</li></ul><hr><div class="note warning">            <p>重点： <code>hexo</code> 根目录配置文件 <code>hexo/_config.yml</code>  下文用 <code>Hexo 配置文件</code> 表示，<code>NexT</code> 样式配置文件 <code>hexo/theme/next/_config.yml</code> 下文用 <code>NexT 配置文件</code> 表示一定要分清，它们都叫 <code>_comfig.yml</code></p>          </div><p><strong>本文章写于 <code>2019/5/5</code> 图片内容可能和您现在看的内容不太一样，但是功能大体是不会变的。</strong></p><hr><h1 id="加入-Coding-服务器"><a href="#加入-Coding-服务器" class="headerlink" title="加入 Coding 服务器"></a>加入 <code>Coding</code> 服务器</h1><p>这里加入<code>Coding</code> 服务器的作用主要是访问速度，其次就是由于 <code>github</code> 屏蔽百度的爬虫，所以使用 <code>github page</code> 服务的站点的链接无法被抓取，可用  <code>Coding</code>  的 <code>page</code> 服务。</p><ol><li><p>登录 <a href="https://dev.tencent.com/" target="_blank" rel="noopener">Coding</a></p><p>登录 <a href="https://dev.tencent.com/" target="_blank" rel="noopener">Coding</a> ，并创建项目<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://raw.githubusercontent.com/CalmCenter/picGo/master/pictures/20190505114135.png" style="zoom:50%"></p></li><li><p>个人设置</p><p>首先你需要点击头像，找到个人设置，在个人设置中设置 <strong>密码</strong> 和 <strong>邮箱</strong> 才能设置 <strong>SSH</strong> ，如果你之前设置过 <code>github</code> 的 <code>SSH</code> 你只需要执行以下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clip &lt; ~&#x2F;.ssh&#x2F;id_rsa.pub</span><br></pre></td></tr></table></figure><p>然后点击 <code>SSH</code>公钥 设置即可，如果没有设置过 <code>github</code> 请参考 <a href="https://calmcenter.club/2019/Hexo_bash.html#2-3-%E9%85%8D%E7%BD%AE-SSH-%E5%AF%86%E9%92%A5">Hexo 基础搭建 - 配置 SSH 秘钥部分</a></p></li><li><p>验证</p><p>输入以下命令，查看 <code>SSH</code> 配置是否成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@git.coding.net</span><br></pre></td></tr></table></figure></li><li><p>添加配置</p><p>在  <code>Hexo 配置文件</code> 中注释掉之前的，添加 <code>repo</code> 中的内容 <code>SSH</code> 路径 <code>,master</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure><h1 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h1><h2 id="Docs-https-hexo-io-docs-deployment-html"><a href="#Docs-https-hexo-io-docs-deployment-html" class="headerlink" title="Docs: https://hexo.io/docs/deployment.html"></a>Docs: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">https://hexo.io/docs/deployment.html</a></h2><p>deploy:<br>type: git<br>#repository: <a href="mailto:git@github.com">git@github.com</a>:CalmCenter/calmcenter.github.io.git<br>#branch: master<br>repo:<br> github: <a href="mailto:git@github.com">git@github.com</a>:CalmCenter/calmcenter.github.io.git,master<br> coding: <a href="mailto:git@git.dev.tencent.com">git@git.dev.tencent.com</a>:CalmCenter/calmcenter.coding.me.git,master</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">5. 提交</span><br></pre></td></tr></table></figure><p>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">6. 打开 &#96;Coding Pages&#96; 服务</span><br><span class="line"></span><br><span class="line">   &#96;头像 -&gt; 我的主页 -&gt; 项目 -&gt; 代码 -&gt; Pages 服务&#96; 打钩已阅读服务，点击开启即可</span><br><span class="line"></span><br><span class="line">   会告诉你访问地址，打开如果排版不正常，不要慌，可能是子文件目录问题，设置域名后可解决。</span><br><span class="line"></span><br><span class="line">   &lt;img src&#x3D;&quot;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;CalmCenter&#x2F;picGo&#x2F;master&#x2F;pictures&#x2F;20190508105842.png&quot; style&#x3D;&quot;zoom:50%&quot;&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line"># 个人域名</span><br><span class="line"></span><br><span class="line">1. 获得域名</span><br><span class="line"></span><br><span class="line">   首先你得有你自己的域名，几块钱就好~  [腾讯云](https:&#x2F;&#x2F;cloud.tencent.com&#x2F;act&#x2F;domainsales?fromSource&#x3D;gwzcw.2211770.2211770.2211770&amp;utm_medium&#x3D;cpc&amp;utm_id&#x3D;gwzcw.2211770.2211770.2211770) 、[阿里云](https:&#x2F;&#x2F;wanwang.aliyun.com&#x2F;domain&#x2F;yumingheji) ，然后需要进行实名认证。完成后就可以添加域名解析地址啦~ </span><br><span class="line"></span><br><span class="line">2. 添加解析</span><br><span class="line"></span><br><span class="line">   这是 [腾讯云](https:&#x2F;&#x2F;cloud.tencent.com&#x2F;act&#x2F;domainsales?fromSource&#x3D;gwzcw.2211770.2211770.2211770&amp;utm_medium&#x3D;cpc&amp;utm_id&#x3D;gwzcw.2211770.2211770.2211770) 的域名解析。</span><br><span class="line"></span><br><span class="line">   **注意：这里域名操作，每次操作完都会有一定缓冲时间，不会立即生效，每次操作完等待 10 分钟左右，再去配置域名** </span><br><span class="line"></span><br><span class="line">   &lt;img src&#x3D;&quot;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;CalmCenter&#x2F;picGo&#x2F;master&#x2F;pictures&#x2F;20190508104813.png&quot; style&#x3D;&quot;zoom:50%&quot;&gt;</span><br><span class="line"></span><br><span class="line">   这是添加的解析，因为添加了 &#96;coding&#96; ，所以有两条，分别将两个访问地址添加到域名解析中，&#96;github&#96; 用于境外访问，&#96;coding&#96; 本想着用于境内，但这里必须设置成默认才行。</span><br><span class="line"></span><br><span class="line">3. &#96;github&#96; 域名设置</span><br><span class="line"></span><br><span class="line">   点击你的博客项目的 &#96;Setting&#96; -&gt; &#96;Options&#96; 下滑找到 &#96;GitHub Pages&#96; </span><br><span class="line"></span><br><span class="line">   &lt;img src&#x3D;&quot;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;CalmCenter&#x2F;picGo&#x2F;master&#x2F;pictures&#x2F;20190508105420.png&quot; style&#x3D;&quot;zoom:50%&quot;&gt;</span><br><span class="line"></span><br><span class="line">   &lt;img src&#x3D;&quot;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;CalmCenter&#x2F;picGo&#x2F;master&#x2F;pictures&#x2F;20190508105344.png&quot; style&#x3D;&quot;zoom:50%&quot;&gt;</span><br><span class="line"></span><br><span class="line">   这里会提示你站点发布在什么地方，记得开启 &#96;HTTPS&#96; 哦。</span><br><span class="line"></span><br><span class="line">4. &#96;Coding&#96; 域名设置</span><br><span class="line"></span><br><span class="line">   &lt;img src&#x3D;&quot;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;CalmCenter&#x2F;picGo&#x2F;master&#x2F;pictures&#x2F;20190508105715.png&quot; style&#x3D;&quot;zoom:50%&quot;&gt;</span><br><span class="line"></span><br><span class="line">   自定义域名，将申请好的域名添加上去，点击绑定，然后刷新页面，知道 &#96;SSL&#x2F;TLS 安全证书&#96; 出现结果，如果错误，请查看解析中 &#96;coding&#96; 线路类型配置是否是默认，如果是默认还不行，请将境外的 &#96;github&#96; 先暂停，再去重新绑定。记得开启 &#96;HTTPS&#96; 哦。</span><br><span class="line"></span><br><span class="line">   **操作时请留意 个人域名 开头说明的注意事项**</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"># &#96;SEO&#96;  推广</span><br><span class="line"></span><br><span class="line">参考自作者 [EnjoyToShare](https:&#x2F;&#x2F;blog.enjoytoshare.club&#x2F;article&#x2F;hexo-do-optimization.html#5) </span><br><span class="line"></span><br><span class="line">##  &#96;SEO&#96; 是什么</span><br><span class="line"></span><br><span class="line">刚搭建完博客，可能你会发现你发表的文章在谷歌或者百度都搜索不到，因为需要进行 &#96;SEO&#96; 优化的，什么是 &#96;SEO&#96; ，顾名思义，&#96;SEO&#96; 即 &#96;(Search Engine Optimization)&#96; : 汉译为搜索引擎优化，它可以让自己的博文能在谷歌百度上搜索到。</span><br><span class="line"></span><br><span class="line">## 生成 &#96;sitemap&#96;</span><br><span class="line"></span><br><span class="line">&#96;sitemap&#96; 用于通知搜索引擎网站上有哪些可供抓取的网页，以便搜索引擎可以更加智能地抓取网站。</span><br><span class="line">安装 &#96;sitemap&#96; 站点地图自动生成插件 &#96;hexo-generator-sitemap&#96; 和 &#96;hexo-generator-baidu-sitemap&#96;</span><br></pre></td></tr></table></figure><p>npm install hexo-generator-sitemap –save</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>npm install hexo-generator-baidu-sitemap –save</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">然后修改  &#96;Hexo 配置文件&#96; ，**添加**如下内容</span><br></pre></td></tr></table></figure><p>sitemap:<br>path: sitemap.xml<br>baidusitemap:<br>path: baidusitemap.xml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">并**修改** &#96;url&#96; 为你的域名地址 如 &#96;url: https:&#x2F;&#x2F;blog.calmcenter.club&#x2F;&#96; </span><br><span class="line"></span><br><span class="line">然后编译代码</span><br></pre></td></tr></table></figure><p>hexo g</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">就会生成在 &#96;hexo\public&#96; 下生成 &#96;sitemap.xml&#96; 和 &#96;baidusitemap.xml&#96; 一个是给谷歌的，一个给是百度的。</span><br><span class="line"></span><br><span class="line">## 添加协议</span><br><span class="line"></span><br><span class="line">网站通过 &#96;Robots协议&#96; 告诉搜索引擎哪些页面可以抓取，哪些页面不能抓取。 &#96;robots.txt&#96; 通常存放于网站根目录 ( &#96;public&#96; 目录)。由于我们每次 &#96;hexo clean&#96; 都会清空 &#96;public&#96; ，着实不方便，我们都知道 &#96;source&#96; 目录下的文件通过 &#96;hexo g&#96; 命令会转换成 &#96;public&#96; 中的文件，所以为了方便起见，我们把 &#96;robots.txt&#96; 文件放在&#96;source&#96;目录下，我的 &#96;robots.txt&#96; 内容为：</span><br></pre></td></tr></table></figure><p>User-agent: *<br>Allow: /<br>Allow: /archives/<br>Allow: /categories/<br>Allow: /tags/<br>Allow: /links/<br>Disallow: /js/<br>Disallow: /css/<br>Disallow: /fonts/<br>Disallow: /vendors/<br>Disallow: /fancybox/<br>Sitemap: https://你的域名/sitemap.xml<br>Sitemap: https://你的域名/baidusitemap.xml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">其中Allow后面的就是你的menu</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 域名 </tag>
            
            <tag> coding </tag>
            
            <tag> seo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 功能样式配置</title>
      <link href="/2019/hexo-functional-style.html"/>
      <url>/2019/hexo-functional-style.html</url>
      
        <content type="html"><![CDATA[<p>目录请看  <a href="https://calmcenter.club/2019/Complete_works_of_hexo.html">Hexo 搭建博客大全</a></p><p><strong>注意：如果出现图片不显示问题请移步</strong> <a href="https://calmcenter.club/2019/PicNotShow.html">图片不显示问题</a></p><h1 id="本文主要记载"><a href="#本文主要记载" class="headerlink" title="本文主要记载"></a>本文主要记载</h1><ul><li><code>NexT</code> 主题设置</li><li>基础样式设置</li><li>图片相关</li><li>打赏、评论、复制功能</li><li><code>DaoVoice</code> 实现在线联系</li><li>文章置顶</li><li>搜索功能</li><li>细节美化</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">本文环境是 win10 或 win 7。mac 再执行 npm 时需要在前面添加 sudo</span><br><span class="line">本文整理于各大佬文章，文中会给出相应链接，如有侵权，请联系我修改或删除。</span><br></pre></td></tr></table></figure><hr><h1 id="功能样式配置"><a href="#功能样式配置" class="headerlink" title="功能样式配置"></a>功能样式配置</h1><h2 id="NexT-主题设置"><a href="#NexT-主题设置" class="headerlink" title="NexT 主题设置"></a><code>NexT</code> 主题设置</h2><p>*<em>重点标注：<code>hexo</code> 根目录配置文件 <code>hexo/_config.yml</code>  下文用 <code>Hexo 配置文件</code> 表示，<code>NexT</code> 样式配置文件 <code>hexo/theme/next/_config.yml</code> 下文用 <code>NexT 配置文件</code> 表示一定要分清，它们都叫 <code>_cpmfig.yml</code> *</em></p><p><a href="https://hexo.io/themes/" target="_blank" rel="noopener">这里有很多主题</a> 这里主要说 <a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener">NexT</a> </p><p>进入 <code>hexo</code> 文件目录 ，执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;hexo-theme-next themes&#x2F;next</span><br></pre></td></tr></table></figure><p>成功后，在 <code>Hexo 配置文件</code> 找到 <code>theme</code> 字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure><p>这样 <code>next</code> 样式就设置好了，快打开看看吧  <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a></p><p><strong>注意:如果你是 <code>git</code> 直接 <code>clone</code> 的，会自带 <code>.git</code> 和 <code>.github</code> 文件，需要删掉 <code>.git</code> 和 <code>.github</code> 文件，如果不删在 <a href="https://calmcenter.club/2019/Hexo_code_management.html">Hexo 管理代码</a> 一文中会出现 <code>them/next</code> 里的文件提交不上去的问题</strong></p><h2 id="设置语言、标题等"><a href="#设置语言、标题等" class="headerlink" title="设置语言、标题等"></a>设置语言、标题等</h2><p>在  <code>Hexo 配置文件</code> 找到 <code>Site</code> 字段 </p><table><thead><tr><th align="left">字段</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">title</td><td align="left">网站标题</td></tr><tr><td align="left">subtitle</td><td align="left">副标题</td></tr><tr><td align="left">description</td><td align="left">描述</td></tr><tr><td align="left">author</td><td align="left">作者(您的名字)</td></tr><tr><td align="left">language</td><td align="left">语言 (zh-CN，en等)</td></tr><tr><td align="left">timezone</td><td align="left">网站时区，默认使用您电脑的时区</td></tr></tbody></table><h2 id="NexT-样式"><a href="#NexT-样式" class="headerlink" title="NexT 样式"></a><code>NexT</code> 样式</h2><p>在 <code>Hexo 配置文件</code> 找到 <code>Schemes</code> 字段，这里有四种样式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Schemes</span><br><span class="line">#scheme: Muse</span><br><span class="line">#scheme: Mist</span><br><span class="line">#scheme: Pisces</span><br><span class="line">scheme: Gemini</span><br></pre></td></tr></table></figure><h2 id="图片上传-PicGo-GitHub-图床"><a href="#图片上传-PicGo-GitHub-图床" class="headerlink" title="图片上传 PicGo + GitHub 图床"></a>图片上传 <code>PicGo</code> + <code>GitHub</code> 图床</h2><p>参考自作者 <a href="https://blog.enjoytoshare.club/article/hexo-do-optimization-picture.html" target="_blank" rel="noopener">EnjoyToShare 《PicGo+GitHub图床，让Markdown飞起》</a>  </p><ol><li><p>首先下载工具<br>下载地址 : <a href="https://github.com/Molunerfinn/PicGo/releases" target="_blank" rel="noopener">PicGo</a> </p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://raw.githubusercontent.com/CalmCenter/picGo/master/picturespicgo_down.png" style="zoom:50%"></li><li><p>登录 <code>GitHub</code> </p><p>创建 <code>Repository</code> 之前都讲过怎么创建，名字可以取成 <code>PicGo</code> 类似的名字，主要用于存放图片。</p></li><li><p>生成 Token  </p><p>点击头像 <code>Settings -&gt; Developer settings -&gt; Personal access tokens</code> 点击  <code>Generate new token</code>  </p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://raw.githubusercontent.com/CalmCenter/picGo/master/picturesnew_token.png" style="zoom:80%"><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://raw.githubusercontent.com/CalmCenter/picGo/master/picturesaccess_tokens.png" style="zoom:30%"><p>点击最下面的  <code>Generate token</code> ，会出现 <code>token</code> ，这个 <code>token</code> 只出现一次，所以要保存一下</p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://raw.githubusercontent.com/CalmCenter/picGo/master/picturesaccess_token.png" style="zoom:50%"></li><li><p>配置 <code>PicGo</code> 客户端</p></li></ol><p>打开 <code>PicGo</code> ，输入相关信息</p><ul><li>仓库名 即你的仓库名</li><li>分支名 默认 master</li><li>Token 就是刚刚复制的那一串字符</li><li>存储路径 这个可以填也可以不填，填了的话图片就上传到这个文件夹，比如 <code>picture/</code> 图中少一个 <code>/</code></li><li>自定义域名 这个要改一下 格式： <code>https://raw.githubusercontent.com/[仓库名]/master</code> </li></ul><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://raw.githubusercontent.com/CalmCenter/picGo/master/picturespic_go_token.png" style="zoom:50%"><p>然后点确定就OK了，不妨试试。</p><p>还有一个方便的操作就是 修改上传快捷键 ，快捷键直接上传，跳过拖入上传区</p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://raw.githubusercontent.com/CalmCenter/picGo/master/pictures/20190426111300.png" style="zoom:50%"><h2 id="图片全屏查看"><a href="#图片全屏查看" class="headerlink" title="图片全屏查看"></a>图片全屏查看</h2><p>首先进入 <code>hexo/themes/next/source/lib</code> 目录，下载插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;theme-next-fancybox3 fancybox</span><br></pre></td></tr></table></figure><p>然后更改 <code>NexT 配置文件</code> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fancybox: true</span><br></pre></td></tr></table></figure><p>完成 ~ </p><p><strong>注意:如果你是 <code>git</code> 直接 <code>clone</code> 的，会自带 <code>.git</code> 和 <code>.github</code> 文件，需要删掉 <code>.git</code> 和 <code>.github</code> 文件，如果不删在 <a href="https://calmcenter.club/2019/Hexo_code_management.html">Hexo 管理代码</a> 一文中会出现 <code>them/next/source/lib/fancybox</code> 里的文件提交不上去的问题</strong></p><h2 id="打赏功能"><a href="#打赏功能" class="headerlink" title="打赏功能"></a>打赏功能</h2><p>参考自作者 <a href="https://blog.enjoytoshare.club/article/hexo-do-donate.html" target="_blank" rel="noopener">EnjoyToShare 《Hexo的NexT主题打赏功能》</a>  </p><p>准备好收款二维码，放入 <code>hexo/themes/next/source/images</code> ，打开 <code>NexT 配置文件</code> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">reward_settings:</span><br><span class="line">  enable: true</span><br><span class="line">  animation: false</span><br><span class="line">  comment: 分享不易，可否赏杯咖啡钱</span><br><span class="line">reward:</span><br><span class="line">  wechatpay: &#x2F;images&#x2F;wechatpay.png</span><br><span class="line">  alipay: &#x2F;images&#x2F;alipay.png</span><br><span class="line">  #bitcoin: &#x2F;images&#x2F;bitcoin.png</span><br></pre></td></tr></table></figure><h2 id="评论功能"><a href="#评论功能" class="headerlink" title="评论功能"></a>评论功能</h2><p>参考自作者 <a href="https://blog.enjoytoshare.club/article/hexo-do-gitalk.html" target="_blank" rel="noopener">EnjoyToShare 《Hexo NexT 加入评论功能gitalk》</a>  </p><p><code>Gitalk</code> :</p><ul><li>一个基于 <code>Github Issue</code> 和 <code>Preact</code> 开发的评论插件</li><li>详情 <code>Demo</code> 可见:  <a href="https://gitalk.github.io/" target="_blank" rel="noopener">https://gitalk.github.io/</a></li></ul><p>增加评论区</p><ul><li>注册 <code>OAuth Application</code></li><li>在 <code>GitHub</code> 上注册新应用, 链接:  <a href="https://github.com/settings/applications/new" target="_blank" rel="noopener">https://github.com/settings/applications/new</a> </li></ul><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">Application name</td><td align="left">应用名称, 可以任意填入</td></tr><tr><td align="left">Homepage URL</td><td align="left">网站URL, 注意用https://开头</td></tr><tr><td align="left">Application description</td><td align="left">应用描述, 可以任意填入</td></tr><tr><td align="left">Authorization callback URL</td><td align="left">网站URL, 注意用https://开头</td></tr></tbody></table><p>注册后记录 <code>Client ID</code> 和 <code>Client Secret</code> , 后续要使用到。</p><p>打开 <code>NexT 配置文件</code> ， <strong>根据自己信息</strong> 进行一下修改，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gitalk:</span><br><span class="line">  enable: true</span><br><span class="line">  github_id: CalmCenter</span><br><span class="line">  repo: calmcenter.github.io</span><br><span class="line">  client_id: ****</span><br><span class="line">  client_secret: ****</span><br><span class="line">  admin_user: CalmCenter  </span><br><span class="line">  distraction_free_mode: true </span><br><span class="line">  language:</span><br></pre></td></tr></table></figure><p> 集成过程中出现的错误 <a href="https://liujunzhou.top/2018/8/10/gitalk-error/#%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B" target="_blank" rel="noopener">Junzhou Liu</a> 这里给出了很多，但是在我集成是发现有的 <code>NexT</code> 已经修正，所以这里说几点需要注意的地方。</p><ul><li>你的评论仓库或者 <code>GitHub Page</code> 仓库必须是 <code>public</code> ， <code>NexT 配置文件</code> 的 <code>reop</code> 指定的仓库名称也必须是 <code>public</code> ，否者可能出现 <code>404</code> 的错误</li><li><code>NexT</code> 中的字段配置 和 <code>Gitalk</code> 有两个不一样，需要用 <code>NexT</code> 指定的，否者会出现 <code>Erroe Not Found</code> </li></ul><p>如果错误修改后没反应，试一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure><p>重新编译运行。</p><p>成功后会提示你未找到相关 <code>issues</code>  ，需要你登录</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://raw.githubusercontent.com/CalmCenter/picGo/master/pictures/20190426155441.png" alt=""></p><p><strong>如果有自己的域名记得把 Authorization callback URL 设置成自己的 域名地址</strong> <code>Authorization callback URL</code> 在 <a href="https://github.com/settings/developers" target="_blank" rel="noopener">github setting</a> 点击自己绑定的进去修改</p><p><strong>2019/5/10 踩坑记录，文章的文件名，中文会有问题，导致一直跳转首页并登陆不上，title  可以是中文</strong></p><h2 id="代码块复制功能"><a href="#代码块复制功能" class="headerlink" title="代码块复制功能"></a>代码块复制功能</h2><p>在 <code>NexT 配置文件</code> 中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">codeblock:</span><br><span class="line">  border_radius:</span><br><span class="line">  copy_button:</span><br><span class="line">    enable: true</span><br><span class="line">    show_result: true</span><br><span class="line">    style:</span><br></pre></td></tr></table></figure><p><code>NexT</code> 随着版本的升级，省去了很多操作，基本都剩开关的设置了</p><h2 id="DaoVoice-实现在线联系"><a href="#DaoVoice-实现在线联系" class="headerlink" title="DaoVoice 实现在线联系"></a><code>DaoVoice</code> 实现在线联系</h2><ol><li><p>注册登录 <code>DaoVoice</code></p><p><a href="http://www.daovoice.io/" target="_blank" rel="noopener">DaoVoice</a> 点击进行登录注册，邀请码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c1f73bd5</span><br></pre></td></tr></table></figure><p>登录成功后，你可能是这个目录</p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://raw.githubusercontent.com/CalmCenter/picGo/master/pictures/20190428141105.png" style="zoom:50%"><p>这样的话你需要关掉这个页面，重新进入 <a href="http://www.daovoice.io/" target="_blank" rel="noopener">DaoVoice</a> 点击登录，如果最后看到是这个目录</p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://raw.githubusercontent.com/CalmCenter/picGo/master/pictures/20190428141212.png" style="zoom:50%"><p>那就可以继续下面的 ~ </p></li><li><p>集成 </p><p>找到你的 <code>app_id</code></p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://raw.githubusercontent.com/CalmCenter/picGo/master/pictures/20190428141938.png" style="zoom:30%"><p>并将 <code>1</code> 和 <code>2</code> 的代码 粘贴到 <code>themes/next/layout/_partials/head.swig</code> </p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://raw.githubusercontent.com/CalmCenter/picGo/master/pictures/20200516194622.png" style="zoom:70%"><p><strong>有两处需要填写你的 <code>appid</code> 并且要加 <code>if</code> 开始和结束代码</strong></p><p>然后再  <code>NexT 配置文件</code> 中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">daovoice: true</span><br><span class="line">daovoice_app_id: 你的appid</span><br></pre></td></tr></table></figure><p>编译并运行 <code>Hexo</code> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure><p>会发现 <code>DaoVoice</code> 官网会提示</p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://raw.githubusercontent.com/CalmCenter/picGo/master/pictures/20190428143112.png" style="zoom:30%"></li><li><p>绑定微信</p><p>点击右上角头像，然后点击绑定微信</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://raw.githubusercontent.com/CalmCenter/picGo/master/pictures/20190428143854.png" alt=""></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://raw.githubusercontent.com/CalmCenter/picGo/master/pictures/20190428143916.png" alt=""></p><p>这样，可以同时在 <code>DaoVoice</code> 网页的对话页面，和微信小程序 <code>DaoVoice</code> 同时回复~ </p></li></ol><h2 id="文章置顶"><a href="#文章置顶" class="headerlink" title="文章置顶"></a>文章置顶</h2><ol><li><p>将 <code>node_modules/hexo-generator-index/lib/generator.js</code> 文件内的内容替换为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#39;use strict&#39;;</span><br><span class="line">var pagination &#x3D; require(&#39;hexo-pagination&#39;);</span><br><span class="line">module.exports &#x3D; function(locals)&#123;</span><br><span class="line">    var config &#x3D; this.config;</span><br><span class="line">    var posts &#x3D; locals.posts;</span><br><span class="line">    posts.data &#x3D; posts.data.sort(function(a, b) &#123;</span><br><span class="line">        if(a.top &amp;&amp; b.top) &#123; &#x2F;&#x2F; 两篇文章top都有定义</span><br><span class="line">            if(a.top &#x3D;&#x3D; b.top) return b.date - a.date; &#x2F;&#x2F; 若top值一样则按照文章日期降序排</span><br><span class="line">            else return b.top - a.top; &#x2F;&#x2F; 否则按照top值降序排</span><br><span class="line">        &#125;</span><br><span class="line">        else if(a.top &amp;&amp; !b.top) &#123; &#x2F;&#x2F; 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233）</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(!a.top &amp;&amp; b.top) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else return b.date - a.date; &#x2F;&#x2F; 都没定义按照文章日期降序排</span><br><span class="line">    &#125;);</span><br><span class="line">    var paginationDir &#x3D; config.pagination_dir || &#39;page&#39;;</span><br><span class="line">    return pagination(&#39;&#39;, posts, &#123;</span><br><span class="line">    perPage: config.index_generator.per_page,</span><br><span class="line">    layout: [&#39;index&#39;, &#39;archive&#39;],</span><br><span class="line">    format: paginationDir + &#39;&#x2F;%d&#x2F;&#39;,</span><br><span class="line">    data: &#123;</span><br><span class="line">      __index: true</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>在文章头部添加 <code>top</code> 值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">title: Hexo 搭建博客大全</span><br><span class="line">date: 2019-04-18 17:32:22</span><br><span class="line">categories: Hexo</span><br><span class="line">tags: [Hexo, NexT, 博客]</span><br><span class="line">top: 100</span><br></pre></td></tr></table></figure></li></ol><h2 id="搜索功能"><a href="#搜索功能" class="headerlink" title="搜索功能"></a>搜索功能</h2><ol><li><p>安装插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure></li><li><p>在 <code>Hexo 配置文件</code> 中添加 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#本地搜索</span><br><span class="line">search:</span><br><span class="line">    path: search.xml</span><br><span class="line">    field: post</span><br><span class="line">    format: html</span><br><span class="line">    limit: 10000</span><br></pre></td></tr></table></figure></li><li><p>在 <code>NexT 配置文件</code> 启动搜索功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">local_search:</span><br><span class="line">    enable: true</span><br><span class="line">    trigger: auto</span><br><span class="line">    top_n_per_article: 1</span><br><span class="line">    unescape: false</span><br></pre></td></tr></table></figure></li><li><p>完成，清理缓存编译运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure></li></ol><h2 id="隐藏特定文章"><a href="#隐藏特定文章" class="headerlink" title="隐藏特定文章"></a>隐藏特定文章</h2><p>比如说没写完的 ~ </p><p>首先修改 <code>/themes/next/layout/index.swig</code> 文件，把</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% for post in page.posts %&#125;</span><br><span class="line">  &#123;&#123; post_template.render(post, true) &#125;&#125;</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure><p>替换成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;% for post in page.posts %&#125;</span><br><span class="line">   &#123;% set hide &#x3D; false %&#125;</span><br><span class="line">   &#123;% if theme.hide.hide_post %&#125;</span><br><span class="line">     &#123;% if post.hide %&#125;</span><br><span class="line">       &#123;% set hide &#x3D; true %&#125;</span><br><span class="line">     &#123;% endif %&#125;</span><br><span class="line">   &#123;% endif %&#125;</span><br><span class="line">   &#123;% if !hide %&#125;</span><br><span class="line">     &#123;&#123; post_template.render(post, true) &#125;&#125;</span><br><span class="line">   &#123;% endif %&#125;</span><br><span class="line"> &#123;% endfor %&#125;</span><br></pre></td></tr></table></figure><p>在 <code>NexT 配置文件</code>  添加代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Hide single post</span><br><span class="line">hide:</span><br><span class="line">  hide_post: true</span><br></pre></td></tr></table></figure><h2 id="细节美化"><a href="#细节美化" class="headerlink" title="细节美化"></a>细节美化</h2><h3 id="头像"><a href="#头像" class="headerlink" title="头像"></a>头像</h3><p>在<code>NexT 配置文件</code> 中，找到 <code>avatar</code> 字段</p><table><thead><tr><th>字段</th><th>作用</th></tr></thead><tbody><tr><td>url</td><td>图片相对位置(/image/xxx.png)图片保存在  \hexo\themes\next\source\images 文件下</td></tr><tr><td>rounded</td><td>是否启用圆角</td></tr><tr><td>opacity</td><td>透明度</td></tr><tr><td>rotated</td><td>旋转动画</td></tr></tbody></table><h3 id="回到顶部"><a href="#回到顶部" class="headerlink" title="回到顶部"></a>回到顶部</h3><p>打开 <code>NexT 配置文件</code> 搜索 <code>back2top</code>  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">back2top:</span><br><span class="line">  enable: true</span><br><span class="line">  # 回到侧边栏顶部.</span><br><span class="line">  sidebar: true</span><br><span class="line">  # 滚动%标签.</span><br><span class="line">  scrollpercent: true</span><br></pre></td></tr></table></figure><h3 id="页面底部优化"><a href="#页面底部优化" class="headerlink" title="页面底部优化"></a>页面底部优化</h3><ul><li>跳动的心</li></ul><p>参考自作者 <a href="https://11.tt/posts/2018/set-up-hexo-with-coding-and-github/" target="_blank" rel="noopener">十一種情緒的堆棧</a> 在这篇文章 1/2 处左右</p><p>效果就在本页面底部 ~ ，首先先去 <a href="https://fontawesome.com/v4.7.0/icons/" target="_blank" rel="noopener">The Icons</a> 选择一张图片，例如搜索 <code>heartbeat</code> ，点击进去将图片代码 <code>fa-heartbeat</code> 复制下来，打开<code>NexT 配置文件</code> ，搜索 <code>footer</code> 关键字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">footer:</span><br><span class="line">  icon:</span><br><span class="line">    name: fas fa-heartbeat</span><br><span class="line">    animated: true</span><br><span class="line">    color: &quot;#ff0000&quot;</span><br></pre></td></tr></table></figure><p>需要将复制的图片代码粘贴到 <code>name</code> 字段，并且前面加上 fas ，如果需要动画的话，将 <code>animated</code> 设置为 <code>true</code> ，并将 <code>color</code> 修改为 <code>#ff0000</code> 。就和我底部效果一样了啦。</p><ul><li>访问统计</li></ul><p>还是在 <code>NexT 配置文件</code> ，搜索 <code>busuanzi_count</code> 字段。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">busuanzi_count:</span><br><span class="line">  enable: true</span><br><span class="line">  total_visitors: true</span><br><span class="line">  total_visitors_icon: user</span><br><span class="line">  total_views: true</span><br><span class="line">  total_views_icon: eye</span><br><span class="line">  post_views: true</span><br><span class="line">  post_views_icon: eye</span><br></pre></td></tr></table></figure><p>将 <code>enable</code> 设置为 <code>true</code> 就有和我底部一样的 访问统计 功能了</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://raw.githubusercontent.com/CalmCenter/picGo/master/picturesvisit.png" alt=""></p><p>统计这块还可以添加一个字数和阅读时长统计，在<code>hexo</code> 根目录配置文件 <code>hexo/_config.yml</code> 搜索 <code>symbols_count_time</code> 如果没有则添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">symbols_count_time:</span><br><span class="line"> symbols: true </span><br><span class="line"> time: true </span><br><span class="line"> total_symbols: true </span><br><span class="line"> total_time: true</span><br></pre></td></tr></table></figure><p>在 <code>NexT 配置文件</code> 搜索 <code>symbols_count_time</code> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">symbols_count_time:</span><br><span class="line">  separated_meta: true</span><br><span class="line">  item_text_post: true</span><br><span class="line">  item_text_total: false</span><br><span class="line">  awl: 4</span><br><span class="line">  wpm: 275</span><br></pre></td></tr></table></figure><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://raw.githubusercontent.com/CalmCenter/picGo/master/picturesnumber.png" alt=""></p><p><strong>注: 格式很重要</strong> </p><h3 id="圆角布局"><a href="#圆角布局" class="headerlink" title="圆角布局"></a>圆角布局</h3><p>参考自作者 <a href="https://blog.enjoytoshare.club/article/hexo-do-optimization.html" target="_blank" rel="noopener">EnjoyToShare</a> 在这篇文章 3.12，这篇里边还有好多好看的样式 ~</p><p>在 <code>/themes/next/source/css/_variables</code> 中的 <code>Gemini.styl</code> 文件添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 修改主题页面布局为圆角</span><br><span class="line">$border-radius-inner            &#x3D; 15px 15px 15px 15px;</span><br><span class="line">$border-radius                  &#x3D; 15px;</span><br></pre></td></tr></table></figure><h3 id="文章标签、分类"><a href="#文章标签、分类" class="headerlink" title="文章标签、分类"></a>文章标签、分类</h3><p>我们在用 <code>hexo new post</code> 创建文件时</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new post &quot;name&quot;</span><br></pre></td></tr></table></figure><p><code>hexo</code> 自动为我们的文章头部生成了如下的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">title: 标题</span><br><span class="line">date: 2019-04-18 17:32:22</span><br></pre></td></tr></table></figure><ul><li>首先添加分类</li></ul><p>在 <code>data</code> 下方添加 <code>categories</code> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">title: 标题</span><br><span class="line">date: 2019-04-18 17:32:22</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">categories: Hexo</span><br></pre></td></tr></table></figure><p><strong>注意：英文冒号，还有一个空格</strong></p><p>这样分类就添加上了，还需要给分类一个跳转页，创建一个 <code>categories.md</code> 用于跳转</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure><p>会提示我们输入目录 <code>/source/categories/index.md</code>  ，打开这个 <code>index.md</code> ，加入 <code>type</code> 这个页面用于做什么的，<code>comment</code> 是否开启评论，前提是你有评论功能的话。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">title: categories</span><br><span class="line">date: 2019-04-25 14:53:31</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type: categories</span><br><span class="line">comments: false</span><br></pre></td></tr></table></figure><p>这样分类就设置好了，检查一下 <code>Hexo 配置文件</code> ，搜索  <code>category_dir</code> 字段 <code>category_dir: categories</code> 这里已经设置了分类夹的名称，如果之前创建的文件夹完成和这个不一样，需要统一才行。</p><ul><li>添加标签</li></ul><p>同样在 <code>Hexo 配置文件</code> 搜索，<code>tag_dir</code> 可以知道 <code>tag</code> 设置好的文件夹名称，<code>tag_dir: tags</code>  ，我们可以在 <code>categories</code> 下添加 <code>tags</code> 来添加标签。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tags: [Hexo, NexT, 博客]</span><br></pre></td></tr></table></figure><p>然后添加跳转页面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure><p>创建完成后，为 <code>tags/index.md</code> 添加内容 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">title: categories</span><br><span class="line">date: 2019-04-25 15:34:07</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type: tags</span><br><span class="line">comments: false</span><br></pre></td></tr></table></figure><p>标签比分类多一步，我们需要安装一个插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-tag --save</span><br></pre></td></tr></table></figure><p>这样 <code>hexo g &amp;&amp; hexo s</code> 编译并运行，本地就可以看到了，标签在文章底部，发现它是 <code># xxx</code> 很难看，修改的 <code>#</code> 需要找到 <code>/themes/next/layout/_macro/post.swig</code> ，搜索 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rel&#x3D;&quot;tag&quot;&gt;#</span><br></pre></td></tr></table></figure><p>将 <code>#</code> 换成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;i class&#x3D;&quot;fa fa-tag&quot;&gt;&lt;&#x2F;i&gt;</span><br></pre></td></tr></table></figure><p>这里的 <code>fa-tag</code> 也是在 <a href="https://fontawesome.com/v4.7.0/icons/" target="_blank" rel="noopener">The Icons</a> 中的图片。</p><ul><li>将标签、分类添加至做出菜单栏</li></ul><p>打开 <code>NexT 配置文件</code>   搜索 <code>menu</code> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: &#x2F; || home</span><br><span class="line">  #about: &#x2F;about&#x2F; || user</span><br><span class="line">  tags: &#x2F;tags&#x2F; || tags</span><br><span class="line">  categories: &#x2F;categories&#x2F; || th</span><br><span class="line">  archives: &#x2F;archives&#x2F; || archive</span><br><span class="line">  #schedule: &#x2F;schedule&#x2F; || calendar</span><br><span class="line">  #sitemap: &#x2F;sitemap.xml || sitemap</span><br><span class="line">  #commonweal: &#x2F;404&#x2F; || heartbeat</span><br></pre></td></tr></table></figure><p>将 <code>tags</code> 和 <code>categories</code> 打开，完成 ~ </p><h3 id="强调颜色"><a href="#强调颜色" class="headerlink" title="强调颜色"></a>强调颜色</h3><p>参考自作者 <a href="https://www.jianshu.com/p/f054333ac9e6" target="_blank" rel="noopener">Moorez</a> </p><ul><li>‘’ 内容样式的修改</li></ul><p>打开 <code>/hemes/next/source/css/_custom/custom.styl</code> ，在里面加入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Custom styles.</span><br><span class="line">code &#123;</span><br><span class="line">    color: #ff7600;</span><br><span class="line">    background: #fbf7f8;</span><br><span class="line">    margin: 2px;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 大代码块的自定义样式</span><br><span class="line">.highlight, pre &#123;</span><br><span class="line">    margin: 5px 0;</span><br><span class="line">    padding: 5px;</span><br><span class="line">    border-radius: 3px;</span><br><span class="line">&#125;</span><br><span class="line">.highlight, code, pre &#123;</span><br><span class="line">    border: 1px solid #d6d6d6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>链接样式修改</li></ul><p>修改文件 <code>/themes/next/source/css/_common/components/post/post.styl</code>，在末尾添加如下css样式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 文章内链接文本样式</span><br><span class="line">.post-body p a&#123;</span><br><span class="line">  color: #0593d3;</span><br><span class="line">  border-bottom: none;</span><br><span class="line">  border-bottom: 1px solid #0593d3;</span><br><span class="line">  &amp;:hover &#123;</span><br><span class="line">    color: #fc6423;</span><br><span class="line">    border-bottom: none;</span><br><span class="line">    border-bottom: 1px solid #fc6423;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置网站图标</p><h3 id="设置网站图标"><a href="#设置网站图标" class="headerlink" title="设置网站图标"></a>设置网站图标</h3><p>参考自作者 <a href="https://www.jianshu.com/p/f054333ac9e6" target="_blank" rel="noopener">Moorez</a> </p><p>首先找一张喜欢的图片，可以在 <a href="http://www.easyicon.net/" target="_blank" rel="noopener">EasyIcon</a> 中或其他任意地方，分别下载 <code>32px</code> 和 <code>16px</code> 两张，然后放到 <code>/themes/next/source/images</code> 里，然后修改 <code>NexT 配置文件</code>  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">favicon:</span><br><span class="line">  small: &#x2F;images&#x2F;c_16.png</span><br><span class="line">  medium: &#x2F;images&#x2F;c_32.png</span><br><span class="line">  apple_touch_icon: &#x2F;images&#x2F;apple-touch-icon-next.png</span><br><span class="line">  safari_pinned_tab: &#x2F;images&#x2F;logo.svg</span><br></pre></td></tr></table></figure><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://raw.githubusercontent.com/CalmCenter/picGo/master/picturesblog_title.png" style="zoom:100%"><h3 id="主页文章添加边框阴影效果"><a href="#主页文章添加边框阴影效果" class="headerlink" title="主页文章添加边框阴影效果"></a>主页文章添加边框阴影效果</h3><p>在 <code>theme/next/source/css/_custom/custom.styl</code>  文件下添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 主页文章添加阴影效果</span><br><span class="line">.posts-expand &#123; </span><br><span class="line">.post &#123;</span><br><span class="line">margin-top: 30px;</span><br><span class="line">margin-bottom: 30px;</span><br><span class="line">&#x2F;&#x2F;border-radius: 15px;</span><br><span class="line">-webkit-box-shadow: 5px 5px 20px rgba(119,118,118,.6);</span><br><span class="line">-moz-box-shadow: 5px 5px 20px rgba(119,118,118,.6);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很多博客上都没有 <code>posts-expand</code> 这一层，如果没有这一层，你的归档页面将会变得很丑~如果你用了之前的圆角布局，需要把 <code>border-radius: 15px;</code> 的注释删掉。</p><p>应用主要作用实在 <code>-webkit-box-shadow</code> 和 <code>-moz-box-shadow</code> 属性上。</p><p>基于主流浏览器上使用 <code>box-shadow</code> 属性时，我们需要将属性的名称写成 <code>-webkit-box-shadow</code> 的形式。Firefox浏览器则需要写成 <code>-moz-box-shadow</code> 的形式。</p><p>四个值分别为 <code>X轴</code>与 <code>Y轴</code> 移动 、<code>阴影值大小</code> 、<code>阴影颜色rgba</code></p><hr><h1 id="更多样式修改-💦💦"><a href="#更多样式修改-💦💦" class="headerlink" title="更多样式修改 💦💦"></a>更多样式修改 💦💦</h1><p><a href="https://bestzuo.cn/posts/1689445187.html" target="_blank" rel="noopener">Sanarous Hexo博客界面美化2.0</a></p><p><a href="https://leafjame.github.io/posts/2114475547.html" target="_blank" rel="noopener">Leaface Hexo NexT主题美化2.0</a></p><p><a href="https://walesexcitedmei.github.io/2018/08/30/HEXO-NexT-%E4%B8%BB%E9%A2%98%E6%8F%90%E9%AB%98%E5%8D%9A%E5%AE%A2%E9%A2%9C%E5%80%BC/" target="_blank" rel="noopener">[HEXO] NexT 主题提高博客颜值</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> git </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Live2D 看板娘</title>
      <link href="/2019/hexo-live2d.html"/>
      <url>/2019/hexo-live2d.html</url>
      
        <content type="html"><![CDATA[<p>目录请看  <a href="https://calmcenter.club/2019/Complete_works_of_hexo.html">Hexo 搭建博客大全</a></p><p><strong>注意：如果出现图片不显示问题请移步</strong> <a href="https://calmcenter.club/2019/PicNotShow.html">图片不显示问题</a></p><h2 id="本文主要记载"><a href="#本文主要记载" class="headerlink" title="本文主要记载"></a>本文主要记载</h2><ul><li>使用 <code>hexo-helper-live2d</code> 完成看板娘</li><li>自定义看板娘(右下角那个~)<ul><li>运行、接入 <code>Demo</code></li><li>更换、修改模型</li></ul></li></ul><hr><h2 id="使用-hexo-helper-live2d-完成看板娘"><a href="#使用-hexo-helper-live2d-完成看板娘" class="headerlink" title="使用 hexo-helper-live2d 完成看板娘"></a>使用 <code>hexo-helper-live2d</code> 完成看板娘</h2><p>我的 <code>Live2D</code> 版本是 <code>3.1.1</code></p><p>首先安装配置 hexo-helper-live2d，在 <code>hexo</code> 根目录下执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-helper-live2d --save</span><br></pre></td></tr></table></figure><p>插件就安装完成了，你可一下选一个 <a href="https://huaji8.top/post/live2d-plugin-2.0/" target="_blank" rel="noopener">模型</a> 这个给出了展示效果，但是不全， <a href="https://github.com/xiazeyu/live2d-widget-models" target="_blank" rel="noopener">更多模型</a> 这个没有展示效果，比之前的全一点，可以自己试试效果 ~</p><p>在模型中记住自己选择模型的名字 <code>live2d-widget-model-你选中的模型名字</code> ，然后进行安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install live2d-widget-model-wanko --save</span><br></pre></td></tr></table></figure><p>然后再 <code>Hexo 配置文件</code> 中，添加如下代码，<strong>代码格式很重要！！！</strong> 有时候复制进去没有缩进，效果是出不来的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">live2d:</span><br><span class="line">  enable: true</span><br><span class="line">  scriptFrom: local</span><br><span class="line">  pluginRootPath: live2dw&#x2F;</span><br><span class="line">  pluginJsPath: lib&#x2F;</span><br><span class="line">  pluginModelPath: assets&#x2F;</span><br><span class="line">  tagMode: false</span><br><span class="line">  debug: false</span><br><span class="line">  model:</span><br><span class="line">    use: live2d-widget-model-wanko</span><br><span class="line">  display:</span><br><span class="line">    position: left</span><br><span class="line">    width: 150</span><br><span class="line">    height: 300</span><br><span class="line">  mobile:</span><br><span class="line">    show: true</span><br><span class="line">  react:</span><br><span class="line">    opacity: 0.7</span><br></pre></td></tr></table></figure><p>这样一只可爱的小白狗就出现了。</p><p>如果要加载自定义模型，需要在根目录新建文件夹 <code>live2d_models</code> 下，再新建一个文件夹 <code>kesshouban （此处自定义）</code> 然后将资源文件放入 <code>kesshouban</code> 内 。然后修改 <code>Hexo 配置文件</code> ，将 <code>model.use</code> 写成 <code>kesshouban</code> 。</p><h2 id="自定义看板娘"><a href="#自定义看板娘" class="headerlink" title="自定义看板娘"></a>自定义看板娘</h2><p>首先感谢 <a href="https://haokan.baidu.com/v?pd=wisenatural&vid=11405187949707723550" target="_blank" rel="noopener">大佬</a> 提供的视屏教程，清晰易懂。</p><p>感谢 <a href="https://github.com/galnetwen" target="_blank" rel="noopener">galnetwen</a> 提供的代码。</p><h3 id="1-运行-Demo"><a href="#1-运行-Demo" class="headerlink" title="1. 运行 Demo"></a>1. 运行 <code>Demo</code></h3><p>首先你需要将 <a href="https://github.com/galnetwen/Live2D" target="_blank" rel="noopener">代码</a> 下载下来</p><p>解压代码并将 <code>Live2D-master</code> 里的内容 <code>live2d</code> 和 <code>demo.html</code> ，解压到 <code>hexo</code> 根目录的 <code>public</code> 的文件夹下。并运行且进入本地访问</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:4000&#x2F;demo.html</span><br></pre></td></tr></table></figure><p>如果出现 <a href="https://play.google.com/store/apps/details?id=com.sinsiroad.potionmaker&hl=zh_CN" target="_blank" rel="noopener">药水制作师</a> 里的模型，就可以啦，如果出不来，证明你路径有问题，请检查路径， <code>live2d</code> 和 <code>demo.html</code> 文件在 <code>public</code> 文件夹下。</p><h3 id="2-接入-Demo"><a href="#2-接入-Demo" class="headerlink" title="2. 接入 Demo"></a>2. 接入 <code>Demo</code></h3><p>将 <code>live2d</code> 文件夹剪切到 <code>hexo/themes/next/source</code> , 文件夹内应该有三个文件夹 <code>css js model</code> 和一个文件 <code>message.json</code> 。</p><p>然后将 <code>demo.html</code> 中的代码整理出来</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"/live2d/css/live2d.css"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"landlord"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"message"</span> <span class="attr">style</span>=<span class="string">"opacity:0"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"live2d"</span> <span class="attr">width</span>=<span class="string">"280"</span> <span class="attr">height</span>=<span class="string">"250"</span> <span class="attr">class</span>=<span class="string">"live2d"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"hide-button"</span>&gt;</span>隐藏<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/jquery/2.2.4/jquery.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">  <span class="keyword">var</span> message_Path = <span class="string">'/live2d/'</span></span></span><br><span class="line"><span class="actionscript">  <span class="keyword">var</span> home_Path = <span class="string">'https://calmcenter.club/'</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"/live2d/js/live2d.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"/live2d/js/message.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">  loadlive2d(<span class="string">"live2d"</span>, <span class="string">"/live2d/model/tia/model.json"</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>粘贴到 <code>/theme/next/layout/layout.swig</code> 的 <code>&lt;footer&gt;</code> 标签下</p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://raw.githubusercontent.com/CalmCenter/picGo/master/pictures/20190509151030.png" style="zoom:50%"><p>执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure><p>看板娘就到我们的博客上来啦~</p><h3 id="3-更换模型"><a href="#3-更换模型" class="headerlink" title="3. 更换模型"></a>3. 更换模型</h3><p>感谢 <a href="https://imjad.cn/" target="_blank" rel="noopener">猫与向日葵</a> 提供血小板模型 <a href="https://cdn.imjad.cn/usr/uploads/kesshouban_v2.7z" target="_blank" rel="noopener">下载地址</a></p><p>在 <code>hexo/next/source/live2d/model</code> 中新建一个文件夹，将压缩包里面的内容，也就是模型放到里面，然后修改 <code>model.json</code> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;type&quot;: &quot;Live2D Model Setting&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;model&quot;,</span><br><span class="line">    &quot;version&quot;:&quot;1.0.0&quot;,</span><br><span class="line">    &quot;model&quot;: &quot;model.moc&quot;,</span><br><span class="line">    &quot;textures&quot;: [</span><br><span class="line">      &quot;model.2048&#x2F;texture_00.png&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;layout&quot;:&#123;</span><br><span class="line">      &quot;center_x&quot;:0.0,</span><br><span class="line">      &quot;center_y&quot;:0.05,</span><br><span class="line">      &quot;width&quot;:1.8</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;hit_areas_custom&quot;:&#123;</span><br><span class="line">      &quot;head_x&quot;:[-0.35, 0.6],</span><br><span class="line">      &quot;head_y&quot;:[0.19, -0.2],</span><br><span class="line">      &quot;body_x&quot;:[-0.3, -0.25],</span><br><span class="line">      &quot;body_y&quot;:[0.3, -0.9]</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;motions&quot;:&#123;</span><br><span class="line">      &quot;idle&quot;:[</span><br><span class="line">        &#123;&quot;file&quot;:&quot;motions&#x2F;Idle.mtn&quot;&#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;sleepy&quot;:[</span><br><span class="line">      &#123;&quot;file&quot;:&quot;motions&#x2F;Nemui.mtn&quot;&#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;flick_head&quot;:[</span><br><span class="line">      &#123;&quot;file&quot;:&quot;motions&#x2F;Anone_Synced.mtn&quot;&#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;tap_body&quot;:[</span><br><span class="line">      &#123;&quot;file&quot;:&quot;motions&#x2F;Dance.mtn&quot;&#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终成这样，一个标点都不能错 ！主要是 <code>layout(用于移动模型位置)</code> 和 <code>hit_areas_custom(用于声明点击事件范围)</code> </p><p>值的算法很简单(自己一点一点试的 = =)，以父布局中心为原点，做直角坐标系~ </p><p>这里感谢 <a href="https://www.jbblogs.cn/" target="_blank" rel="noopener">jacob</a> 与我一起讨论相关内容</p><p>然后将  <code>/theme/next/layout/layout.swig</code> 的 <code>&lt;footer&gt;</code> 添加的那句话</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">loadlive2d(<span class="string">"live2d"</span>, <span class="string">"/live2d/model/xxb/model.json"</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>将 <code>xxb</code> 改成你新建的文件夹名字，编译运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure><h3 id="4-修改模型"><a href="#4-修改模型" class="headerlink" title="4. 修改模型"></a>4. 修改模型</h3><p><a href="https://imjad.cn/archives/lab/add-dynamic-poster-girl-with-live2d-to-your-blog-01" target="_blank" rel="noopener">大佬链接</a></p>]]></content>
      
      
      <categories>
          
          <category> live2D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> live2D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 管理代码</title>
      <link href="/2019/hexo-code-management.html"/>
      <url>/2019/hexo-code-management.html</url>
      
        <content type="html"><![CDATA[<p>目录请看  <a href="https://calmcenter.club/2019/Complete_works_of_hexo.html">Hexo 搭建博客大全</a></p><p><strong>注意：如果出现图片不显示问题请移步</strong> <a href="https://calmcenter.club/2019/PicNotShow.html">图片不显示问题</a></p><h2 id="本文主要记载"><a href="#本文主要记载" class="headerlink" title="本文主要记载"></a>本文主要记载</h2><ul><li><code>git</code> 拉取代码</li><li><code>git</code> 创建分支</li><li><code>git</code> 提交分支代码</li><li>其他终端如何使用 <code>Hexo</code> 源码</li></ul><hr><a id="more"></a><h2 id="一、管理代码"><a href="#一、管理代码" class="headerlink" title="一、管理代码"></a>一、管理代码</h2><p>当我们需要在不同的终端去写博客的时候，发现 <code>github</code> 库中只有编译后的代码，所以我们需要将我们的 <code>hexo</code> 源码页放入 <code>github</code> 的分支中</p><p>首先我们需要拉取所有代码，选择一个空文件夹例如 <code>D:\blog\github_hexo</code> </p><h3 id="1-1-拉取主分支代码"><a href="#1-1-拉取主分支代码" class="headerlink" title="1.1 拉取主分支代码"></a>1.1 拉取主分支代码</h3><h4 id="1-1-1-初始化-git"><a href="#1-1-1-初始化-git" class="headerlink" title="1.1.1 初始化 git"></a>1.1.1 初始化 <code>git</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><h4 id="1-1-2-clone-远程代码，复制刚才的-SSH-路径-或者-HTTPS-路径"><a href="#1-1-2-clone-远程代码，复制刚才的-SSH-路径-或者-HTTPS-路径" class="headerlink" title="1.1.2 clone 远程代码，复制刚才的 SSH 路径 或者 HTTPS 路径"></a>1.1.2 clone 远程代码，复制刚才的 <code>SSH</code> 路径 或者 <code>HTTPS</code> 路径</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone &lt;SSH&#x2F;HTTPS&gt;</span><br></pre></td></tr></table></figure><h4 id="1-1-3-和远程仓库建立关联"><a href="#1-1-3-和远程仓库建立关联" class="headerlink" title="1.1.3 和远程仓库建立关联"></a>1.1.3 和远程仓库建立关联</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin &lt;SSH&#x2F;HTTPS&gt;</span><br></pre></td></tr></table></figure><p>如果 <code>falal：remote origin already exists.</code> ，执行下面命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rm origin</span><br></pre></td></tr></table></figure><p>然后再次建立关联 <code>git remote add origin &lt;SSH/HTTPS&gt;</code> </p><h3 id="1-2-创建分支"><a href="#1-2-创建分支" class="headerlink" title="1.2 创建分支"></a>1.2 创建分支</h3><h4 id="1-2-1-查看分支情况"><a href="#1-2-1-查看分支情况" class="headerlink" title="1.2.1 查看分支情况"></a>1.2.1 查看分支情况</h4><p>进入拉取下来的目录 <code>cd &lt;文件名&gt;</code></p><p>查看分支，查看本地分支包括远程分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure><h4 id="1-2-2-创建本地分支"><a href="#1-2-2-创建本地分支" class="headerlink" title="1.2.2 创建本地分支"></a>1.2.2 创建本地分支</h4><p>创建本地分支并切换到新分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b test</span><br></pre></td></tr></table></figure><p>等价于 <code>git branch test</code> 和 <code>git checkout test</code> </p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://raw.githubusercontent.com/CalmCenter/picGo/master/picturesgit_branch1.png" style="zoom:100%"><p>这里会告诉你本地当前所处的分支，切换分支可以用，<strong>当你切换分支时，如果本地没有但是远程有这个分支，它会自动给你拉取远程分支，并切换</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout test</span><br></pre></td></tr></table></figure><h4 id="1-2-3-更新远程分支"><a href="#1-2-3-更新远程分支" class="headerlink" title="1.2.3 更新远程分支"></a>1.2.3 更新远程分支</h4><p>上图你可以看到本地分支比远程分支多一个 <code>test</code> 下一步就是将新分支推送至远程GitHub</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin test</span><br></pre></td></tr></table></figure><p>完成后，执行查看分支命令 <code>git branch -a</code> 会发现远程 多了 <code>test</code> 分支。</p><p><strong>如果想删掉分支</strong>，删除本地分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d &lt;分支名称&gt;</span><br></pre></td></tr></table></figure><p>提交删除到远程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin --delete &lt;分支名称&gt;</span><br></pre></td></tr></table></figure><h3 id="1-3-提交源码到远程分支"><a href="#1-3-提交源码到远程分支" class="headerlink" title="1.3 提交源码到远程分支"></a>1.3 提交源码到远程分支</h3><h4 id="1-3-1-本地操作代码"><a href="#1-3-1-本地操作代码" class="headerlink" title="1.3.1 本地操作代码"></a>1.3.1 本地操作代码</h4><p>在确保是 <code>test</code> 分支下，然后将 <code>.git</code> 以外的所有文件删掉，将 <code>hexo</code> 源码复制到  <code>D:\blog\github_hexo</code> 下，查看文件状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><p><strong>注意:如果你之前是 <code>git</code> 直接 <code>clone</code> 的 <code>NexT</code> ，在拉取目录会自带 <code>.git</code> 和 <code>.github</code> 文件，需要删掉 <code>.git</code> 和 <code>.github</code> 文件，如果不删会出现拉取目录里的文件提交不上去的问题</strong></p><h3 id="设置语言、标题等"><a href="#设置语言、标题等" class="headerlink" title="设置语言、标题等"></a>设置语言、标题等</h3><h4 id="1-3-2-添加到暂存区"><a href="#1-3-2-添加到暂存区" class="headerlink" title="1.3.2 添加到暂存区"></a>1.3.2 添加到暂存区</h4><p><strong>(最后是一个 . 或者 -A 表示所有)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure><h4 id="1-3-3-提交本地代码库"><a href="#1-3-3-提交本地代码库" class="headerlink" title="1.3.3 提交本地代码库"></a>1.3.3 提交本地代码库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;描述&quot;</span><br></pre></td></tr></table></figure><h4 id="1-3-4-提交到远程分支"><a href="#1-3-4-提交到远程分支" class="headerlink" title="1.3.4 提交到远程分支"></a>1.3.4 提交到远程分支</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure><p>如果提示没有关联，则用下面指令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push --set-upstream origin &lt;分支名&gt;</span><br></pre></td></tr></table></figure><h3 id="1-5-其他终端操作"><a href="#1-5-其他终端操作" class="headerlink" title="1.5 其他终端操作"></a>1.5 其他终端操作</h3><h4 id="1-5-1-hexo-环境搭建"><a href="#1-5-1-hexo-环境搭建" class="headerlink" title="1.5.1 hexo 环境搭建"></a>1.5.1 <code>hexo</code> 环境搭建</h4><p>首先创建一个空目录，初始化 <code>git</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>安装 <code>hexo-cli</code> 执行下面命令，如果该终端执行过可跳过，再次执行会报错，需要删除掉 <code>C:\Users\&lt;电脑名字&gt;\AppData\Roaming</code> 目录下 <code>npm-cache</code> 和 <code>npm</code> 文件，重新执行这个命令就好。<code>(个人多次实践出来的，不行就删。。。)</code> </p><p>如果 <code>hexo</code> 命令执行过程中报 <code>bash: hexo: command not found</code> 就是没有安装 <code>hexo</code> ，需要执行下面的命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure><h4 id="1-5-2-拉取远程分支代码"><a href="#1-5-2-拉取远程分支代码" class="headerlink" title="1.5.2 拉取远程分支代码"></a>1.5.2 拉取远程分支代码</h4><p>然后执行 5.1 的操作 <code>git clone &lt;SSH/HTTPS&gt;</code>、<code>git remote add origin &lt;SSH/HTTPS&gt;</code> ，将远程所有代码拉下来。当前状态你只有主分支代码，你还需要拉取你 <code>test</code> 分支的代码，进入拉取下来的目录 <code>cd &lt;文件名&gt;</code> 。</p><p><code>git branch -a</code> 查看分支情况。然后切换并拉取 <code>test</code> 分支。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout test</span><br></pre></td></tr></table></figure><h4 id="1-5-3-安装环境"><a href="#1-5-3-安装环境" class="headerlink" title="1.5.3 安装环境"></a>1.5.3 安装环境</h4><p>首先在文件目录下，安装 <code>hexo</code> 和 <code>deployer</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo --save</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>然后编译并运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure><p>这样本地就好了，发布 <code>github</code> 需要配置 <code>SSH</code> 和之前 4.3 操作是一样的。</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> git </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 基础搭建</title>
      <link href="/2019/hexo-bash.html"/>
      <url>/2019/hexo-bash.html</url>
      
        <content type="html"><![CDATA[<p>目录请看 <a href="https://calmcenter.club/2019/Complete_works_of_hexo.html">Hexo 搭建博客大全</a></p><p><strong>注意：如果出现图片不显示问题请移步</strong> <a href="https://calmcenter.club/2019/PicNotShow.html">图片不显示问题</a></p><h2 id="本文主要记载"><a href="#本文主要记载" class="headerlink" title="本文主要记载"></a>本文主要记载</h2><ul><li>搭建本地博客</li><li>部署到 <code>Github Pages</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">本文环境是 win10 或 win 7。mac 再执行 npm 时需要在前面添加 sudo</span><br><span class="line">本文整理于各大佬文章，文中会给出相应链接，如有侵权，请联系我修改或删除。</span><br></pre></td></tr></table></figure><hr><a id="more"></a><h2 id="一、-搭建本地博客"><a href="#一、-搭建本地博客" class="headerlink" title="一、 搭建本地博客"></a>一、 搭建本地博客</h2><h3 id="1-1-首先安装-Node-js"><a href="#1-1-首先安装-Node-js" class="headerlink" title="1.1 首先安装 Node.js"></a>1.1 首先安装 <code>Node.js</code></h3><p>首先去 <a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">官方页面</a> 下载安装文件，无脑安装就好 （<del>。</del>）</p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://raw.githubusercontent.com/CalmCenter/picGo/master/picturesnode.png" style="zoom:20%"><p>图中绿色选择部分，安装完成后输入 <code>npm -v</code> , 会告诉你版本号，就证明你安装成功了</p><p>3.2 安装 <code>Git</code></p><p>去 <a href="https://git-scm.com/download/win" target="_blank" rel="noopener">git官网</a> 下载电脑对应版本，进行安装，安装完成后，输入 <code>git version</code> ，会告诉你版本号，就证明你安装成功了。安装成功后，鼠标右键菜单里会多出 <code>Git GUI Here</code> 和 <code>Git Bash Here</code> 两个按钮。</p><p><strong><a href="https://www.cnblogs.com/wj-1314/p/7993819.html" target="_blank" rel="noopener">Git安装教程</a>  这个是百度的，如果不会查看本链接或重新百度就好~</strong></p><p><strong>我管理代码都是在 <a href="https://www.sourcetreeapp.com/" target="_blank" rel="noopener">Sourcetree</a> 上进行，后续会说，当然也是要 Git 的支持，这个还是很方便的，无脑操作~6</strong></p><h3 id="1-2-安装-Hexo"><a href="#1-2-安装-Hexo" class="headerlink" title="1.2 安装 Hexo"></a>1.2 安装 <code>Hexo</code></h3><p>*<em>注意执行命令期间 <code>WARN</code> 不管 只看 <code>ERR</code> *</em></p><p>在文件夹内如 <code>D:\blog</code> ，鼠标右键点击 <code>Git Bash Here</code> 一气呵成，来到了命令行界面。</p><p>首先安装 <code>hexo</code> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure><h4 id="1-2-1-镜像相关（如果-npm-可以正常使用这里跳过！）"><a href="#1-2-1-镜像相关（如果-npm-可以正常使用这里跳过！）" class="headerlink" title="1.2.1 镜像相关（如果 npm 可以正常使用这里跳过！）"></a>1.2.1 镜像相关（如果 npm 可以正常使用这里跳过！）</h4><p> 上面正常情况是没有问题的，但是由于国内访问官方 NPM 源速度较慢，为了一劳永逸，此处可以将 NPM 源更换为了淘宝 NPM 镜像源。<br><strong>请注意!!，如果你觉得你的 NPM 源速度够快，更换镜像源这部分可选择性使用</strong></p><p>在 <code>Git Bash Here</code> 中输入指令，将官方 npm 源更换为淘宝 npm 镜像源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>可以输入 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm config list</span><br></pre></td></tr></table></figure><p> 查看是否更换成功</p><p><strong>请注意，如需使用上方安装的淘宝源，需要在使用 npm 命令时将其改为 cnpm</strong>，但是如果用了 cnpm 再使用 npm 的话，好像有点问题，npm 一直报 err 。所以这里给出卸载镜像的命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall cnpm -g</span><br></pre></td></tr></table></figure><p>但是 npm 命令还是报错，还需要删除掉 <code>C:\Users\&lt;电脑名字&gt;\AppData\Roaming</code> 目录下  <code>npm-cache</code> 和 <code>npm</code> 文件，重新执行上面两个安装命令即可</p><h3 id="1-3-Hexo初始化"><a href="#1-3-Hexo初始化" class="headerlink" title="1.3 Hexo初始化"></a>1.3 Hexo初始化</h3><p>安装完成后，输入 <code>hexo -v</code> 会输出 hexo 版本号，证明安装成功。</p><p>然后在当前目录新建一个文件夹，比如 <code>D:\blog\hexos</code> ，在此目录下鼠标右键点击 <code>Git Bash Here</code> 执行，这条命令需要一个空文件夹所以新建一个。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><p>完成后，文件目录如下</p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://raw.githubusercontent.com/CalmCenter/picGo/master/pictureshexo_file.png" style="zoom:100%"><p>这样就证明初始化完成了，然后我们继续要生成静态页面，用到的命令是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><p>其中，<code>g</code> 的全称是 <code>generate</code>，当然也可以用 <code>hexo generate</code> 这条命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-server --save</span><br></pre></td></tr></table></figure><p>然后就是运行了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>其中， <code>s</code> 的全称是 <code>server</code>，当然也可以用 <code>hexo server</code> 这条命令</p><p>然后，打开你的浏览器，输入<code>http://localhost:4000/</code> 即可看到本地静态博客</p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://raw.githubusercontent.com/CalmCenter/picGo/master/pictureshexo_page.png" style="zoom:20%"><p>本地静态博客完成 ~ </p><p>如果出现 <code>Cannot GET/xxx</code> 等类似错误，意味着有文件未被找到。<code>Cannot GET/xxx</code> 错误本质是 <code>hexo server</code> 返回的一个404错误。</p><p>判断public目录下 <code>xxx</code> 文件是否存在。(我的错误是 <code>Cannot GET/</code> ，因此在public目录下寻找 <code>index.html</code> 是否存在。)</p><p>如果说 <code>index.html</code> 不存在，那么执行 <code>hexo clean</code>，<code>hexo g</code> 重新生成一次，回到步骤1。</p><p>步骤2执行完后 <code>index.html</code> 仍不存在，执行 <code>npm audit fix</code> ，查看是否少了什么组件，通过 <code>npm install hexo-xxx-xxx</code>  安装即可。</p><p>步骤3完成之后，执行 <code>hexo clean</code>，<code>hexo g</code> 重新生成静态文件。</p><p>仍然有问题，请再参考此文：<a href="https://www.cnblogs.com/Sroot/p/6305938.html" target="_blank" rel="noopener">https://www.cnblogs.com/Sroot/p/6305938.html</a></p><p>感谢 <a href="https://www.jianshu.com/p/af83fc73e525" target="_blank" rel="noopener">Cannot GET 错误解决方式 原文地址</a></p><hr><h2 id="二、部署到-Github-Pages"><a href="#二、部署到-Github-Pages" class="headerlink" title="二、部署到 Github Pages"></a>二、部署到 Github Pages</h2><h3 id="2-1-注册Github账户"><a href="#2-1-注册Github账户" class="headerlink" title="2.1 注册Github账户"></a>2.1 注册Github账户</h3><p>进入 <a href="https://github.com/" target="_blank" rel="noopener">github首页</a> ，点击右上角 <a href="https://github.com/join?source=header-home" target="_blank" rel="noopener">sign up</a> 进行注册。</p><h3 id="2-2-创建项目"><a href="#2-2-创建项目" class="headerlink" title="2.2 创建项目"></a>2.2 创建项目</h3><p>登录后，创建一个自己的 <code>GitHub Pages</code>。 点击头像中的 <a href="https://github.com/new" target="_blank" rel="noopener">New repository</a> 。</p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://raw.githubusercontent.com/CalmCenter/picGo/master/picturesnew_repository.png" style="zoom:50%"><p>*<em>敲黑板！！ 这里重点就是项目名称必须是 <code>自己名称.github.io</code>  *</em></p><h3 id="2-3-配置-SSH-密钥"><a href="#2-3-配置-SSH-密钥" class="headerlink" title="2.3 配置 SSH 密钥"></a>2.3 配置 <code>SSH</code> 密钥</h3><h4 id="2-3-1-查看是否存在-SSH-密钥"><a href="#2-3-1-查看是否存在-SSH-密钥" class="headerlink" title="2.3.1 查看是否存在 SSH 密钥"></a>2.3.1 查看是否存在 <code>SSH</code> 密钥</h4><p>首先通过输入命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~&#x2F;. ssh</span><br></pre></td></tr></table></figure><p>如果存在则会进入此目录,可以略过 4.3.2，否则会提示你不存在，那么继续 4.3.2</p><h4 id="2-3-2-创建新的-SSH-密钥"><a href="#2-3-2-创建新的-SSH-密钥" class="headerlink" title="2.3.2 创建新的 SSH 密钥"></a>2.3.2 创建新的 <code>SSH</code> 密钥</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;your_email@example.com&quot;</span><br></pre></td></tr></table></figure><p>这将按照你提供的邮箱地址，创建一对密钥，然后让你输入 密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Enter passphrase (empty for no passphrase): [Type a passphrase]</span><br><span class="line">Enter same passphrase again: [Type passphrase again]</span><br></pre></td></tr></table></figure><p>如果你放心，可以不用密码，直接回车，这样每次提交的时候比较方便。</p><h4 id="2-3-3-在-GitHub-添加你的公钥"><a href="#2-3-3-在-GitHub-添加你的公钥" class="headerlink" title="2.3.3 在 GitHub 添加你的公钥"></a>2.3.3 在 <code>GitHub</code> 添加你的公钥</h4><ol><li>首先拷贝公钥内容（ mac 可能用不了，需要手动找到这个文件复制内容）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clip &lt; ~&#x2F;.ssh&#x2F;id_rsa.pub</span><br></pre></td></tr></table></figure><ol start="2"><li>然后登陆 <a href="https://github.com/" target="_blank" rel="noopener">GitHub</a> ，点击头像</li></ol><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://raw.githubusercontent.com/CalmCenter/picGo/master/picturessetting.png" style="zoom:50%"><ol start="3"><li>进入设置页，选择 <code>SSH</code> </li></ol><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://raw.githubusercontent.com/CalmCenter/picGo/master/picturessetting_list.png" style="zoom:50%"><ol start="4"><li>粘贴密钥，添加即可</li></ol><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://raw.githubusercontent.com/CalmCenter/picGo/master/picturesssh_content.png" style="zoom:50%"><ol start="5"><li>测试</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://raw.githubusercontent.com/CalmCenter/picGo/master/picturestest_ssh.png" style="zoom:100%"><ol start="6"><li>设置用户信息</li></ol><p><code>Git</code> 会根据用户的名字和邮箱来记录提交。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;name&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.email &quot;email&quot;</span><br></pre></td></tr></table></figure><p>这样就配置好了SSH</p><h3 id="2-4-将本地-Hexo-文件编译并上传-GitHub-的库中"><a href="#2-4-将本地-Hexo-文件编译并上传-GitHub-的库中" class="headerlink" title="2.4 将本地 Hexo 文件编译并上传 GitHub 的库中"></a>2.4 将本地 <code>Hexo</code> 文件编译并上传 <code>GitHub</code> 的库中</h3><ol><li>打开 <a href="https://github.com/" target="_blank" rel="noopener">github首页</a> 登录，找到左上角自己的项目</li></ol><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://raw.githubusercontent.com/CalmCenter/picGo/master/picturesgithub_list.png" style="zoom:70%"><ol start="2"><li><p>点击 clone 点击 Use SSH 并复制 <code>SSH</code> 路径</p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://raw.githubusercontent.com/CalmCenter/picGo/master/picturesgithub_ssh_path.png" style="zoom:70%"></li><li><p>打开 <code>hexo</code> 目录，找到 <code>_config</code> 文件</p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://raw.githubusercontent.com/CalmCenter/picGo/master/pictureshexo_catalog_config.png" style="zoom:70%"></li><li><p>打开并找到 <code>deploy</code> 关键字</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:CalmCenter&#x2F;calmcenter.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p><strong>注意: 引号 后有一个空格，repository 填写 ssh 地址，branch 如果没有特殊要求，写master</strong></p><ol start="5"><li>编译并提交</li></ol><p>部署前需要先装 <code>deployer</code> ，<code>deployer</code> 用于将 <code>hexo</code> 部署到  <code>git page</code> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>提交前，有时候提交了不生效，需要清理一下缓存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure><p>编译并提交</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure><p> 和 <code>hexo g</code> 、 <code>hexo d</code> 一样</p><p><strong>提交后线上会有延迟才会展现最新效果，特别是配置样式之后</strong></p><p>提交过程中会让你输入一次密码，完成后就可以在外网访问博客了。<a href="https://calmcenter.github.io/" target="_blank" rel="noopener">https://calmcenter.github.io/</a> <code>https://用户名.github.io</code></p><p>假如这时候，报错 <code>ERROR Deployer not found: git</code>，那么就是你的 <code>deployer</code> 没有安装成功，你需要执行如下命令再安装一次：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>这样，你再执行 <code>hexo g -d</code> ，你的博客就部署到 <code>Github</code> 上了。</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> git </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>职场的真相</title>
      <link href="/2019/zhi-chang-de-zhen-xiang.html"/>
      <url>/2019/zhi-chang-de-zhen-xiang.html</url>
      
        <content type="html"><![CDATA[<p>各位同学，大家好，我是曹政，谢谢各位参与我的年终福利课程，职场的真相。<br>关于职场，说实话，我年轻的时候做的并不好，很多教训，很多很愚蠢的事情，所以，我不是说，一个成功职场精英，一个上市公司高管，给你们讲职场，当然，实话说，现在而言，上市高管对我来说不算什么很难的目标，但重要的是，当年我在混职场的时候，其实是很糟糕的。<br>直到自己参与创业，以及自己开公司的时候，站的地位不同了，反过来思考，才知道自己当年职场为什么糟糕。但我知道很多年轻人，可能会重蹈我的覆辙，经历很多教训，做很多自以为聪明的事情。所以这次分享，主要是面对年轻读者，特别是初入职场的读者，希望大家少走弯路，职场顺利。<br>有相当部分内容可能是去年提过的，如果看到了，就当复习吧，两年都提过的肯定是非常非常关键的，特意回看了一下去年的分享课内容，真的是太棒了，感觉今年内容很难超过去年。</p><a id="more"></a><h2 id="1-关于面试"><a href="#1-关于面试" class="headerlink" title="1 关于面试"></a>1 关于面试</h2><h3 id="1-1-做功课很重要"><a href="#1-1-做功课很重要" class="headerlink" title="1.1 做功课很重要"></a>1.1 做功课很重要</h3><p>什么是做功课，你去面试之前，应该先搜索了解这个公司的背景，诸如股权结构，公司负责人的背景，公司主要产品线构成和主要收入构成，公司主要竞品和竞争格局。如果有可能，尽量测试使用以下公司的产品，并搜索一下相关公司的口碑和介绍。</p><p><a href="https://mp.weixin.qq.com/s/9cT-Ng_hvj9V61_XEl-ZVg" target="_blank" rel="noopener">职场自救指南</a><br><a href="https://mp.weixin.qq.com/s/NQuWI2cg_JVJa4SJSpw9rg" target="_blank" rel="noopener">求职是需要诚意的</a></p><p>重复强调一下，有不少公司网上有一些坏的口碑，怎么办？要评估一下，其实大部分知名企业都会存在两极口碑，甚至是很糟糕的口碑，但不代表这个公司没价值，你要知道自己目的是什么。<br>当然也要根据你手里的offer数量和质量综合判断，你一把名企offer，你去甄别口碑，如果你现在要解决当下吃饭问题，只要公司不是那种骗子公司或者法律风险吓人的公司，其实都可以去的。</p><h3 id="1-2-简单而精确的自我介绍"><a href="#1-2-简单而精确的自我介绍" class="headerlink" title="1.2 简单而精确的自我介绍"></a>1.2 简单而精确的自我介绍</h3><p>面试一般都要自我介绍，那么介绍的环节要做到简单精确。</p><p>什么是简单精确</p><p>第一，最能体现你的价值，你的能力的点，要重点表达出来。不要不好意思说，不要以为面试官已经完整的审阅了你的简历或求职信。</p><p>第二，不要啰里啰唆，什么都讲，要分清重点，年轻人找工作有时候生怕少介绍了自己的成绩，什么都要列出来，说实话，有些学校里的证书价值含量极低，你越强调，别人会觉得，你的能力不过如此，还不如不提。</p><p><a href="https://mp.weixin.qq.com/s/v5uFBplY6lkcUqd7vuzETA" target="_blank" rel="noopener">「谈谈自我介绍与第一印象」</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI0MjA1Mjg2Ng==&mid=401539494&idx=1&sn=137441bcf08a53c84f67c5d859c66854&scene=21#wechat_redirect" target="_blank" rel="noopener">「谈谈写作」</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI0MjA1Mjg2Ng==&mid=400367085&idx=1&sn=108ac3dfc843baf5bc56f73edf646ae1&scene=21#wechat_redirect" target="_blank" rel="noopener">「所谓坚持」</a></p><p>大V系列<br><a href="https://mp.weixin.qq.com/s?__biz=MzI0MjA1Mjg2Ng==&mid=401981770&idx=1&sn=127123fb1ca12af53d77e3c567d75fca&scene=21#wechat_redirect" target="_blank" rel="noopener">「关于影响力」</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI0MjA1Mjg2Ng==&mid=401310703&idx=1&sn=979e25d208a6013b8c487726a5a2b020&scene=21#wechat_redirect" target="_blank" rel="noopener">「自我修养」</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI0MjA1Mjg2Ng==&mid=402041293&idx=1&sn=8ba4a204c76eb987f7a7b6130c304e71&chksm=7b0033a04c77bab6b9823c0d3ac21cc03771f5723c06205f0f48b1c50c751b3c4a98f1a14c76&scene=21#wechat_redirect" target="_blank" rel="noopener">「如何正确的勾搭大V」</a></p><h3 id="1-3提出有价值的问题"><a href="#1-3提出有价值的问题" class="headerlink" title="1.3提出有价值的问题"></a>1.3提出有价值的问题</h3><p>大部分公司面试都会有个让面试者提问的环节，很多面试者会问年终奖怎么发，休假怎么休之类的问题。<br>实话说，这类问题不是不能问，别人明确给你offer的时候，你问是没有问题的。<br>人家还在考核你的时候，问题本身是考核的一部分，能理解么？<br>前面为什么说要做功课，这里要问出有价值的问题。</p><p>什么是有价值的问题，关于对方的产品，竞品，业务方向，技术方案，提出自己认真思考后的疑惑。<br>实话说，做到有价值不容易，你可能觉得自己思考深度已经够深了，没准在别人眼里还是一个非常烂的差问题，这咋办，这岂不是弄巧成拙？</p><p>看你怎么理解了，你并不是只有一次面试，职场也并非只有一次选择，被 <code>Diss</code> 了，被别人批驳了，勤反思，为什么很关键的点自己没想到，为什么自己觉得很复杂的问题别人觉得不值一提？只要有收获，就不亏，每个人的职场认知都不是一步到位的，发现自己的不足，是成长的过程，只要成长够快，好的offer迟早是你的，不要在意一城一池的得失。</p><p>最怕的是什么，面试受了点挫折，出了点丑，问的问题被鄙视了，就觉得自己被针对了，被歧视了，加戏很多，对方不尊重自己了，企业文化糟糕了，有时候网上看看各种讨论，这样心态的年轻人还是挺多的。</p><p><a href="https://mp.weixin.qq.com/s/yW4rto4VF1AwFCs62UMZaw" target="_blank" rel="noopener">「别把自己当小受」</a></p><p>浅谈关于领导力<br><a href="https://mp.weixin.qq.com/s?__biz=MzI0MjA1Mjg2Ng==&mid=400713104&idx=1&sn=d38e44a244fb4125808124eb12a17299&scene=21#wechat_redirect" target="_blank" rel="noopener">「识人之能」</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI0MjA1Mjg2Ng==&mid=400819865&idx=1&sn=15fb195cb1cccc71430909a0b267ad2b&scene=21#wechat_redirect" target="_blank" rel="noopener">「授权与放权」</a></p><p>能力成长系列<br><a href="https://mp.weixin.qq.com/s?__biz=MzI0MjA1Mjg2Ng==&mid=209733294&idx=1&sn=111340c5aa21a98dd8b76abc1016dc68&scene=21#wechat_redirect" target="_blank" rel="noopener">「机会来自于担当」</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI0MjA1Mjg2Ng==&mid=209714599&idx=1&sn=1cd7f5ca6045be9da9374477871f1d3d&scene=21#wechat_redirect" target="_blank" rel="noopener">「归纳与总结」</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI0MjA1Mjg2Ng==&mid=209695455&idx=1&sn=4d9a296a87f9525907e1e58c85b0648b&scene=21#wechat_redirect" target="_blank" rel="noopener">「提问的技术」</a> </p><p>年轻人，如何抗造<br><a href="https://mp.weixin.qq.com/s?__biz=MzI0MjA1Mjg2Ng==&mid=2649868155&idx=1&sn=953dec87eb8af0ea29b6b0683f98ba36&chksm=f1075d16c670d4004438ab5a639eacfce8164caaec49d3c56727bc1e97cbceb0075889d3fd06&scene=21#wechat_redirect" target="_blank" rel="noopener">「无意义的忧虑与烦恼」</a><br><a href="https://mp.weixin.qq.com/s/YT85l1W9IqeybiE0fso0Bw" target="_blank" rel="noopener">「 预期管理及心态控制」</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI0MjA1Mjg2Ng==&mid=400665044&idx=1&sn=a8c001c227eb8e4b2559cde4c31db267&scene=21#wechat_redirect" target="_blank" rel="noopener">「从历史中讲创业的韧性」</a></p><h3 id="1-4-保持后续可行性"><a href="#1-4-保持后续可行性" class="headerlink" title="1.4 保持后续可行性"></a>1.4 保持后续可行性</h3><p>技术面试，或者产品运营的面试被难题考倒了，很多人当然会很沮丧，认为失去了一次机会。</p><p>其实这也是一种学习的机会，那么可以考虑这样的一种回答方式，“这道题确实超出了我的知识范畴，我回去想认真思考一下，方便留一下您的联系邮件么，我希望再次解答后还得到您的指点，不不不，我不是奢求再来一次面试，我只是想学会这个算法。”</p><p>或者这类“今天我回答的不好，谢谢您帮我发现了自己的差距和不足，能不能给我一些相关问题的学习资料，书籍和网址，我想回去认真学习一下，如果有可能，不知道以后还能不能得到您的指点，能否留一个您的联系方式。”</p><p>当然，以上并不只是面试的一套说辞，你回去之后还是要认真的完成学习并且认真的把更好的答案发给对方，并诚恳的希望得到对方的批评和指导。</p><p>每个求职者都会说自己热爱学习，愿意接受挑战，怎么证明啊？你看，你没拿到offer，都愿意去学习，这个印象分是什么。</p><p>下次这个公司有新的人力诉求的时候，或者其他岗位有诉求的时候，会不会想到你？我不能说肯定会，但我会说，这样的机会真的会有。</p><h3 id="1-5-关于离职原因的回答"><a href="#1-5-关于离职原因的回答" class="headerlink" title="1.5 关于离职原因的回答"></a>1.5 关于离职原因的回答</h3><p>这是最难回答的面试问题了，那么分三个情况。</p><p>第一，非裸辞的情况，这种相对容易一点，觉得这边机会更好，发展空间更大，能学到更多东西，待遇更有优势，这些都没问题的。尽量不要埋怨老东家，不要说老领导多不好，老东家多苛刻，实话说，人家会很担心，你以后去下一家公司的时候，还会这么说他们。</p><p>第二，裸辞的情况下，那么确实要解释的更多，有些是比较容易解释的，旧公司业务风险较高，所以赶紧撤出。加班太多，个人身体有些吃不消/家里人照顾不到。这种直说也无妨。</p><p>有些可能确实跟旧东家发生了较多矛盾，或者甚至是被裁员，被开除。可能讲出来不是很好听，我觉得把握一个原则，要敢承认自己的不足。比如当时争论的时候确实有些冲动，或者说认真反思了一下，当时确实可以做的更好一些。</p><p>不要一昧的指责旧东家和旧同事，要认真的反思和承认不足，摆事实讲道理，特别是情绪要稳定，一定要让面试官觉得你是讲道理的人，是不记仇的人，这点很重要，说实话，职场上的老江湖，没有谁会轻信一家之言，你真的特别委屈特别冤枉，别人也不会认为这是完全的事实。</p><p>第三，换工作较多的场景，比较碎的工作经验，说实话，尽量尽量不要有这样的职场记录，你说我抹去一些行不行，其实是可以的，但还是尽量不要有这样的职场记录。</p><p>现在一些年轻人，怎么说呢，挺任性的，工作不开心就辞职，换工作比换手机快，一年换好几份，当然，往好处说也是一种人生体验，但确实在后续求职应聘的时候，会有很不好的影响。</p><p>还是那句话，要坦诚自己的问题，面试官问了，别找太多借口，自己当时年轻，社会经验不足，求职的时候考虑不周全，工作的时候也有点任性，坦坦荡荡的说，尽量让人觉得你现在成熟了，认识问题了，不会那么毛躁了。</p><p>当然，有些换工作的经历并不是坏事情，比如前任领导离职创业把我拉出去了，后来创业失败了，投资人拉我进了另一个项目，但很不幸项目也没成功。这种其实不是坏事，说明你的能力被之前的领导，投资人认可，虽然项目换的多，但不会是负面。</p><p>现在不是说找份工作一定要干很多年，但换工作还是要谨慎，尽量找能坚持几年的事情做。</p><h3 id="1-6-关于项目经验的回答"><a href="#1-6-关于项目经验的回答" class="headerlink" title="1.6 关于项目经验的回答"></a>1.6 关于项目经验的回答</h3><p>面试官经常会问，你以前做过的项目，及你在项目中的工作是什么。我其实也强烈建议，日常工作中养成勤奋总结的好习惯。功夫当然还是在日常。</p><p>我以前说过这个案例，项目的方案描述，数据及逻辑清晰不清晰，比如性能优化，优化前的并发指标是什么，优化方案是怎么考虑的，优化后如何测试的，测试指标是怎样的。<br>上线后的数据指标是怎样的，进一步优化的预案有没有，对进一步并发压力的预警系统有没有做，怎么做的。很多人只是简单描述了优化方案，然后说问题解决了，这其实是不行的。</p><p>项目经验，你的总结能力比项目本身更重要，项目很牛逼，你讲出来都是泛泛而谈，我是里面的工程师，写了一个什么结构，你觉得你讲的很清楚，面试官怎么觉得？项目牛逼和你有关系么？项目很一般，你讲的逻辑很清晰，什么问题，如何解决，为什么选择这个方案，效果对比，说明什么，说明你分析问题，处理问题的思路清晰，逻辑严谨，这是人家看重的。</p><p>所以，面试前，把你当年最得意的，认为最能体现自己价值的项目经验，认真复盘一下，尽可能用数据化的方式展现出来，并整理好你的决策和分析逻辑，以及整个项目的分析逻辑。</p><p>为什么很多人觉得我牛逼，很多事情不是我做的，但是我整理后写出来，思路很清晰，逻辑很严谨，数据指标很给力，人家至少知道，这个事情，我是理解透彻了，面试官发现你对项目理解透彻了，能够驾驭了，是不是你完成的，还那么重要么。</p><p> <a href="https://mp.weixin.qq.com/s/A3k8aRbd7o4uuELZAMM_KA" target="_blank" rel="noopener">「面试官是怎么看简历里的项目经验」</a></p><h3 id="1-7-刷题"><a href="#1-7-刷题" class="headerlink" title="1.7 刷题"></a>1.7 刷题</h3><p>刷题有用没？其实是有用的，特别是巨头的面试，还是很看重的。技术面试，<code>leetcode</code> 的题目，如果有足够的刷题经验，还是会很有帮助。</p><p>刷题的几个要点，第一，举一反三，一定要对解题思路理解透彻，能够让算法适应不同的类似场景。第二，一定要增强题目理解力，因为面试官问问题的时候，往往不是题库里那么直接，很多人明明刷题做的很好，但是现场理解上出了偏差，本来是做过的东西，现场换了一个问题，就不知道怎么处理了。</p><p>那么现场如果对面试官的题目理解不到位，可以多问一些问题来理解，不要不好意思问，问清楚再回答。</p><p>刷题的时候自我感觉没问题，面试理解错，这种情况其实非常常见，那么同时，我也说过容错性的话题很多次，也要允许面试官，存在表达歧义的可能性，这就是为什么要追问，要通过追问明确问题的原因。</p><p>增加理解力和沟通能力，在职场永远都是非常重要的。</p><p>我有篇文章，找个小伙伴，日常沟通训练，不知道有多少读者去实践了。</p><p>沟通 <a href="https://mp.weixin.qq.com/s/f_CF8dRObw78k9b9DFAyKA" target="_blank" rel="noopener">「有效提升沟通能力」</a> </p><h3 id="1-8-交流得体"><a href="#1-8-交流得体" class="headerlink" title="1.8 交流得体"></a>1.8 交流得体</h3><p>沟通交流过程中，如何得体，不要太过拘谨，但也不要太过于随便。</p><p>这个度怎么把握？<br>说真的，有些年轻人学校里随便惯了，进入职场的时候，还是那种无所谓，各种玩笑，各种不在乎的样子，这种印象是很不好的。</p><p>第一，穿衣着装，不是说非要正装西服，但还是要相对正式一点，比如短裤背心是不合适的，当然如果你在业内是顶尖大牛，你穿什么都行，职场新人，求职的时候，着装稍微正式一点。</p><p>第二，称谓和交流，客气一些。多用“您”字，多说几句谢谢，多体谅一下面试官，“没关系，我可以等”。“今天学到了很多，感谢您的指导。”“对不起，我能稍微打断一下么，刚才那个问题没听清楚。”，“不好意思，我想多问一句，这个题目中的什么什么，我理解是这样这样，不知道是不是。”</p><p>第三，也不用过于拘谨，适当的主动表达也是很有意义的。“我试了一下咱们的产品，真的很好用，昨天还在跟同学安利呢。”，“咱们公司今年增长太快了，我还特意看了一下财报数据，太惊人了。”</p><p>第四，既要谦虚，也要有自信，不知道能不能理解这个尺度。“我们当年这个项目其实还是有些缺陷的，当时经验不足，时间也比较紧张，有几个地方这里那里的考虑不全，如果现在交给我来做，应该会好很多。” 要承认自己的不足，也要对自己的发展空间有信心。“您提的这个问题，确实我现在可能没办法回答到位，不过如果给我一周时间，我相信会给您一个满意的答案。”</p><p>第五，无论面试成败，都要感谢对方，保留好印象，行业不大，人生何处不相逢。</p><h2 id="2-什么是职场中的态度"><a href="#2-什么是职场中的态度" class="headerlink" title="2 什么是职场中的态度"></a>2 什么是职场中的态度</h2><h3 id="2-1-愿意尝试，愿意学习，积极沟通"><a href="#2-1-愿意尝试，愿意学习，积极沟通" class="headerlink" title="2.1 愿意尝试，愿意学习，积极沟通"></a>2.1 愿意尝试，愿意学习，积极沟通</h3><p>在职场里，态度是非常关键的。<br>遇到困难和障碍，是否愿意学习，是否愿意尝试，这是很重要的，还记得王兴不是贴过一段记录，说他们公司谁谁谁，问什么东西用过没有，人家的回答是，没用过，不过我可以学。</p><p>王兴为什么会贴这句话，“我不会，但我可以学”，在职场是几乎每个老板都看重的素质。</p><p>“我不是这个专业的”，“我来这里不是为了干这个的”，“这个事情不该我来做”，很糟糕，真的，很糟糕。</p><p>另一点就是积极沟通，什么是积极沟通，有问题就问，有观点要表达，当然表达方式可能需要一些技巧，但要敢于表达，有机会要争取，有责任要敢承担。</p><p>此外，项目出现问题，或者出现阻碍的时候，要主动通报，主动寻求协助，主动告知相关同事，这也是积极沟通很重要的一点。</p><p>我们一直说的，印度裔在欧美为什么比华裔吃香，积极沟通这件事上，我们很多人真的没有当回事。中国人干活，印度人表功，为什么会这样，真的是职场不公？其实不是的。</p><p>积极沟通对应的是消极沟通，什么是消极沟通，坐等老板给机会，坐等别人派任务，别人不问就闷头不说，遇到问题不找人帮忙，非要自己抗，影响全局还觉得自己很委屈。</p><p>当你作为老板，面临项目安排规划和人员调配的时候，你就会理解，为什么积极沟通如此重要，为什么闷头做事的中国人不如擅长表功的印度人。我非常希望读者能彻底理解这一点。</p><p><a href="https://mp.weixin.qq.com/s/tlw7hm9No7WNnaDqozyB7w" target="_blank" rel="noopener">「谈谈主动工作」</a><br><a href="https://mp.weixin.qq.com/s/QXEg4oK48G0X-AV3X9c2NQ" target="_blank" rel="noopener">「从校园到职场 - 提问与交流」</a><br><a href="https://mp.weixin.qq.com/s/WI-rFdNOQjRfcwnXNFYx9g" target="_blank" rel="noopener">「再谈职场沟通」</a></p><h3 id="2-2关于加班的话题"><a href="#2-2关于加班的话题" class="headerlink" title="2.2关于加班的话题"></a>2.2关于加班的话题</h3><p>我知道很多人不想加班，但确实很多公司可能存在较多加班场景。</p><p>第一，要理解临时性的加班任务，比如线上出了一个紧急bug，或者有个活动得组织和维护压力非常大，我觉得除非家里有紧急情况需要处理，这种加班还是多体谅一下公司。<br>比如所有国内电商周边公司双11可能都加班，你要想吃这碗饭，你说你坚决不加班，那可能这行真的没你位置了。</p><p>第二，在工作效率和表现上体现优势，你不加班，但你做的事情漂亮，任务完成的很好，那你跟领导沟通的时候，也有足够的底气。</p><p>第三，积极沟通，充分理解诉求和目标，减少无用功。这个去年分享课也提过，很多职场的人闷头做事，把简单的事情做复杂，把很容易处理的问题扩大化，实际上很多都是一厢情愿造成的。多沟通，深入了解诉求，学会把握重点，抓大放小，很多时候，看上去很复杂的工作任务，其实可能没那么复杂，要允许领导描述不清，但自己应该具有进一步核对和澄清的能力。事情多的做不完，最后发现都是无用功，这种情况在职场真的非常常见的！</p><p>第四，部分任务可以考虑在家完成，我在西雅图见一个老朋友，<code>FB</code> 的华人技术经理，美国名校博士，我们觉得美国公司不加班，其实他说很辛苦的，给我看他的日常任务排期，从早到下午都是会议，然后说，白天上班根本没时间写代码，而自己还是有很多代码任务的，怎么办，晚上回家写。</p><p>是的，因为要接孩子，从不在公司加班，但实际上每天都要工作到很晚。 据说在 <code>FB</code> 这种情况并不少见。 其实美国也不止是 <code>FB</code> 如此，西方互联网巨头，很多人工作也是蛮辛苦的。</p><p>这就存在一个跟领导沟通的问题，家里确实有事情，不能在公司加班，但应该完成的工作任务会在家里完成，不会影响进度。实际上家里如果干扰少一些，完成的效率会更高。可能在公司需要几个小时扯皮交流然后慢慢熬的任务，回家后一个小时，甚至半个小时就搞定了。而且你不用去想着如何偷懒摸鱼，早干完时间都是自己的。</p><p>第五，认清现实，我们讲正确呢，说一个好的企业不应该大量无效加班，但另一方面，我们在职场，确实很多事情不是自己认为对就可以的。</p><p>如果你能选择一个不加班，待遇好，成长好，而且还能发挥你优势的岗位，当然，我恭喜你。</p><p>如果你发现很多条件不能兼顾，想清楚自己想要什么，这点很重要。</p><p>选择offer 的时候，很多时候你不可能拿到完全满意的条件，这时候，什么是你当前最看重的，我不能替你做主。</p><p>我去年讲过职场的成长期，成熟期和变现期，不同期间不同诉求，但不同的人有不同选择，不要苛求完美的职场，不要苛求完美的工作，想好自己这一步能获得什么很重要。</p><p> <a href="https://mp.weixin.qq.com/s/Gz5rBTpMdFkNZUZKlV7D4Q" target="_blank" rel="noopener">「关于程序员的996，我们谈谈历史和逻辑」</a></p><h3 id="2-3-面对事故和问题"><a href="#2-3-面对事故和问题" class="headerlink" title="2.3 面对事故和问题"></a>2.3 面对事故和问题</h3><p>职场经常会遇到一些严重的事故，问题，障碍。<br>很多人觉得我必须努力解决掉所有问题，再去给领导汇报，这样可能显得自己比较厉害和负责。</p><p>当然，如果你能尽快的解决掉问题，处理完事故，然后写汇报，这是没问题的，但很多时候，你可能没办法快速解决，快速处理，而且，甚至可能这个问题会影响到很多关联的同事，很多相关工作和计划安排，这时候，你如果还是憋着自己去解决，不汇报，不通知，就非常要命了。</p><p>一定要有全局意识，如果问题会导致其他人的工作延期或者对别人的工作有重要影响，或者超出个人能力范围，一定要主动知会相关人员，并寻求协助。</p><p>就算你工作很努力，一直很拼，很竭尽全力的处理问题，你认为自己的表现已经足够好了，但因为你没有知会关联同事，影响了其他人的进度和主管的项目把控，你这个努力也不能扭转这个损害，你觉得自己委屈，出bug，出故障难道不是很常见的事情么，出问题可以说不是什么太大的责任，但不通报是严重的灾难。当你成为经理，总监，或更高层的管理者，你就明白为什么这么说了。</p><p>我经常对自己公司的员工说这样的话，但我发现很多人依然还是我行我素，自己闷头去处理问题，闷头解决问题，不通报，不知会，总想着解决完再告诉我。讲真，这种情况惹得我火很大，这是管理者不能容忍的。</p><p>面对事故和问题，还有一个责任的承担问题，其实遇到事故，遇到问题，第一重要的是尽快解决问题，责任不要急于撇清，不要急于去分辨，先解决问题。不要说，这不是我的责任，这不是我的错，先说，我现在就去检查，去解决。解决完，处理完，写汇报的时候，再去说明真实原因和逻辑。</p><p>那么该自己承担的责任，要敢于承担，不要总是想着甩锅，总是想着辩白，大部分主管和领导都不傻，年轻人进入职场，千万不要小聪明，很容易被识破，如果发现你不诚实，没担当，这个问题的严重性远远大于你犯了错误。</p><p>但承担责任，敢于担当，也要有具体的行动，比如如何弥补，如何有效的预防类似的问题，如何进一步提升自己的问题解决能力，而不是每次都态度诚恳的道歉，认错。你总是态度很诚恳，但总是犯同样的错误，这也不行对不对。</p><p>我在职场真的见识过那些会甩锅，会推卸责任的年轻人，我说实话，可能一次两次，领导没有真的追究，看上去好像平安无事，但后面遇到升职机会或者更好的项目安排的时候，基本上领导是不会给他们的，我是看在眼里的，这样的案例并不少。</p><p>很多时候这些人觉得自己很聪明，每次都没事，但他们并不知道，人家已经给他们在心里打上一个标签。后续无数好机会都跟他们没关系了。</p><h3 id="2-4-面对合作诉求"><a href="#2-4-面对合作诉求" class="headerlink" title="2.4 面对合作诉求"></a>2.4 面对合作诉求</h3><p>第一，是跟上司和领导通报。很多内部合作，别人来找你，你觉得不麻烦，或者是对方级别比较高，你不敢得罪，就去给人家做事情了，但你的直接上司不知道，你影响本职工作进度，或者有些数据和信息处理是未经授权的，这其实就非常糟糕了。我以前就不是太在意这个，总觉得我为了公司难道不对么？你的上司有权决定这件事该做还是不该做，以及该如何做。你说我私下不影响进度帮同事忙行不行，有些信息数据授权的问题要考虑的，企业内部也有风控，很多你不以为然的事情可能是有严重问题的。遇到严格的内部审计吃不了兜着走的。要通报，要征询上司的授权，不要总觉得无所谓，可能一两次上司没有追究你的问题，但是记着，他心理可能给你打标签了，你没有尊重他的管理职权，他以后怎么会信任你。</p><p><a href="https://mp.weixin.qq.com/s/RLy79oG-ovYr23oOWUPrgA" target="_blank" rel="noopener">「那些用力过猛的员工」</a></p><p>第二，是外部合作中，关于利益诉求和目标的问题，以前旧文也提过，很多职场的人会用力过猛，以为自己为公司特别尽力，各种事情务必在自己公司角度争取最大利益，其实是很糟糕的，因为长远的合作需要双赢，也需要持续的信任。太鸡贼太苛求实际上过犹不及。<br>包括自媒体合作也是，有些企业的公关恨不得自媒体作者所有数据都提供清清楚楚，内容版式改上七八遍各种调整，各种朋友圈微信群都要给他们发一轮，似乎他们这样是为了公司的宣传效果，体现工作价值。坦白说，遇到我和冯老师这种大V，合作一次就烦了，爱做不做，爱信不信，唧唧歪歪，不伺候行不行啊。反而有些简单明了的，他们轻松，我们也轻松，长期合作，我们特么的也不会为了赚他一笔广告费砸自己招牌对不对。确实效果不太好的，不用广告主说，看到数据不理想，我直接补送一个位置就是了。<br>合作的要点，总结一下，一是向上汇报，二是双赢互利互信。别鸡贼，别什么便宜都想赚，多换位思考。</p><h3 id="2-5-面对可能的误解和委屈"><a href="#2-5-面对可能的误解和委屈" class="headerlink" title="2.5 面对可能的误解和委屈"></a>2.5 面对可能的误解和委屈</h3><p>职场中会不会背锅，有没有委屈，会不会被误解。肯定有，而且很常见。</p><p>但我说句潜规则，领导会喜欢那些经得起委屈，扛得起批评的人。很多事情，时间会给出不同的答案。当年王坚博士搞阿里云的时候被批判的还少么，全公司大会上被几乎各个部门吐槽，最后怎样，现在叫王坚院士。</p><p>还有就是，其实有不少领导，只有对亲信才会批头就骂，毫不留情。你看他对你客客气气，从不大声指责，说实话，根本就没拿你当自己人。</p><p>做好手头的工作，用事实来证明自己，事实是最好的辩解。当然，并不是说遭到误解就不解释，有些真的需要时间来证明，有些可能需要深入的沟通，但这里有两点要说明，第一，就事论事，切忌情绪化和人身攻击。否则对的也会变错。第二，只列事实即可，不要臆测，不要假设，不要扣帽子。事实如此，不要说对方是怎样怎样陷害你，这些都是臆测，而且很多都是错误的臆测。</p><p>当然，职场还有一个潜规则，就是尽可能有证据留存，比如沟通邮件，会议记录，确认通知。遇到扯皮的时候，没有证据，就没办法证明责任了，比如某个需求到底是谁提出的，为什么这么提，你明明只是执行者，但是需求方说没提过，你百口莫辩。</p><p>最后，还是要强调，职场不能怕委屈，不能怕误解，时间真的会给出证明。你背了锅，也许你的领导不清楚，但也许别人清楚，公司发展过程中，每个人的角色都会变化，只要你自己不要自暴自弃，总会有新的机会，在某些人眼里，你的委屈甚至是加分项。</p><h3 id="2-6-不吝称赞"><a href="#2-6-不吝称赞" class="headerlink" title="2.6 不吝称赞"></a>2.6 不吝称赞</h3><p><a href="https://mp.weixin.qq.com/s/b0vPDniK3S1KcfWtTQ27lQ" target="_blank" rel="noopener">「再谈职场中的用力过猛」</a></p><p>读书的时候，经常会有一个坏习惯，嘴比较损，特别喜欢揶揄别人，并认为这是关系亲密的象征。说实话，这个问题很常见，我也不例外。</p><p>但职场有时候不自觉就会得罪人。而且自己还以为彼此关系很融洽。</p><p>很多人不喜欢称赞别人，觉得是拍马屁，觉得是奉承。</p><p>我这么说吧，如果人家做的真的好，确实体现了水平，你就应该正面的称赞别人，职场情商里，最重要的就是这条。</p><p>特别是团队合作，项目总结，要感谢所有帮助过你的同事，上司，下属，感谢每个做出贡献的人，并如实的称赞他们的功劳。<br>下属习惯想当然，不知道问一下主管–本来可以避免的。</p><p>赞美他人会让你的职场和社交关系突飞猛进，真的。<br>把那些用于揶揄挖苦的语言天赋转为赞美，你的职场之路会完全不同。<br>实话说，我也不喜欢奉承，拍马屁，很多名气很大的人我也不给面子的，但我认为如实称赞是非常值得的，很多人在某些领域很优秀，首先，你应该看的到，然后，也应该说出来。</p><h2 id="3-信任是如何产生的"><a href="#3-信任是如何产生的" class="headerlink" title="3 信任是如何产生的"></a>3 信任是如何产生的</h2><p>职场信任关系是极为关键的，取得信任才能获得更多的机会，那么信任不是一蹴而就的，需要积累，以下是信任关系的一些要点。</p><h3 id="3-1-正确而及时的汇报"><a href="#3-1-正确而及时的汇报" class="headerlink" title="3.1 正确而及时的汇报"></a>3.1 正确而及时的汇报</h3><p><a href="https://mp.weixin.qq.com/s/tlw7hm9No7WNnaDqozyB7w" target="_blank" rel="noopener">「谈谈主动工作」</a><br><a href="https://mp.weixin.qq.com/s/fWx_JY6tcrYr8DJ6YmPeog" target="_blank" rel="noopener">「职场推进屡屡受阻，别总找借口。」</a></p><p>常见问题，该汇报而不汇报<br>任何可能导致你所承诺的时间计划任务产生变动的因表和事任何可能需要上一级授权的事件和工作。<br>任何可能影响团队其他人或公司其他团队工作安排和计划的因素和事件。<br>里程碑事件，进度变化，任务状态需要其他团队协助，资源协助的事件和工作。</p><p>很多人闷头做事，自己闷头解决问题，不汇报。不知会，总想着自己解决完问题再汇报，我再次强调，这是极为糟糕的！我自己团队有这种情况，我是极为火大的，如果你是创业者，你就能理解为什么这种情况极为糟糕。因为很多项目进度和后续安排，彻底失控。</p><p>我希望读者理解，作为管理者，最怕的不是问题和困难，而是失控，完金无法掌握项目的进度，障碍和影响范畴。<br>很多闷头做事的人犯了严重的错误而自己不知道，觉得自己很辛若，觉得别人天天打小报告的还能升职，你导致了领导失控，你还觉得自己没问题。</p><p>常见误区，不该汇报而频繁汇报自己职权内完全可以处理并解决的问题和事件。<br>无意义的表功表忠心<br>流水账，工作清单记录</p><p>汇报什么呢，我今天做了什么，我完成了什么，我解决了什么问题，我学习体会了领导的讲话，一切都是表达我很努力，很认真，很勤奋的工作。<br>这种普通员工这么写呢，也不是什么大问题，但如果你有一定职务级别，这样写是很糖糕的。因为这些事情，很多是上级完全不关心的。</p><p>我为什么要关心你今天写了什么代码，解决了什么问题，我要关心的是你进度到哪里了，你任务完成的如何了，预计上线时间会不会有影响，对项目团队有没有影响，需要不需要我做什么<br>很多人觉得自己汇报的很详纽，工作量很大，但为什么每次升职都轮不到自己，人家觉得你就是一个闷头干活的，根本抓不住重点讲，连份汇报都写不好，还谈什么升职。</p><p>认真的想想，如果你是领导，底下人的汇报对你来说意味着什么，是让你继续掌控项目的进展和状况，同时让你知道你需要做什么来推动这个项目前进，解决中间的问题。很多人认为汇报就是说自己工作多努力多辛苦多了不起。骨子上就错了。</p><h3 id="3-2-完成任务是第一位的"><a href="#3-2-完成任务是第一位的" class="headerlink" title="3.2 完成任务是第一位的"></a>3.2 完成任务是第一位的</h3><p>很多人觉得怀才不遇，我有很好的想法领导不采纳，我有很棒的建议领导不肯听。或者我的方案比领导的更好。</p><p>是真的么？也许是真的，但问题是，领导凭什么相信你呢？这是需要过程的，而这个过程最核心的就是，你要先把交代的任务做好。</p><p>你可以说你有更好的建议，更多的想法，基本的工作没做好，你谈什么其他呢？</p><p>建立信任的第一步，先把交代的任务做好，不管大事小事，完成到位。你说领导的设计不合理，你完成到位，然后项目没有成功，这不是你的责任，但你已经证明你自己可以做好事情，建立了做事靠谱的印象分，你再提出新的方案，新的计划，被接受的可能性更大一些。</p><p>嫌弃工作不重要，嫌弃事情没有办法体现你的能力和价值，但又不好好做，应付，错漏百出，然后埋怨领导不给你更好的机会，不让你做更有挑战的工作或者完成你更伟大的梦想，信任基础啊。</p><p>很多失败的项目同样可以建立信任基础，你做的好不好，别人看的出来，失败的原因，别人能想明白，你自己没做好，说是别人设计问题，这个你推卸不出去的。你至少要让自己的表现足够好。</p><h3 id="3-3-提出有价值的问题，不断提出有价值的问题"><a href="#3-3-提出有价值的问题，不断提出有价值的问题" class="headerlink" title="3.3 提出有价值的问题，不断提出有价值的问题"></a>3.3 提出有价值的问题，不断提出有价值的问题</h3><p><a href="https://mp.weixin.qq.com/s?__biz=MzI0MjA1Mjg2Ng==&mid=209695455&idx=1&sn=4d9a296a87f9525907e1e58c85b0648b&scene=21#wechat_redirect" target="_blank" rel="noopener">「提问的技术」</a><br><a href="https://mp.weixin.qq.com/s/QXEg4oK48G0X-AV3X9c2NQ" target="_blank" rel="noopener">「从校园到职场 - 提问与交流」</a> </p><p>不要怕提问，不要不敢提问，其实提出有价值的问题，是建立职场信任很关键的步骤。</p><p>上司讲解了产品设计目标，你提出关键的一些要点问题，这证明什么，第一，你认真的去理解上司的讲话了，第二，你有自己的深入思考，第三，你能从中发现一些关键点，关键问题。</p><p>提出有价值问题的人，更容易得到好的项目机会和升迁机会，真的。欧美更是如此，我以前讲过，新加坡英语职场培训，案例里，乖乖记录不提问的是坏案例，而能举一反三提出有价值问题的是好案例。不懂必须问清楚是这边职场很重要的原则。</p><p>当然，尽量不要问蠢问题，什么是蠢问题，你一个设计师去问马云，集团下一步的海外战略是什么，听上去很高大上，其实是个蠢问题。</p><p>与自己工作职能目标密切相关，具有一定的合理选择范围，并且需要一定的洞察力才能回答的问题，那种根本不用选择的问题也是蠢问题，比如，问上司，咱们是要做合法的产品还是违法的？你说呢。</p><p>如果对问题的答案表示质疑，也可以合理指出，请问为什么我们会选择这样一个方案，从而理解方案动机和选择逻辑，这对工作中很多重要选择很有帮助，你才知道什么是你应该关注的，是应该重视的，什么不是。</p><h3 id="3-4-不要试图掩盖自己的弱点，要主动寻求帮助和提升"><a href="#3-4-不要试图掩盖自己的弱点，要主动寻求帮助和提升" class="headerlink" title="3.4 不要试图掩盖自己的弱点，要主动寻求帮助和提升"></a>3.4 不要试图掩盖自己的弱点，要主动寻求帮助和提升</h3><p>很多年轻人知道自己存在缺点和不足，不希望领导知道，尽量去隐瞒，用其他借口和理由规避自己的不足，其实我年轻时候也会这样。<br>主动寻求帮助和提升，其实更容易建立与领导的信任。</p><p>第一，坦诚是有长期复利的。<br>第二，从心理学来说，领导会认为，帮助你成长是他的成本，他有回报预期，而他的回报预期，就是你向上的机会。<br>第三，以前科举，学子们中榜后要去拜老师，递门生贴，我希望你们能理解这个背后的含义是什么，你主动寻求领导的帮助和提升，其实也是递门生贴。</p><h3 id="3-5-扛得住委屈，忍得住寂寞，坚持出成果"><a href="#3-5-扛得住委屈，忍得住寂寞，坚持出成果" class="headerlink" title="3.5 扛得住委屈，忍得住寂寞，坚持出成果"></a>3.5 扛得住委屈，忍得住寂寞，坚持出成果</h3><p>有些委屈，需要时间来证明，那就花点时间去证明。</p><p>有时候，别人风光在前，你觉得不公平，但自己做好自己的事情，很多时候，时间会给你公平，这样的案例我在职场看到太多了，不要说三十年河东，三十年河西，风光一时的可能没有一两年就原形必露，而扎扎实实做事情的不会总是被埋没。当然，这里依然要强调沟通和汇报的能力。但你要做出证明自己的成果，不要总是因为一时委屈和埋怨就半途而废。</p><p>市场需要成熟期，产品需要成熟期，用户也需要成熟期，一些被批评的体无完肤的产品，可能几年后就成为明星爆款，不说别的，当年大话西游不就是么。更早之前，周星驰龙套憋屈了多少年，做出证明自己的成果，是最令人信服的反击质疑和押击的方式。</p><h2 id="4-如何面对不公平"><a href="#4-如何面对不公平" class="headerlink" title="4 如何面对不公平"></a>4 如何面对不公平</h2><h3 id="4-1-世界就没有公平"><a href="#4-1-世界就没有公平" class="headerlink" title="4.1 世界就没有公平"></a>4.1 世界就没有公平</h3><p> <a href="https://mp.weixin.qq.com/s/Si_Hrk6GBP7uGbY3C-gOlA" target="_blank" rel="noopener">「从校园到职场，很抱歉，世界并不按你的计划前进」</a><br><a href="http://mp.weixin.qq.com/s?__biz=MzI0MjA1Mjg2Ng==&mid=2649867486&idx=1&sn=d5a15a242f7c55d5b62195f51b768722&chksm=f1075eb3c670d7a5b837eeefd98051c02b624668e3583afceee15eedb0a6ae3dfb6f0d4eae61&scene=21#wechat_redirect" target="_blank" rel="noopener">「从“自相矛盾”的一些问题来谈谈认知」</a><br><a href="http://mp.weixin.qq.com/s?__biz=MzI0MjA1Mjg2Ng==&mid=2649867005&idx=1&sn=8d2c47cead54264afbfc0bc628f48a0c&chksm=f1075890c670d186792521e0afa1ed2e1e8162d26786ba58fe384002cd566aa9721c76ee17ff&scene=21#wechat_redirect" target="_blank" rel="noopener">「谈谈容错性」</a></p><p>你需要的是机会，和提升自己把握机会的能力，别人机会比你多，别人比你条件优越，没办法的，人从基因就开始不公平，投胎也不公平，你怎么办，就放弃自己重新投胎了？<br>最重要的是有没有自己向上，前进的机会，没有机会，再好的企业氛围，领导重视，公司环境，不要留恋。有很好的机会，那些噪音，可能的不公平，真的不用那么看重。</p><h3 id="4-2-确认自己的投入产出合理性"><a href="#4-2-确认自己的投入产出合理性" class="headerlink" title="4.2 确认自己的投入产出合理性"></a>4.2 确认自己的投入产出合理性</h3><p>你投入的时间，精力，资源，和你所获得的回报，从行业来说，从其他平台对比来说，这份回报是否合理，是否值得，值得，这就是很好的工作，很好的事情。你说某某某不如你比你回报高，这种心态要不得。如果你觉得不值得，你可以找到投入产出回报更高的平台和职位，那就转身离开，你说公司已经特殊照顾你了，这不重要。</p><h3 id="4-3-良好的沟通方式"><a href="#4-3-良好的沟通方式" class="headerlink" title="4.3 良好的沟通方式"></a>4.3 良好的沟通方式</h3><p>确实遭遇到职场不平，涉及维权，涉及解释，涉及赔偿，几个原则。</p><p>其实前面段落提过的，重述一下<br>第一，就事论事，切忌情绪化和人身攻击。否则对的也会变错。<br>第二，只列事实即可，不要魔测，不要假设，不要扣帽子。第三，尽量留存足够的证据，如果真的没有证据，有些事也真的没办法追索。<br>那么这里多加一条，第四，一旦涉及维权相关，务必通过律师和第三方进行，尽量不要自己直接追索，维权尺度一定要听律师的，不要认为自己占理就过度维权。<br>这一条关键时刻是救命的。</p><h3 id="4-4-干净的离开"><a href="#4-4-干净的离开" class="headerlink" title="4.4 干净的离开"></a>4.4 干净的离开</h3><p>如果确实无法继续工作，希望换个环境，那我想说一点，干净的离开。</p><p>不要自作聪明的搞一些报复行为，不要做一些可能违反法律风险的事情，不要以为自己可以要挟东家或者可以通过某种手段逼对方就范。</p><p>中国现在的执法力度非常强大，而且，说实话，很多时候，你意气用事，对的也会变错，本来可以合法争取的权益，也会输得干干净净。</p><p>干净的离开，长期来说，会有很好的口碑，很多企业会做尽调，不干净的事情，就算一时得逞，你也瞒不了太久。江湖并不大，很多人总会在不同场合遇到，尽量不要树敌太多。</p><h2 id="5-晋升的秘密"><a href="#5-晋升的秘密" class="headerlink" title="5 晋升的秘密"></a>5 晋升的秘密</h2><p>领导是如何选择晋升的人选，是不是干活最多的那个，是不是能力最强的那个，很多时候，其实并不是，这一点，我希望读者能够理解，并不是因为谁谁会来事，会做人，而是你没有站在更高的角度看问题。</p><p><a href="https://mp.weixin.qq.com/s/_nx-v_-j_U9V1SRhp4Wltw" target="_blank" rel="noopener">「如何提拔骨干及挑选接班人」</a><br><a href="http://mp.weixin.qq.com/s?__biz=MzI0MjA1Mjg2Ng==&mid=2649867267&idx=1&sn=004bcc8fd248edf7340bdc5f45032b23&chksm=f1075e6ec670d778e98d7b18f85d7328184e22f44347392d6546040888723f36b791b7980b84&scene=21#wechat_redirect" target="_blank" rel="noopener">「当我们追求不可替代。。。」</a></p><h3 id="5-1-团队的信任和支持"><a href="#5-1-团队的信任和支持" class="headerlink" title="5.1 团队的信任和支持"></a>5.1 团队的信任和支持</h3><p>提拔一个新的负责人。很多时候，要看整个团队是否信任和支持，这一条几乎是绝大部分企业晋升都会考虑的关键因素。包括外聘空降，也会考虑内部团队的人接受程度。</p><p>提拔起来的人底下不服气，不支持，是很麻烦的事情。</p><p>所以，平时人缘要好，为什么我说要多称赞别人，团队都信任你，支持你，这一点对晋升机会来说，尤为重要。</p><p>有些人能力很强，但性格不好，处处得罪人，那么怎么提拔？</p><p>别说老板不给你机会，老板希望的是团队的稳定和可控。</p><h3 id="5-2-良好的汇报能力和沟通能力"><a href="#5-2-良好的汇报能力和沟通能力" class="headerlink" title="5.2 良好的汇报能力和沟通能力"></a>5.2 良好的汇报能力和沟通能力</h3><p>前面提到信任关系里，汇报能力很重要，那么沟通能力也很重要。</p><p>光闷头干活，不懂得及时汇报，或者什么破事小事都汇报，你让领导怎么用你，这种提拔起来，项目团队会失控的。</p><p>沟通能力也很重要，你可能团队里大家都很信服你，其他团队，其他部门，沟通少，经常互相不对付，老板也头大对不对，能不能协调资源，沟通不同团队的人员共同完成任务，既然要提拔你作为主管/经理，不能事事都靠上面的大老板，自己要担当这方面的事情对不对。</p><p>沟通还包括什么，如何培养新人，如何提升团队干劲，自己一个人吭哧吭哧加班干活，团队懒洋洋，新人不成长，你觉得做负责人合适么。</p><h3 id="5-3-具有向上管理的能力和思维方式"><a href="#5-3-具有向上管理的能力和思维方式" class="headerlink" title="5.3 具有向上管理的能力和思维方式"></a>5.3 具有向上管理的能力和思维方式</h3><p><a href="https://mp.weixin.qq.com/s/3kzCHGH1E9BXpT1TkS-xZw" target="_blank" rel="noopener">「如何管理和指挥你的上司」</a><br><a href="http://mp.weixin.qq.com/s?__biz=MzI0MjA1Mjg2Ng==&mid=2649867315&idx=1&sn=5e379424b25a683b8be38c3ef0bb83f0&chksm=f1075e5ec670d7488cf5149ac152028e70737963651a287992bf77a0126ab5c663a2b33c043f&scene=21#wechat_redirect" target="_blank" rel="noopener">「从校园到职场 - 技能与职位」</a><br><a href="http://mp.weixin.qq.com/s?__biz=MzI0MjA1Mjg2Ng==&mid=2649867335&idx=1&sn=6d160634a420161b936f53fa54bec4a2&chksm=f1075e2ac670d73c9777004711d959b725c0d8d471a6a7717bbe4b4d78d66904dee8db8606fd&scene=21#wechat_redirect" target="_blank" rel="noopener">「从技术到管理」</a><br><a href="http://mp.weixin.qq.com/s?__biz=MzI0MjA1Mjg2Ng==&mid=2649866907&idx=1&sn=df64810a067a9f1cbbb3c45f8ad8d38c&scene=21#wechat_redirect" target="_blank" rel="noopener">「浅谈领导力之 - 价值决策」</a></p><p>什么叫向上管理，不能什么事情都等着上面分配，上面指挥，上面发现问题告诉你如何解决。要更主动，更积极一点，主动发现问题，主动承揽任务，主动寻求上司的支持和资源调配。我以前也强调过，能把老板利用起来的才是好的项目负责人，老板有时候也是一手好牌，使不上劲懂不懂，老板的人脉资源，老板的社会影响力，如果你的项目足够好，让老板用他的资源配合你，老板开心还来不及。</p><p>当然，强调一下，向上管理是有前提的，信任关系，没有信任关系，老板不可能听你的。信任关系一定是基础，路要一步步走，饭要一口口吃。</p><h3 id="5-4-对产品，业务的理解具有全面性"><a href="#5-4-对产品，业务的理解具有全面性" class="headerlink" title="5.4 对产品，业务的理解具有全面性"></a>5.4 对产品，业务的理解具有全面性</h3><p>到达一定级别的时候，需要的不是你某个领域特定的能力，你需要站在一定高度看问题，所谓全局观，你需要对产品业务的逻辑具有完整的理解，因为你需要对很多关键行为，做出判断，什么是进一步优化的方向，什么是产品的阶段性目标，这时候，你不能只停留在可以把事情做好的地步。</p><p>不要急于上升到战略高度，但工作中做的每件事情，尽可能理解其背后的逻辑，来龙去脉，业务关系，商业途径。</p><p>以前我在百度的时候，做产品经理，我江湖经验多一点，百度很多研发都是那种，怎么说呢，刚毕业进百度，社会经验几乎是0，代码写的不错，但对所谓联盟流量获利的途径，个人草根站长和百度关系什么的，其实都是一知半解，甚至是没有感觉的。</p><p>这时候你会发现，有的人就好奇心很重，写程序看产品设计的时候，会多问一些为什么，会好奇背后的设计思路和逻辑是什么，我也好为人师，你来问，我就讲这些站长是怎么赚钱的，以及怎么赫百度羊毛的，所以我们的产品应该怎么设计，既要共赢，又要防止被对不对。</p><p>那么这些特别喜欢问，特别好奇的程序员，我都记着呢，后来发展的都特别好，跟着很厉害的人去创业，现在好几个这样的程序员身价都好几个亿了，比如多盟的 <code>CTO</code> 王鹏云，还有跟谁学的合伙人张怀亭，都是典型的例子，当年都是这么过来的。也有的就闷头做事，你让我干什么就干什么，懒得问，遇到问题就是你设计没写清楚。从代码能力来说，和前者有差距么？没什么差距的，但从职场发展来说，很容易就看到差距了。</p><h3 id="5-5-能把握关键问题，具有发现问题的能力"><a href="#5-5-能把握关键问题，具有发现问题的能力" class="headerlink" title="5.5 能把握关键问题，具有发现问题的能力"></a>5.5 能把握关键问题，具有发现问题的能力</h3><p>有的的人擅长解决问题，当然很好，但作为管理者，应该擅长发现问题。不要等服务器崩溃了才知道性能负载需要优化。不要等用户规模化流失了才知道产品体验需要改进，不要等无可挽回的时候才知道系统存在问题了。</p><p>要在出现苗头，或者有一些不好的迹象的时候，快速敏锐的发现问题，在还没有出现严重状况的时候，就把风险遏制住。这对管理者来说，非常重要。发现问题，才能有效的分配任务，安排任务，确立目标。</p><p>管理者发现问题不一定完全靠自己，毕竟个人的能力和所获取的信息是有限的，要懂得如何收集信息，如何建立信息分析的网络，以及如何有效的甄别不同渠道的信息反馈。</p><p>所谓发现问题的能力，既包括个人的信息敏锐度，其实也包括一整套信息分析的方法体系。哪怕这套信息架构是前任领导建立的，至少你要能透彻领悟和接手。</p><p>很多时候，一些新上任的管理者，习惯呼啦啦的解决一堆遗留问题彰显自己的才能，却忽视了发现问题和分析问题的手段，对前任留下的信息渠道和网络不重视，甚至从不使用，结果直到出现严重问题的时候无法收场。</p><h3 id="5-6-信任度是关键项"><a href="#5-6-信任度是关键项" class="headerlink" title="5.6 信任度是关键项"></a>5.6 信任度是关键项</h3><p>其实前面一直都强调过了，首先要建立与上司和老板信任关系，才有以上其他，信任是需要证明的，如果没有证明自己值得信任，那就什么都不用提了。</p><p>信任是怎么确立的，件件有着落，事事有回声。还是那句话，有时候你参与一个项目，项目失败了，是不是你失败了？如果在项目中，你的工作表现很好，指派的任务完成得很到位，项目失败不等于你的失败，领导依然会让你肩负其他重任，这一点在很多巨头里你都能看到案例，很多内部失败项目出来的人，有的人会被争抢，有的人还会升职。关键要自己做到位。</p><p>关于建立信任的章节，多仔细再看看。</p><h2 id="6-企业永远不是家"><a href="#6-企业永远不是家" class="headerlink" title="6 企业永远不是家"></a>6 企业永远不是家</h2><p> <a href="https://mp.weixin.qq.com/s/Yxks9eEohmtHCmJFDX37pA" target="_blank" rel="noopener">「谈谈企业福利」</a></p><p>我们讲半天说如何让老板信任，如何获得团队的认可，但这里为什么要说这句呢。再好的老板，再好的团队，不是你的家庭，不是你的亲人。我希望读者务必明确这一点。刘强东说，我们不会亏待和放弃任何一个兄弟。<br>刘强东又说，那些跟不上我们脚步的人，不是我们兄弟。</p><p>很简单，企业文化再吸引人，解释权不归你所有。</p><p>再者，任何企业都有持续维持的风险，哪怕老板特别好，真的人品没得挑，公司如果出现经营困难，老板也不可能变卖家产养你对不对。除非老板是你父母，另当别论。</p><h3 id="6-1-维持职场竞争力"><a href="#6-1-维持职场竞争力" class="headerlink" title="6.1 维持职场竞争力"></a>6.1 维持职场竞争力</h3><p><a href="https://mp.weixin.qq.com/s/qef3o4tygS2LR1AW56jcmA" target="_blank" rel="noopener">「当你面临选择，所谓经验可能一文不值」</a><br><a href="http://mp.weixin.qq.com/s?__biz=MzI0MjA1Mjg2Ng==&mid=2649867713&idx=1&sn=829698f78d0b922fe53f4fee8fa06b79&chksm=f1075facc670d6ba10ccae3d50a6fc068b27ea54e3efb67a598c8af9202cf69cd7dbc23d1122&scene=21#wechat_redirect" target="_blank" rel="noopener">「与时俱进，拥抱变化」</a></p><p>除非你能做到财务自由，或者已经有足够的养活自己的手段。否则，务必要维系自己的职场竞争力，保持自己在职场上有足够的选择权，永远不要认为自己的职场路线会越来越上升，35岁以后，很多工作机会会骤然消失。</p><p>如何维系职场竞争力，第一要不断学习新东西，保持知识面和信息面不要受限。第二要建立业内影响力，能够被一些业内有资源的人所赏识认可。第三要多帮助有潜质的人，现在你帮助过的有潜力年轻人，可能未来成长壮大，遇到一些状况，没准会给你机会收留你。</p><h3 id="6-2-有好的机会要把握"><a href="#6-2-有好的机会要把握" class="headerlink" title="6.2 有好的机会要把握"></a>6.2 有好的机会要把握</h3><p>公司对我很好，老板对我很好，但从职场而言，你尽职尽责的工作，就是对得起他们，如果遇到更好的机会，能够上一个台阶，能够在职场地位，收入上有较大的进步，我的建议是，不要舍不得老板，舍不得同事，真的不要舍不得。</p><p>当然，如果非要抬杠说，有可能留在原公司未来回报更高呢，比如当年阿里不也一穷二白么？我解释一下，这是职场判断问题，如果你判断错了，那就是判断错了，这是另一个话题。但我要说的是，不要为了所谓情感，而失去更好的发展机会。</p><p>我见过有这样的朋友，为了报答老板的知遇之恩，想再干几年，有个好的结果再走，但是，再干几年，不好意思，35岁以上了，以前很好的机会，已经没有了。其实真的不值得，而且，很可能，对老板而言，你没有自己想象的那么重要。</p><h3 id="6-3-止损，止损，一定要止损"><a href="#6-3-止损，止损，一定要止损" class="headerlink" title="6.3 止损，止损，一定要止损"></a>6.3 止损，止损，一定要止损</h3><p>如果公司遇到较大的风险，工资无法发放，经营存在法律风险。</p><p>该走立即要走，不要说，现在走了拿不到什么什么，再过几个月没准如何如何。</p><p>止损务必要果断！</p><p>维权也是，适度维权，不要为了一点点维权利益，把自己的时间和精力都耗进去，你要明白你的前途比那些值钱。</p><h3 id="6-4-注意个人信用，不要被企业滥用"><a href="#6-4-注意个人信用，不要被企业滥用" class="headerlink" title="6.4 注意个人信用，不要被企业滥用"></a>6.4 注意个人信用，不要被企业滥用</h3><p>很多人已经犯了这样的错误，加入一家金融理财公司，为了完成业绩，为了更好地获得晋升机会，不遗余力的发展身边的亲朋好友购买相关产品，最后爆雷，之前的社交网络完全崩渍。个人信用不要那么容易被企业滥用，不要为了几个月的奖金，一点点奖励，把个人信用和口碑都消耗掉，非常愚蠢的做法。</p><p>现在有些公司新员工入职要用身份证办信用卡，办电话卡，给公司业务用，这个那个的，我看着都觉得害怕，个人征信就这么不当回事么？就真的找不到工作了么？把自己当三和大神了么？</p><p>如果一个企业为了发展，不尊重个人信用，滥用员工个人信用，这种公司尽量脱身。</p><p>还有一种，明知公司快出问题，快要沉船，还出来撒谎安慰闹事的人，这种也很蠢，马上走人就对了，最多闭嘴不说话，这算是对得起老板了。这时候还要消耗个人信用，为了站好最后一班岗，还以为这是职场操守，你不想做反骨仔，你退出江湖行不行啊。</p><h3 id="6-5-再好的上司，老板，不要跟着一起沉船"><a href="#6-5-再好的上司，老板，不要跟着一起沉船" class="headerlink" title="6.5 再好的上司，老板，不要跟着一起沉船"></a>6.5 再好的上司，老板，不要跟着一起沉船</h3><p>如果一个企业存在经营风险，或者多年以来业务没有任何起色，不管上司，老板对你多么好，没必要陪着他们沉没。</p><p>我不会鼓励在职摸鱼，或者说那些违反职场道德和法律的事情，但从业者不要给自己加戏太多，真把企业当家一样，同生共死，那实在不值得。<br>不要认为自己是救世主，时间已经证明，你的忠诚拯救不了任何事情。</p><h3 id="6-6-忠诚度的体现是，在其位谋其事，而不是把命和前途都交给他们"><a href="#6-6-忠诚度的体现是，在其位谋其事，而不是把命和前途都交给他们" class="headerlink" title="6.6 忠诚度的体现是，在其位谋其事，而不是把命和前途都交给他们"></a>6.6 忠诚度的体现是，在其位谋其事，而不是把命和前途都交给他们</h3><p>在职的时候认真工作，全力投入，离职的时候遵守契约，这就是忠诚。不是把命和前途交给别人。记住，企业永远不是家，不要被一时的企业文化口号所蒙蔽，记住再好的企业文化，解释权不在你这里。</p><h2 id="7-所谓副业"><a href="#7-所谓副业" class="headerlink" title="7 所谓副业"></a>7 所谓副业</h2><p><a href="https://mp.weixin.qq.com/s/w8qCG-amQe6dm5yoY9jxbA" target="_blank" rel="noopener">「你适合搞副业么？」</a><br><a href="http://mp.weixin.qq.com/s?__biz=MzI0MjA1Mjg2Ng==&mid=2649868955&idx=1&sn=7fcd8e1d034bfce14c954207c05a1b18&chksm=f10750f6c670d9e0edb12ebae725d47780bf0aee01f7c3a7032e270fbc0d5521d0dba7a0c44d&scene=21#wechat_redirect" target="_blank" rel="noopener">「副业赚钱这事，靠谱么？」</a></p><p>很多人都关心副业话题，其实我旧文写过关于副业的文章，我的观点都在里面，今天不会展开太多。</p><h3 id="7-1-副业往往是职场忌讳"><a href="#7-1-副业往往是职场忌讳" class="headerlink" title="7.1 副业往往是职场忌讳"></a>7.1 副业往往是职场忌讳</h3><p>大部分企业和管理者，会忌讳员工搞副业，如果你想在职场精进，我建议你不要投入太多精力和时间在副业上。<br>副业的禁忌其实非常多，竞业，职务侵占，内幕交易等，很容易碰雷，一旦遭遇法务追究，基本上能幸免的极少。</p><p>有的人觉得，我的副业和我的工作没关系，那你分心二用，而且没有办法利用你职场优势，你折腾啥呢？</p><p>昨天新闻里说，<code>google</code> 也不是很允许个人业余研发当作副业。以及最近 <code>nginx</code> 创始人被抓的案例，真的不止是中国的公司不允许。</p><p> <a href="https://mp.weixin.qq.com/s/S3T6V3pevI8cM2PU0DALJA" target="_blank" rel="noopener">「程序员想搞点副业太难了：谷歌已将个人项目归属问题写进雇佣协议」</a></p><p>还有，要强调一句，职场的人会高估你副业的受益，哪怕你亏的一塌糊涂，人家也会认为你赚的很多，更不用说会把你所有工作的过失都归咎于你在副业，这种情况下，别人会心理不平衡，你会失去团队的信任，失去领导的信任，失去同事的支持，也就失去晋升的机会，哪怕你什么都没做错。</p><h3 id="7-2-投资行为相对宽容，但有告知义务"><a href="#7-2-投资行为相对宽容，但有告知义务" class="headerlink" title="7.2 投资行为相对宽容，但有告知义务"></a>7.2 投资行为相对宽容，但有告知义务</h3><p>如果对外有投资项目，相对来说，一些企业会宽松一些，毕竟你没有占用工作的时间和精力，但仍然有告知义务，并且在公司内部也有一些避嫌的考量，比如你投资的项目，恰好是公司的重要供货商和合作伙伴，这其实是非常尴尬的，有的公司是坚决禁止的，有的是你需要避嫌，不参与该供货商选择的任何决策讨论，但很多事是说不清的。</p><p>实际上，很多巨头的高管和中层在外面都有投资项目，也不算是完全的禁忌，只是规避自己职权获利这块注意就行。所以告知是非常重要的，你告知了，而没有规避，责任也容易分担，你没有告知，就很难说了。<br>还有，告知要留证据，不是走过去说一声叫告知，正式写封邮件抄送有关负责人，我在外面有参与某某项目投资，目前该项目与公司有合作洽谈，申请回避。日后追究起来，这封邮件能救命。</p><p>做基金的LP基本上没有任何风险，因为LP不参与决策，所以一般不需要忌讳。但实话说，有些巨头的高管，名义上是外面基金的LP，骨子里做的是GP的事情，这种事，只要大老板不认为有问题，也不会有问题。</p><p>其实很多公司的潜规则是，你投资的项目不去跟竞争对手合作就行。但并不是每个公司都是这么宽容的。</p><h3 id="7-3-企业的敏感度和容忍度"><a href="#7-3-企业的敏感度和容忍度" class="headerlink" title="7.3 企业的敏感度和容忍度"></a>7.3 企业的敏感度和容忍度</h3><p>不同的企业敏感度和容忍度不同，还是前面提到的，有的企业会特别在意你的副业和竞争对手的合作关系.但不在意和自己公司的合作关系。有的敏感度就很高，容忍度很低，这种也不会被允许。</p><p>还有就是职位的容忍度，有些高管可以做的副业，基层是不行的，高管和大老板有信任基础.大老板觉得你不会企业的羊毛.就算第一点，相对于历史贡献，也不会太在意。但基层就不一样了，没有信任基础，那就默认认为你是有问题的。</p><h3 id="7-4-风险性偏好和个人能力资源判断"><a href="#7-4-风险性偏好和个人能力资源判断" class="headerlink" title="7.4 风险性偏好和个人能力资源判断"></a>7.4 风险性偏好和个人能力资源判断</h3><p>网上绝大部分教你副业赚钱的课程和内容都是靠这个话题赚你的钱的，鉴于分辨能力，我建议你一个都不要信。所谓开连锁店.投资什么项目可以坐地收钱，基本没可能。真赚钱的也都是各种精打细算，累的要死，各种踩坑学习总结出来的，没有躺赚的。<br>写文章做自媒体赚钱，我旧文不断强调，可能性不是没有.极低极低。不要总问为什么写了那么久涨不了粉，涨不了是正常的。你写不过半佛仙人的，我都写不过的。</p><p>做影响力，做分享，价值是有的，我一直强调的是，提升业内影响力，一个月写一篇就好，让业内的人看到就好，只要写的够好，几百个人看到也是有价值的，不是靠这个赚钱，是靠这个让你获得更多的业内认可。同时锻炼你表达和总结的能力。坦白说，我看不出有快速复制的适合所有人做副业的项目，你说抖音好不好，快手好不好，公众号好不好，或者这个那个好不好，因人而异，可能极少数人可以成，不具备广泛的复制性。</p><p>先看看你自己能力在哪里，资源在哪里，你对风险的承担力是多少，以及如何正确的评估风险和机会。</p><p> <a href="https:/mp.weixin.qq.com/s/4RB/MifZlaAcYkM76aU8sQ" target="_blank" rel="noopener">「影响力阶级」</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzI0MjA1Mjg2Ng==&mid=2649867195&idx=1&sn=ed55de561442a7a34b162af611ce0c86&chksm=f10759d6c670d0c0ba10e37201199246b5e2c7b916a768afc59505fa2ce45f52e4faf13f6d3e&scene=21#wechat_redirect" target="_blank" rel="noopener">「给我的偷懒找点借口」</a></p><p>任何投资行为，我建议你做好交学费的心理准备。</p><p>其实我也交过不少学费了，我觉得验证一些事情，或者一些人.也不是不可以，关键足，这个学费我交得起才行。</p><h2 id="8-永远不要自作聪明"><a href="#8-永远不要自作聪明" class="headerlink" title="8 永远不要自作聪明"></a>8 永远不要自作聪明</h2><h3 id="8-1-诚实具有持续复利"><a href="#8-1-诚实具有持续复利" class="headerlink" title="8.1 诚实具有持续复利"></a>8.1 诚实具有持续复利</h3><p>很多年轻人会在职场耍小聪明，以为撒点小谎，推卸一下责任，领导不会察觉，其实职场上司很多是老江湖，阅人无数，你的那点伎俩根本逃不过人家眼光，就算一时逃得过，稍微过一段时间，很容易穿帮。</p><p>很多时候，上司和领导真的不会揭穿你，职场上并不是非要绝对正确，有时候看穿不说穿，留点面子给你，但会默默在心理给你打个标签，而你自己还不知道。</p><p>诚实是有复利的，坚持下来你才会知道。</p><h3 id="8-2-不要轻易否定别人"><a href="#8-2-不要轻易否定别人" class="headerlink" title="8.2 不要轻易否定别人"></a>8.2 不要轻易否定别人</h3><p>批评别人很容易，但实际上很多人容易忽视别人的优点，相互尊重是职场生存法则之一，而很多背景还不错的年轻人会有一种天然优越感，学校里惯出来的臭毛病，自以为自己很厉害，自以为职场的人毛病很多。</p><p>比如很多历史遗留问题，自己没有去了解，不知道来龙去脉，批评别人代码不规范，很多逻辑不清晰，其实当时解决的问题场景，所面临的复杂局面，自己根本不知道，人家所用到的技巧和思路，根本没领悟。上去自以为是的调整，很容易闯下大祸。</p><p>还有就是自己加戏的那种，总觉得别人是针对你，是歧视你，是如何的瞧不起你，甚至把别人试图保护你，试图栽培你的苦心当作是恶意，这种情况也挺常见的。</p><p>很多时候，很多年轻人在职场树敌，是自找的，而自己还不知道原委，自己一上来就把别人否定，把别人当敌人，那么人家也不笨，感受到你的恶意，自然会把你当敌人。</p><h3 id="8-3-尽量不要当众指责批评"><a href="#8-3-尽量不要当众指责批评" class="headerlink" title="8.3 尽量不要当众指责批评"></a>8.3 尽量不要当众指责批评</h3><p>有不同意见和不同观点，对对方的安排和决策不满意，可以提么，可以提，但尽可能私下提，一对一提出，如果想留存证据，写一封邮件，不要抄送无关的第三人，然后就事论事，注意态度，不要上纲上线，不要人身攻击。</p><p>除非是非常严重的人品道德问题或者迫不及待要指出的紧急问题，否则尽量留一点空间给别人。</p><h3 id="8-4-不要以己之长评人之短，尊重不同领域的专长"><a href="#8-4-不要以己之长评人之短，尊重不同领域的专长" class="headerlink" title="8.4 不要以己之长评人之短，尊重不同领域的专长"></a>8.4 不要以己之长评人之短，尊重不同领域的专长</h3><p>互相尊重非常重要，如果总是用自己的优点去对比别人，你总是比别人优秀，但别人也有比你强的地方。学会互相尊重，学会互相学习，这一点对个人职场成长和人际关系网络都非常重要。<br>要善于发现和挖掘别人的优点，并给予足够的肯定和鼓励。</p><h3 id="8-5学会对感恩和正向回馈"><a href="#8-5学会对感恩和正向回馈" class="headerlink" title="8.5学会对感恩和正向回馈"></a>8.5学会对感恩和正向回馈</h3><p>得到别人的帮助，一定要表达感谢，不是说一定要给与足够或等额的回馈，但必须有这个表达的过程，并给与正向回馈。不要以为别人帮你是理所当然的，哪怕对方是迫于工作任务，不情愿的帮你，也要表达感谢。<br>我常说的，你微信上请教别人一个问题，也是要给个红包回馈的。也许这个问题超级值钱，远远大于红包的价值，但给一个大红包，毕竟是一种心意。</p><p> <a href="https://mp.weixin.qq.com/s/hsjh6RLTboMYpEetWwb4AQ" target="_blank" rel="noopener">「感恩，不只是一种美德」</a></p><h3 id="8-6-学会站在不同立场的思维方式"><a href="#8-6-学会站在不同立场的思维方式" class="headerlink" title="8.6 学会站在不同立场的思维方式"></a>8.6 学会站在不同立场的思维方式</h3><p>不要总是站在自己的立场评判他人，每个人在不同的立场，会有不同的判断方式，我前面提到了很多，为什么上司，领导在看待一些人的时候，和我们想象的不一样，你站在他的位置的时候，你就会完全明白了。但今天你没机会站在那里，你也能理解，你的格局和视野就真的厉害了。</p><p>站在管理者的立场，你才能理解晋升的关键是什么。站在老板的立场，你才能理解工作的价值是什么。<br>要尽可能站在自己更上一级的立场思考问题，你才能更好的理解你当前工作的意义和价值。</p><h3 id="8-7-不要遮掩问题，要学会认错"><a href="#8-7-不要遮掩问题，要学会认错" class="headerlink" title="8.7 不要遮掩问题，要学会认错"></a>8.7 不要遮掩问题，要学会认错</h3><p><a href="https://mp.weixin.qq.com/s/SQDCbmseIQ-4PQrpzW3SAg" target="_blank" rel="noopener">「年轻人，如何抗造系列之 - 做好自己，留有空间」</a></p><p>遮掩问题，推卸责任往往是很拙劣的一种自作聪明，也是年轻人最容易犯得职场错误。<br>承认错误不丢人，对于大部分企业和领导来说，其实年轻人犯错是被允许的，是培养计划中的一部分。而对错误的反思，复盘，下一步的调整计划，更能体现出你的价值和能力。</p><p>遮掩问题，用更多的谎言去掩盖谎言，很容易穿帮，记住，你不是韦小宝，就算是韦小宝最后也会穿帮。</p><h2 id="9-关于不同领域的职场竞争力"><a href="#9-关于不同领域的职场竞争力" class="headerlink" title="9 关于不同领域的职场竞争力"></a>9 关于不同领域的职场竞争力</h2><p>不同领域，不同行业，可能职场有较大的差距，我不能说我分享的逻辑，一定可以通用所有领域和行业，或者所有企业，我只能说，这代表了我认为较为通用的职场环境，但这里有两个比较大的分支领域，其一，是所谓充分市场竞争领域；其二，是所谓垄断行业；这两个领域的职场，关于升职加薪的重点，有可能是完全不同的。</p><p>怎么思考这个问题呢，在充分市场竞争领域，你的职场竞争力是最重要的，什么是竞争力，就是你的能力和价值，一定会被同行中的某个公司所认可，所需要，这时候你谈领导是否赏识你，老板是否够大方，根本不重要，重要的是你要建立业内影响力，让更多同行老板知道你的能力，这时候就可以待价而沽。</p><p>在垄断领域，所谓职场竞争力就没那么重要了，家庭背景资源更重要，那如果没有怎么办，如何建立信任度就很重要，你必须获得领导和上司的充分信任，才有机会。</p><p>有人问问题，说银行利润这么高，为什么基层工资水平并不高，这个问题很可笑，银行是典型的垄断行业啊！虽然银行间也存在竞争，那是什么竞争，资源的竞争，人脉关系的竞争，你的竞争力在哪里，你说你代码写的好，不重要！那么信任关系如何建立，就是你需要思考的重点了。</p><p>市场竞争才会提升优质人才的身价，这其实是一个很简单的道理，互联网行业的高薪酬来自于残酷的市场竞争，很多人总是想不明白。以为去了利润高的垄断机构可以躺着拿高薪，凭什么啊，先问问你爹是谁？</p><h2 id="10-提升职场容错性"><a href="#10-提升职场容错性" class="headerlink" title="10 提升职场容错性"></a>10 提升职场容错性</h2><p>就是说呢，你要坚持做一些正确的事情，正确的选择，但要允许自己的领导，上司，不那么正确。</p><p>就具体企业，具体职位而言，可能做出了正确的选择，未必得到合理的回报，这是很常见的，世界并不是按照我们的计划前进。</p><p>但职场是个长期的事情，坚持正确的做法，相信时间的裁决。</p><h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><h3 id="1-我领导让我做一件事情，习惯性透出安给我的背景信息（大图、原因、合作方）比较少，曹大您有什么建议吗？"><a href="#1-我领导让我做一件事情，习惯性透出安给我的背景信息（大图、原因、合作方）比较少，曹大您有什么建议吗？" class="headerlink" title="1.我领导让我做一件事情，习惯性透出安给我的背景信息（大图、原因、合作方）比较少，曹大您有什么建议吗？"></a>1.我领导让我做一件事情，习惯性透出安给我的背景信息（大图、原因、合作方）比较少，曹大您有什么建议吗？</h3><p>追问就对了，当然注意态度和方法。</p><h3 id="2-说行政单位的公职人员也类比垄断行业吧？"><a href="#2-说行政单位的公职人员也类比垄断行业吧？" class="headerlink" title="2.说行政单位的公职人员也类比垄断行业吧？"></a>2.说行政单位的公职人员也类比垄断行业吧？</h3><p>是的，肯定是的</p><h3 id="3-问一下曹大，如果我已经在市场竞争行业，和领导起过冲突，后面被穿小鞋，是不是离职换下家才是最优解？"><a href="#3-问一下曹大，如果我已经在市场竞争行业，和领导起过冲突，后面被穿小鞋，是不是离职换下家才是最优解？" class="headerlink" title="3.问一下曹大，如果我已经在市场竞争行业，和领导起过冲突，后面被穿小鞋，是不是离职换下家才是最优解？"></a>3.问一下曹大，如果我已经在市场竞争行业，和领导起过冲突，后面被穿小鞋，是不是离职换下家才是最优解？</h3><p>试试开诚布公的和解，如果无解可以考虑换岗。<br>公司里如果人脉好一点，不要四处树敌，换岗机会应该很多。</p><h3 id="4-如果公司现在问题十分严重，是现在立即找工作吗？还是能等到年后？我在新能源汽车，才工作1年半一边投简历一边上班啊。"><a href="#4-如果公司现在问题十分严重，是现在立即找工作吗？还是能等到年后？我在新能源汽车，才工作1年半一边投简历一边上班啊。" class="headerlink" title="4.如果公司现在问题十分严重，是现在立即找工作吗？还是能等到年后？我在新能源汽车，才工作1年半一边投简历一边上班啊。"></a>4.如果公司现在问题十分严重，是现在立即找工作吗？还是能等到年后？我在新能源汽车，才工作1年半一边投简历一边上班啊。</h3><p>今年情况真不好说</p><h3 id="5-想请问下曹大，如果公司目前项目进度较慢或者有其他进度插入，那手头上自己的事情已经基本完成了，那该如何安排工作呢？"><a href="#5-想请问下曹大，如果公司目前项目进度较慢或者有其他进度插入，那手头上自己的事情已经基本完成了，那该如何安排工作呢？" class="headerlink" title="5.想请问下曹大，如果公司目前项目进度较慢或者有其他进度插入，那手头上自己的事情已经基本完成了，那该如何安排工作呢？"></a>5.想请问下曹大，如果公司目前项目进度较慢或者有其他进度插入，那手头上自己的事情已经基本完成了，那该如何安排工作呢？</h3><p>主动汇报，并申请一些新的事情做</p><h3 id="6-曹大，越级沟通在职场属于核弹式武器，所以职场明规则：不可以越级沟通，不然会死的很快。但是又有一条职场潜规则：不精通越级沟通，那么你这辈子都没法升上去。怎样合理的使用？"><a href="#6-曹大，越级沟通在职场属于核弹式武器，所以职场明规则：不可以越级沟通，不然会死的很快。但是又有一条职场潜规则：不精通越级沟通，那么你这辈子都没法升上去。怎样合理的使用？" class="headerlink" title="6.曹大，越级沟通在职场属于核弹式武器，所以职场明规则：不可以越级沟通，不然会死的很快。但是又有一条职场潜规则：不精通越级沟通，那么你这辈子都没法升上去。怎样合理的使用？"></a>6.曹大，越级沟通在职场属于核弹式武器，所以职场明规则：不可以越级沟通，不然会死的很快。但是又有一条职场潜规则：不精通越级沟通，那么你这辈子都没法升上去。怎样合理的使用？</h3><p>这种事情其实很常见，但是不能靠自己主动地这样的沟通，你可以被动地、因为你做得好，会产生跨级的被动的沟通。但如果大领导给你分配任务，你还是要如实汇报给你当前领导。</p><h3 id="7-能聊一聊转行吗？"><a href="#7-能聊一聊转行吗？" class="headerlink" title="7.能聊一聊转行吗？"></a>7.能聊一聊转行吗？</h3><p>这话题太大了，需要很多背景信息。在转行之前，我建议你先斜杠。</p><h3 id="8-曹大来讲讲2020年的一些机会与风险吧"><a href="#8-曹大来讲讲2020年的一些机会与风险吧" class="headerlink" title="8.曹大来讲讲2020年的一些机会与风险吧"></a>8.曹大来讲讲2020年的一些机会与风险吧</h3><p>出海这些年一直是机会，但是政策和合规性风险都很大。说实话我也不太好判断，要看国际关系的一个走势。</p><h3 id="9-请教曹大：我今年40，职位是研发经理，感觉这么发展下去路越走越窄，这种情况下如何规划未来？需要做些什么功课来提升自己？本来想效仿帅张做些副业，但听您这么一说，又不知道何去何从了"><a href="#9-请教曹大：我今年40，职位是研发经理，感觉这么发展下去路越走越窄，这种情况下如何规划未来？需要做些什么功课来提升自己？本来想效仿帅张做些副业，但听您这么一说，又不知道何去何从了" class="headerlink" title="9.请教曹大：我今年40，职位是研发经理，感觉这么发展下去路越走越窄，这种情况下如何规划未来？需要做些什么功课来提升自己？本来想效仿帅张做些副业，但听您这么一说，又不知道何去何从了"></a>9.请教曹大：我今年40，职位是研发经理，感觉这么发展下去路越走越窄，这种情况下如何规划未来？需要做些什么功课来提升自己？本来想效仿帅张做些副业，但听您这么一说，又不知道何去何从了</h3><p>第一个尽可能要懂业务，对行业业务要精通；第二点可以多扶持一些年轻人。<br>副业不是不能做，是你要平铺一下自己的优势在哪里，不是别人能赚这个钱你自己就能赚这个钱。</p><h3 id="10-曹大，如果投资了与公司业务完全无关的项目，有告知义务吗个人觉得没有这个义务，而且职位只是中层"><a href="#10-曹大，如果投资了与公司业务完全无关的项目，有告知义务吗个人觉得没有这个义务，而且职位只是中层" class="headerlink" title="10.曹大，如果投资了与公司业务完全无关的项目，有告知义务吗个人觉得没有这个义务，而且职位只是中层"></a>10.曹大，如果投资了与公司业务完全无关的项目，有告知义务吗个人觉得没有这个义务，而且职位只是中层</h3><p>是不是与公司的业务无关，不是你说了算而是公司法务说的算。我建议你先私下问一下你上司、或公司的管理人员。</p><h3 id="11-请教曹大，如果觉得不适合做技术，是不是应该提早转行"><a href="#11-请教曹大，如果觉得不适合做技术，是不是应该提早转行" class="headerlink" title="11.请教曹大，如果觉得不适合做技术，是不是应该提早转行"></a>11.请教曹大，如果觉得不适合做技术，是不是应该提早转行</h3><p>先要想好自己究竟适合做什么，以及你所想转过去的这个领域，你的职场竞争力在哪里。</p><h3 id="12-曹大，请教沟通能力应该怎么培养？"><a href="#12-曹大，请教沟通能力应该怎么培养？" class="headerlink" title="12.曹大，请教沟通能力应该怎么培养？"></a>12.曹大，请教沟通能力应该怎么培养？</h3><p>翻翻我的历史文章吧。</p><h3 id="13-请教下曹老师，团队有些高T喜欢带着大家加班导致大家工作效率很低，这种情况一般怎么办比较好？另外曹老师可以多聊聊35岁的问题么？如何及早的规划"><a href="#13-请教下曹老师，团队有些高T喜欢带着大家加班导致大家工作效率很低，这种情况一般怎么办比较好？另外曹老师可以多聊聊35岁的问题么？如何及早的规划" class="headerlink" title="13.请教下曹老师，团队有些高T喜欢带着大家加班导致大家工作效率很低，这种情况一般怎么办比较好？另外曹老师可以多聊聊35岁的问题么？如何及早的规划"></a>13.请教下曹老师，团队有些高T喜欢带着大家加班导致大家工作效率很低，这种情况一般怎么办比较好？另外曹老师可以多聊聊35岁的问题么？如何及早的规划</h3><p>第一如果效率很低的加班你无法改变，换岗呗。尽量换一下岗位。<br>另外说35岁这个问题有点大，在35岁之前让职位尽量高一些，人脉尽量广一点。</p><h3 id="14-曹大，如何建立职场人脉？"><a href="#14-曹大，如何建立职场人脉？" class="headerlink" title="14.曹大，如何建立职场人脉？"></a>14.曹大，如何建立职场人脉？</h3><p>多分享，而且是那种有价值的分享，多参与那种分享场合，通过这种过程让别人认可你。<br>人脉不是你认识多少人，你有多少人的联系方式，有多少人认可你才是人脉，一定要把这个当回事。</p><h3 id="15-请问曹大，领导对于自己的工作不太关注，并且不会分配给自己特别多任务，这种情况应该如何凸显自己的能力？"><a href="#15-请问曹大，领导对于自己的工作不太关注，并且不会分配给自己特别多任务，这种情况应该如何凸显自己的能力？" class="headerlink" title="15.请问曹大，领导对于自己的工作不太关注，并且不会分配给自己特别多任务，这种情况应该如何凸显自己的能力？"></a>15.请问曹大，领导对于自己的工作不太关注，并且不会分配给自己特别多任务，这种情况应该如何凸显自己的能力？</h3><p>无论事情大小要做好做透，多去问问领导对你的工作有什么不满意、有什么可以提升的地方，躲让领导提提批评，这样你态度到了，慢慢他就会重视你。</p><h3 id="16-曹大，请问一下作为基层的开发人员，领导在交任务并不会交代到具体细节，但是开发人员在梳理需求是发现细节可以有不同的做法，但是对应的做法产生的结果不同，这种时候罗列不同做法可能导致的后果，然后再交由领导决断是否可行？如果这种情况出现多次呢？"><a href="#16-曹大，请问一下作为基层的开发人员，领导在交任务并不会交代到具体细节，但是开发人员在梳理需求是发现细节可以有不同的做法，但是对应的做法产生的结果不同，这种时候罗列不同做法可能导致的后果，然后再交由领导决断是否可行？如果这种情况出现多次呢？" class="headerlink" title="16.曹大，请问一下作为基层的开发人员，领导在交任务并不会交代到具体细节，但是开发人员在梳理需求是发现细节可以有不同的做法，但是对应的做法产生的结果不同，这种时候罗列不同做法可能导致的后果，然后再交由领导决断是否可行？如果这种情况出现多次呢？"></a>16.曹大，请问一下作为基层的开发人员，领导在交任务并不会交代到具体细节，但是开发人员在梳理需求是发现细节可以有不同的做法，但是对应的做法产生的结果不同，这种时候罗列不同做法可能导致的后果，然后再交由领导决断是否可行？如果这种情况出现多次呢？</h3><p>这就是为什么要追问，要问上司具体的决策的依据和逻辑，因为你只有知道他的逻辑底层、知道哪些是重要的、哪些是可以忽略的，才可以理解。</p><h3 id="17-请问曹老师：从管理者的角度，如何培养和选拔有潜力成为管理者的员工？最为看重的品质有哪些？谢谢！"><a href="#17-请问曹老师：从管理者的角度，如何培养和选拔有潜力成为管理者的员工？最为看重的品质有哪些？谢谢！" class="headerlink" title="17.请问曹老师：从管理者的角度，如何培养和选拔有潜力成为管理者的员工？最为看重的品质有哪些？谢谢！"></a>17.请问曹老师：从管理者的角度，如何培养和选拔有潜力成为管理者的员工？最为看重的品质有哪些？谢谢！</h3><p>主动性很重要；敢担当、敢承担责任；人脉好，至少团队要服Ta。</p><h3 id="18-曹大，目前刚刚工作3年半，在一家新公司担任二级部门研发leader，目前感觉自己管理能力较弱，并且研发能力到达瓶颈。想问下是花更多经历在突破研发瓶颈呢，还是提升自己的管理能力？（行业为手机行业）"><a href="#18-曹大，目前刚刚工作3年半，在一家新公司担任二级部门研发leader，目前感觉自己管理能力较弱，并且研发能力到达瓶颈。想问下是花更多经历在突破研发瓶颈呢，还是提升自己的管理能力？（行业为手机行业）" class="headerlink" title="18.曹大，目前刚刚工作3年半，在一家新公司担任二级部门研发leader，目前感觉自己管理能力较弱，并且研发能力到达瓶颈。想问下是花更多经历在突破研发瓶颈呢，还是提升自己的管理能力？（行业为手机行业）"></a>18.曹大，目前刚刚工作3年半，在一家新公司担任二级部门研发leader，目前感觉自己管理能力较弱，并且研发能力到达瓶颈。想问下是花更多经历在突破研发瓶颈呢，还是提升自己的管理能力？（行业为手机行业）</h3><p>建议你直接问问自己的上司，哪些地方可以提升和改进。</p><h3 id="19-想请教下曹大，当前感觉技术进步不大，想跳槽，但能力又达不到好公司的要求，这时该怎么办？"><a href="#19-想请教下曹大，当前感觉技术进步不大，想跳槽，但能力又达不到好公司的要求，这时该怎么办？" class="headerlink" title="19.想请教下曹大，当前感觉技术进步不大，想跳槽，但能力又达不到好公司的要求，这时该怎么办？"></a>19.想请教下曹大，当前感觉技术进步不大，想跳槽，但能力又达不到好公司的要求，这时该怎么办？</h3><p>刷题，以及把以前的项目反复整理看怎么能做得更好一点。<br>可以在GitHub上做点好的开源项目，会加分。</p><h3 id="20-请问曹大之所以能成为曹大，最重要的因素是什么？"><a href="#20-请问曹大之所以能成为曹大，最重要的因素是什么？" class="headerlink" title="20.请问曹大之所以能成为曹大，最重要的因素是什么？"></a>20.请问曹大之所以能成为曹大，最重要的因素是什么？</h3><p>第一是我入行比较早，早期互联网人才比较少；<br>第二是我好为人师，攒了很多人脉，口碑比较好。</p><h3 id="21-曹老师，今天要续签合同，两年没有加薪了，我要怎么给领导提？"><a href="#21-曹老师，今天要续签合同，两年没有加薪了，我要怎么给领导提？" class="headerlink" title="21.曹老师，今天要续签合同，两年没有加薪了，我要怎么给领导提？"></a>21.曹老师，今天要续签合同，两年没有加薪了，我要怎么给领导提？</h3><p>两年没加薪你应该是几个月前就在找新的工作了而不是在续签的时候才想起来这个问题。<br>很多人总觉得自己的收入高低是取决于老板对你的赏识及老板够不够大方，很多时候你的价值取决于你在职场、你在你行业里公认的价值中，自己做到了什么程度。</p><h3 id="22-曹大公司有意把我培养成管理层，后续带团队。但目前我下面正在筹备着，还没有人员的补充（光棍司令）那我应该目前做哪些准备来应对接下来的安排呢？或者优先规划哪一块的工作内容呢？（在完成自己工作的前提下）"><a href="#22-曹大公司有意把我培养成管理层，后续带团队。但目前我下面正在筹备着，还没有人员的补充（光棍司令）那我应该目前做哪些准备来应对接下来的安排呢？或者优先规划哪一块的工作内容呢？（在完成自己工作的前提下）" class="headerlink" title="22.曹大公司有意把我培养成管理层，后续带团队。但目前我下面正在筹备着，还没有人员的补充（光棍司令）那我应该目前做哪些准备来应对接下来的安排呢？或者优先规划哪一块的工作内容呢？（在完成自己工作的前提下）"></a>22.曹大公司有意把我培养成管理层，后续带团队。但目前我下面正在筹备着，还没有人员的补充（光棍司令）那我应该目前做哪些准备来应对接下来的安排呢？或者优先规划哪一块的工作内容呢？（在完成自己工作的前提下）</h3><p>还是问上司，直接问Ta你应该学习什么，做什么，准备什么。</p><h3 id="23-请教曹大，职场如何更好处理与同事的关系呢？同级和上下级的"><a href="#23-请教曹大，职场如何更好处理与同事的关系呢？同级和上下级的" class="headerlink" title="23.请教曹大，职场如何更好处理与同事的关系呢？同级和上下级的"></a>23.请教曹大，职场如何更好处理与同事的关系呢？同级和上下级的</h3><p>多感谢别人的帮助多称赞别人的成绩<br>但注意，你不可能让每个人都认同你、称赞你，但你可以坚持正确的方法，这样才有正确的人认同你。<br>发现别人的优点，不是阿谀奉承。</p><h3 id="24-曹大，请问一下，基层开发，然后也算是小组长了。但是公司是扁平化管理，这种如何晋升。做的也是传统化互联网企业。"><a href="#24-曹大，请问一下，基层开发，然后也算是小组长了。但是公司是扁平化管理，这种如何晋升。做的也是传统化互联网企业。" class="headerlink" title="24.曹大，请问一下，基层开发，然后也算是小组长了。但是公司是扁平化管理，这种如何晋升。做的也是传统化互联网企业。"></a>24.曹大，请问一下，基层开发，然后也算是小组长了。但是公司是扁平化管理，这种如何晋升。做的也是传统化互联网企业。</h3><p>尽量做出令人信服的成绩，然后也要尽量建立职场影响力，你的晋升不一定在这家公司。</p><h3 id="25-大公司和创业公司如何选择？"><a href="#25-大公司和创业公司如何选择？" class="headerlink" title="25.大公司和创业公司如何选择？"></a>25.大公司和创业公司如何选择？</h3><p>今年除非特别好的创业公司，我不太建议别人去创业公司。<br>前些年我会建议，这两年我不太敢说这样的话。</p><h3 id="26-开发人员，加班太多，想找个轻松的工作，还适合继续干下去吗"><a href="#26-开发人员，加班太多，想找个轻松的工作，还适合继续干下去吗" class="headerlink" title="26.开发人员，加班太多，想找个轻松的工作，还适合继续干下去吗"></a>26.开发人员，加班太多，想找个轻松的工作，还适合继续干下去吗</h3><p>看你处于职场的什么阶段，以及你个人对自己职场的评估是什么，这种事情不要找别人提建议。</p><h3 id="27-曹大您好，请问职场中应该主动提加薪吗？该怎么提？"><a href="#27-曹大您好，请问职场中应该主动提加薪吗？该怎么提？" class="headerlink" title="27.曹大您好，请问职场中应该主动提加薪吗？该怎么提？"></a>27.曹大您好，请问职场中应该主动提加薪吗？该怎么提？</h3><p>让自己变得值钱。值钱的意思是在行业内很容易找到高工资的职位，如果他不给你加薪你可以直接走。<br>如果你没有变得值钱，提了之后他们也没有给你加薪，是不是很尴尬。</p><h3 id="28-曹大，我现在31了，还没有找到适合自己的职业，自己性格是内向的，现在做销售，一直做不好，想找一些技术向的工作，可是现在这个岁数，面试了不少，都拒绝了，我改怎么办"><a href="#28-曹大，我现在31了，还没有找到适合自己的职业，自己性格是内向的，现在做销售，一直做不好，想找一些技术向的工作，可是现在这个岁数，面试了不少，都拒绝了，我改怎么办" class="headerlink" title="28.曹大，我现在31了，还没有找到适合自己的职业，自己性格是内向的，现在做销售，一直做不好，想找一些技术向的工作，可是现在这个岁数，面试了不少，都拒绝了，我改怎么办"></a>28.曹大，我现在31了，还没有找到适合自己的职业，自己性格是内向的，现在做销售，一直做不好，想找一些技术向的工作，可是现在这个岁数，面试了不少，都拒绝了，我改怎么办</h3><p>面试被拒绝的时候，原因是什么？有没有深入沟通过？有没有保持后续的可能性？有没有在面试后把下一次做得更好？有没有去刷题？类似这样的。</p><h3 id="29-求问曹大，我在事业单位上班但是对做生意感兴趣，而且做了好几年了，想问问怎么结交商业上厉害的朋友并跟着他们学到东西？"><a href="#29-求问曹大，我在事业单位上班但是对做生意感兴趣，而且做了好几年了，想问问怎么结交商业上厉害的朋友并跟着他们学到东西？" class="headerlink" title="29.求问曹大，我在事业单位上班但是对做生意感兴趣，而且做了好几年了，想问问怎么结交商业上厉害的朋友并跟着他们学到东西？"></a>29.求问曹大，我在事业单位上班但是对做生意感兴趣，而且做了好几年了，想问问怎么结交商业上厉害的朋友并跟着他们学到东西？</h3><p>在事业单位上确实可以做副业，如果空余时间比较多的话。而且事业单位对副业这件事的企业敏感度也没有那么高。</p><p>在一些知识星球或者论坛分享你对商业的看法。实话说，你分享的价值越高，找你的人机会也越好，但事实上行业里骗子很多，你要做好鉴别。</p><h3 id="30-曹大，我是非科班培训出来做技术的，随着工龄增长感觉技术路越来越吃力，并且渐渐失去兴趣，但是由于经济压力暂时无法做出取舍的决定，能帮我分析一下我应该怎么做？"><a href="#30-曹大，我是非科班培训出来做技术的，随着工龄增长感觉技术路越来越吃力，并且渐渐失去兴趣，但是由于经济压力暂时无法做出取舍的决定，能帮我分析一下我应该怎么做？" class="headerlink" title="30.曹大，我是非科班培训出来做技术的，随着工龄增长感觉技术路越来越吃力，并且渐渐失去兴趣，但是由于经济压力暂时无法做出取舍的决定，能帮我分析一下我应该怎么做？"></a>30.曹大，我是非科班培训出来做技术的，随着工龄增长感觉技术路越来越吃力，并且渐渐失去兴趣，但是由于经济压力暂时无法做出取舍的决定，能帮我分析一下我应该怎么做？</h3><p>我前面强调过，技术人员如果对业务和商业有比较敏锐的觉察你的职场路会越走越宽的。<br>作为公司的老板和高层，他们有时和技术人员沟通很困难，可能说你的技术能力不是最好的、但他们和你沟通很方便的话，你很理解他们说的话，你能理解他们说的商业目标之类的，就会很有用。<br>所以我前面提到的人，他们现在不会再写代码了，但是他们很理解商业、很理解技术。</p><h3 id="31-请教曹大，关于职场上的人性世故开窍的晚，职场处处上碰壁，吃灰，该阿谀奉承，跟各种人混，还是秉持直白天真，按自己意愿做事，做人？"><a href="#31-请教曹大，关于职场上的人性世故开窍的晚，职场处处上碰壁，吃灰，该阿谀奉承，跟各种人混，还是秉持直白天真，按自己意愿做事，做人？" class="headerlink" title="31.请教曹大，关于职场上的人性世故开窍的晚，职场处处上碰壁，吃灰，该阿谀奉承，跟各种人混，还是秉持直白天真，按自己意愿做事，做人？"></a>31.请教曹大，关于职场上的人性世故开窍的晚，职场处处上碰壁，吃灰，该阿谀奉承，跟各种人混，还是秉持直白天真，按自己意愿做事，做人？</h3><p>沟通不讲方法，不叫直白天真，叫蠢。<br>不能说想怼谁就怼谁，这不对的。</p><h3 id="32-请问曹大，干程序员才4年，就感觉身体不舒服，尤其是颈椎，腰椎等工作一天特别僵硬，怎么平衡工作与身体健康的关系？"><a href="#32-请问曹大，干程序员才4年，就感觉身体不舒服，尤其是颈椎，腰椎等工作一天特别僵硬，怎么平衡工作与身体健康的关系？" class="headerlink" title="32.请问曹大，干程序员才4年，就感觉身体不舒服，尤其是颈椎，腰椎等工作一天特别僵硬，怎么平衡工作与身体健康的关系？"></a>32.请问曹大，干程序员才4年，就感觉身体不舒服，尤其是颈椎，腰椎等工作一天特别僵硬，怎么平衡工作与身体健康的关系？</h3><p>坚持锻炼身体，真的要坚持锻炼身体。</p><h3 id="33-曹老师，遇得那种不懂汇报，你说一句，他做一下，说几次的都没用的员工，是不是要舍得裁掉？"><a href="#33-曹老师，遇得那种不懂汇报，你说一句，他做一下，说几次的都没用的员工，是不是要舍得裁掉？" class="headerlink" title="33.曹老师，遇得那种不懂汇报，你说一句，他做一下，说几次的都没用的员工，是不是要舍得裁掉？"></a>33.曹老师，遇得那种不懂汇报，你说一句，他做一下，说几次的都没用的员工，是不是要舍得裁掉？</h3><p>做事行不行？行就丢在底层，这种人是没办法晋升的。</p><h3 id="34-对于领导强压的不太合理的制度，如何给团队传达？"><a href="#34-对于领导强压的不太合理的制度，如何给团队传达？" class="headerlink" title="34.对于领导强压的不太合理的制度，如何给团队传达？"></a>34.对于领导强压的不太合理的制度，如何给团队传达？</h3><p>跟领导沟通一下，要理解领导作出这种决策的逻辑和原因。</p><h3 id="35-请问曹大，作为职场新人想在公司推进新的业务，该怎么推进呢？除了自己调研业务的可行性以外，在协调同事和领导资源的时候该注意什么呢？"><a href="#35-请问曹大，作为职场新人想在公司推进新的业务，该怎么推进呢？除了自己调研业务的可行性以外，在协调同事和领导资源的时候该注意什么呢？" class="headerlink" title="35.请问曹大，作为职场新人想在公司推进新的业务，该怎么推进呢？除了自己调研业务的可行性以外，在协调同事和领导资源的时候该注意什么呢？"></a>35.请问曹大，作为职场新人想在公司推进新的业务，该怎么推进呢？除了自己调研业务的可行性以外，在协调同事和领导资源的时候该注意什么呢？</h3><p>调研能力是非常考验职场新人的点之一，百度会把这个作为他们考量新产品经理的指标。调研能做好，你在职场会加分很多。</p><h3 id="36-请教曹老师，一个非常普通的计算机本科毕业生需要在哪些方面发力才能进入互联网大厂，还是说建议考研？"><a href="#36-请教曹老师，一个非常普通的计算机本科毕业生需要在哪些方面发力才能进入互联网大厂，还是说建议考研？" class="headerlink" title="36.请教曹老师，一个非常普通的计算机本科毕业生需要在哪些方面发力才能进入互联网大厂，还是说建议考研？"></a>36.请教曹老师，一个非常普通的计算机本科毕业生需要在哪些方面发力才能进入互联网大厂，还是说建议考研？</h3><p>Google Code Jam，拿到前一百，大厂抢着要。</p><h3 id="37-曹大你好。我是程序员，报了挺多类似极客时间的这种技术课程。最大的感受是，学了但很多东西工作用不到，过段时间就忘光了。请问如何进行有效的学习提升？"><a href="#37-曹大你好。我是程序员，报了挺多类似极客时间的这种技术课程。最大的感受是，学了但很多东西工作用不到，过段时间就忘光了。请问如何进行有效的学习提升？" class="headerlink" title="37.曹大你好。我是程序员，报了挺多类似极客时间的这种技术课程。最大的感受是，学了但很多东西工作用不到，过段时间就忘光了。请问如何进行有效的学习提升？"></a>37.曹大你好。我是程序员，报了挺多类似极客时间的这种技术课程。最大的感受是，学了但很多东西工作用不到，过段时间就忘光了。请问如何进行有效的学习提升？</h3><p>你要看你工作中真的哪些东西用得到，带着问题去学习。然后再做做项目。<br>一定要学透，上十个课不如把一堂课学透学扎实。</p><p>「</p><p>」</p><p> <a href="">「」</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Android 性能优化篇</title>
      <link href="/2019/complete-works-of-android-performance.html"/>
      <url>/2019/complete-works-of-android-performance.html</url>
      
        <content type="html"><![CDATA[<p>随着项目版本的迭代，<strong>App</strong> 的性能问题会逐渐暴露出来，而好的用户体验与性能表现紧密相关。 最近项目核心功能收尾，准备开启优化之路，打造一个高用户体验的 <strong>APP</strong></p><p>技术不断更新，我将在边学习边实践的过程中进行分享，并将实践结果与大家分享，希望大家看到文章中有不足的地方及时给我留言，我将与大家积极讨论。</p><hr><h2 id="App-启动优化"><a href="#App-启动优化" class="headerlink" title="App 启动优化"></a>App 启动优化</h2><h3 id="App-初体验-启动优化-more-💦"><a href="#App-初体验-启动优化-more-💦" class="headerlink" title="App 初体验-启动优化 more  💦"></a><a href="https://calmcenter.club/2019/start-optimization.html">App 初体验-启动优化 more  💦</a></h3><ul><li><strong>1 启动</strong></li><li><strong>2 检测启动消耗<code>(敲黑板)</code></strong></li><li><strong>3 启动优化<code>(干货)</code></strong></li><li><strong>4 启动监控</strong></li></ul><hr><h2 id="App-内存优化"><a href="#App-内存优化" class="headerlink" title="App 内存优化"></a>App 内存优化</h2><h3 id="App-内存知识介绍-more-💦"><a href="#App-内存知识介绍-more-💦" class="headerlink" title="App 内存知识介绍 more 💦"></a><a href="https://calmcenter.club/2020/memory-optimization.html">App 内存知识介绍 more 💦</a></h3><ul><li><strong>1 什么是内存？</strong></li><li><strong>2 JVM 如何分配内存？</strong></li><li><strong>3 JVM 如何管理内存？</strong></li><li><strong>4 什么是 Dalvik?</strong></li><li><strong>5 什么是 ART?</strong></li><li><strong>6 内存引发的问题</strong></li><li><strong>7 Android Bitmap 内存分配的变化</strong></li><li><strong>8 内存优化的两个误区</strong></li></ul><h3 id="App-内存检测优化-more-💦"><a href="#App-内存检测优化-more-💦" class="headerlink" title="App 内存检测优化 more 💦"></a><a href="https://calmcenter.club/2020/memory-optimization2.html">App 内存检测优化 more 💦</a></h3><ul><li><strong>1 什么是 Memory Profiler？</strong></li><li><strong>2 什么是 MAT？</strong></li><li><strong>3 什么是 LeakCanary？</strong></li><li><strong>4 自定义实现 Demo<code>(学习 ~ )</code></strong></li><li><strong>5 优化思路</strong></li><li><strong>6 更多</strong></li></ul><hr><h2 id="App-UI-优化"><a href="#App-UI-优化" class="headerlink" title="App UI 优化"></a>App UI 优化</h2><h3 id="App-UI-优化-more-💦"><a href="#App-UI-优化-more-💦" class="headerlink" title="App UI 优化 more 💦"></a><a href="https://calmcenter.club/2020/ui-optimization.html">App UI 优化 more 💦</a></h3><ul><li><strong>1 UI 优化究竟指的是什么呢？</strong></li><li><strong>2 屏幕适配？？？</strong></li><li><strong>3 如何测量、监控 UI 需要优化？</strong></li><li><strong>4 UI 优化常用手段</strong></li><li><strong>5 总结</strong></li></ul><p><a href="https://time.geekbang.org/column/article/74044" target="_blank" rel="noopener">极客时间 Android开发高手课</a>  </p><p><a href="https://coding.imooc.com/learn/list/308.html" target="_blank" rel="noopener">慕课 Top团队大牛带你玩转Android性能分析与优化</a></p><p><strong>注意：如果出现图片不显示问题请移步</strong> <a href="https://calmcenter.club/2019/PicNotShow.html">图片不显示问题</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 搭建博客篇</title>
      <link href="/2019/complete-works-of-hexo.html"/>
      <url>/2019/complete-works-of-hexo.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、为什么要写这篇文章"><a href="#一、为什么要写这篇文章" class="headerlink" title="一、为什么要写这篇文章"></a>一、为什么要写这篇文章</h1><p>各大网站关于搭建博客的文章已经不是一篇两篇了，但是他们的文章也有坑~<code>(可能是版本问题)</code>也各有各的特点，这里带你踩坑，并带你实现他们的特点</p><blockquote><p>把无序的信息变的有序，本质上也是信息差，也是可以创造价值的。</p></blockquote><p>所以我准备整理一下各各博客的特点，尽力写成一本大全。</p><h1 id="二、本文主要记载"><a href="#二、本文主要记载" class="headerlink" title="二、本文主要记载"></a>二、本文主要记载</h1><ul><li><strong>Hexo</strong> 基础搭建</li><li>管理代码( <strong>git</strong> 基本操作)</li><li>装饰博客</li><li><strong>live2D</strong> 看板娘</li><li>网站管理<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">本文环境是 win10 或 win 7。mac 再执行 npm 时需要在前面添加 sudo</span><br><span class="line">本文整理于各大佬文章，文中会给出相应链接，如有侵权，请联系我修改或删除。</span><br></pre></td></tr></table></figure></li></ul><hr><a id="more"></a><h2 id="Hexo-基础搭建-more"><a href="#Hexo-基础搭建-more" class="headerlink" title="Hexo 基础搭建 more  "></a><a href="https://calmcenter.club/2019/Hexo_bash.html">Hexo 基础搭建 more  </a></h2><ul><li>搭建本地博客</li><li>部署到 <strong>Github Pages</strong></li></ul><h2 id="管理代码-git-基本操作-more"><a href="#管理代码-git-基本操作-more" class="headerlink" title="管理代码( git 基本操作) more"></a><a href="https://calmcenter.club/2019/Hexo_code_management.html">管理代码( git 基本操作) more</a></h2><ul><li><strong>git</strong> 拉取代码</li><li><strong>git</strong> 创建分支</li><li><strong>git</strong> 提交分支代码</li><li>其他终端如何使用 <strong>Hexo</strong> 源码</li></ul><h2 id="功能样式配置-more"><a href="#功能样式配置-more" class="headerlink" title="功能样式配置 more  "></a><a href="https://calmcenter.club/2019/Hexo_functional_style.html">功能样式配置 more  </a></h2><ul><li><strong>NexT</strong> 主题设置</li><li>基础样式设置</li><li>图片相关</li><li>打赏、评论、复制功能</li><li><strong>DaoVoice</strong> 实现在线联系</li><li>文章置顶</li><li>搜索功能</li><li>细节美化</li></ul><h2 id="live2D-看板娘-more"><a href="#live2D-看板娘-more" class="headerlink" title="live2D 看板娘 more  "></a><a href="https://calmcenter.club/2019/Hexo_Live2D.html"><strong>live2D</strong> 看板娘 more  </a></h2><ul><li>使用 <strong>hexo-helper-live2d</strong> 完成看板娘</li><li>自定义看板娘(右下角那个~)<ul><li>运行、接入 <strong>Demo</strong></li><li>更换、修改模型</li></ul></li></ul><h2 id="网站管理-more"><a href="#网站管理-more" class="headerlink" title="网站管理 more  "></a><a href="https://calmcenter.club/2019/Hexo_website_management.html">网站管理 more  </a></h2><ul><li>个人域名</li><li>加入 <strong>Coding</strong> 服务器</li><li><strong>SEO</strong>  推广</li></ul><hr><h1 id="来都来了-在评论留下你的足迹可否-？"><a href="#来都来了-在评论留下你的足迹可否-？" class="headerlink" title="来都来了 ~ 在评论留下你的足迹可否 ？"></a><code>来都来了 ~ 在评论留下你的足迹可否 ？</code></h1><p><strong>注意：如果出现图片不显示问题请移步</strong> <a href="https://calmcenter.club/2019/PicNotShow.html">图片不显示问题</a></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Next </tag>
            
            <tag> git </tag>
            
            <tag> github </tag>
            
            <tag> live2d </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
