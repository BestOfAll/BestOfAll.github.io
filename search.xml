<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>设计模式-结构型-享元模式</title>
      <link href="/2020/design-pattern-flyweight.html"/>
      <url>/2020/design-pattern-flyweight.html</url>
      
        <content type="html"><![CDATA[<p>所谓 “享元”，顾名思义就是被共享的单元。享元模式的意图是复用对象，节省内存，前提是享元对象是不可变对象。</p><p>当一个系统中存在大量重复对象的时候，如果这些重复的对象是<strong>不可变对象</strong>，我们就可以利用享元模式将对象设计成享元，在内存中只保留一份实例，供多处代码引用。这样可以减少内存中对象的数量，起到节省内存的目的。</p><p>实际上，不仅仅相同对象可以设计成享元，对于相似对象，我们也可以将这些对象中相同的部分（字段）提取出来，设计成享元，让这些大量相似对象引用这些享元。</p><p>定义中的 “<strong>不可变对象</strong>” 指的是，一旦通过构造函数初始化完成之后，它的状态（对象的成员变量或者属性）就不会再被修改了。所以，不可变对象不能暴露任何 <code>set()</code> 等修改内部状态的方法。之所以要求享元是不可变对象，那是因为它会被多处代码共享使用，避免一处代码对享元进行了修改，影响到其他使用它的代码。</p><h1 id="1-享元模式-UML"><a href="#1-享元模式-UML" class="headerlink" title="1 享元模式 UML"></a>1 享元模式 UML</h1><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/design/design_uml_flyweight.webp" alt="图片来源于《Android 源码设计模式解析与实战》"></p><p>举个 🌰</p><p>过年回家买火车票是一件很困难的事，无数人用刷票插件软件在向服务端发出请求，对于每一个请求服务器都必须做出应答。</p><p>在用户设置好出发地和目的地之后，每次请求都返回一个查询的车票结果。那么当数以万计的人不间断在请求数据时，如果每次都重新创建一个查询的车票结果，那么必然会造成大量重复对象的创建、销毁，使得 <code>GC</code> 任务繁重、内存占用率高居不下。</p><p>而这类问题通过享元模式就能够得到很好地改善，从城市 <code>A</code> 到城市 <code>B</code> 的车辆是有限的，车上的铺位也就是硬卧、硬卧、坐票 3 种。我们将这些可以公用的对象缓存起来，在用户查询时优先使用缓存，如果没有缓存则重新创建。这样就将成千上万的对象变为了可选择的有限数量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Ticket</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showTicketInfo</span><span class="params">(String bunk)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrainTicket</span> <span class="keyword">implements</span> <span class="title">Ticket</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String from;</span><br><span class="line">    <span class="keyword">private</span> String to;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TrainTicket</span><span class="params">(String from, String to)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.from = from;</span><br><span class="line">        <span class="keyword">this</span>.to = to;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showTicketInfo</span><span class="params">(String bunk)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> price = <span class="keyword">new</span> Random().nextInt(<span class="number">300</span>);</span><br><span class="line">        System.out.println(<span class="string">"购买 从 "</span> + from + <span class="string">" 到 "</span> + to + <span class="string">" 的 "</span> + bunk + <span class="string">" 火车票，价格："</span> + price);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Map&lt;String, Ticket&gt; sTringTicketMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Ticket <span class="title">getTicket</span><span class="params">(String from, String to)</span> </span>&#123;</span><br><span class="line">        String key = from + <span class="string">"-"</span> + to;</span><br><span class="line">        <span class="keyword">if</span> (sTringTicketMap.containsKey(key)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"使用缓存 ==&gt;"</span> + key);</span><br><span class="line">            <span class="keyword">return</span> sTringTicketMap.get(key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"创建对象 ==&gt;"</span> + key);</span><br><span class="line">            Ticket ticket = <span class="keyword">new</span> TrainTicket(from, to);</span><br><span class="line">            sTringTicketMap.put(key, ticket);</span><br><span class="line">            <span class="keyword">return</span> ticket;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-简单实现"><a href="#2-简单实现" class="headerlink" title="2 简单实现"></a>2 简单实现</h1><p>举个 🌰</p><p>假设我们在开发一个棋牌游戏（比如象棋）。一个游戏厅中有成千上万个“房间”，每个房间对应一个棋局。棋局要保存每个棋子的数据，比如：棋子类型（将、相、士、炮等）、棋子颜色（红方、黑方）、棋子在棋局中的位置。利用这些数据，我们就能显示一个完整的棋盘给玩家。</p><p>为了记录每个房间当前的棋局情况，我们需要给每个房间都创建一个 <code>ChessBoard</code> 棋局对象。因为游戏大厅中有成千上万的房间（实际上，百万人同时在线的游戏大厅也有很多），那保存这么多棋局对象就会消耗大量的内存。</p><p>这个时候，<strong>享元模式</strong>就可以派上用场了。像刚刚的实现方式，在内存中会有大量的相似对象。这些相似对象的 <code>id</code>、<code>text</code>、<code>color</code> 都是相同的，唯独 <code>positionX</code>、<code>positionY</code> 不同。实际上，我们可以将棋子的 <code>id</code>、<code>text</code>、<code>color</code> 属性拆分出来，设计成独立的类，并且作为享元供多个棋盘复用。这样，棋盘只需要记录每个棋子的位置信息就可以了。</p><p>棋盘上旗子颜色和字都是固定的，只需要全部添加，并且缓存使用就好。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChessPieceUnit</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String text;</span><br><span class="line">    <span class="keyword">private</span> Color color;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChessPieceUnit</span><span class="params">(<span class="keyword">int</span> id, String text, Color color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.text = text;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">enum</span> Color &#123;RED, BLACK&#125; <span class="comment">// ...省略其他属性和getter/setter方法...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChessPiece</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ChessPieceUnit chessPieceUnit;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> positionX;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> positionY;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChessPiece</span><span class="params">(ChessPieceUnit chessPieceUnit, <span class="keyword">int</span> positionX, <span class="keyword">int</span> positionY)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.chessPieceUnit = chessPieceUnit;</span><br><span class="line">        <span class="keyword">this</span>.positionX = positionX;</span><br><span class="line">        <span class="keyword">this</span>.positionY = positionX;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChessPieceUnitFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Integer, ChessPieceUnit&gt; pieces = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        pieces.put(<span class="number">1</span>, <span class="keyword">new</span> ChessPieceUnit(<span class="number">1</span>, <span class="string">"車"</span>, ChessPieceUnit.Color.BLACK));</span><br><span class="line">        pieces.put(<span class="number">2</span>, <span class="keyword">new</span> ChessPieceUnit(<span class="number">2</span>, <span class="string">"馬"</span>, ChessPieceUnit.Color.BLACK));</span><br><span class="line">        <span class="comment">//...省略摆放其他棋子的代码...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ChessPieceUnit <span class="title">getChessPiece</span><span class="params">(<span class="keyword">int</span> chessPieceId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pieces.get(chessPieceId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们利用工厂类来缓存 <code>ChessPieceUnit</code> 信息（也就是 <code>id</code>、<code>text</code>、<code>color</code>）。通过工厂类获取到的 <code>ChessPieceUnit</code> 就是享元。所有的 <code>ChessBoard</code> 对象共享这 30 个 <code>ChessPieceUnit</code> 对象（因为象棋中只有 30 个棋子）。在使用享元模式之前，记录 1 万个棋局，我们要创建 30 万（ 30*1 万）个棋子的 <code>ChessPieceUnit</code> 对象。利用享元模式，我们只需要创建 30 个享元对象供所有棋局共享使用即可，大大节省了内存。</p><p>享元模式实际上，它的代码实现非常简单，主要是通过工厂模式，在工厂类中，通过一个 <code>Map</code> 来缓存已经创建过的享元对象，来达到复用的目的。</p><h1 id="3-享元模式-vs-单例、缓存、对象池"><a href="#3-享元模式-vs-单例、缓存、对象池" class="headerlink" title="3 享元模式 vs 单例、缓存、对象池"></a>3 享元模式 vs 单例、缓存、对象池</h1><p>在上面的讲解中，我们多次提到 “共享” “缓存” “复用” 这些字眼，那它跟单例、缓存、对象池这些概念有什么区别呢？</p><h2 id="3-1-享元模式跟单例的区别"><a href="#3-1-享元模式跟单例的区别" class="headerlink" title="3.1 享元模式跟单例的区别"></a>3.1 享元模式跟单例的区别</h2><p>在单例模式中，一个类只能创建一个对象，而在享元模式中，一个类可以创建多个对象，每个对象被多处代码引用共享。实际上，享元模式有点类似于之前讲到的单例的变体：多例。</p><p>区别两种设计模式，不能光看代码实现，而是要看设计意图，也就是要解决的问题。应用享元模式是为了对象复用，节省内存，而应用多例模式是为了限制对象的个数。</p><h2 id="3-2-享元模式跟缓存的区别"><a href="#3-2-享元模式跟缓存的区别" class="headerlink" title="3.2 享元模式跟缓存的区别"></a>3.2 享元模式跟缓存的区别</h2><p>在享元模式的实现中，我们通过工厂类来 “缓存” 已经创建好的对象。这里的 “缓存” 实际上是 “存储” 的意思，跟我们平时所说的 “数据库缓存” “CPU 缓存” “<code>MemCache</code> 缓存” 是两回事。我们平时所讲的缓存，主要是为了提高访问效率，而非复用。</p><h2 id="3-3-享元模式跟对象池的区别"><a href="#3-3-享元模式跟对象池的区别" class="headerlink" title="3.3 享元模式跟对象池的区别"></a>3.3 享元模式跟对象池的区别</h2><p>池化技术中的 “复用” 可以理解为 “重复使用” ，主要目的是节省时间（比如从数据库池中取一个连接，不需要重新创建）。<strong>在任意时刻，每一个对象、连接、线程，并不会被多处使用，而是被一个使用者独占，当使用完成之后，放回到池中，再由其他使用者重复利用</strong>。享元模式中的“复用”可以理解为 “共享使用”，<strong>在整个生命周期中，都是被所有使用者共享的</strong>，主要目的是节省空间。</p><h1 id="4-享元模式在-Integer、String-中的应用"><a href="#4-享元模式在-Integer、String-中的应用" class="headerlink" title="4 享元模式在 Integer、String 中的应用"></a>4 享元模式在 Integer、String 中的应用</h1><h2 id="4-1-Integer"><a href="#4-1-Integer" class="headerlink" title="4.1 Integer"></a>4.1 Integer</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 = <span class="number">56</span>;</span><br><span class="line">Integer i2 = <span class="number">56</span>;</span><br><span class="line">Integer i3 = <span class="number">129</span>;</span><br><span class="line">Integer i4 = <span class="number">129</span>;</span><br><span class="line">System.out.println(i1 == i2);</span><br><span class="line">System.out.println(i3 == i4);</span><br></pre></td></tr></table></figure><p>要正确地分析上面的代码，我们需要弄清楚下面两个问题：</p><ul><li>如何判定两个 <code>Java</code> 对象是否相等（也就代码中的 “==” 操作符的含义）？</li><li>什么是自动装箱（<code>Autoboxing</code>）和自动拆箱（<code>Unboxing</code>）？</li></ul><p>所谓的<strong>自动装箱</strong>，就是自动将基本数据类型转换为包装器类型。所谓的<strong>自动拆箱</strong>，也就是自动将包装器类型转化为基本数据类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="number">56</span>; <span class="comment">//自动装箱</span></span><br><span class="line"><span class="keyword">int</span> j = i; <span class="comment">//自动拆箱</span></span><br></pre></td></tr></table></figure><p>数值 <code>56</code> 是基本数据类型 <code>int</code>，当赋值给包装器类型（<code>Integer</code>）变量的时候，触发自动装箱操作，创建一个 <code>Integer</code> 类型的对象，并且赋值给变量 <code>i</code>。其底层相当于执行了下面这条语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="number">59</span>；底层执行了：Integer i = Integer.valueOf(<span class="number">59</span>);</span><br></pre></td></tr></table></figure><p>当我们通过 “==” 来判定两个对象是否相等的时候，实际上是在<strong>判断两个局部变量存储的地址是否相同</strong>，换句话说，是在<strong>判断两个局部变量是否指向相同的对象</strong>。</p><p>回头看那段代码，前 <code>4</code> 行赋值语句都会触发自动装箱操作，也就是会创建 <code>Integer</code> 对象并且赋值给 <code>i1</code>、<code>i2</code>、<code>i3</code>、<code>i4</code> 这四个变量。根据刚刚的讲解，<code>i1</code>、<code>i2</code> 尽管存储的数值相同，都是 <code>56</code>，但是指向不同的 <code>Integer</code> 对象，所以通过 <code>“==”</code> 来判定是否相同的时候，会返回 false。同理，<code>i3==i4</code> 判定语句也会返回 <code>false</code>。</p><p>以为这样就完了吗？上面的分析还是不对，答案并非是两个 <code>false</code>，而是一个 <code>true</code>，一个 <code>false</code>。<br>这正是因为 <code>Integer</code> 用到了享元模式来复用对象，才导致了这样的运行结果。当我们通过自动装箱，也就是调用 <code>valueOf()</code> 来创建 <code>Integer</code> 对象的时候，如果要创建的 <code>Integer</code> 对象的值在 <code>-128</code> 到 <code>127</code> 之间，会从 <code>IntegerCache</code> 类中直接返回，否则才调用 <code>new</code> 方法创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>IntegerCache</code> 相当于享元对象的工厂类，只不过名字不叫 <code>xxxFactory</code> 而已。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Cache to support the object identity semantics of autoboxing for values between</span></span><br><span class="line"><span class="comment"> * -128 and 127 (inclusive) as required by JLS.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The cache is initialized on first usage.  The size of the cache</span></span><br><span class="line"><span class="comment"> * may be controlled by the &#123;<span class="doctag">@code</span> -XX:AutoBoxCacheMax=&lt;size&gt;&#125; option.</span></span><br><span class="line"><span class="comment"> * During VM initialization, java.lang.Integer.IntegerCache.high property</span></span><br><span class="line"><span class="comment"> * may be set and saved in the private system properties in the</span></span><br><span class="line"><span class="comment"> * sun.misc.VM class.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">        String integerCacheHighPropValue =</span><br><span class="line">            sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</span><br><span class="line">        <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        high = h;</span><br><span class="line"></span><br><span class="line">        cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> j = low;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">        <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么 <code>IntegerCache</code> 只缓存 <code>-128</code> 到 <code>127</code> 之间的整型值呢？</p><p>在 <code>IntegerCache</code> 的代码实现中，当这个类被加载的时候，缓存的享元对象会被集中一次性创建好。毕竟整型值太多了，我们不可能在 <code>IntegerCache</code> 类中预先创建好所有的整型值，这样既占用太多内存，也使得加载 <code>IntegerCache</code> 类的时间过长。所以，我们只能选择缓存对于大部分应用来说最常用的整型值，也就是一个字节的大小（<code>-128</code> 到 <code>127</code> 之间的数据）。</p><p>如何修改这个值呢？</p><p><code>JDK</code> 提供了方法来让我们可以自定义缓存的最大值，但没有提供设置最小值的方法。这里只有 <code>idea</code> 的设置参数。<code>Android Studio</code> 还没有找到相关的设置方法，我试过了再 <code>studio64.exe.vmoptions</code> 中设置，并且执行了 <code>Invalidate Caches/Restart...</code> 但是没有效果。</p><p>希望哪位大佬指点一下 ~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;方法一：</span><br><span class="line">-Djava.lang.Integer.IntegerCache.high&#x3D;255</span><br><span class="line">&#x2F;&#x2F;方法二：</span><br><span class="line">-XX:AutoBoxCacheMax&#x3D;255</span><br></pre></td></tr></table></figure><p>除了 <code>Integer</code> 类型之外，其他包装器类型，比如 <code>Long</code>、<code>Short</code>、<code>Byte</code> 等，也都利用了享元模式来缓存 <code>-128</code> 到 <code>127</code> 之间的数据。具体查看对应的 <code>valueOf()</code> 方法。</p><p>在我们平时的开发中，对于下面这样三种创建整型对象的方式，我们优先使用后两种。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer a = <span class="keyword">new</span> Integer(<span class="number">123</span>);</span><br><span class="line">Integer a = <span class="number">123</span>;</span><br><span class="line">Integer a = Integer.valueOf(<span class="number">123</span>);</span><br></pre></td></tr></table></figure><p>第一种创建方式并不会使用到 <code>IntegerCache</code>，而后面两种创建方法可以利用 <code>IntegerCache</code> 缓存，返回共享的对象，以达到节省内存的目的。</p><h2 id="4-2-String"><a href="#4-2-String" class="headerlink" title="4.2 String"></a>4.2 String</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"abc"</span>;</span><br><span class="line">String s2 = <span class="string">"abc"</span>;</span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(s1 == s2);</span><br><span class="line">System.out.println(s1 == s3);</span><br></pre></td></tr></table></figure><p>上面代码的运行结果是：一个 <code>true</code>，一个 <code>false</code>。</p><p><code>String</code> 类利用享元模式来复用相同的字符串常量。<code>JVM</code> 会专门开辟一块存储区来存储字符串常量，这块存储区叫作 <strong>“字符串常量池”</strong>。</p><p><code>String</code> 类的享元模式的设计，跟 <code>Integer</code> 类稍微有些不同。<code>Integer</code> 类中要共享的对象，是在类加载的时候，就集中一次性创建好的。但是，对于字符串来说，我们没法事先知道要共享哪些字符串常量，所以没办法事先创建好，只能在某个字符串常量第一次被用到的时候，存储到常量池中，当之后再用到的时候，直接引用常量池中已经存在的即可，就不需要再重新创建了。</p><h1 id="5-Android-源码中的享元（Handler）"><a href="#5-Android-源码中的享元（Handler）" class="headerlink" title="5 Android 源码中的享元（Handler）"></a>5 Android 源码中的享元（Handler）</h1><p>万万没想到，很不常用的享元模式，竟然在我们经常使用的 <code>Handler</code> 中用到了！说起 <code>Handler</code> ，一般都是在耗时操作的时候才会使用 <code>Handler</code> ，比如更新 <code>UI</code>，大家肯定听过一句话，<code>UI</code> 不能够在子线程中更新。这原本就是一个伪命题，因为并不是 <code>UI</code> 不可以在子线程更新，而是 <code>UI</code> 不可以在不是它的创建线程里进行更新。只是绝大多数情况下 <code>UI</code> 都是从 <code>UI</code> 线程中创建的，因此，在其他线程更新时会抛出异常。</p><p><a href="https://blog.csdn.net/lmj623565791/article/details/105624391" target="_blank" rel="noopener">Android UI 线程更新UI也会崩溃？？？</a></p><p>这里插入一个小小的知识点，然后回到我们的猪脚 ^(*￣(oo)￣)^  <code>handler</code> 中。</p><p>我们在通过 <code>Handler</code> 中传递消息时会传递一个 <code>Runnable</code>，<code>Runnable</code> 会被包装到一个 <code>Message</code> 对象中，然后再投递到 <code>UI</code> 线程的消息队列。具体看 <code>post</code> 代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span>  sendMessageDelayed(getPostMessage(r), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Message <span class="title">getPostMessage</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">    Message m = Message.obtain();</span><br><span class="line">    m.callback = r;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到，<code>Message</code> 并不是 <code>new</code> 出来的，这个 <code>obtain</code> 有点蹊跷 ~ 这里只研究和享元模式相关的部分，其他部分看下面扩展 ~ </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sPool != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Message m = sPool;</span><br><span class="line">            sPool = m.next;</span><br><span class="line">            m.next = <span class="keyword">null</span>;<span class="comment">// 从sPool中取出一个 Message 对象，并消息链表断开(单独的一个节点)</span></span><br><span class="line">            m.flags = <span class="number">0</span>; <span class="comment">// clear in-use flag</span></span><br><span class="line">            sPoolSize--; <span class="comment">//消息池的可用大小进行减1操作</span></span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Message();<span class="comment">// 当消息池为空时，直接创建Message对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到，在 <code>mPool</code> 为 <code>null</code> 时才会去重新 <code>new</code> 一个 <code>Message</code> ，那我们只需要知道这个 <code>sPoolSync</code> 和 <code>sPool</code> 是什么，就可以知道这里的缓存是怎么做的了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Defines a message containing a description and arbitrary data object that can be</span></span><br><span class="line"><span class="comment"> * sent to a &#123;<span class="doctag">@link</span> Handler&#125;.  This object contains two extra int fields and an</span></span><br><span class="line"><span class="comment"> * extra object field that allow you to not do allocations in many cases.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p class="note"&gt;While the constructor of Message is public, the best way to get</span></span><br><span class="line"><span class="comment"> * one of these is to call &#123;<span class="doctag">@link</span> #obtain Message.obtain()&#125; or one of the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Handler#obtainMessage Handler.obtainMessage()&#125; methods, which will pull</span></span><br><span class="line"><span class="comment"> * them from a pool of recycled objects.&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object sPoolSync = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Message sPool;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> sPoolSize = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>首先 <code>Message</code> 文档第一段的意思就是介绍了一下这个 <code>Message</code> 类的字段，以及说明 <code>Message</code> 对象是被发送到 <code>Handler</code> 的，对于我们来说作用不大。</p><p>第二段的意思是建议我们使用 <code>Message</code> 的 <code>obtain</code> 方法获取 <code>Message</code> 对象，而不是通过 <code>Message</code> 的构造函数，因为 <code>obtain</code> 方法会从被回收的对象池中获取 <code>Message</code> 对象。</p><p>然后再看看关键的字段，<code>sPoolSync</code> 是一个普通的 <code>Object</code> 对象，它的作用就是用于在获取 <code>Message</code> 对象时进行同步锁。再看 <code>sPool</code> 居然是一个 <code>Message</code> 对象，居然不是消息池之类的东西，既然它命名为 <code>sPool</code> 不可能是有名无实吧。原来还有一个比较总要的字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sometimes we store linked lists of these things</span></span><br><span class="line">Message next;</span><br></pre></td></tr></table></figure><p>原来 <code>Message</code> 消息池没有使用 <code>map</code> 这样的容器，使用的是链表！这个 <code>next</code> 就是指向下一个 <code>Message</code> 的。</p><p>每个 <code>Message</code> 对象都有一个同类型的 <code>next</code> 字段，这个 <code>next</code> 指向的就是下一个可用的 <code>Message</code> ，最后一个可用的 <code>Message</code> 的 <code>next</code> 则为空。这样一来，所有可用的 <code>Message</code> 对象就通过 <code>next</code> 串连成一个可用的 <code>Message</code> 池。</p><p>我们在 <code>obtain</code> 函数中只看到了从链表中获取，并且看到存储。如果消息池链表中没有可用对象的时候，<code>obtain</code> 中则是直接返回一个通过 <code>new</code> 创建的 <code>Message</code> 对象，而且并没有存储到链表中。那么这些 <code>Message</code> 对象什么时候会被放到链表中呢？</p><p><code>“which will pull them from a pool of recycled objects.”</code>，这是 <code>Message</code> 注释中的第二句话末尾的一句话，原来在创建的时候不会把 <code>Message</code> 对象放到池中，在回收（这里的回收并不是指虚拟机回收<code>Message</code> 对象）该对象时才会将该对象添加到链表中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否该消息还在使用</span></span><br><span class="line">    <span class="keyword">if</span> (isInUse()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (gCheckRecycle) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"This message cannot be recycled because it "</span></span><br><span class="line">                    + <span class="string">"is still in use."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清空状态，并且将消息添加到消息池中</span></span><br><span class="line">    recycleUnchecked();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对于不再使用的消息，加入到消息池 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recycleUnchecked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//清空消息状态，设置该消息 in - use flag</span></span><br><span class="line">    flags = FLAG_IN_USE;</span><br><span class="line">    what = <span class="number">0</span>;</span><br><span class="line">    arg1 = <span class="number">0</span>;</span><br><span class="line">    arg2 = <span class="number">0</span>;</span><br><span class="line">    obj = <span class="keyword">null</span>;</span><br><span class="line">    replyTo = <span class="keyword">null</span>;</span><br><span class="line">    sendingUid = -<span class="number">1</span>;</span><br><span class="line">    when = <span class="number">0</span>;</span><br><span class="line">    target = <span class="keyword">null</span>;</span><br><span class="line">    callback = <span class="keyword">null</span>;</span><br><span class="line">    data = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 回收消息到消息池中</span></span><br><span class="line">    <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sPoolSize &lt; MAX_POOL_SIZE) &#123; <span class="comment">//当消息池没有满时，将Message对象加入消息池</span></span><br><span class="line">            next = sPool;</span><br><span class="line">            sPool = <span class="keyword">this</span>;</span><br><span class="line">            sPoolSize++;<span class="comment">//消息池的可用大小进行加1操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>recycle</code> 函数会将一个 <code>Message</code> 对象回收到一个全局的池中，这个池也就是链表。<br><code>recycle</code> 函数首先判断该消息是否还在使用，如果还在使用则抛出异常，否则调用 <code>recycleUnchecked</code> 函数处理该消息。</p><p><code>recycleUnchecked</code> 函数中先清空该消息的各字段，并且将 <code>flags</code> 设置为 <code>FLAG_IN_USE</code> ，表明该消息已被使用，这个 <code>flag</code> 在 <code>obtain</code> 函数中会被置为 <code>0</code> ，这样根据这个 <code>flag</code> 就能够追踪该消息的状态。</p><p>然后判断是否要将该消息回收到消息池中，如果池的大小小于 <code>MAX_POOL_SIZE</code> 时，将<strong>自身添加到链表的表头</strong>。</p><p>例如，当链表中还没有元素时，将第一个<code>Message</code> 对象添加到链表中，此时 <code>sPool</code> 为null，<code>next</code> 指向了 <code>sPool</code> ，因此，<code>next</code> 也为 <code>null</code> ，然后 <code>sPool</code> 又指向了 <code>this</code> ，因此，<code>sPool</code> 就指向了当前这个被回收的对象，并且 <code>sPoolSize</code> 加1。<strong>相当于当前要回收的 <code>Message</code> (既然是要被回收的，肯定是一个独立的节点) <code>next</code> 指向回收池的头节点，再将 <code>sPool(头指针)</code>  指向当前节点，作为头节点。<code>obtain</code> 取的时候就是将头节点与之后的节点断开，单独取出来使用。</strong></p><p>这里的 <code>Message</code> 相当于承担了享元模式中 3 个元素的职责，即是 <code>Flyweight</code> 抽象，又是 <code>ConcreteFlyweight</code> 角色，同时又承担了 <code>FlyweightFactory</code> 管理对象池的职责。因为 <code>Android</code> 应用是事件驱动的，因此，如果通过 <code>new</code> 创建 <code>Message</code> 就会创建大量重复的 <code>Message</code> 对象，导致内存占用率高、频繁 <code>GC</code> 等问题，通过享元模式创建一个大小为 50 的消息池，避免了上述问题的产生，使得这些问题迎刃而解。</p><p><strong><code>Handler</code> 扩展</strong></p><p><a href="http://gityuan.com/2015/12/26/handler-message-framework/" target="_blank" rel="noopener">Android消息机制-Handler(framework篇)</a></p><p><a href="http://gityuan.com/2015/12/27/handler-message-native/" target="_blank" rel="noopener">Android消息机制-Handler(native篇)</a></p><p><a href="http://gityuan.com/2016/01/01/handler-message-usage/" target="_blank" rel="noopener">Android消息机制3-Handler(实战)</a></p>]]></content>
      
      
      <categories>
          
          <category> 编码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-结构型-组合模式</title>
      <link href="/2020/design-pattern-composite.html"/>
      <url>/2020/design-pattern-composite.html</url>
      
        <content type="html"><![CDATA[<p><code>Compose objects into tree structure to represent part-whole hierarchies.Composite lets client treat individual objects and compositions of objects uniformly.</code> </p><p><code>(将一组对象组织（Compose）成树形结构，以表示一种“部分 - 整体”的层次结构。组合让客户端（在很多设计模式书籍中，“客户端”代指代码的使用者。）可以统一单个对象和组合对象的处理逻辑。)</code></p><p>组合模式的数据必须能表示成树形结构，这也导致了这种模式在实际的项目开发中并不那么常用。但是，一旦数据满足树形结构，应用这种模式就能发挥很大的作用，能让代码变得非常简洁。</p><h1 id="1-组合模式-UML"><a href="#1-组合模式-UML" class="headerlink" title="1 组合模式 UML"></a>1 组合模式 UML</h1><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/design/design_uml_composite2.webp" alt="图片来源于《Android 源码设计模式解析与实战》"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象根节点，为组合中的对象声明接口。</span></span><br><span class="line"><span class="comment"> * 在适当的情况下，实现所有类共有接口的缺省行为。</span></span><br><span class="line"><span class="comment"> * 声明一个接口用于访问和管理 Component 的子节点。可在递归结构中定义一个接口，用于访问一个父节点，并在合适的情况下实现它。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Component</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">addChild</span><span class="params">(Component child)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">removeChild</span><span class="params">(Component child)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Component <span class="title">getChildren</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义有子节点的那些枝干节点的行为，存储子节点，在 Component 接口中实现与子节点有关的操作。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Composite</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Component&gt; components = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Composite</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != components) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Component c : components) &#123;</span><br><span class="line">                c.doSomething();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addChild</span><span class="params">(Component child)</span> </span>&#123;</span><br><span class="line">        components.add(child);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeChild</span><span class="params">(Component child)</span> </span>&#123;</span><br><span class="line">        components.remove(child);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Component <span class="title">getChildren</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> components.get(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在组合中表示叶子节点对象，叶子节点没有子节点，在组合中定义节点对象的行为。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Leaf</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Leaf</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addChild</span><span class="params">(Component child)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span>  <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"叶子节点没有子节点"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeChild</span><span class="params">(Component child)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span>  <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"叶子节点没有子节点"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Component <span class="title">getChildren</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span>  <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"叶子节点没有子节点"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//构造一个根节点</span></span><br><span class="line">Component root = <span class="keyword">new</span> Composite(<span class="string">"Root"</span>);</span><br><span class="line"><span class="comment">//构造连个枝干节点</span></span><br><span class="line">Component branch1 = <span class="keyword">new</span> Composite(<span class="string">"Branch1"</span>);</span><br><span class="line">Component branch2 = <span class="keyword">new</span> Composite(<span class="string">"Branch2"</span>);</span><br><span class="line"><span class="comment">//构造两个叶子节点</span></span><br><span class="line">Component leaf1 = <span class="keyword">new</span> Leaf(<span class="string">"Leaf1"</span>);</span><br><span class="line">Component leaf2 = <span class="keyword">new</span> Leaf(<span class="string">"Leaf2"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将叶子节点添加至枝干节点</span></span><br><span class="line">branch1.addChild(leaf1);</span><br><span class="line">branch2.addChild(leaf2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将枝干节点添加至根节点中</span></span><br><span class="line">root.addChild(branch1);</span><br><span class="line">root.addChild(branch2);</span><br><span class="line"></span><br><span class="line">root.doSomething();</span><br></pre></td></tr></table></figure><p>像这样将组合所使用的方法定义在抽象类的方式称为<strong>透明的组合模式</strong>，而还有一种组合模式则称为<strong>安全的组合模式</strong>。</p><p>透明组合模式中不管是叶子节点还是枝干节点都有着相同的结构，那意味着我们无法通过 <code>getChildren</code> 方法得到子节点的类型，而必须在方法实现的内部进行判断。</p><p>安全的组合模式在使用时都必须直接使用具体的实现类。<code>UML</code> 如下，下面的 文件目录 例子是一个安全的组合模式。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/design/design_uml_composite.webp" alt="图片来源于《Android 源码设计模式解析与实战》"></p><h1 id="2-组合模式的简单实现"><a href="#2-组合模式的简单实现" class="headerlink" title="2 组合模式的简单实现"></a>2 组合模式的简单实现</h1><p>设计一个类来表示文件系统中的目录，能方便地实现下面这些功能：</p><ul><li>动态地添加、删除某个目录下的子目录或文件；</li><li>统计指定目录下的文件个数；</li><li>统计指定目录下的文件总大小。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FileSystemNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String path;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileSystemNode</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.path = path;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//文件数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">countNumOfFiles</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">countSizeOfFiles</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">File</span> <span class="keyword">extends</span> <span class="title">FileSystemNode</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">File</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(path);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNumOfFiles</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">countSizeOfFiles</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        java.io.File file = <span class="keyword">new</span> java.io.File(path);</span><br><span class="line">        <span class="keyword">if</span> (!file.exists()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> file.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Directory</span> <span class="keyword">extends</span> <span class="title">FileSystemNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;FileSystemNode&gt; subNodes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Directory</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(path);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNumOfFiles</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> numOfFiles = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (FileSystemNode fileOrDir : subNodes) &#123;</span><br><span class="line">            numOfFiles += fileOrDir.countNumOfFiles();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numOfFiles;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">countSizeOfFiles</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> sizeofFiles = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (FileSystemNode fileOrDir : subNodes) &#123;</span><br><span class="line">            sizeofFiles += fileOrDir.countSizeOfFiles();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sizeofFiles;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addSubNode</span><span class="params">(FileSystemNode fileOrDir)</span> </span>&#123;</span><br><span class="line">        subNodes.add(fileOrDir);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeSubNode</span><span class="params">(FileSystemNode fileOrDir)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = subNodes.size();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; size; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (subNodes.get(i).getPath().equalsIgnoreCase(fileOrDir.getPath())) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; size) &#123;</span><br><span class="line">            subNodes.remove(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * /</span></span><br><span class="line"><span class="comment"> * /wz/</span></span><br><span class="line"><span class="comment"> * /wz/a.txt</span></span><br><span class="line"><span class="comment"> * /wz/b.txt</span></span><br><span class="line"><span class="comment"> * /wz/movies/</span></span><br><span class="line"><span class="comment"> * /wz/movies/c.avi</span></span><br><span class="line"><span class="comment"> * /xzg/</span></span><br><span class="line"><span class="comment"> * /xzg/docs/</span></span><br><span class="line"><span class="comment"> * /xzg/docs/d.txt</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Directory fileSystemTree = <span class="keyword">new</span> Directory(<span class="string">"/"</span>);</span><br><span class="line">Directory node_wz = <span class="keyword">new</span> Directory(<span class="string">"/wz/"</span>);</span><br><span class="line">Directory node_xzg = <span class="keyword">new</span> Directory(<span class="string">"/xzg/"</span>);</span><br><span class="line">fileSystemTree.addSubNode(node_wz);</span><br><span class="line">fileSystemTree.addSubNode(node_xzg);</span><br><span class="line"></span><br><span class="line">File node_wz_a = <span class="keyword">new</span> File(<span class="string">"/wz/a.txt"</span>);</span><br><span class="line">File node_wz_b = <span class="keyword">new</span> File(<span class="string">"/wz/b.txt"</span>);</span><br><span class="line">Directory node_wz_movies = <span class="keyword">new</span> Directory(<span class="string">"/wz/movies/"</span>);</span><br><span class="line">node_wz.addSubNode(node_wz_a);</span><br><span class="line">node_wz.addSubNode(node_wz_b);</span><br><span class="line">node_wz.addSubNode(node_wz_movies);</span><br><span class="line"></span><br><span class="line">File node_wz_movies_c = <span class="keyword">new</span> File(<span class="string">"/wz/movies/c.avi"</span>);</span><br><span class="line">node_wz_movies.addSubNode(node_wz_movies_c);</span><br><span class="line"></span><br><span class="line">Directory node_xzg_docs = <span class="keyword">new</span> Directory(<span class="string">"/xzg/docs/"</span>);</span><br><span class="line">node_xzg.addSubNode(node_xzg_docs);</span><br><span class="line"></span><br><span class="line">File node_xzg_docs_d = <span class="keyword">new</span> File(<span class="string">"/xzg/docs/d.txt"</span>);</span><br><span class="line">node_xzg_docs.addSubNode(node_xzg_docs_d);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"/ files num:"</span> + fileSystemTree.countNumOfFiles());</span><br><span class="line">System.out.println(<span class="string">"/wz/ files num:"</span> + node_wz.countNumOfFiles());</span><br></pre></td></tr></table></figure><p>组合模式的定义：“将一组对象（文件和目录）组织成树形结构，以表示一种 ‘部分 - 整体’ 的层次结构（目录与子目录的嵌套结构）。组合模式让客户端可以统一单个对象（文件）和组合对象（目录）的处理逻辑（递归遍历）。”</p><p>这种组合模式的设计思路，与其说是一种设计模式，倒不如说是对业务场景的一种数据结构和算法的抽象。其中，数据可以表示成树这种数据结构，业务需求可以通过在树上的递归遍历算法来实现。</p><h1 id="3-Android-源码中的模式实现"><a href="#3-Android-源码中的模式实现" class="headerlink" title="3 Android 源码中的模式实现"></a>3 Android 源码中的模式实现</h1><p>在 <code>Android</code> 中，说到树，脱口而出的就是 <code>View</code> 树，是树形结构跑不了了！先看看 <code>UML</code></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/design/design_uml_view.webp" alt="图片来源于《Android 源码设计模式解析与实战》"></p><p>这里省略了 <code>View</code> 和 <code>ViewGroup</code> 类中的一些方法，在 <code>Android</code> 的这个视图层级中，容器一定是 <code>ViewGroup</code> ，而且只有 <code>ViewGroup</code> 才能包含其他的 <code>View</code> ，比如 <code>LinearLayout</code> 能包含 <code>TextView</code> 、<code>Button</code>、<code>CheckBox</code> 等，但是反过来 <code>TextView</code> 是不能包含 <code>LinearLayout</code> 的，因为 <code>TextView</code> 直接继承于<code>View</code>，其并非一个容器。这里 <code>View</code> 的视图层级中使用到的其实是一种安全的设计模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">View</span> <span class="keyword">implements</span> <span class="title">Drawable</span>.<span class="title">Callback</span>, <span class="title">KeyEvent</span>.<span class="title">Callback</span>,</span></span><br><span class="line"><span class="class">        <span class="title">AccessibilityEventSource</span> </span>&#123;</span><br><span class="line">          </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewGroup</span> <span class="keyword">extends</span> <span class="title">View</span> <span class="keyword">implements</span> <span class="title">ViewParent</span>, <span class="title">ViewManager</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>从继承的角度来说 <code>ViewGroup</code> 拥有 <code>View</code> 类所有的非私有方法，既然如此，两者的差别就在于 <code>ViewGroup</code> 所实现的 <code>ViewParent</code> 和 <code>ViewManager</code> 接口上，而事实也是如此，<code>ViewManager</code> 接口定义了 <code>addView</code> 、<code>removeView</code> 等对子视图操作的方法。</p><p>而 <code>ViewParent</code> 则定义了刷新容器的接口 <code>requestLayout</code> 和其他一些焦点事件的处理的接口。</p><p><code>ViewGroup</code> 除了所实现的这两个接口与 <code>View</code> 不一样外，还有重要的一点就是 <code>ViewGroup</code> 是抽象类，其将 <code>View</code> 中的 <code>onLayout</code> 方法重置为抽象方法，也就是说容器子类必须实现该方法来实现布局定位，我们知道 <code>View</code> 中的该方法是个空实现，因为对于一个普通的 <code>View</code> 来说该方法并没有什么实现价值，但是 <code>ViewGroup</code> 就不一样，要必须实现。除此之外，在 <code>View</code> 中比较重要的两个测绘流程的方法 <code>onMeasure</code> 和 <code>onDraw</code> 在 <code>ViewGroup</code> 中都没有被重写，相对于 <code>onMeasure</code> 方法，在 <code>ViewGroup</code> 中增加了一些计算子 <code>View</code> 的方法，如 <code>measureChildren</code>、<code>measureChildrenWithMargins</code> 等；而对于 <code>onDraw</code> 方法，<code>ViewGroup</code> 定义了一个 <code>dispatchDraw</code> 方法来调用其每一个子 <code>View</code> 的 <code>onDraw</code> 方法，由此可见，<code>ViewGroup</code> 真的就象一个容器一样，其职责只是负责对子元素的操作而非具体的个体行为。</p>]]></content>
      
      
      <categories>
          
          <category> 编码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-结构型-适配器模式</title>
      <link href="/2020/design-pattern-adapter.html"/>
      <url>/2020/design-pattern-adapter.html</url>
      
        <content type="html"><![CDATA[<p>适配器是将两个不兼容的类融合在一起，它有点像粘合剂，将不同的东西通过一种转换使得它们能够协作起来。例如，经常碰到要在两个没有关系的类型之间进行交互，第一个解决方案是修改各自类的接口，但是如果没有源代码或者我们不愿意为了一个应用而修改各自的接口，此时怎么办？这种情况我们往往会使用一个 <code>Adapter</code> ，在这两种接口之间创建一个 “混血儿” 接口，这个 <code>Adapter</code> 会将这两个接口进行兼容，在不修改原有代码的情况下满足需求。</p><h1 id="1-适配器模式-UML"><a href="#1-适配器模式-UML" class="headerlink" title="1 适配器模式 UML"></a>1 适配器模式 UML</h1><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/design/design_adapter_uml.webp" alt="图片来源于《Android 源码设计模式解析与实战》"></p><ul><li>冲突：<code>Target</code> 期待调用 <code>operation2</code> 方法，而 <code>Adaptee</code> 并没有（这就是所谓的不兼容了）。</li><li>解决方案：为使 <code>Target</code> 能够使用 <code>Adaptee</code> 类里的 <code>operation3</code> 方法，故提供一个中间环节Adapter类（继承 <code>Adaptee</code> &amp; 实现 <code>Target</code> 接口），把<code>Adaptee</code> 的 <code>API</code>  与 <code>Target</code> 的 <code>API</code> 衔接起来（适配）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//目标抽象类定义客户所需接口，可以是一个抽象类或接口，也可以是具体类。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//适配者即被适配的角色，它定义了一个已经存在的接口，</span></span><br><span class="line"><span class="comment">// 这个接口需要适配，适配者类一般是一个具体类，包含了客户希望使用的业务方法，在某些情况下可能没有适配者类的源代码。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"被适配者的方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//适配器可以调用另一个接口，作为一个转换器，对Adaptee和Target进行适配，</span></span><br><span class="line"><span class="comment">// 适配器类是适配器模式的核心，在对象适配器中，它通过继承Target并关联一个Adaptee对象使二者产生联系。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Adaptee</span> <span class="keyword">implements</span> <span class="title">Target</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...一些操作...</span></span><br><span class="line">        <span class="keyword">super</span>.operation3();</span><br><span class="line">        <span class="comment">//...一些操作...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Target adapterTarget = <span class="keyword">new</span> Adapter();</span><br><span class="line">adapterTarget.operation2();</span><br></pre></td></tr></table></figure><p>这是继承的方式，当然也可以用组合的方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">implements</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    Adaptee adaptee;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Adapter</span><span class="params">(Adaptee adaptee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.adaptee = adaptee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...一些操作...</span></span><br><span class="line">        adaptee.operation3();</span><br><span class="line">        <span class="comment">//...一些操作...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Target adapterTarget = <span class="keyword">new</span> Adapter(<span class="keyword">new</span> Adaptee());</span><br><span class="line">adapterTarget.operation2();</span><br></pre></td></tr></table></figure><h1 id="2-装饰模式案例-电压适配器"><a href="#2-装饰模式案例-电压适配器" class="headerlink" title="2 装饰模式案例 电压适配器"></a>2 装饰模式案例 电压适配器</h1><p>我们国家的民用电都是 <code>220V</code>，有些国家是 <code>110V</code>，而我们的手机充电一般需要 <code>5V</code>，这时候要充电，就需要一个电压适配器，将 <code>220V</code> 或者 <code>100V</code> 的输入电压变换为 <code>5V</code> 输出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Adaptee</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AC</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">outputAC</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AC110</span> <span class="keyword">implements</span> <span class="title">AC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> output = <span class="number">110</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">outputAC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AC220</span> <span class="keyword">implements</span> <span class="title">AC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> output = <span class="number">220</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">outputAC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Target</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DC5Adapter</span> </span>&#123;</span><br><span class="line">    <span class="comment">//用于检查输入的电压是否与适配器匹配</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">support</span><span class="params">(AC ac)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用于将输入的电压变换为 5V 后输出</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">outputDC5V</span><span class="params">(AC ac)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//adapter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PowerAdapter110</span> <span class="keyword">implements</span> <span class="title">DC5Adapter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> voltage = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">support</span><span class="params">(AC ac)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (voltage == ac.outputAC());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">outputDC5V</span><span class="params">(AC ac)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> adapterInput = ac.outputAC();</span><br><span class="line">        <span class="comment">//变压器...</span></span><br><span class="line">        <span class="keyword">int</span> adapterOutput = adapterInput / <span class="number">22</span>;</span><br><span class="line">        System.out.println(<span class="string">"使用 PowerAdapter110 变压适配器，输入AC:"</span> + adapterInput + <span class="string">"V"</span> + <span class="string">"，输出DC:"</span> + adapterOutput + <span class="string">"V"</span>);</span><br><span class="line">        <span class="keyword">return</span> adapterOutput;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PowerAdapter220</span> <span class="keyword">implements</span> <span class="title">DC5Adapter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> voltage = <span class="number">220</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">support</span><span class="params">(AC ac)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (voltage == ac.outputAC());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">outputDC5V</span><span class="params">(AC ac)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> adapterInput = ac.outputAC();</span><br><span class="line">        <span class="comment">//变压器...</span></span><br><span class="line">        <span class="keyword">int</span> adapterOutput = adapterInput / <span class="number">44</span>;</span><br><span class="line">        System.out.println(<span class="string">"使用 PowerAdapter220 变压适配器，输入AC:"</span> + adapterInput + <span class="string">"V"</span> + <span class="string">"，输出DC:"</span> + adapterOutput + <span class="string">"V"</span>);</span><br><span class="line">        <span class="keyword">return</span> adapterOutput;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;DC5Adapter&gt; adapters = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Client</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.adapters.add(<span class="keyword">new</span> PowerAdapter220());</span><br><span class="line">        <span class="keyword">this</span>.adapters.add(<span class="keyword">new</span> PowerAdapter110());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据电压找合适的变压器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DC5Adapter <span class="title">getPowerAdapter</span><span class="params">(AC ac)</span> </span>&#123;</span><br><span class="line">        DC5Adapter adapter = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (DC5Adapter ad : <span class="keyword">this</span>.adapters) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ad.support(ac)) &#123;</span><br><span class="line">                adapter = ad;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (adapter == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"没有找到合适的变压适配器"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> adapter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Adapter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Client test = <span class="keyword">new</span> Client();</span><br><span class="line"><span class="comment">//        AC ac = new AC220();</span></span><br><span class="line">        AC ac = <span class="keyword">new</span> AC110();</span><br><span class="line">        <span class="comment">//通过外部传入 ac 确定电压适配器</span></span><br><span class="line">        DC5Adapter adapter = test.getPowerAdapter(ac);</span><br><span class="line">        adapter.outputDC5V(ac);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-Android-源码中的适配器模式"><a href="#4-Android-源码中的适配器模式" class="headerlink" title="4 Android 源码中的适配器模式"></a>4 Android 源码中的适配器模式</h1><p>说起 <code>Android</code> 最常见的就是 <code>Adapter</code> 了吧，那就整个学习一下 <code>RecyclerView</code> 、<code>LayoutManager</code> 和 <code>Adapter</code> </p><p>通过<strong>桥接模式</strong>，使 <code>RecyclerView</code> 将布局方式独立成 <code>LayoutManager</code>，实现对布局的定制化。</p><p>通过<strong>组合模式</strong>，使 <code>RecycleView</code> 通过 <code>dispatchLayout</code> 对 <code>Item View</code> 进行布局绘制的。</p><p>通过<strong>适配器模式</strong>，<code>ViewHolder</code> 将 <code>RecycleView</code> 与 <code>ItemView</code> 联系起来，使得 <code>RecycleView</code> 方便操作 <code>ItemView</code>。</p><p>通过<strong>观察者模式</strong>，给 <code>ViewHolder</code> 注册观察者，当调用 <code>notifyDataSetChanged</code> 时，就能重新绘制。</p><p><a href="https://www.jianshu.com/p/c52b947fe064" target="_blank" rel="noopener">RecyclerView 源码解析</a></p><p><a href="https://www.jianshu.com/p/eabb00c500ef" target="_blank" rel="noopener">RecyclerView 相关面试</a></p>]]></content>
      
      
      <categories>
          
          <category> 编码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-结构型-装饰模式</title>
      <link href="/2020/design-pattern-decorator.html"/>
      <url>/2020/design-pattern-decorator.html</url>
      
        <content type="html"><![CDATA[<p>装饰模式（<code>Decorator Pattern</code>）也称为包装模式（<code>Wrapper Pattern</code>），使用一种对客户端透明的方式来动态地扩展对象的功能，同时它也是继承关系的一种替代方案之一。在现实生活中你也可以看见很多装饰模式的例子，或者可以大胆地说装饰模式无处不在，就拿人来说，人需要各式各样的衣着，不管你穿着怎样，但是，对于个人的本质来说是不变的，充其量只是在外面披上一层遮羞物而已，这就是装饰模式，装饰物也许各不相同但是装饰的对象本质是不变的。</p><h1 id="1-装饰模式-UML"><a href="#1-装饰模式-UML" class="headerlink" title="1 装饰模式 UML"></a>1 装饰模式 UML</h1><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/design/design_uml_decorator.webp" alt="图片来源于《Android 源码设计模式解析与实战》"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象类， 被装饰的原始对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="comment">//返回类型可以改变，从而实现装饰不同的属性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">operate</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//组件的具体实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="comment">//最基础的实现方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象装饰者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Component component;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decorator</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.component = component;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        component.operate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteDecoratorA</span> <span class="keyword">extends</span> <span class="title">Decorator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteDecoratorA</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//装饰基础方法，可以在在调用前后</span></span><br><span class="line">        <span class="comment">//如果父类有返回类型也可以接着处理返回对象，最后返回最终昂对象</span></span><br><span class="line">        operateA();</span><br><span class="line">        <span class="keyword">super</span>.operate();</span><br><span class="line">        operateB();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operateA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//装饰 A</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operateB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//装饰 B</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//具体调用，初始化基础类</span></span><br><span class="line">Component component = <span class="keyword">new</span> ConcreteComponent();</span><br><span class="line"><span class="comment">//基础类进行装饰</span></span><br><span class="line">Decorator decorator = <span class="keyword">new</span> ConcreteDecoratorA(component);</span><br><span class="line">decorator.operate();</span><br></pre></td></tr></table></figure><h1 id="2-简单实现"><a href="#2-简单实现" class="headerlink" title="2 简单实现"></a>2 简单实现</h1><p>开头说过人需要各式各样的衣着，不管你穿着怎样，但是，对于个人的本质来说是不变的，充其量只是在外面披上一层遮羞物而已，这就是装饰模式。那就用穿衣举例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">dressed</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类就是抽象类， 被装饰的原始对象，然后我们需要一个基础实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Boy</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dressed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"穿平角内裤"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是一个正常男生，实现了最基础的方法，当然你可以新增加一个屌丝男士，穿个丁字的 ~。然后我们需要对这个男生进行包装！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象装饰者，抽象方法过多时，可以统一重写子类不需要重写的方法，避免代码重复</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonCloth</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Person mPerson;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PersonCloth</span><span class="params">(Person mPerson)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mPerson = mPerson;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dressed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mPerson.dressed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExpensiveCloth</span> <span class="keyword">extends</span> <span class="title">PersonCloth</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExpensiveCloth</span><span class="params">(Person mPerson)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(mPerson);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dressShirt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"穿件短袖"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dressLeather</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"穿件皮衣"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dressJean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"穿条牛仔裤"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dressed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.dressed();</span><br><span class="line">        dressShirt();</span><br><span class="line">        dressLeather();</span><br><span class="line">        dressJean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheapCloth</span> <span class="keyword">extends</span> <span class="title">PersonCloth</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CheapCloth</span><span class="params">(Person mPerson)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(mPerson);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dressShorts</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"穿个短裤"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dressed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.dressed();</span><br><span class="line">        dressShorts();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是两种不同价位的包装（装饰），两者都是为原本 <code>Boy</code> 类中的 <code>dressed</code> 方法提供功能扩展，不过这种扩展并非是直接修改原有的方法逻辑或结构，更恰当地说，仅仅是在另一个类中将原有方法和新逻辑进行封装整合而已。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Person person = <span class="keyword">new</span> Boy();</span><br><span class="line"></span><br><span class="line">PersonCloth clothCheap = <span class="keyword">new</span> CheapCloth(person);</span><br><span class="line">clothCheap.dressed();</span><br><span class="line"></span><br><span class="line">PersonCloth clothExpensive = <span class="keyword">new</span> ExpensiveCloth(person);</span><br><span class="line">clothExpensive.dressed();</span><br></pre></td></tr></table></figure><h1 id="3-Java-中的装饰模式（Java-IO）"><a href="#3-Java-中的装饰模式（Java-IO）" class="headerlink" title="3 Java 中的装饰模式（Java IO）"></a>3 Java 中的装饰模式（Java IO）</h1><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/design/design_decorator_java.webp" alt="图片来源于极客时间"></p><p>在初学 <code>Java</code> 的时候，曾经对 <code>Java IO</code> 的一些用法产生过很大疑惑。我们打开文件 <code>test.txt</code>，从中读取数据。其中，<code>InputStream</code> 是一个抽象类，<code>FileInputStream</code> 是专门用来读取文件流的子类。<code>BufferedInputStream</code> 是一个支持带缓存功能的数据读取类，可以提高数据读取的效率。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">InputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">"/test.txt"</span>);</span><br><span class="line">InputStream bin = <span class="keyword">new</span> BufferedInputStream(in);</span><br><span class="line"><span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">128</span>];</span><br><span class="line"><span class="keyword">while</span> (bin.read(data) != -<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的装饰模式有个特殊的使用场景（之前的例子代码上也可以，只是场景不合适），装饰器类和原始类继承同样的父类，这样我们可以对原始类 “嵌套” 多个装饰器类。</p><p>对 <code>FileInputStream</code> 嵌套了两个装饰器类：<code>BufferedInputStream</code> 和 <code>DataInputStream</code>，让它既支持缓存读取，又支持按照基本数据类型来读取数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">InputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">"/test.txt"</span>);</span><br><span class="line">InputStream bin = <span class="keyword">new</span> BufferedInputStream(in);</span><br><span class="line">DataInputStream din = <span class="keyword">new</span> DataInputStream(bin);</span><br><span class="line"><span class="keyword">int</span> data = din.readInt();</span><br></pre></td></tr></table></figure><p>其实 <code>BufferedInputStream</code> 和 <code>DataInputStream</code> 继承自 <code>FilterInputStream</code>，<code>Java IO</code> 抽象出的一个装饰器父类，他就类似于 抽象装饰者(<code>PersonCloth</code>)  ，因为这两个装饰类只是对部分方法进行装饰，还有一部分方法没必要重写 <code>FilterInputStream</code> 就是统一重写方法，避免代码重复。</p><p>具体可以看 <code>JDK</code> 源码，和上面例子基本类似。</p><h1 id="4-Android-源码中的装饰模式（Context）"><a href="#4-Android-源码中的装饰模式（Context）" class="headerlink" title="4 Android 源码中的装饰模式（Context）"></a>4 Android 源码中的装饰模式（Context）</h1><p><a href="http://gityuan.com/2017/04/09/android_context/" target="_blank" rel="noopener">理解Android Context</a></p>]]></content>
      
      
      <categories>
          
          <category> 编码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 功能原理记录</title>
      <link href="/2020/git-principle.html"/>
      <url>/2020/git-principle.html</url>
      
        <content type="html"><![CDATA[<p><code>git</code> 是一个版本管理软件，由 <code>linux</code> 之父花了 <strong>三天</strong> 搞出来的东西。</p><p>手动惭愧 (〃’▽’〃)</p><h2 id="一-clone-项目"><a href="#一-clone-项目" class="headerlink" title="一 clone(项目)"></a>一 clone(项目)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;CalmCenter&#x2F;UiStarge.git ui-starge</span><br></pre></td></tr></table></figure><p>最后那个 <code>ui-starge</code> 表示手动指定本地仓库目录名称。</p><p>使用 <code>git clone</code> 时，除了从远程仓库把 <code>.git</code> 这个仓库目录下载到工作目录中，还会 <code>checkout</code> （签出） <code>master</code>（<code>checkout</code> 的意思就是把某个 <code>commit</code> 作为<strong>当前</strong> <code>commit</code>，把 <code>HEAD</code> 移动过去，并把工作目录的文件内容替换成这个 <code>commit</code> 所对应的内容）。</p><h2 id="二-push-提交"><a href="#二-push-提交" class="headerlink" title="二 push(提交)"></a>二 push(提交)</h2><h3 id="add-添加至暂存区"><a href="#add-添加至暂存区" class="headerlink" title="add(添加至暂存区)"></a>add(添加至暂存区)</h3><p><code>push</code> 做的事是：把当前 <code>branch</code> 的位置（即它指向哪个 <code>commit</code>）上传到远端仓库，并把它的路径上的  <code>commits</code>  一并上传。</p><p>基础步骤 <code>add -&gt; commit -&gt; push</code> ，接下来一个一个看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add test.txt</span><br></pre></td></tr></table></figure><p><code>add</code> 后面可以使文件或者文件夹，如果是文件夹 <code>test/</code> 。如果文件或文件夹名字有空格，比如 <code>text 1.txt</code> 文件 或 <code>text 2</code> 文件夹 ，需要写成  <code>get add test\ 1.txt</code> 或 <code>get add test\ 2/</code> ，将空格转义一下。</p><p>还有一个更方便的方法 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure><p><code>add</code> 指令除了 <code>git add 文件名</code> 这种用法外，还可以使用 <code>add .</code> 来直接把工作目录下的所有改动全部放进暂存区。这个用法没什么特别的好处，但就一个字：方便 (^_−)☆。</p><p>添加或删除的文件都需要 <code>add</code> ，也包括<strong>改名</strong>前的文件。 </p><p>你在 <code>add</code> 后，如果再次修改的已经添加的文件，需要再次 <code>add</code> ，因为通过 add 添加进暂存区的不是文件名，而是具体的对改动内容的一个快照。</p><h3 id="commit-提交到本地仓库"><a href="#commit-提交到本地仓库" class="headerlink" title="commit(提交到本地仓库)"></a>commit(提交到本地仓库)</h3><p>正常提交 <code>-m</code> 后面写提交信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;test&quot;</span><br></pre></td></tr></table></figure><p>当提交后，发现内容有误，需要怎么办？修改后重新提交一个 <code>commit</code> ？ 当然可以，不过还有一个更加优雅和简单的解决方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -—amend</span><br></pre></td></tr></table></figure><p><code>&quot;amend&quot;</code> 是「修正」的意思。在提交时，如果加上 <code>--amend</code> 参数，<code>Git</code> 不会在当前 <code>commit</code> 上增加 <code>commit</code>，而是会把当前 <code>commit</code> 里的内容和暂存区里的内容合并起来后创建一个新的 <code>commit</code>，<strong>用这个新的 <code>commit</code> 把当前 <code>commit</code> 替换掉</strong>。</p><p>需要注意：<code>commit --amend</code> 并不是直接修改原 <code>commit</code> 的内容，而是生成一条新的 <code>commit</code> ，替换掉旧的 <code>commit</code> 。如果旧的 <code>commit</code> 已经 <code>push</code> 到远程仓库，替换后 <code>push</code> 的时候需要在 <code>push</code> 后加 <code>-f</code> ：<code>git push -f</code> 强制更新远程仓库历史。</p><p>这种方式只能修改最新的 <code>commit</code> ，那如果要修改倒数第二个、第三个 <code>commit</code> 怎么办呢？<code>八 rebase 4.1</code> 中会详细说明。</p><h3 id="push"><a href="#push" class="headerlink" title="push"></a>push</h3><p>提交到远程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure><p><code>git push</code> 是提交当前分支已经 <code>commit</code> 的文件。<strong>分支提交请查看  <code>Branch(分支)</code> 部分</strong></p><h3 id="push-上去了才发现写错怎么办？"><a href="#push-上去了才发现写错怎么办？" class="headerlink" title="push 上去了才发现写错怎么办？"></a>push 上去了才发现写错怎么办？</h3><p><strong>出错的内容在你自己的 <code>branch</code></strong>，不会影响到其他人，那没关系用本文的方法把写错的 <code>commit</code> 修改或者删除掉，然后再 <code>push</code> 上去就好了。</p><p>如果是修改或删掉了本地的 <code>commit</code> 需要用下面的命令强制更新远程才可以  ~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin branch1 -f</span><br></pre></td></tr></table></figure><p><strong>当出错的内容已经合并到 <code>master</code></strong> ，同事的工作都在 <code>master</code> 上，永远不知道一次强制 <code>push</code> 会不会洗掉同事刚发上去的新提交。<br>除非人员数量和行为都完全可控的超小团队，可以和同事做到无死角的完美沟通，不然一定别在 <code>master</code> 上强制 <code>push</code>。</p><p>在这种时候，你只能退一步，选用另一种策略：<br>增加一个新的提交，把之前提交的内容抹掉。例如之前你增加了一行代码，你希望撤销它，那么你就做一个删掉这行代码的提交；<br>如果你删掉了一行代码，你希望撤销它，那么你就做一个把这行代码还原回来的提交。</p><p>这种事做起来也不算麻烦，因为 Git 有一个对应的指令：<code>revert</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert HEAD^</span><br></pre></td></tr></table></figure><p>上面这行代码就会增加一条新的 <code>commit</code>，它的内容和倒数第二个 <code>commit</code> 是相反的，从而和倒数第二个 <code>commit</code> 相互抵消，达到撤销的效果。</p><p>在 <code>revert</code> 完成之后，把新的 <code>commit</code> 再 <code>push</code> 上去，这个 <code>commit</code> 的内容就被撤销了。它和前面所介绍的撤销方式相比，最主要的区别是，这次改动只是被「反转」了，并没有在历史中消失掉，你的历史中会存在两条 <code>commit</code> ：一个原始 <code>commit</code> ，一个对它的反转 <code>commit</code>。</p><h2 id="三-pull-拉取"><a href="#三-pull-拉取" class="headerlink" title="三 pull(拉取)"></a>三 pull(拉取)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure><p>这个命令可以 <code>拉取文件</code> 比如其他人提交或合并了文件，还可以 <code>拉取远程分支</code> 比如其他人将分支提交到了远程仓库，<code>pull</code> 的实际操作其实是把远端仓库的内容用 <code>fetch</code> 取下来之后，用 <code>merge</code> 来合并。</p><h2 id="四-查看提交记录"><a href="#四-查看提交记录" class="headerlink" title="四 查看提交记录"></a>四 查看提交记录</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit 2c796942b103740176aae9eab1e2ead364c75787 (HEAD -&gt; master, origin&#x2F;master, origin&#x2F;HEAD)</span><br><span class="line">Author: Pc</span><br><span class="line">Date:   Thu Jul 16 16:04:31 2020 +0800</span><br><span class="line"></span><br><span class="line">    delete</span><br><span class="line"></span><br><span class="line">commit efc90131928c01ff3c8db1feae58461c766c78cd</span><br><span class="line">Author: Calm Lv</span><br><span class="line">Date:   Thu Jul 16 16:02:28 2020 +0800</span><br><span class="line"></span><br><span class="line">    Delete test 1.txt</span><br><span class="line"></span><br><span class="line">commit 24078eeecdaae6091e65170d86dcd4e20a474817</span><br><span class="line">Author: Pc</span><br><span class="line">Date:   Thu Jul 16 16:00:17 2020 +0800</span><br><span class="line"></span><br><span class="line">    test</span><br></pre></td></tr></table></figure><p>第一行的 <code>commit</code> 后面括号里的 <code>HEAD -&gt; master, origin/master, origin/HEAD</code> ，是几个指向这个 <code>commit</code> 的<strong>「引用」</strong>。</p><ul><li><p><strong>commit 唯一标识</strong></p><p>每一个 <code>commit</code> 都有一个它唯一的指定方式，它的 <code>SHA-1</code> 校验和，也就是上图中每个 <code>commit</code> 右边的那一长串字符。</p><p>两个 <code>SHA-1</code> 值的重复概率极低，所以可以使用这个 <code>SHA-1</code> 值来指代 <code>commit</code>，也可以只使用它的前几位来指代它（例如第一个 <code>2c796942b...75787</code>，你使用 ``2c79694<code>甚至</code>2c79` 来指代它）</p><p>但毕竟这种没有任何含义的字符串是很难记忆的，所以 <code>Git</code> 提供了「引用」的机制：使用固定的字符串作为「引用」，指向某个 <code>commit</code>，作为操作 <code>commit</code> 时的快捷方式。</p></li><li><p><strong>HEAD</strong></p><p> <code>HEAD</code> 是「引用」中最特殊的一个：它是指向当前 <code>commit</code> 的「引用」，也就是当前工作目录所对应的 <code>commit</code>。</p></li><li><p><strong>origin/master、origin/HEAD</strong></p><p> 它们是对远端仓库的 <code>master</code> 和 <code>HEAD</code> 的本地镜像</p></li></ul><p><code>git log</code> 可以查看提交记录，但是看不到更多的细节，如何查看更多的细节呢？</p><h3 id="查看每个-commit-单行显示"><a href="#查看每个-commit-单行显示" class="headerlink" title="查看每个 commit 单行显示"></a>查看每个 commit 单行显示</h3><p>只显示 <code>commit SHA-1</code> 校验和 ，以及 提交说明。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --oneline</span><br></pre></td></tr></table></figure><h3 id="查看每个-commit-图标显示"><a href="#查看每个-commit-图标显示" class="headerlink" title="查看每个 commit 图标显示"></a>查看每个 commit 图标显示</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --oneline --graph --all</span><br></pre></td></tr></table></figure><h3 id="查看每个-commit-大致改动"><a href="#查看每个-commit-大致改动" class="headerlink" title="查看每个 commit 大致改动"></a>查看每个 commit 大致改动</h3><p>如果你只想大致看一下改动内容，但并不想深入每一行的细节（例如你想回顾一下自己是在哪个 <code>commit</code> 中修改了 <code>xxx.txt</code> 文件）可以使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --stat</span><br></pre></td></tr></table></figure><h3 id="查看每个-commit-详细改动"><a href="#查看每个-commit-详细改动" class="headerlink" title="查看每个 commit 详细改动"></a>查看每个 commit 详细改动</h3><p><code>-p</code> 是 <code>--patch</code> 的缩写，通过 <code>-p</code> 参数，你可以看到具体每个 <code>commit</code> 的改动细节</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log -p</span><br></pre></td></tr></table></figure><h3 id="查看当前-commit-的改动内容"><a href="#查看当前-commit-的改动内容" class="headerlink" title="查看当前 commit 的改动内容"></a>查看当前 <code>commit</code> 的改动内容</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git show</span><br></pre></td></tr></table></figure><h3 id="查看任意一个-commit"><a href="#查看任意一个-commit" class="headerlink" title="查看任意一个 commit"></a>查看任意一个 commit</h3><p>在 <code>show</code> 后面加上这个 <code>commit</code> 的引用（<code>branch</code> 或 <code>HEAD</code> 标记）或它的 <code>SHA-1</code> 码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git show 03c8</span><br></pre></td></tr></table></figure><h3 id="查看指定-commit-中的指定文件改动内容"><a href="#查看指定-commit-中的指定文件改动内容" class="headerlink" title="查看指定 commit 中的指定文件改动内容"></a>查看指定 commit 中的指定文件改动内容</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git show 03c8 branch1.txt</span><br></pre></td></tr></table></figure><h3 id="查看未提交的内容"><a href="#查看未提交的内容" class="headerlink" title="查看未提交的内容"></a>查看未提交的内容</h3><p>使用 <code>git diff --staged</code> 可以显示 暂存区( <code>add</code> 后的内容) 和 上一条提交 之间的不同，换句话说，这条指令可以让你看到「输入 <code>git commit</code> 后，你将会提交什么」</p><h4 id="比对暂存区和上一条提交"><a href="#比对暂存区和上一条提交" class="headerlink" title="比对暂存区和上一条提交"></a>比对暂存区和上一条提交</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff --staged</span><br></pre></td></tr></table></figure><p><code>--staged</code> 有一个等价的选项叫做 <code>--cached</code>。这里所谓的「等价」，是真真正正的等价，它们的意思完全相同。</p><h4 id="比对工作目录和暂存区"><a href="#比对工作目录和暂存区" class="headerlink" title="比对工作目录和暂存区"></a>比对工作目录和暂存区</h4><p>使用 <code>git diff</code> （不加选项参数）可以显示 工作目录 和 暂存区之间 的不同。换句话说，这条指令可以让你看到「执行 <code>add .</code> ，你会向暂存区中增加哪些内容」</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></table></figure><h4 id="比对工作目录和上一条提交"><a href="#比对工作目录和上一条提交" class="headerlink" title="比对工作目录和上一条提交"></a>比对工作目录和上一条提交</h4><p>它是上面这二者的内容相加。换句话说，这条指令可以让你看到「现在把所有文件都 <code>add</code> 然后 <code>git commit</code>，你将会提交什么」（不过需要注意，没有被 <code>Git</code> 记录在案的文件（即从来没有被 <code>add</code> 过 的文件，<code>untracked files</code> 并不会显示出来。为什么？因为对 <code>Git</code> 来说它并不存在啊，新创建的文件不会显示）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff HEAD</span><br></pre></td></tr></table></figure><p>如果你把 <code>HEAD</code> 换成其他的 <code>commit</code>，也可以显示当前工作目录和这条 <code>commit</code> 的区别。</p><h3 id="Reflog-查看引用移动记录"><a href="#Reflog-查看引用移动记录" class="headerlink" title="Reflog 查看引用移动记录"></a>Reflog 查看引用移动记录</h3><p><code>reflog</code> 是 <code>&quot;reference log&quot;</code> 的缩写，使用它可以查看 <code>Git</code> 仓库中的引用的移动记录。如果不指定引用，它会显示 <code>HEAD</code> 的移动记录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog</span><br><span class="line">347cd98 (HEAD -&gt; master, origin&#x2F;master, origin&#x2F;HEAD) HEAD@&#123;0&#125;: checkout: moving from feature2 to master</span><br><span class="line">3a10357 (feature2) HEAD@&#123;1&#125;: checkout: moving from master to feature2</span><br></pre></td></tr></table></figure><p>这里可以查看之前分支的 <code>commit</code> 信息，如果 <code>feature2</code> 在这之后被删除了，可以查看之前 <code>feature2</code> 最后的切换信息，例如上面的 <code>347cd98</code> 表示 <code>HEAD</code> 的最后一次移动行为是「从 <code>feature2</code> 移动到 <code>master</code>」，如果之后 <code>feature2</code> 被删除了，我们可以切换回 <code>347cd98</code>，然后重新创建 <code>feature2</code> ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout 347cd98</span><br><span class="line">git checkout -b feature2</span><br></pre></td></tr></table></figure><p>这样就实现了分支追回。</p><blockquote><p>注意：不再被引用直接或间接指向的 <code>commit</code> 会在一定时间后被 <code>Git</code> 回收，所以使用 <code>reflog</code> 来找回删除的 <code>branch</code> 的操作一定要及时，不然有可能会由于 <code>commit</code> 被回收而再也找不回来。</p></blockquote><h2 id="五-Branch-分支"><a href="#五-Branch-分支" class="headerlink" title="五 Branch(分支)"></a>五 Branch(分支)</h2><p><code>HEAD</code> 是 <code>Git</code> 中一个独特的「引用」，它是唯一的。而除了 <code>HEAD</code> 之外，<code>Git</code> 还有一种「引用」，叫做 <code>branch</code>（分支）。</p><p><code>HEAD</code> 除了可以指向 <code>commit</code>，还可以指向一个 <code>branch</code>，当它指向某个 <code>branch</code> 的时候，会通过这个 <code>branch</code> 来间接地指向某个 <code>commit</code></p><p>上面的 <code>git log</code> 输出中，<code>HEAD -&gt; master</code> 中的 <code>master</code> 就是一个 <code>branch</code> 的名字，并且它是默认的 <code>branch</code>，而它左边的箭头 <code>-&gt;</code> 表示 <code>HEAD</code> 正指向它（当然，也会间接地指向它所指向的 <code>commit</code>）。</p><p>当我们执行 <code>git commit</code> 后 ，<code>HEAD</code> 和 <code>master</code> 这两个「引用」都指向了新的 <code>commit</code>，而 <code>origin/master</code> 和 <code>origin/HEAD</code> 则依然停留在原先的位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit 0b4d1da7f998bc5fb724b0a74b4034c5dab9e35a (HEAD -&gt; master)</span><br><span class="line">Author: Pc </span><br><span class="line">Date:   Thu Jul 16 16:46:58 2020 +0800</span><br><span class="line"></span><br><span class="line">    add</span><br><span class="line"></span><br><span class="line">commit 2c796942b103740176aae9eab1e2ead364c75787 (origin&#x2F;master, origin&#x2F;HEAD)</span><br><span class="line">Author: Pc </span><br><span class="line">Date:   Thu Jul 16 16:04:31 2020 +0800</span><br><span class="line"></span><br><span class="line">    delete</span><br></pre></td></tr></table></figure><h3 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch &lt;分支名&gt;</span><br></pre></td></tr></table></figure><h3 id="提交分支"><a href="#提交分支" class="headerlink" title="提交分支"></a>提交分支</h3><p>这里会将本地创建的分支更新到远程，并提交分支中的 <code>commits</code>。</p><p>如果本地当前 <code>HEAD</code> 处于新分支并且没有和远程关联，需要输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin &lt;分支名&gt;</span><br></pre></td></tr></table></figure><p>才能提交当前分支以及分支中的文件到远程仓库</p><p><code>origin</code> 是远程仓库的别名，是你在 <code>git clone</code> 的时候 <code>Git</code> 自动帮你起的，然后指明分支名称。这两个参数合起来指定了你要 <code>push</code> 到的目标仓库和目标分支。</p><p>如果进行了关联 （设置本地分支追踪远程分支）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push --set-upstream origin &lt;分支名&gt;</span><br><span class="line">git push -u origin &lt;分支名&gt;</span><br></pre></td></tr></table></figure><p>关联后就可以在当前分支使用 <code>git push</code> 直接提交。</p><p><a href="https://stackoverflow.com/questions/5697750/what-exactly-does-the-u-do-git-push-u-origin-master-vs-git-push-origin-ma" target="_blank" rel="noopener">What exactly does the “u” do? “git push -u origin master” vs “git push origin master”</a></p><p><a href="https://www.zhihu.com/question/20019419/answer/138627544" target="_blank" rel="noopener">git push 的 -u 参数具体适合含义？</a></p><h3 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure><h3 id="切换分支（checkout）"><a href="#切换分支（checkout）" class="headerlink" title="切换分支（checkout）"></a>切换分支（checkout）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;分支名&gt;</span><br></pre></td></tr></table></figure><p>还有一种方式是创建分支，创建并切换到刚创建的分支。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b &lt;分支名&gt;</span><br></pre></td></tr></table></figure><h4 id="checkout-本质："><a href="#checkout-本质：" class="headerlink" title="checkout 本质："></a><code>checkout</code> 本质：</h4><p><code>checkout</code> 并不止可以切换 <code>branch</code>。<code>checkout</code> 本质上的功能其实是：签出（ checkout ）指定的 <code>commit</code>。</p><p><code>git checkout branch名</code> 的本质，其实是把 <code>HEAD</code> 指向指定的 <code>branch</code>，然后签出这个 <code>branch</code> 所对应的 <code>commit</code> 的工作目录。所以同样的，<code>checkout</code> 的目标也可以不是 <code>branch</code>，而直接指定某个 <code>commit</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout HEAD^^</span><br><span class="line">git checkout 78a4bc</span><br></pre></td></tr></table></figure><p>在 <code>git status</code> 的提示语中，<code>Git</code> 会告诉你可以用 <code>checkout -- 文件名</code> 的格式，通过「签出」的方式来撤销工作目录中指定文件的修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is ahead of &#39;origin&#x2F;master&#39; by 8 commits.</span><br><span class="line">  (use &quot;git push&quot; to publish your local commits)</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">        modified:   branch1.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and&#x2F;or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- branch1.txt</span><br></pre></td></tr></table></figure><p>然后刚刚对这个文件的修改就都被撤回了 ~ </p><h4 id="checkout-和-reset-的不同"><a href="#checkout-和-reset-的不同" class="headerlink" title="checkout 和 reset 的不同"></a><code>checkout</code> 和 <code>reset</code> 的不同</h4><p><code>reset</code> 后面会讲，但是这里先说一下不同，既然说不同那肯定就有相同的地方：</p><p><code>checkout</code> 和 <code>reset</code> 都可以切换 <code>HEAD</code> 的位置，它们除了有许多细节的差异外，最大的区别在于：<code>reset</code> 在移动 <code>HEAD</code> 时会带着它所指向的 <code>branch(引用)</code> 一起移动，而 <code>checkout</code> 不会。</p><p><code>checkout</code> 有一个专门用来只让 <code>HEAD</code> 和 <code>branch</code> 脱离而不移动 <code>HEAD</code> 的用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout --detach</span><br></pre></td></tr></table></figure><p>现在提交 <code>commit</code> 之前所依赖的 <code>branch</code> 将不会一起移动。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">commit 347cd9856e1edf4c0a96cb15bad227ab8d255cda (HEAD)</span><br><span class="line">Author: Pc</span><br><span class="line">Date:   Tue Sep 29 18:27:18 2020 +0800</span><br><span class="line"></span><br><span class="line">    head</span><br><span class="line"></span><br><span class="line">commit 81bb6988fc9698699f697613876f5ad43a698564 (master)</span><br><span class="line">Author: Pc</span><br><span class="line">Date:   Tue Sep 29 18:26:43 2020 +0800</span><br><span class="line"></span><br><span class="line">    c</span><br></pre></td></tr></table></figure><p>应用场景：<br>比如想在某个 <code>commit</code> 出写一些临时的新的 <code>commits</code>，但不确定是否保留这些内容（或者倾向于不保留），那么就：</p><ol><li>不希望把当前的 branch 带跑；</li><li>不想新建一个别的 branch。</li></ol><p>那么就可以 <code>detach</code> 一下，这样就可以在后面的 <code>commits</code> 中只有 <code>HEAD</code> 在跟着 <code>commits</code> 跑，而 <code>branch</code> 一直留在原地。</p><h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d &lt;分支名&gt;</span><br></pre></td></tr></table></figure><ul><li><code>HEAD</code> 指向的 <code>branch</code> 不能删除。如果要删除 <code>HEAD</code> 指向的 <code>branch</code>，需要先用 <code>checkout</code> 把 <code>HEAD</code> 指向其他地方。</li><li>由于 <code>Git</code> 中的 <code>branch</code> 只是一个「引用」，所以删除 <code>branch</code> 的操作也只会删掉这个「引用」，并不会删除任何的 <code>commit(分支提交的内容)</code>。（不过如果一个 <code>commit</code> 不在任何一个 <code>branch</code> 的「路径」上，或者换句话说，如果没有任何一个 <code>branch</code> 可以回溯到这条 <code>commit</code>（也许可以称为野生 <code>commit</code>？），那么在一定时间后，它会被 <code>Git</code> 的回收机制删除掉。）</li><li>出于安全考虑，没有被合并到 <code>master</code> 的 <code>branch</code> 在删除时会失败<code>(前提是有新内容)</code>，这种情况如果你确认是要删除这个 <code>branch</code> （例如某个未完成的功能被团队确认永久毙掉了，不再做了），可以把 <code>-d</code> 改成 <code>-D</code>，小写换成大写，就能删除了。</li></ul><p><strong>「引用」的本质</strong></p><p>所谓「引用」（<code>reference</code>），其实就是一个个的字符串。这个字符串可以是一个 <code>commit</code> 的 <code>SHA-1</code> 码（例：<code>c08de9a4d8771144cd23986f9f76c4ed729e69b0</code>），也可以是一个 <code>branch</code>（例：<code>ref: refs/heads/feature3</code>）。拿到这个字符串，就知道当前引用指向谁。</p><p><code>Git</code> 中的 <code>HEAD</code> 和每一个 <code>branch</code> 以及其他的引用，都是以文本文件的形式存储在本地仓库 <code>.git</code> 目录中，而 <code>Git</code> 在工作的时候，就是通过这些文本文件的内容来判断这些所谓的「引用」是指向谁的。</p><h2 id="六-merge-合并"><a href="#六-merge-合并" class="headerlink" title="六  merge(合并)"></a>六  merge(合并)</h2><p><code>merge</code> 的意思是「合并」，它做的事也是合并：指定一个 <code>commit</code>，把它合并到当前的 <code>commit</code> 来。</p><p><strong>把目标 <code>commit</code> 的路径上的所有 <code>commit</code> 的内容一并应用到当前 <code>commit</code> （即 <code>HEAD</code> 所指向的 <code>commit</code>），然后自动生成一个新的 <code>commit</code>。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge &lt;目标分支名&gt;</span><br></pre></td></tr></table></figure><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li><p>合并分支</p><p>当一个 <code>branch</code> 的开发已经完成，需要把内容合并回去时，用 <code>merge</code> 来进行合并。</p></li><li><p><code>pull</code> 的内部操作</p><p><code>pull</code> 的实际操作其实是把远端仓库的内容用 <code>fetch</code> 取下来之后，用 <code>merge</code> 来合并。</p></li></ul><h3 id="特殊情况-1：冲突"><a href="#特殊情况-1：冲突" class="headerlink" title="特殊情况 1：冲突"></a>特殊情况 1：冲突</h3><p><code>merge</code> 在做合并的时候，是有一定的自动合并能力的：<br>如果一个分支改了 <code>A</code> 文件，另一个分支改了 <code>B</code> 文件，那么合并后就是既改 <code>A</code>也改 <code>B</code>，这个动作会自动完成；<br>如果两个分支都改了同一个文件，但一个改的是第 <code>1</code> 行，另一个改的是第 <code>2</code> 行，那么合并后就是第 <code>1</code> 行和第 <code>2</code> 行都改，也是自动完成。</p><p>但是，如果两个分支修改了同一部分内容，<code>merge</code> 的自动算法就搞不定了。这种情况 <code>Git</code> 称之为：冲突（<code>Conflict</code>）。</p><p>两个分支改了相同的内容，<code>Git</code> 不知道应该以哪个为准。如果在 <code>merge</code> 的时候发生了这种情况，<code>Git</code> 就会把问题交给你来决定。它会告诉你 <code>merge</code> 失败，以及失败的原因。</p><p>我再 <code>feature1</code> 分支 <code>mergeTest.txt</code> 文件第一行写了几个字，并 <code>commit</code> 提交，然后切换到 <code>master</code> 分支，这时 <code>mergeTest.txt</code> 文件是没东西的，又在第一行写了几个字，并 <code>commit</code> 提交，最后在 <code>master</code> 分支去合并 <code>feature1</code> 分支，提示如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git merge feature1</span><br><span class="line">Auto-merging mergeTest.txt</span><br><span class="line">CONFLICT (content): Merge conflict in mergeTest.txt</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure><p>提示信息中心说 <code>mergeTest.txt</code> 中出现合并冲突，自动合并失败，要求把冲突解决后再提交。意思就是需要<strong>先 解决冲突 ，然后手动 <code>commit</code> 一下</strong></p><h4 id="1-解决冲突"><a href="#1-解决冲突" class="headerlink" title="1.解决冲突"></a>1.解决冲突</h4><p>现在打开冲突的文件，会发现是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">烦烦烦</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">奥德赛</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1</span><br></pre></td></tr></table></figure><p><code>Git</code> 虽然没有帮你完成自动 <code>merge</code>，但它对文件还是做了一些工作：它把两个分支冲突的内容放在了一起，并用 <code>=======</code> 符号标记出了它们的边界以及它们的出处。</p><p><code>HEAD</code> 中的内容是 <code>烦烦烦</code>，而 <code>feature1</code> 中的内容则是 <code>奥德赛</code>。这两个改动 <code>Git</code> 不知道应该怎样合并，于是把它们放在一起，由你来决定。假设你决定保留 <code>HEAD</code> 的修改，那么只要删除掉 <code>feature1</code> 的修改，再把 Git 添加的那三行 <code>&lt;&lt;&lt;</code> <code>===</code> <code>&gt;&gt;&gt;</code> 辅助文字也删掉，保存文件退出，所谓的「解决掉冲突」就完成了。</p><p>修改后只能剩下需要的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">烦烦烦</span><br></pre></td></tr></table></figure><h4 id="2-提交"><a href="#2-提交" class="headerlink" title="2.提交"></a>2.提交</h4><p>解决完冲突以后，就可以进行第二步—— <code>commit</code> 了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add mergeTest.txt</span><br><span class="line">git commit</span><br></pre></td></tr></table></figure><p>被冲突中断的 <code>merge</code>，在手动 <code>commit</code> 的时候依然会自动填写提交信息。这是因为在发生冲突后，<code>Git</code> 仓库处于一个「<code>merge</code> 冲突待解决」的中间状态，在这种状态下 <code>commit</code>，<code>Git</code> 就会自动地帮你添加「这是一个 <code>merge commit</code>」的提交信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Merge branch &#39;feature1&#39; into master</span><br><span class="line"></span><br><span class="line"># Conflicts:</span><br><span class="line">#mergeTest.txt</span><br></pre></td></tr></table></figure><h4 id="3-放弃解决冲突，取消-merge"><a href="#3-放弃解决冲突，取消-merge" class="headerlink" title="3.放弃解决冲突，取消 merge"></a>3.放弃解决冲突，取消 merge</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge --abort</span><br></pre></td></tr></table></figure><p>输入这行代码，你的 <code>Git</code> 仓库就会回到 <code>merge</code> 前的状态。</p><h3 id="特殊情况-2：HEAD-领先于目标-commit"><a href="#特殊情况-2：HEAD-领先于目标-commit" class="headerlink" title="特殊情况 2：HEAD 领先于目标 commit"></a>特殊情况 2：HEAD 领先于目标 commit</h3><p>如果 <code>merge</code> 时的目标 <code>commit</code> 和 <code>HEAD</code> 处的 <code>commit</code> 并不存在分叉，而是 <code>HEAD</code> 领先于目标 <code>commit</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1          2          3</span><br><span class="line">           ↑          ↑</span><br><span class="line">       feature1  HEAD&#x2F;master</span><br></pre></td></tr></table></figure><p>那么 <code>merge</code> 就没必要再创建一个新的 <code>commit</code> 来进行合并操作，因为并没有什么需要合并的。在这种情况下， <code>Git</code> 什么也不会做，<code>merge</code> 是一个空操作。</p><h3 id="特殊情况-3：HEAD-落后于目标-commit"><a href="#特殊情况-3：HEAD-落后于目标-commit" class="headerlink" title="特殊情况 3：HEAD 落后于目标 commit"></a>特殊情况 3：HEAD 落后于目标 commit</h3><p>这种又叫 <code>fast-forward</code></p><p>另一种情况：如果 <code>HEAD</code> 和目标 <code>commit</code> 依然是不存在分叉，但 <code>HEAD</code> 不是领先于目标 <code>commit</code>，而是落后于目标 <code>commit</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1          2          3          4</span><br><span class="line">                      ↑          ↑</span><br><span class="line">                 HEAD&#x2F;master   origin&#x2F;master</span><br></pre></td></tr></table></figure><p>那么 <code>Git</code> 会直接把 <code>HEAD</code> 移动到目标 <code>commit</code> </p><p>这种操作有一个专有称谓，叫做 <code>&quot;fast-forward&quot;</code>（快速前移）。</p><p>一般情况下，创建新的 <code>branch</code> 都是会和原 <code>branch</code> 并行开发的，不然没必要开 <code>branch</code> ，直接在原 <code>branch</code> 上开发就好。</p><p>但事实上，这种情形其实很常见，因为这其实是 <code>pull</code> 操作的一种经典情形：<strong>本地的 <code>master</code> 没有新提交，而远端仓库中有同事提交了新内容到 <code>master</code>。</strong><br>那么这时如果在本地执行一次 <code>pull</code> 操作，就会由于 <code>HEAD</code> 落后于目标 <code>commit</code> （也就是远端的 <code>master</code>）而造成 <code>&quot;fast-forward&quot;</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ git pull</span><br><span class="line">remote: Enumerating objects: 2, done.</span><br><span class="line">remote: Counting objects: 100% (2&#x2F;2), done.</span><br><span class="line">remote: Total 2 (delta 1), reused 2 (delta 1), pack-reused 0</span><br><span class="line">Unpacking objects: 100% (2&#x2F;2), done.</span><br><span class="line">From https:&#x2F;&#x2F;github.com&#x2F;CalmCenter&#x2F;UiStarge</span><br><span class="line">   195efe8..61213f7  master     -&gt; origin&#x2F;master</span><br><span class="line">Updating 195efe8..61213f7</span><br><span class="line">Fast-forward</span><br><span class="line"> branch1.txt   | 1 +</span><br><span class="line"> mergeTest.txt | 1 +</span><br><span class="line"> test1.txt     | 1 +</span><br><span class="line"> 3 files changed, 3 insertions(+)</span><br><span class="line"> create mode 100644 branch1.txt</span><br><span class="line"> create mode 100644 mergeTest.txt</span><br></pre></td></tr></table></figure><p>现在把 <code>git pull</code> 拆分执行：</p><p>第一步</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch</span><br></pre></td></tr></table></figure><p>下载远端仓库内容时，这两个镜像引用得到了更新，<code>origin/master</code> 和 <code>origin/HEAD</code> 移动到了最新的 <code>commit</code>。</p><p>在输入 <code>git log</code> 后你会发现找不到 <code>(origin/master, origin/HEAD)</code>  这个引用了，因为到更新到最新的 <code>commit</code> 了，这里只能打印当前 <code>commit</code>  以下的信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit 61213f7813ad116abdd498bd3575e7b4173b4c8e (HEAD -&gt; master)</span><br><span class="line">Merge: 195efe8 75aa327</span><br><span class="line">Author: Pc </span><br><span class="line">Date:   Wed Sep 23 14:32:33 2020 +0800</span><br><span class="line"></span><br><span class="line">    Merge branch &#39;feature2&#39;</span><br></pre></td></tr></table></figure><p>而 <code>git pull</code> 的第二步操作 <code>merge</code> 的目标 <code>commit</code> ，是远端仓库的 <code>HEAD</code>，也就是 <code>origin/HEAD</code> ，所以 <code>git pull</code> 的第二步的完整内容是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git merge origin&#x2F;HEAD</span><br><span class="line">Updating 61213f7..6c2bcc2</span><br><span class="line">Fast-forward</span><br><span class="line"> mergeTest.txt | 2 +-</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit 6c2bcc2a8ca9d872338d36df45dee8a95d900148 (HEAD -&gt; master, origin&#x2F;master, origin&#x2F;HEAD)</span><br><span class="line">Author: Pc</span><br><span class="line">Date:   Wed Sep 23 14:39:43 2020 +0800</span><br><span class="line"></span><br><span class="line">    test</span><br><span class="line"></span><br><span class="line">commit 61213f7813ad116abdd498bd3575e7b4173b4c8e</span><br><span class="line">Merge: 195efe8 75aa327</span><br><span class="line">Author: Pc </span><br><span class="line">Date:   Wed Sep 23 14:32:33 2020 +0800</span><br><span class="line"></span><br><span class="line">    Merge branch &#39;feature2&#39;</span><br></pre></td></tr></table></figure><p>因此 <code>HEAD</code> 就会带着 <code>master</code> 一起，也指向了最新 <code>commit</code> 。</p><p>如果不想用 <code>fast-forward</code> ，可以使用如下命令 <code>--no-ff：不使用 fast-forward 方式合并，保留分支的 commit 历史</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge --no-ff feature</span><br></pre></td></tr></table></figure><h2 id="七-Feature-Branch-最流行的工作流"><a href="#七-Feature-Branch-最流行的工作流" class="headerlink" title="七 Feature Branch(最流行的工作流)"></a>七 Feature Branch(最流行的工作流)</h2><p>目前最流行（不论是中国还是世界）的团队开发的工作流：<code>Feature Branch</code>。</p><p>这种工作流的核心内容可以总结为两点：</p><ol><li>任何新的功能（<code>feature</code>）或 <code>bug</code> 修复全都新建一个 <code>branch</code> 来写；</li><li><code>branch</code> 写完后，合并到 <code>master</code>，然后删掉这个 <code>branch</code>。</li></ol><p>这种工作流似乎没什么特别之处。但实质上，<code>Feature Branching</code> 这种工作流，为团队开发时两个关键的问题—— <strong>代码分享</strong> 和 <strong>一人多任务</strong> ——提供了解决方案。</p><h3 id="1-代码分享"><a href="#1-代码分享" class="headerlink" title="1.代码分享"></a>1.代码分享</h3><p>假设需要开发一个新功能，于是创建了一个新的 <code>branch</code> 叫做 <code>books</code>，然后开始在 <code>books</code> 上进行开发工作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b books</span><br></pre></td></tr></table></figure><p>在十几个 <code>commit</code> 过后，功能开发完毕，把代码 <code>push</code> 到中央仓库（例如 <code>GitHub</code>）去，然后告诉 <code>review</code> 的同事：「嘿，功能写完了，分支名是 <code>books</code>，谁有空的话帮我 <code>review</code> 一下吧。」</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin books</span><br></pre></td></tr></table></figure><p>然后负责 <code>review</code> 的同事就可以从中央仓库拉下来你的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br><span class="line">git chekcout books</span><br></pre></td></tr></table></figure><p>然后可以根据同事要求修改、更新，<code>review</code> 通过后，就可以合并到 <code>master</code> 上了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git pull </span><br><span class="line">git merge books</span><br></pre></td></tr></table></figure><p><code>merge</code> 之前 <code>pull</code> 一下，让 <code>master</code> 更新到和远程仓库同步</p><p>然后把合并后的结果 <code>push</code> 到了中央仓库，并删掉了 <code>books</code> 这个 <code>branch</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br><span class="line">git branch -d books</span><br><span class="line">git push origin -d books</span><br></pre></td></tr></table></figure><p><code>git push origin -d books</code> 用 <code>-d</code>参数把远程仓库的 <code>branch</code> 也删了</p><h3 id="2-Pull-Request"><a href="#2-Pull-Request" class="headerlink" title="2.Pull Request"></a>2.Pull Request</h3><p>上面这个流程，还可以利用 <code>Pull Request</code> 来进一步简化。</p><p><code>Pull Request</code> 并不是 <code>Git</code> 的内容，而是一些 Git 仓库服务提供方（例如 <code>GitHub</code>）所提供的一种便捷功能，它可以让团队的成员方便地讨论一个 <code>branch</code> ，并在讨论结束后一键合并这个 <code>branch</code> 到 <code>master</code>。</p><p>同样是把写好的 <code>branch</code> 给同事看，使用 <code>Pull Request</code> 的话可以这样：</p><p>首先创建一个 <code>pull request</code> </p><p>这是在 <code>push</code> 分支之后，会有一个这么个按钮快捷创建 <code>pull request</code>，但我现在试着不是每次都出~</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/git/git_pull_requests_7.png" alt=""></p><p>下面是正常创建流程。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/git/git_pull_requests_1.webp" alt=""></p><p>点击 <code>New pull request</code> 然后选择需要分享的分支，这里是 <code>feature2</code> ，选择后就可以看到修改内容，并且 <code>create pull request</code> 也可以点击了。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/git/git_pull_requests_2.webp" alt=""></p><p>这里需要写修改内容 <code>md</code> 格式的。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/git/git_pull_requests_4.webp" alt=""></p><p>然后你的同事就可以在 <code>GitHub</code> 上看到你创建的 <code>Pull Request</code> 了。他们可以在 <code>GitHub</code> 的这个页面查看你的 <code>commits</code>，也可以给你评论表示赞同或提意见，你接下来也可以根据他们的意见把新的 <code>commits</code>  <code>push</code> 上来，页面会随着你新的 <code>push</code> 而展示出最新的 <code>commits</code>。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/git/git_pull_requests_5.webp" alt=""></p><p>在讨论结束以后，认为这个 <code>branch</code> 可以合并了，只需要点一下页面中那个绿色的 <code>&quot;Merge pull request&quot;</code> 按钮，<code>GitHub</code> 就会自动地在中央仓库帮你把 <code>branch</code> 合并到 <code>master</code> 了。</p><p>然后你只要在本地 <code>pull</code> 一下，把最新的内容拉到你的电脑上，这件事情就算完成了。</p><p>另外，<code>GitHub</code> 还设计了一个贴心的 <code>&quot;Delete branch&quot;</code> 按钮，方便你在合并之后一键删除 <code>branch</code>。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/git/git_pull_requests_6.webp" alt=""></p><h3 id="3-一人多任务"><a href="#3-一人多任务" class="headerlink" title="3.一人多任务"></a>3.一人多任务</h3><p>除了代码分享的便捷，基于 <code>Feature Branch</code> 的工作流对于<strong>一人多任务</strong>的工作需求也提供了很好的支持。</p><p>安安心心做事不被打扰，做完一件再做下一件自然是很美好的事，但现实往往不能这样。对于程序员来说，一种很常见的情况是，你正在认真写着代码，忽然紧急需要新填另外一个功能！</p><p>其实，虽然这种情况确实有点烦，但如果你是在独立的 <code>branch</code> 上做事，切换任务是很简单的。你只要稍微把目前未提交的代码简单收尾一下，然后做一个带有「未完成」标记的提交（例如，在提交信息里标上<code>「TODO」</code>），然后回到 <code>master</code> 去创建一个新的 <code>branch</code> 就好了。</p><p>如果有一天需要回来继续做这个 <code>branch</code>，你只要用 <code>checkout</code> 切回来，就可以继续了。</p><h2 id="八-rebase（变基）"><a href="#八-rebase（变基）" class="headerlink" title="八 rebase（变基）"></a>八 rebase（变基）</h2><p><code>rebase</code> ，又是一个中国人看不懂的词。这个词的意思，你如果查一下的话是 <code>变基</code>  (〃’▽’〃)    。 不忍直视 ~ (<em>/ω＼</em>)</p><p>其实这个翻译还是比较准确的。<code>rebase</code> 的意思是，给你的 <code>commit</code> 序列重新设置基础点（也就是父 <code>commit</code>）。展开来说就是，把你指定的 <code>commit</code> 以及它所在的 <code>commit</code> 串，以指定的目标 <code>commit</code> 为基础，依次重新提交一次。</p><p>一般情况下是在子分支去 <code>rebase</code> 主分支</p><h3 id="1-rebase-和-merge-的区别"><a href="#1-rebase-和-merge-的区别" class="headerlink" title="1. rebase 和 merge 的区别"></a>1. <code>rebase</code> 和 <code>merge</code> 的区别</h3><p>先看一下 <code>rebase</code> 的情况。</p><p>当前分支情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">                      master</span><br><span class="line">                        ↓</span><br><span class="line">1   →   2   →   3   →   4      </span><br><span class="line">          ↘</span><br><span class="line">             ↘</span><br><span class="line">                5   →   6</span><br><span class="line">                        ↑</span><br><span class="line">                     feature2</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout feature2</span><br><span class="line">git rebase master</span><br></pre></td></tr></table></figure><p>执行完后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">                      master         feature2</span><br><span class="line">                        ↓               ↓</span><br><span class="line">1   →   2   →   3   →   4   →   7   →   8      </span><br><span class="line">          ↘</span><br><span class="line">             ↘</span><br><span class="line">                5   →   6</span><br></pre></td></tr></table></figure><p>通过 <code>rebase</code>，<code>feature2</code> 把基础点从 <code>2</code> 换成了 <code>4</code> ，<code>feature2</code> 中的 <code>5</code> 和 <code>6</code> 两条 <code>commit</code> 也 变成了新的 <code>commit</code>  <code>7</code> 和 <code>8</code> ，但是内容是没有变的。<br>通过这样的方式，就让本来分叉了的提交历史重新回到了一条线。这种「重新设置基础点」的操作，就是 <code>rebase</code> 的含义。</p><p>更直观一点：</p><p>这是 <code>sourTree</code> 的历史日志，<code>feature2</code> 当前的在 <code>delete branch</code> 这个 <code>commit</code> 的基础下，更改了一些内容，并且当前 <code>master</code> 也有了新的更新，现在需要把 <code>master</code> 的内容合并到 <code>feature2</code> 上</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/git/git_log_2.png" alt=""></p><p>使用 <code>rebase</code> 合并后</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/git/git_log.png" alt=""></p><p><code>feature2</code> 的基准点变了，成了当前 <code>master</code> 指向的 <code>commit</code> ，并且他们的提交历史变成了一条直线。</p><p>那 <code>merge</code> 呢？</p><p><code>feature2</code> 当前的在 <code>branch 更新</code> 这个 <code>commit</code> 的基础下，更改了一些内容，并且当前 <code>master</code> 也有了新的更新，现在需要把 <code>master</code> 的内容合并到 <code>feature2</code> 上</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/git/git_log_3.png" alt=""></p><p>使用 <code>merge</code> 合并后</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/git/git_log_4.png" alt=""></p><p>这里可以明显的看到，多了一个 <code>commit</code> ，并且提交历史也是分叉的，如果分支多的情况下，会很乱的！</p><blockquote><p>现在，基本明白了 <code>rebase</code> 的作用，可以减少 <code>commit</code> 的数量以及减少分叉数量，使得提交历史干净整洁。</p></blockquote><p>当然这只是其中一部分作用。</p><h3 id="2-rebase-时出现了冲突怎么办？"><a href="#2-rebase-时出现了冲突怎么办？" class="headerlink" title="2.rebase 时出现了冲突怎么办？"></a>2.<code>rebase</code> 时出现了冲突怎么办？</h3><p>如果出现了冲突，在 <code>git</code> 页面中会出现 <code>REBASE 1/1</code> 。 <code>merge</code> 冲突时也会出现类似的提示，解决办法相同，把 <code>rebase</code> 改成 <code>merge</code> 即可。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/git/git_rebase_conflict.png" alt=""></p><p>需要手动解决，解决完后，用 <code>git add .</code> 或者某个文件名，来标记已解决，最后执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase --continue</span><br></pre></td></tr></table></figure><p>继续执行 <code>rebase</code> 完成变基。</p><p>如果想回到 <code>rebase</code> 执行之前的状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase --abort</span><br></pre></td></tr></table></figure><h3 id="3-使用-rebase-需要注意什么？"><a href="#3-使用-rebase-需要注意什么？" class="headerlink" title="3. 使用 rebase 需要注意什么？"></a>3. 使用 <code>rebase</code> 需要注意什么？</h3><p><code>rebase</code> 在为理解透彻之前，是不能随便使用的！</p><p>但是，有一个黄金定律，只要满足，就可以安全使用，并且比 <code>merge</code> 要好用很多。</p><blockquote><p><strong>只要你的分支上需要 <code>rebase</code> 的所有 <code>commits</code> 历史还没有被 <code>push</code> 过，就可以安全地使用 <code>git rebase</code> 来操作。</strong></p></blockquote><p>也就是说永远不要 <code>rebase</code> 一个已经在中央库中存在的 <code>commit</code> ，只能 <code>rebase</code> 你自己使用的私有 <code>commit</code>。</p><p>那 <code>rebase</code> 了一个已经 <code>push</code> 过的 <code>commit</code> 会怎么办呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">                      master</span><br><span class="line">                        ↓</span><br><span class="line">1   →   2   →   3   →   4      </span><br><span class="line">          ↘</span><br><span class="line">             ↘</span><br><span class="line">                5   →   6</span><br><span class="line">                ↑       ↑</span><br><span class="line">    origin&#x2F;feature2  feature2</span><br></pre></td></tr></table></figure><p>还是这张图，假设 <code>5</code> 已经被 <code>push</code> 到远程，现在 <code>rebase</code> 到 <code>master</code> 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">                      master         feature2</span><br><span class="line">                        ↓               ↓</span><br><span class="line">1   →   2   →   3   →   4   →   7   →   8      </span><br><span class="line">          ↘</span><br><span class="line">             ↘</span><br><span class="line">                5   →   6</span><br><span class="line">                ↑</span><br><span class="line">         origin&#x2F;feature2</span><br></pre></td></tr></table></figure><p>现在看着没什么问题，但是你查看远程时，发现 <code>5</code> 那个 <code>commit</code> 是可以 <code>pull</code> 下来的。因为本地的 <code>5</code> 已经变成了新的  <code>commit 7</code> ，本地已经没有 <code>5</code> 的记录了，但是远程有。</p><p>如果你在 <code>5</code> 的时候添加的一些文件并 <code>push</code> 到了远程，在 <code>6</code> 的时候删除了那些文件，执行 <code>rebase</code> 后你是可以 <code>pull</code> 的， <code>pull</code> 远程后，你会发现那些删除的文件又回来了！</p><p>这里这种问题，可以通过下面的命令，强制提交，不需要 <code>pull</code> 而是直接覆盖中央仓库的历史。(<code>--force</code>)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -f</span><br></pre></td></tr></table></figure><p>这只是本人亲身经历过的一种情况，所以一定要遵循 <code>rebase 黄金定律</code> 。</p><h3 id="4-交互式-rebase-i"><a href="#4-交互式-rebase-i" class="headerlink" title="4.交互式 rebase -i"></a>4.交互式 <code>rebase -i</code></h3><h4 id="偏移符号"><a href="#偏移符号" class="headerlink" title="偏移符号"></a>偏移符号</h4><p>在了解交互式 <code>rebase -i</code> 之前，先了解下偏移符号。</p><p>说明：在 <code>Git</code> 中，有两个「偏移符号」： <code>^</code> 和 <code>~</code>。</p><p><code>^</code> 的用法：在 <code>commit</code> 的后面加一个或多个 <code>^</code> 号，可以把 <code>commit</code> 往回偏移，偏移的数量是 <code>^</code> 的数量。例如：<code>master^</code> 表示 <code>master</code> 指向的 <code>commit</code> 之前的那个 <code>commit</code>； <code>HEAD^^</code> 表示 <code>HEAD</code> 所指向的 <code>commit</code> 往前数两个 <code>commit</code>。</p><p><code>~</code> 的用法：在 <code>commit</code> 的后面加上 <code>~</code> 号和一个数，可以把 <code>commit</code> 往回偏移，偏移的数量是 <code>~</code> 号后面的数。例如：<code>HEAD~5</code> 表示 <code>HEAD</code> 指向的 <code>commit</code>往前数 5 个 <code>commit</code>。</p><p>下面详细说明。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git log --oneline --graph --all</span><br><span class="line">*   1699603 (HEAD -&gt; master) Merge branch &#39;feature2&#39;</span><br><span class="line">|\</span><br><span class="line">| * 2b21ec9 (feature2) feature2 第二次提交</span><br><span class="line">| * 2fb7de8 feature2 第一次提交</span><br><span class="line">* | 528eb23 (feature1) feature1 第二次提交</span><br><span class="line">* | d4faecf feature1 第一次提交</span><br><span class="line">|&#x2F;</span><br><span class="line">* 9001713 (origin&#x2F;master, origin&#x2F;feature2, origin&#x2F;feature1, origin&#x2F;HEAD) 第二次添加</span><br></pre></td></tr></table></figure><p>先看一下 <code>~</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git show --oneline HEAD~1</span><br><span class="line">528eb23 (feature1) feature1 第二次提交</span><br><span class="line"></span><br><span class="line">$ git show --oneline HEAD~2</span><br><span class="line">d4faecf feature1 第一次提交</span><br><span class="line"></span><br><span class="line">$ git show --oneline HEAD~3</span><br><span class="line">9001713 (origin&#x2F;master, origin&#x2F;feature2, origin&#x2F;feature1, origin&#x2F;HEAD) 第二次添加</span><br></pre></td></tr></table></figure><p>然后看 <code>^</code> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git show --oneline HEAD^</span><br><span class="line">528eb23 (feature1) feature1 第二次提交</span><br><span class="line"></span><br><span class="line">$ git show --oneline HEAD^^</span><br><span class="line">d4faecf feature1 第一次提交</span><br><span class="line"></span><br><span class="line">$ git show --oneline HEAD^^^</span><br><span class="line">9001713 (origin&#x2F;master, origin&#x2F;feature2, origin&#x2F;feature1, origin&#x2F;HEAD) 第二次添加</span><br></pre></td></tr></table></figure><p>可以看到这里并没有打印到 <code>feature2</code> 的提交，那如何就可以打印了呢？</p><p>切换分支 ~ </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git show --oneline HEAD^2</span><br><span class="line">2b21ec9 (feature2) feature2 第二次提交</span><br><span class="line"></span><br><span class="line">$ git show --oneline HEAD^2^</span><br><span class="line">2fb7de8 feature2 第一次提交</span><br><span class="line"></span><br><span class="line">$ git show --oneline HEAD^2~1</span><br><span class="line">2fb7de8 feature2 第一次提交</span><br></pre></td></tr></table></figure><p><code>^2</code> 这里没有偏移，只是切换分支。当然，还可以切换引用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git show --oneline feature2^</span><br><span class="line">2fb7de8 feature2 第一次提交</span><br></pre></td></tr></table></figure><p>总结</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 当前提交</span><br><span class="line">HEAD &#x3D; HEAD~0 &#x3D; HEAD^0</span><br><span class="line"></span><br><span class="line"># 主线回溯(最靠左边的即为主线)</span><br><span class="line">HEAD~1 &#x3D; HEAD^ 主线的上一次提交</span><br><span class="line">HEAD~2 &#x3D; HEAD^^ 主线的上二次提交</span><br><span class="line">HEAD~3 &#x3D; HEAD^^^ 主线的上三次提交</span><br><span class="line"></span><br><span class="line"># 如果某个节点有其他分支并入</span><br><span class="line">HEAD^1 主线提交（第一个父提交）</span><br><span class="line">HEAD^2 切换到了第2个并入的分支并得到最近一次的提交</span><br><span class="line">HEAD^2~3 切换到了第2个并入的分支并得到最近第 4 次的提交</span><br><span class="line">HEAD^3~2 切换到了第3个并入的分支并得到最近第 3 次的提交</span><br><span class="line"></span><br><span class="line"># ^&#123;n&#125; 和 ^ 重复 n 次的区别 </span><br><span class="line">HEAD~1 &#x3D; HEAD^</span><br><span class="line">HEAD~2 &#x3D; HEAD^^</span><br><span class="line">HEAD~3 &#x3D; HEAD^^^</span><br><span class="line"></span><br><span class="line"># 切换父级</span><br><span class="line">HEAD^1~3 &#x3D; HEAD~4 </span><br><span class="line">HEAD^2~3 &#x3D; HEAD^2^^^</span><br><span class="line">HEAD^3~3 &#x3D; HEAD^3^^^</span><br></pre></td></tr></table></figure><h4 id="修改之前的-commit"><a href="#修改之前的-commit" class="headerlink" title="修改之前的 commit"></a>修改之前的 <code>commit</code></h4><p>之前讲过 <code>git commit -—amend</code> 可以 修复/替换 最新 <code>commit</code> 的错误，那倒数第二个，第三个 <code>commit</code> 需要修改怎么办呢？</p><p>那就需要用到 <code>rebase -i</code> 了，它是 <code>rebase --interactive</code> 的缩写形式，意为「交互式 <code>rebase</code>」。</p><p>所谓「交互式 <code>rebase</code>」，就是在 <code>rebase</code> 的操作执行之前，你可以指定要 <code>rebase</code> 的 <code>commit</code> 链中的每一个 <code>commit</code> 是否需要进一步修改。</p><p>当前我提交了几个 <code>commit</code> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">*   1699603 (HEAD -&gt; master) Merge branch &#39;feature2&#39;</span><br><span class="line">|\</span><br><span class="line">| * 2b21ec9 (feature2) feature2 第二次提交</span><br><span class="line">| * 2fb7de8 feature2 第一次提交</span><br><span class="line">* | 528eb23 (feature1) feature1 第二次提交</span><br><span class="line">* | d4faecf feature1 第一次提交</span><br><span class="line">|&#x2F;</span><br><span class="line">*</span><br></pre></td></tr></table></figure><p>但是我发现在 <code>feature1 第二次提交</code> 的 <code>commit</code> 中需要修改一些内容，这时使用 <code>commit --amend</code> 已经晚了。我们需要使用下面的命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i HEAD^^</span><br></pre></td></tr></table></figure><p>会进入编辑界面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">pick 528eb23 feature1 第二次提交</span><br><span class="line">pick 2fb7de8 feature2 第一次提交</span><br><span class="line">pick 2b21ec9 feature2 第二次提交</span><br><span class="line"></span><br><span class="line"># Rebase d4faecf..5b7f84f onto d4faecf (3 commands)</span><br><span class="line">#</span><br><span class="line"># Commands:</span><br><span class="line"># p, pick &lt;commit&gt; &#x3D; use commit</span><br><span class="line"># r, reword &lt;commit&gt; &#x3D; use commit, but edit the commit message</span><br><span class="line"># e, edit &lt;commit&gt; &#x3D; use commit, but stop for amending</span><br><span class="line"># s, squash &lt;commit&gt; &#x3D; use commit, but meld into previous commit</span><br><span class="line"># f, fixup &lt;commit&gt; &#x3D; like &quot;squash&quot;, but discard this commit&#39;s log message</span><br><span class="line"># x, exec &lt;command&gt; &#x3D; run command (the rest of the line) using shell</span><br><span class="line"># b, break &#x3D; stop here (continue rebase later with &#39;git rebase --continue&#39;)</span><br><span class="line"># d, drop &lt;commit&gt; &#x3D; remove commit</span><br><span class="line"># l, label &lt;label&gt; &#x3D; label current HEAD with a name</span><br><span class="line"># t, reset &lt;label&gt; &#x3D; reset HEAD to a label</span><br><span class="line"># m, merge [-C &lt;commit&gt; | -c &lt;commit&gt;] &lt;label&gt; [# &lt;oneline&gt;]</span><br><span class="line"># .       create a merge commit using the original merge commit&#39;s</span><br><span class="line"># .       message (or the oneline, if no original merge commit was</span><br><span class="line"># .       specified). Use -c &lt;commit&gt; to reword the commit message.</span><br><span class="line">#</span><br><span class="line"># These lines can be re-ordered; they are executed from top to bottom.</span><br><span class="line">#</span><br><span class="line"># If you remove a line here THAT COMMIT WILL BE LOST.</span><br></pre></td></tr></table></figure><p>这里可以看到， <code>rebase -i HEAD^^</code> 和我们之前讲的 <code>git show --oneline HEAD^^</code> 预期是不一样的。</p><p>为什么不一样呢？</p><p><code>rebase -i HEAD^^</code> 表示列出倒数第三个 <code>commit</code> 之前的提交记录，<strong>不包括倒数第三个</strong>。</p><p><code>git show --oneline HEAD^^</code> 表示显示倒数第三个 <code>commit</code> 的记录。</p><p>又因为这里用了 <code>merge</code> ，在 <code>rebase -i HEAD^</code> 时，会列出 <code>merge</code> 操作中合并的所有 <code>commit</code> ，这里正好 <code>merge</code> 了两个 <code>commit</code>，<br>所以第一个 <code>^</code> 会列出主线倒数第一个 <code>commit</code>，但是这个 <code>commit</code> 是个 <code>merge</code> 操作，然后就去寻找 <code>merge</code> 了那些 <code>commit</code> 并列出 ，第二个 <code>^</code> 是主线倒数第二个 <code>commit</code>。</p><p>这个编辑界面的最顶部，列出了将要「被 <code>rebase</code>」的所有 <code>commit</code> 。需要注意，这个排列是正序的，旧的 <code>commit</code> 会排在上面，新的排在下面。</p><p>这两行指示了两个信息：</p><ol><li>需要处理哪些 <code>commit</code>；</li><li>怎么处理它们。</li></ol><p>每个 <code>commit</code> 默认的操作都是 <code>pick</code> ，表示「直接应用这个 <code>commit</code>」。如果直接退出的话，那么这次就是一次空操作。</p><p>各个操作的意思：</p><ol><li><code>pick</code>：直接应用这个 <code>commit</code> </li><li><code>reword</code>：使用此 <code>commit</code>， 编辑 <code>commit message</code>，<code>message</code> 就是 <code>commit -m</code> 命令后面写到说明，下同。</li><li><code>edit</code>：使用此 <code>commit</code>，但是不编辑 <code>commit message</code>，保持原有 <code>commit message</code> </li><li><code>squash</code>：使用此 <code>commit</code>，但是合并到前一个 <code>commit</code> 中去 </li><li><code>fixup</code>： 和 <code>squash</code> 类似，但是放弃此 <code>commit</code> 的 <code>message</code> </li><li><code>drop</code>：删除 <code>commit</code></li><li>其余的没用过 ~ </li></ol><p>点击 <code>i</code> 键进行编辑。我们的目的是修改 <code>feature1 第二次提交</code> ，我们需要把那一行的 <code>pick</code> 改成 <code>edit</code> 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">edit 528eb23 feature1 第二次提交</span><br><span class="line">pick 2fb7de8 feature2 第一次提交</span><br><span class="line">pick 2b21ec9 feature2 第二次提交</span><br></pre></td></tr></table></figure><p>修改完后，按 <code>esc</code> 然后 <code>:wq</code> 这是三个按键依次按，之前我也不懂，但是学习 <code>linux</code> 之后就懂了 ~ 保存退出的意思 ~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase -i HEAD^^</span><br><span class="line">Stopped at 528eb23...  feature1 第二次提交</span><br><span class="line">You can amend the commit now, with</span><br><span class="line"></span><br><span class="line">  git commit --amend</span><br><span class="line"></span><br><span class="line">Once you are satisfied with your changes, run</span><br><span class="line"></span><br><span class="line">  git rebase --continue</span><br></pre></td></tr></table></figure><p>上图的提示信息说明，<code>rebase</code> 过程已经停在了第二个 <code>commit</code> 的位置，那么现在可以去修改想修改的内容了。</p><p>修改完成之后，用 <code>commit --amend</code> 来把修正应用到当前最新的 <code>commit</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit --amend</span><br></pre></td></tr></table></figure><p>在修复完成之后，就可以用 <code>rebase --continue</code> 来继续 <code>rebase</code> 过程，把后面的 <code>commit</code> 直接应用上去。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase --continue</span><br></pre></td></tr></table></figure><p>这里可能出现冲突，解决办法之前讲过 ~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ git log --oneline</span><br><span class="line">2d77504 (HEAD -&gt; master) feature2 第二次提交</span><br><span class="line">82d685f feature2 第一次提交</span><br><span class="line">5729656 feature1 第二次提交</span><br><span class="line">d4faecf feature1 第一次提交</span><br><span class="line"></span><br><span class="line">$ git log --oneline --graph --all</span><br><span class="line">* 2d77504 (HEAD -&gt; master) feature2 第二次提交</span><br><span class="line">* 82d685f feature2 第一次提交</span><br><span class="line">* 5729656 feature1 第二次提交</span><br><span class="line">| * 2b21ec9 (feature2) feature2 第二次提交</span><br><span class="line">| * 2fb7de8 feature2 第一次提交</span><br><span class="line">| | * 528eb23 (feature1) feature1 第二次提交</span><br><span class="line">| |&#x2F;</span><br><span class="line">|&#x2F;|</span><br><span class="line">* | d4faecf feature1 第一次提交</span><br><span class="line">|&#x2F;</span><br><span class="line">* 9001713 (origin&#x2F;master, origin&#x2F;feature2, origin&#x2F;feature1, origin&#x2F;HEAD) 第二次添加</span><br></pre></td></tr></table></figure><p>再次查看，<code>log</code> 发现后三个 <code>commit</code> 的 <code>SHA-1</code> 值都变了，说明是新的 <code>commit</code> 。查看图表会更明确一点，之前的 <code>commit</code> 都还在但是 <code>merge</code> 的那个 <code>commit</code> 不见了，子分支的 <code>commit</code> 的内容，都在主分支都复制了一份，说明使用 <code>rebase -i</code> 不仅可以执行我们制定的操作，还会重新组织历史记录合并在一条主线上，然后清理无用的 <code>commit</code> 。</p><h4 id="删除之前的-commit"><a href="#删除之前的-commit" class="headerlink" title="删除之前的 commit"></a>删除之前的 <code>commit</code></h4><p>和修改的炒作类似，只是在编辑的时候删除我们需要删除的那个 <code>commit</code> 即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pick 528eb23 feature1 第二次提交</span><br><span class="line">pick 2fb7de8 feature2 第一次提交</span><br><span class="line">pick 2b21ec9 feature2 第二次提交</span><br></pre></td></tr></table></figure><p>删掉 <code>feature1 第二次提交</code>，或者将 <code>pick</code> 改为 <code>drop</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pick 2fb7de8 feature2 第一次提交</span><br><span class="line">pick 2b21ec9 feature2 第二次提交</span><br></pre></td></tr></table></figure><p>如果把这一行删掉，那就相当于在 <code>rebase</code> 的过程中跳过了这个 <code>commit</code>，从而也就把这个 <code>commit</code> 撤销掉了。</p><p>那这两种操作有什么不同呢？ <code>emmm….</code> 表面上也没啥区别，具体实质性的却别就不清楚了 ~<br><a href="https://stackoverflow.com/questions/35846154/git-rebase-interactive-drop-vs-deleting-the-commit-line" target="_blank" rel="noopener">Git rebase interactive drop vs deleting the commit line</a></p><p>剩下的操作和上面一样。</p><h3 id="5-rebase-–onto"><a href="#5-rebase-–onto" class="headerlink" title="5. rebase –onto"></a>5. <code>rebase –onto</code></h3><p>我们之前讲过 <code>git rebase master</code> ，<code>rebase</code> 的「起点」是自动判定的：选取当前 <code>commit</code>  和目标 <code>commit</code> 在历史上的交叉点作为起点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">                      master</span><br><span class="line">                        ↓</span><br><span class="line">1   →   2   →   3   →   4      </span><br><span class="line">          ↘</span><br><span class="line">             ↘</span><br><span class="line">                5   →   6</span><br><span class="line">                        ↑</span><br><span class="line">                    HEAD&#x2F;feature2</span><br></pre></td></tr></table></figure><p>比如这里执行  <code>git rebase master</code> ，那么 <code>Git</code> 会自动选取 <code>4</code> 和 <code>6</code> 的历史交叉点 <code>2</code> 作为 <code>rebase</code> 的起点，依次将 <code>5</code> 和 <code>6</code> 重新提交到 <code>4</code> 的路径上去。</p><p>而 <code>--onto</code> 参数，就可以额外给 <code>rebase</code> 指定它的起点。例如同样以上图为例，如果我只想把 <code>6</code> 提交到 <code>4</code> 上，不想附带上 <code>5</code>，那么我可以执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase --onto 4(commit) 5(commit) feature2</span><br></pre></td></tr></table></figure><p><code>--onto</code> 参数后面有三个附加参数：目标 <code>commit</code>、起点 <code>commit</code>（注意：<code>rebase</code> 的时候会把起点排除在外）、终点 <code>commit</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">                      master HEAD&#x2F;feature2</span><br><span class="line">                        ↓       ↓</span><br><span class="line">1   →   2   →   3   →   4   →   7(6的内容)</span><br><span class="line">          ↘</span><br><span class="line">             ↘</span><br><span class="line">                5   →   6</span><br></pre></td></tr></table></figure><p>还可以撤销提交：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git log --oneline --graph --all</span><br><span class="line">* 0b6cb82 (HEAD -&gt; feature2) add</span><br><span class="line">* b8b5146 add new File</span><br><span class="line">* 8b2c2f7 new File</span><br><span class="line">* e657879 rebase</span><br><span class="line">* 99854db feature</span><br></pre></td></tr></table></figure><p>这是生成的一点测试记录，执行下面的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase --onto HEAD^^^ HEAD^ feature2</span><br></pre></td></tr></table></figure><p>上面的意思为，以倒数第二个 <code>commit</code> 为起点（不包括起点），<code>feature2</code> 指向的 <code>commit</code> 为终点，<code>rebase</code> 到倒数第四个 <code>commit</code> 上， 结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git log --oneline --graph --all</span><br><span class="line">* 3a10357 (HEAD -&gt; feature2) add</span><br><span class="line">* e657879 rebase</span><br><span class="line">* 99854db feature</span><br></pre></td></tr></table></figure><p><code>HEAD^^^</code> 目标 <code>commit</code> 之后的 <code>commit</code> 都会被清除掉，起点（<code>HEAD^</code>） 到 终点（<code>feature2</code>） 之间的 <code>commit</code> （不包括 起点<code>HEAD^</code> 本身），会提前复制出一份生成新的 <code>commit</code>，最后连接到目标 <code>commit</code> 后面。<br>相当于 目标（<code>HEAD^^^</code>） 到 起点（<code>HEAD^</code>） 之间的 <code>commit</code> 都会被删除，不包括目标 <code>commit</code> ，包括起点 <code>commit</code> 。</p><h2 id="九-reset（重置）"><a href="#九-reset（重置）" class="headerlink" title="九 reset（重置）"></a>九 reset（重置）</h2><p><code>reset</code> 的本质：移动 <code>HEAD</code> 以及它所指向的 <code>branch</code></p><p>这样就可以起到撤销某个 <code>commit</code> 的作用 ，不是删除，只要记下 <code>SHA-1</code> 还可以再撤回来 ~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br></pre></td></tr></table></figure><p>偏移符号之前讲过，如果移动后想回往回移动，但是已经没有了 <code>SHA-1</code>，可以使用 <code>git reflog</code> 来查看操作记录。</p><blockquote><p>Git 的历史只能往回看，不能向未来看，所以把 <code>HEAD</code> 和 <code>branch</code> 往回移动，就能起到撤回 <code>commit</code> 的效果。</p></blockquote><p>所以同理，<code>reset --hard</code> 不仅可以撤销提交，还可以用来把 <code>HEAD</code> 和 <code>branch</code> 移动到其他的任何地方。</p><h3 id="reset-–hard：重置工作目录"><a href="#reset-–hard：重置工作目录" class="headerlink" title="reset –hard：重置工作目录"></a>reset –hard：重置工作目录</h3><p><code>reset --hard</code> 会在重置 <code>HEAD</code> 和 <code>branch</code> 的同时，重置工作目录里的内容。当你在 <code>reset</code> 后面加了 <code>--hard</code> 参数时，你的工作目录里的内容会被完全重置为和 <code>HEAD</code> 的新位置相同的内容。换句话说，就是<strong>未提交（<code>commit</code>）的修改会被全部擦除，不管它们是否被放进暂存区。添加到暂存区的新增也会被擦除，但是没有添加到缓存区的新增不会！</strong> </p><p><code>modifiedFile.txt</code> 和 <code>addModifiedFile.txt</code> 是当前 <code>commit</code> 新增的（证明已经 <code>commit</code> 上去了），<br>然后修改 <code>addModifiedFile.txt</code> 文件并添加缓存区，然后修改 <code>modifiedFile.txt</code> 文件，不添加到缓存区。这里表示<strong>修改操作</strong>添加暂存区和不添加暂存区的情况。<br>添加 <code>newFile.txt</code> 和 <code>addNewFile.txt</code> 并把   <code>addNewFile.txt</code> 添加到缓存区。这里表示<strong>新增操作</strong>添加暂存区和不添加暂存区的情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch feature2</span><br><span class="line">Your branch and &#39;origin&#x2F;feature2&#39; have diverged,</span><br><span class="line">and have 1 and 2 different commits each, respectively.</span><br><span class="line">  (use &quot;git pull&quot; to merge the remote branch into yours)</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">        new file:   addNewFile.txt</span><br><span class="line">        modified:   addModifiedFile.txt</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">        modified:   modifiedFile.txt</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line"></span><br><span class="line">        newFile.txt</span><br></pre></td></tr></table></figure><p>然后执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br></pre></td></tr></table></figure><p>工作目录里的新改动也一起全都消失了，不管它们是否被放进暂存区<br>只有没有添加到缓冲区新创建的文件，不会清除，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch feature2</span><br><span class="line">Your branch is behind &#39;origin&#x2F;feature2&#39; by 2 commits, and can be fast-forwarded.</span><br><span class="line">  (use &quot;git pull&quot; to update your local branch)</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line"></span><br><span class="line">        newFile.txt</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br></pre></td></tr></table></figure><p>只留下了<strong>新创建的并且没有添加缓存区</strong>的 <code>addHard</code> 文件。其他的修改和添加都被清除了。</p><h3 id="reset-–soft：保留工作目录"><a href="#reset-–soft：保留工作目录" class="headerlink" title="reset –soft：保留工作目录"></a>reset –soft：保留工作目录</h3><p><code>reset --soft</code> 会在重置 <code>HEAD</code> 和 <code>branch</code> 时，保留工作目录和暂存区中的内容，<strong>并把重置 <code>HEAD</code> 所带来的新的差异</strong>放进暂存区。</p><p>「重置 <code>HEAD</code> 所带来的新的差异」 就是当前 <code>HEAD</code> 与 <code>reset</code> 目标之间的 <code>commit</code> 提交的文件。</p><p>初始文件状态和上面一样。</p><p>执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --soft HEAD^</span><br></pre></td></tr></table></figure><p>重点观看 <code>hard.txt</code> 和 <code>reset.txt</code> ，它俩被重新添加到暂存区，并且标记 <code>new file</code> 。这两个文件就是两个 <code>commit</code> 的差异。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch feature2</span><br><span class="line">Your branch is behind &#39;origin&#x2F;feature2&#39; by 2 commits, and can be fast-forwarded.</span><br><span class="line">  (use &quot;git pull&quot; to update your local branch)</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">        new file:   addModifiedFile.txt</span><br><span class="line">        new file:   addNewFile.txt</span><br><span class="line">        new file:   modifiedFile.txt</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">        modified:   modifiedFile.txt</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line"></span><br><span class="line">        newFile.txt</span><br></pre></td></tr></table></figure><p>这就是 <code>--soft</code> 和 <code>--hard</code> 的区别：<code>--hard</code> 会清空暂存目录的改动和新增，以及工作目录的改动，而 <code>--soft</code> 则会保留工作目录的内容，并把因为保留工作目录内容所带来的新的文件差异放进暂存区。</p><h3 id="reset-不加参数：保留工作目录，并清空暂存区（–mixed）"><a href="#reset-不加参数：保留工作目录，并清空暂存区（–mixed）" class="headerlink" title="reset 不加参数：保留工作目录，并清空暂存区（–mixed）"></a>reset 不加参数：保留工作目录，并清空暂存区（–mixed）</h3><p><code>reset</code> 如果不加参数，那么默认使用 <code>--mixed</code> 参数。它的行为是：保留工作目录，并且清空暂存区。</p><p>初始文件状态和上面一样。</p><p>执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD^</span><br></pre></td></tr></table></figure><p>将差异文件、暂存目录的文件、工作目录的文件都保存了下来，但是都放在了工作目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch feature2</span><br><span class="line">Your branch is behind &#39;origin&#x2F;feature2&#39; by 2 commits, and can be fast-forwarded.</span><br><span class="line">  (use &quot;git pull&quot; to update your local branch)</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line"></span><br><span class="line">        addModifiedFile.txt</span><br><span class="line">        addNewFile.txt</span><br><span class="line">        modifiedFile.txt</span><br><span class="line">        newFile.txt</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br></pre></td></tr></table></figure><h2 id="十-stash（临时存储）"><a href="#十-stash（临时存储）" class="headerlink" title="十 stash（临时存储）"></a>十 stash（临时存储）</h2><p><code>&quot;stash&quot;</code> 这个词，和它意思比较接近的中文翻译是「藏匿」，是「把东西放在一个秘密的地方以备未来使用」的意思。</p><p>在 <code>Git</code> 中，<code>stash</code> 指令可以帮你把工作目录的内容全部放在你本地的一个独立的地方，它不会被提交，也不会被删除，你把东西放起来之后就可以去做你的临时工作了，做完以后再来取走，就可以继续之前手头的事了。</p><p>具体说来，<code>stash</code> 的用法很简单。当你手头有一件临时工作要做，需要把工作目录暂时清理干净，那么可以：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure><p>现在工作目录的改动就被清空了，所有改动都被存了起来。</p><p>当手头工作做完后，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash pop</span><br></pre></td></tr></table></figure><p>之前的代码又回来了！</p><blockquote><p>注意：没有被 <code>track</code> 的文件（即从来没有被 add 过的文件不会被 stash 起来，因为 Git 会忽略它们。如果想把这些文件也一起 stash，可以加上 <code>-u</code> 参数，它是 <code>--include-untracked</code> 的简写。就像这样：</p></blockquote><h2 id="十一-tag（引用）"><a href="#十一-tag（引用）" class="headerlink" title="十一 tag（引用）"></a>十一 tag（引用）</h2><h3 id="添加-Tag"><a href="#添加-Tag" class="headerlink" title="添加 Tag"></a>添加 Tag</h3><p><code>tag</code> 是一个和 <code>branch</code> 非常相似的概念，它和 <code>branch</code> 最大的区别是：<code>tag</code> 不能移动。所以在很多团队中，<code>tag</code> 被用来在关键版本处打标记用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -a v1.1 -m &quot;my Tag 1.1&quot;</span><br></pre></td></tr></table></figure><p>这是在当前 <code>commit</code> 创建一个 名为 <code>v1.1</code> 的标签。<code>-m</code> 选项指定了一条将会存储在标签中的信息。 如果没有为附注标签指定一条信息，Git 会启动编辑器要求你输入信息。</p><p>如何给之前的 <code>commit</code> 添加 <code>tag</code> 呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -a v1.0 81bb698 -m &quot;my Tag 1.0&quot;</span><br></pre></td></tr></table></figure><p>只需要在标签名后面加入 <code>commit</code> 的 <code>SHA-1</code> 校验和 。</p><h3 id="查看-Tag"><a href="#查看-Tag" class="headerlink" title="查看 Tag"></a>查看 Tag</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git log --oneline</span><br><span class="line">347cd98 (HEAD -&gt; master, tag: v1.1, origin&#x2F;master, origin&#x2F;HEAD) head</span><br><span class="line">81bb698 (tag: v1.0) c</span><br></pre></td></tr></table></figure><p>也可以使用如下只查看标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git tag</span><br><span class="line">v1.0</span><br><span class="line">v1.1</span><br></pre></td></tr></table></figure><p>通过使用 <code>git show</code> 命令可以看到标签信息和与之对应的提交信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ git show v1.1</span><br><span class="line">tag v1.1</span><br><span class="line">Tagger: companyPc &lt;lvyanv@163.com&gt;</span><br><span class="line">Date:   Fri Oct 9 10:59:57 2020 +0800</span><br><span class="line"></span><br><span class="line">my Tag 1.1</span><br><span class="line"></span><br><span class="line">commit 347cd9856e1edf4c0a96cb15bad227ab8d255cda (HEAD -&gt; master, tag: v1.1, origin&#x2F;master, origin&#x2F;HEAD)</span><br><span class="line">Author: companyPc &lt;lvyanv@163.com&gt;</span><br><span class="line">Date:   Tue Sep 29 18:27:18 2020 +0800</span><br><span class="line"></span><br><span class="line">    head</span><br><span class="line"></span><br><span class="line">diff --git a&#x2F;branch1.txt b&#x2F;branch1.txt</span><br><span class="line">index b3a843b..b9176c0 100644</span><br><span class="line">--- a&#x2F;branch1.txt</span><br><span class="line">+++ b&#x2F;branch1.txt</span><br><span class="line">@@ -4,7 +4,7 @@</span><br><span class="line"> 11</span><br><span class="line"> 11</span><br><span class="line"> 11</span><br><span class="line">-</span><br><span class="line">+22</span><br></pre></td></tr></table></figure><p>输出显示了打标签者的信息、打标签的日期时间、附注信息，然后显示具体的提交信息。</p><h3 id="删除-Tag"><a href="#删除-Tag" class="headerlink" title="删除 Tag"></a>删除 Tag</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -d v1.0</span><br><span class="line">Deleted tag &#39;v1.0&#39; (was a390a5f)</span><br></pre></td></tr></table></figure><p>注意上述命令并不会从任何远程仓库中移除这个标签，通过如下命令可以更新远程分支情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin : refs&#x2F;tags&#x2F;v1.0</span><br></pre></td></tr></table></figure><p>第二种更直观的删除远程标签的方式是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin --delete v1.0</span><br></pre></td></tr></table></figure><h3 id="检出标签"><a href="#检出标签" class="headerlink" title="检出标签"></a>检出标签</h3><p><code>tag</code> 创建后，就相当于一个应用，可以同个 <code>checkout</code> 检出到当前标签的位置 ~ </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout v1.0</span><br><span class="line">Note: checking out &#39;v1.0&#39;.</span><br><span class="line"></span><br><span class="line">You are in &#39;detached HEAD&#39; state. You can look around, make experimental</span><br><span class="line">changes and commit them, and you can discard any commits you make in this</span><br><span class="line">state without impacting any branches by performing another checkout.</span><br><span class="line"></span><br><span class="line">If you want to create a new branch to retain commits you create, you may</span><br><span class="line">do so (now or later) by using -b with the checkout command again. Example:</span><br><span class="line"></span><br><span class="line">  git checkout -b &lt;new-branch-name&gt;</span><br><span class="line"></span><br><span class="line">HEAD is now at 81bb698 c</span><br></pre></td></tr></table></figure><h2 id="十二-Gitflow-工作流"><a href="#十二-Gitflow-工作流" class="headerlink" title="十二 Gitflow 工作流"></a>十二 Gitflow 工作流</h2><p><code>Git-flow</code> 是 <code>Git</code> 的包装器</p><h3 id="Develop-和-Master-分支"><a href="#Develop-和-Master-分支" class="headerlink" title="Develop 和 Master 分支"></a><code>Develop</code> 和 <code>Master</code> 分支</h3><p><strong>master</strong></p><ul><li>主分支 , 产品的功能全部实现后 , 最终在 <code>master</code> 分支对外发布</li><li>该分支为只读唯一分支 , 只能从其他分支 <code>(release/hotfix)</code> 合并 , 不能在此分支修改</li><li>另外所有在 <code>master</code> 分支的推送应该<strong>打标签做记录</strong>,方便追溯</li><li>例如 <code>release</code> 合并到 <code>master</code> , 或 <code>hotfix</code> 合并到 <code>master</code></li></ul><p><strong>develop</strong></p><ul><li>主开发分支 , 基于 <code>master</code> 分支克隆</li><li>包含所有要发布到下一个 <code>release</code> 的代码</li><li>该分支为只读唯一分支 , 只能从其他分支合并</li><li><code>feature</code> 功能分支完成 , 合并到 <code>develop</code> (不推送)</li><li><code>develop</code> 拉取 <code>release</code> 分支 , 提测</li><li><code>release/hotfix</code> 分支上线完毕 , 合并到 <code>develop</code> 并推送</li></ul><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/git/git_flow_1.svg" alt="图片来源于文末链接中的 Gitflow"></p><p>这个工作流使用两个分支来记录项目的历史，而不是单一的 <code>master</code>。 <code>master</code> 存储官方发布历史记录，而 <code>develop</code> 分支充当功能的集成分支。用版本号标记 <code>master</code> 中的所有提交也很方便。</p><p>第一步是用一个 <code>develop</code> 分支来补充默认的 <code>master</code> 。一个简单的方法是一个开发人员在本地创建一个空的 <code>develop</code> 分支，并将其推到服务器:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch develop </span><br><span class="line">git push -u origin develop</span><br></pre></td></tr></table></figure><p>该分支将包含项目的完整历史记录，而<code>master</code>将包含简化版本。现在，其他开发人员现在应该 <code>clone</code> 中央存储库，并为 <code>develop</code> 创建 <code>tracking</code> 分支。</p><p>当使用 <code>git-flow</code> 扩展库时，在已有的 <code>repo</code> 上执行 <code>git flow init</code> 将创建开发分支:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ git flow init</span><br><span class="line"></span><br><span class="line">Which branch should be used for bringing forth production releases?</span><br><span class="line">   - develop</span><br><span class="line">   - master</span><br><span class="line">Branch name for production releases: [master]</span><br><span class="line"></span><br><span class="line">Which branch should be used for integration of the &quot;next release&quot;?</span><br><span class="line">   - develop</span><br><span class="line">Branch name for &quot;next release&quot; development: [develop]</span><br><span class="line"></span><br><span class="line">How to name your supporting branch prefixes?</span><br><span class="line">Feature branches? [] feature&#x2F;</span><br><span class="line">Bugfix branches? [] bugfix&#x2F;</span><br><span class="line">Release branches? [] release&#x2F;</span><br><span class="line">Hotfix branches? [] hotfix&#x2F;</span><br><span class="line">Support branches? [] support&#x2F;</span><br><span class="line">Version tag prefix? [] version&#x2F;</span><br><span class="line">Hooks and filters directory? [C:&#x2F;Users&#x2F;Beepay&#x2F;Desktop&#x2F;新建文件夹&#x2F;ui-starge&#x2F;.git&#x2F;hooks]</span><br></pre></td></tr></table></figure><p><code>git flow init</code> 命令是缺省 <code>git init</code> 命令的扩展，除了为您创建分支外，它不会更改存储库中的任何内容。</p><p>设置前缀的时候加上 <code>/</code> 相当于分组了。试一试下面的过程就知道啦。</p><p>如果使用 <code>Sourcetree</code> ，也可以点击工具中右上角 <code>Git 工作流</code> 切换到 <code>git flow</code> 工作流。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/git/git_flow_1_1.png" alt=""></p><p>之后的操作就是弹框中的，之后就不一一列出 <code>Sourcetree</code> 的操作了。</p><h3 id="Feature-功能-分支"><a href="#Feature-功能-分支" class="headerlink" title="Feature(功能) 分支"></a><code>Feature</code>(功能) 分支</h3><p><strong>feature</strong></p><ul><li>功能开发分支 , 基于 <code>develop</code> 分支克隆 , 主要用于新需求新功能的开发</li><li>功能开发完毕后合到 <code>develop</code> 分支(未正式上线之前不推送到远程中央仓库!!!)</li><li><code>feature</code> 分支可同时存在多个 , 用于团队中多个功能同时开发 , 属于临时分支 , 功能完成后可选删除</li></ul><p>每一个新功能的开发都应该各自使用独立的分支，可以推送到中央存储库进行备份/协作。但是，<code>feature</code> 分支使用 <code>develop</code> 作为它们的父分支，而不是 <code>master</code> 分支。当一个 功能 完成时，它会被合并回到 <code>feature</code> 中。<strong><code>feature</code> 不应该直接与 <code>master</code> 交互。</strong></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/git/git_flow_2.svg" alt="图片来源于文末链接中的 Gitflow"></p><p><strong>注意</strong>：组合使用 <code>feature</code> 分支和 <code>develop</code> 分支的这种设计，其实完全就是 <code>Feature Branch Workflow</code>的理念。然而，<code>Gitflow</code> 流程并不止于此。且看下文分解。</p><p><strong>创建一个工作分支：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout develop </span><br><span class="line">git checkout -b feature_branch</span><br></pre></td></tr></table></figure><p>使用 <code>git-flow</code> 扩展时：(这里注意 <code>init</code> 时的前缀加 <code>/</code> )</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git flow feature start feature_branch</span><br></pre></td></tr></table></figure><p>执行这个命令不需要切换分支，会自动已本地 <code>develop</code> 最新 <code>commit</code> 为基点， 之后像往常一样使用继续 <code>Git</code> 就可以。</p><p><strong>完成/合并 一个工作分支：</strong></p><p>（执行之前记得 <code>add</code> 以及 <code>commit</code> 更新的内容）当完成了 <code>feature</code> 的开发工作后，下一步是将 <code>feature_branch</code> 合并到 <code>develop</code> 中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout develop </span><br><span class="line">git merge feature_branch</span><br><span class="line">git branch -d feature_branch</span><br></pre></td></tr></table></figure><p>使用 <code>git-flow</code> 扩展时：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git flow feature finish feature_branch</span><br></pre></td></tr></table></figure><h3 id="Release-分支"><a href="#Release-分支" class="headerlink" title="Release 分支"></a><code>Release</code> 分支</h3><p><strong>release</strong></p><ul><li>测试分支 , 基于 <code>feature</code> 分支合并到 <code>develop</code> 之后  , 从 <code>develop</code> 分支克隆</li><li>主要用于提交给测试人员进行功能测试 , 测试过程中发现的 <code>BUG</code> 在本分支进行修复 , 修复完成上线后合并到 <code>develop/master</code> 分支并推送(完成功能) , 打<code>Tag</code> </li><li>属于临时分支 , 功能上线后可选删除</li></ul><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/git/git_flow_3.svg" alt="图片来源于文末链接中的 Gitflow"></p><p>一旦 <code>develop</code> 分支积聚了足够多的新功能（或者预定的发布日期临近了），你可以基于 <code>develop</code> 分支建立一个用于产品发布的分支。这个分支的创建意味着一个发布周期的开始，也意味着本次发布不会再增加新的功能，在这个分支上只能修复 <code>bug</code> ，做一些文档工作或者跟发布相关的任务。在一切准备就绪的时候，这个分支会被合并入 <code>master</code> ，并且用版本号打上 <code>tag</code>。<br>另外，<code>release</code> 分支上的改动还应该合并入 <code>develop</code> 分支，在发布周期内，<code>develop</code> 分支仍然在被使用（一些开发者会把其他功能集成到 <code>develop</code> 分支）。</p><p>使用专门的一个分支来为发布做准备的好处是，在一个团队忙于当前的发布的同时，另一个团队可以继续为接下来的一次发布开发新功能。</p><p><strong>创建 <code>release</code> 分支</strong>是另一个简单的分支操作。与 <code>feature</code> 分支一样，<code>release</code> 分支也基于 <code>develop</code> 分支。可以使用以下方法创建一个新的 <code>release</code> 分支。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout develop </span><br><span class="line">git checkout -b release&#x2F;0.1.0</span><br></pre></td></tr></table></figure><p>使用 <code>git-flow</code> 扩展时：(这里注意 <code>init</code> 时的前缀加 <code>/</code> )</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git flow release start 0.1.0</span><br></pre></td></tr></table></figure><p><strong>要 完成/合并 一个发布分支</strong>（执行之前记得 <code>add</code> 以及 <code>commit</code> 更新的内容），使用以下方法: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git checkout master </span><br><span class="line">git merge release&#x2F;0.1.0</span><br><span class="line">git checkout develop </span><br><span class="line">git merge release&#x2F;0.1.0</span><br><span class="line">git branch -d release&#x2F;0.1.0</span><br></pre></td></tr></table></figure><p>使用 <code>git-flow</code> 扩展时：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git flow release finish &#39;0.1.0&#39; -m &quot;my version 0.1.0&quot;</span><br></pre></td></tr></table></figure><p>这里可以不写 <code>-m</code> ，但是在合并 <code>develop</code> 的时候弹出的编辑页面需要再次写入提交信息，否者会导致提交失败。如果写了 <code>-m</code> 只需要两次 <code>:wq</code> 即可。</p><h3 id="Hotfix-分支"><a href="#Hotfix-分支" class="headerlink" title="Hotfix 分支"></a><code>Hotfix</code> 分支</h3><p><strong>hotfix</strong></p><ul><li>补丁分支 , 基于 <code>master</code> 分支克隆 , 主要用于对线上的版本进行 <code>BUG</code> 修复</li><li>修复完毕后合并到 <code>develop/master</code> 分支并推送 , 打 <code>Tag</code> </li><li>属于临时分支 , 补丁修复上线后可选删除</li><li>所有 <code>hotfix</code> 分支的修改会进入到下一个 <code>release</code> </li></ul><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/git/git_flow_4.svg" alt="图片来源于文末链接中的 Gitflow"></p><p><code>hotfix</code> 分支用于快速对生产版本进行补丁。<code>hotfix</code> 分支很像 <code>release</code> 分支和 <code>feature</code> 分支，除了 <code>hotfix</code> 是基于 <code>master</code> 分支而不是 <code>develop</code>。这是唯一一个从主分支 <code>fork</code> 的。一旦修复完成，它应该被合并到 <code>master</code> 和 <code>develop</code> (或者当前的 <code>release</code> 分支)中，并且 <code>master</code> 应该被标记为一个更新的版本号。</p><p>拥有专门的 <code>bug</code> 修复开发线可以让团队解决问题同时，并且不会中断其余的工作流程或等待下一个发布周期。</p><p>可以将维护分支视为直接与 <code>master</code>一起工作的临时 <code>release</code> 分支。</p><p><strong>创建 <code>hotifx</code> 分支</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout master </span><br><span class="line">git checkout -b hotfix_branch</span><br></pre></td></tr></table></figure><p>使用 <code>git-flow</code> 扩展时：(这里注意 <code>init</code> 时的前缀加 <code>/</code> )</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git flow hotfix start hotfix_branch</span><br></pre></td></tr></table></figure><p><strong>完成/合并 一个 <code>hotfix</code> 分支</strong>（执行之前记得 <code>add</code> 以及 <code>commit</code> 更新的内容）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git checkout master </span><br><span class="line">git merge hotfix_branch </span><br><span class="line">git checkout develop </span><br><span class="line">git merge hotfix_branch </span><br><span class="line">git branch -d hotfix_branch</span><br></pre></td></tr></table></figure><p>使用 <code>git-flow</code> 扩展时：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git flow hotfix finish hotfix_branch  -m &quot;my hotfix commit&quot;</span><br></pre></td></tr></table></figure><p>这里可以不写 <code>-m</code> ，但是在合并 <code>develop</code> 的时候弹出的编辑页面需要再次写入提交信息，否者会导致提交失败。如果写了 <code>-m</code> 只需要两次 <code>:wq</code> 即可。</p><p><code>Gitflow</code> 的总体流程为：</p><ol><li>从<code>master</code> 创建一个 <code>develop</code>分支</li><li><code>release</code>从 <code>develop</code>  分支创建</li><li><code>feature</code> 从 <code>develop</code> 分支创建</li><li>当<code>feature</code>完成后，会合并到<code>develop</code> 分支</li><li>当<code>release</code>分支完成后，会合并到<code>develop</code>和<code>master</code></li><li>如果<code>master</code>检测到问题，则从 <code>master</code> 创建 <code>hotfix</code> 程序分支</li><li><code>hotfix</code>完成后，会被合并到两个<code>develop</code>及<code>master</code></li></ol><p><strong>感谢：</strong></p><p><a href="https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow" target="_blank" rel="noopener">Gitflow</a></p><p><a href="https://git-scm.com/book/zh/v2" target="_blank" rel="noopener">Git</a></p><p> <a href="https://segmentfault.com/a/1190000022506884" target="_blank" rel="noopener">git HEAD / HEAD^ / HEAD~ 的含义</a></p><p> <a href="https://www.cnblogs.com/kidsitcn/p/5339382.html" target="_blank" rel="noopener">git rebase vs git merge详解</a></p><p><a href="https://juejin.im/book/6844733697996881928/" target="_blank" rel="noopener">Git 原理详解及实用指南</a></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-结构型-桥接模式</title>
      <link href="/2020/design-pattern-bridge.html"/>
      <url>/2020/design-pattern-bridge.html</url>
      
        <content type="html"><![CDATA[<p><code>GoF</code> 的《设计模式》 中，桥接模式是这么定义的：<code>Decouple an abstraction from its implementation so that the two can vary independently。(将抽象和实现解耦，让它们可以独立变化。)</code> </p><p>其他资料的解释：<code>一个类存在两个（或多个）独立变化的维度，我们通过组合的方式，让这两个（或多个）维度可以独立进行扩展。</code> 通过组合关系来替代继承关系，避免继承层次的指数级爆炸。这种理解方式非常类似于，我们之前讲过的“组合优于继承”设计原则。</p><h1 id="1-桥接模式举例"><a href="#1-桥接模式举例" class="headerlink" title="1 桥接模式举例"></a>1 桥接模式举例</h1><p>举个栗子🌰 </p><p>我们点咖啡的时候，可以选小杯，大杯，可以加糖，或原味。那用设计模式怎么灵活装配这些需求呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Coffee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> CoffeeAdditives impl;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Coffee</span><span class="params">(CoffeeAdditives impl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.impl = impl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 咖啡具体是什么样子由子类决定</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">makeCoffee</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LatgeCoffee</span> <span class="keyword">extends</span> <span class="title">Coffee</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LatgeCoffee</span><span class="params">(CoffeeAdditives impl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(impl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeCoffee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"大杯的"</span> + impl + <span class="string">"咖啡"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmallCoffee</span> <span class="keyword">extends</span> <span class="title">Coffee</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SmallCoffee</span><span class="params">(CoffeeAdditives impl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(impl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeCoffee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"小杯的"</span> + impl + <span class="string">"咖啡"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Coffee</code> 类中保持了对 <code>CoffeeAdditives</code> 的引用，以便调用具体的实现。同样的，咖啡还分大杯小杯，定义两个子类继承于 <code>Coffee</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CoffeeAdditives</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 具体要往咖啡里添加什么由子类实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">addSomething</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sugar</span> <span class="keyword">extends</span> <span class="title">CoffeeAdditives</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"加糖"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ordinary</span> <span class="keyword">extends</span> <span class="title">CoffeeAdditives</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"原味"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>CoffeeAdditives</code> 其实实现部分，而 <code>Coffee</code> 则对应于抽象部分，模式定义中所谓的 “抽象” 与 “实现” 实质上对应的是两个独立变化的维度，因此，任何多维度变化类或者说多个树状类之间的耦合都可以使用桥接模式来实现解耦。</p><p><code>Coffee</code> 类虽是一个抽象类，但它并非是所谓的 “抽象部分” ，而 <code>CoffeeAdditives</code> 类也并非一定就是 “实现部分” ，两者各自为一维度，独立变化，仅此而已，所谓的 “抽象与实现分离” 更偏向于我们实际的程序开发，两者并不一定挂钩，这里其实就可以看到桥接模式的应用性其实很广泛，并不局限于程序设计。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Ordinary implOrdinary = <span class="keyword">new</span> Ordinary();</span><br><span class="line">Sugar implSugar = <span class="keyword">new</span> Sugar();</span><br><span class="line"></span><br><span class="line"><span class="comment">//大杯原味</span></span><br><span class="line">LatgeCoffee latgeCoffeeOrdinary = <span class="keyword">new</span> LatgeCoffee(implOrdinary);</span><br><span class="line">latgeCoffeeOrdinary.makeCoffee();</span><br><span class="line"></span><br><span class="line"><span class="comment">//小杯原味</span></span><br><span class="line">SmallCoffee smallCoffeeOrdinary = <span class="keyword">new</span> SmallCoffee(implOrdinary);</span><br><span class="line">smallCoffeeOrdinary.makeCoffee();</span><br><span class="line"></span><br><span class="line"><span class="comment">//大杯加糖</span></span><br><span class="line">LatgeCoffee latgeCoffeeSugar = <span class="keyword">new</span> LatgeCoffee(implSugar);</span><br><span class="line">latgeCoffeeSugar.makeCoffee();</span><br><span class="line"></span><br><span class="line"><span class="comment">//小杯加糖</span></span><br><span class="line">SmallCoffee smallCoffeeSugar = <span class="keyword">new</span> SmallCoffee(implSugar);</span><br><span class="line">smallCoffeeSugar.makeCoffee();</span><br></pre></td></tr></table></figure><p>这时候如果需要新增 中杯 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MiddleCoffee</span> <span class="keyword">extends</span> <span class="title">Coffee</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MiddleCoffee</span><span class="params">(CoffeeAdditives impl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(impl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeCoffee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"中杯的"</span> + impl + <span class="string">"咖啡"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中杯加糖</span></span><br><span class="line">MiddleCoffee middleCoffeeSugar = <span class="keyword">new</span> MiddleCoffee(implSugar);</span><br><span class="line">middleCoffeeSugar.makeCoffee();</span><br><span class="line"></span><br><span class="line"><span class="comment">//中杯原味</span></span><br><span class="line">MiddleCoffee middleCoffeeOrdinary = <span class="keyword">new</span> MiddleCoffee(implOrdinary);</span><br><span class="line">middleCoffeeOrdinary.makeCoffee();</span><br></pre></td></tr></table></figure><p>我也可以让 <code>CoffeeAdditives</code> 类变化起来，比如加奶、加蜂蜜。不管是 <code>Coffee</code> 变化了还是 <code>CoffeeAdditives</code> 变化了，其相对于对方而言都是独立的没有什么过多的交集，两者之间唯一的联系就是 <code>Coffee</code> 中保持的对 <code>CoffeeAdditives</code> 的引用，此乃两者之纽带，这就是桥接模式。</p><h1 id="2-Android-源码中的桥接模式"><a href="#2-Android-源码中的桥接模式" class="headerlink" title="2 Android 源码中的桥接模式"></a>2 Android 源码中的桥接模式</h1><p>首先是 <code>Adapter</code> 与 <code>AdapterView</code> <a href="https://blog.csdn.net/zhangzeyuaaa/article/details/40151983" target="_blank" rel="noopener">AdapterView 与 Adapter</a> </p><p>这里引用原文两张图片，<code>Adapter</code> 对应抽象部分，<code>Adapter</code>对应实现部分。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/design/bridge_adapter.png" alt="adapter"></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/design/bridge_adapterview.png" alt="adapterView"></p><p>还有是 <code>View</code> 的视图层级中，<code>CheckBox</code>、<code>CompoundButton</code>、<code>Button</code>、<code>TextView</code> 和 <code>View</code> 之间构成一个继承关系的视图层级，每一层视图都仅仅是对一种类型控件的描述，其定义了该类控件所拥有的基本属性和行为，但是将它们真正绘制到屏幕的部分是由与 <code>View</code> 相关的功能实现类 <code>DisplayList</code> 、<code>HardwareLayer</code> 和 <code>Canvas</code> 负责。</p><p>还有就是 <code>Window</code> 和 <code>WindowManager</code></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/design/bridge_window_manager.png" alt="图片来源于 Android 源码设计模式解析与实战"></p><p>在 <code>framework</code> 中 <code>Window</code> 和 <code>PhoneWindow</code> 构成窗口的抽象部分，其中 <code>Window</code> 类为该抽象部分的抽象接口，<code>PhoneWindow</code> 为抽象部分具体的实现及扩展。而 <code>WindowManager</code> 则为实现部分的基类，<code>WindowManagerlmpl</code> 为实现部分具体的逻辑实现，其使用 <code>WindowManagerGlobal</code> 通过 <code>IWindowManager</code>  接口与<code>WindowManagerService</code>（也就是我们常说的 <code>WMS</code> ）进行交互，并由 <code>WMS</code> 完成具体的窗口管理工作，如下为 <code>Window</code> 与 <code>WindowManager</code> 桥梁搭建的主要代码，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Window</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWindowManager</span><span class="params">(WindowManager wm, IBinder appToken, String appName)</span> </span>&#123;</span><br><span class="line">        setWindowManager(wm, appToken, appName, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWindowManager</span><span class="params">(WindowManager wm, IBinder appToken, String appName,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> hardwareAccelerated)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">if</span> (wm == <span class="keyword">null</span>) &#123;</span><br><span class="line">            wm = (WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE);</span><br><span class="line">        &#125;</span><br><span class="line">        mWindowManager = ((WindowManagerImpl)wm).createLocalWindowManager(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以毫不夸张地说，<code>Android</code> 的 <code>framework</code> 层主要就是由它与另外一个系统服务 <code>ActivityManagerService</code>（简称 <code>AMS</code> ）还有 <code>View</code> 所构成，这 <code>3</code> 个模块穿插交互在整个 <code>framework</code> 中，掌握了它们之间的关系以及每一个步骤的逻辑，你对 <code>framework</code> 就至少了解百分之五十了。</p><p><a href="http://gityuan.com/2017/01/08/windowmanger/" target="_blank" rel="noopener">WindowManager启动篇</a></p><h1 id="3-桥接模式-Android-实战"><a href="#3-桥接模式-Android-实战" class="headerlink" title="3 桥接模式 Android 实战"></a>3 桥接模式 Android 实战</h1><p><code>View</code> 的视图层级与执行真正的硬件绘制相关类之间的关系可以看作是一种桥接模式，其实这里也可以模仿这种行为来让我们的自定义控件以桥接的方式提供多种不同的实现机制，逻辑很简单，这里以进度条为例，鉴于进度条的逻辑并不复杂，我们可以自己继承View类来实现进度条控件，这里就以自定义水平、垂直和圆形 <code>3</code> 种不同的进度条为例，为了后期扩展，我们以一个实现类来声明不同进度条需要实现的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseProgressBar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HORIZONTAL = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VERTICAL = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CIRCLE = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Paint mPaint;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法内完成一些具体的初始化信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">BaseProgressBar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mPaint = <span class="keyword">new</span> Paint(Paint.ANTI_ALIAS_FLAG | Paint.DITHER_FLAG);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取测试高度，由具体子类实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getMeasureHeight</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取测试宽度，由具体子类实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getMeasureWidth</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 具体的绘制操作，由子类实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(View view, Canvas canvas)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircleProgressBar</span> <span class="keyword">extends</span> <span class="title">BaseProgressBar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMeasureHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">50</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMeasureWidth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(View view, Canvas canvas)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//具体绘制</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HorizontalProgressBar</span> <span class="keyword">extends</span> <span class="title">BaseProgressBar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMeasureHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">50</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMeasureWidth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(View view, Canvas canvas)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//具体绘制</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VerticalProgressBar</span> <span class="keyword">extends</span> <span class="title">BaseProgressBar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMeasureHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">50</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMeasureWidth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(View view, Canvas canvas)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//具体绘制</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后用一个继承于 <code>View</code> 的进度条来分派绘制逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProgressBar</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HEIGHT = <span class="number">0x6846</span>, WIDTH = <span class="number">0x7889</span>;</span><br><span class="line">    <span class="keyword">private</span> BaseProgressBar mBaseProgressBar;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> style = BaseProgressBar.CIRCLE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProgressBar</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProgressBar</span><span class="params">(Context context, @Nullable AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, attrs, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProgressBar</span><span class="params">(Context context, @Nullable AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.ProgressBar, defStyleAttr, <span class="number">0</span>);</span><br><span class="line">        style = a.getInt(R.styleable.ProgressBar_style, BaseProgressBar.CIRCLE);</span><br><span class="line">        <span class="keyword">if</span> (style == BaseProgressBar.HORIZONTAL) &#123;</span><br><span class="line">            mBaseProgressBar = <span class="keyword">new</span> HorizontalProgressBar();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (style == BaseProgressBar.VERTICAL) &#123;</span><br><span class="line">            mBaseProgressBar = <span class="keyword">new</span> VerticalProgressBar();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mBaseProgressBar = <span class="keyword">new</span> CircleProgressBar();</span><br><span class="line">        &#125;</span><br><span class="line">        a.recycle();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">        setMeasuredDimension(measureDimension(WIDTH, widthMeasureSpec), measureDimension(HEIGHT, heightMeasureSpec));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">measureDimension</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (style == BaseProgressBar.CIRCLE) &#123;</span><br><span class="line">            <span class="keyword">return</span> mBaseProgressBar.getMeasureWidth();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result;</span><br><span class="line">        <span class="keyword">int</span> mode = MeasureSpec.getMode(measureSpec);</span><br><span class="line">        <span class="keyword">int</span> size = MeasureSpec.getSize(measureSpec);</span><br><span class="line">        <span class="keyword">if</span> (mode == MeasureSpec.EXACTLY) &#123;</span><br><span class="line">            result = size;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (type == HEIGHT) &#123;</span><br><span class="line">                result = mBaseProgressBar.getMeasureHeight();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result = mBaseProgressBar.getMeasureWidth();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mode == MeasureSpec.AT_MOST) &#123;</span><br><span class="line">                result = Math.min(result, size);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDraw(canvas);</span><br><span class="line">        mBaseProgressBar.draw(<span class="keyword">this</span>, canvas);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>ProgressBar</code> 类持有 <code>BaseProgressBar</code> 类的引用，通过在不同的绘制阶段调用不同进度条实现类的相应方法完成具体的逻辑。如本文所说，桥接模式的应用其实非常的广泛，除了上面我们提到的控件例子外，在进行数据库 <code>dao</code> 类设计时我们有时也会需要使用到桥接模式。<br>而且对于 <code>Android</code> 来说，应用层与 <code>Native</code> 层之间的交互就是一个最好的例子，在需要操纵 <code>Android</code> 设备硬件时就需要使用一个连接应用层与 <code>Native</code> 的桥梁，这个桥梁通常是一个具体的类，比如提供操作相机的 <code>Camera</code> 、播放音视频的 <code>MediaPlayer</code> 、提供图形绘制接口的 <code>OpenCV</code> 等，这些 <code>API</code> 类为我们操作底层硬件提供了可能。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对于这个模式有两种不同的理解方式。在 <code>GoF</code>  的《设计模式》一书中，桥接模式被定义为：</p><p>“将抽象和实现解耦，让它们可以独立变化。”</p><p>在其他资料和书籍中，还有另外一种更加简单的理解方式：</p><p>“一个类存在两个（或多个）独立变化的维度，我们通过组合的方式，让这两个（或多个）维度可以独立进行扩展。”</p><p>对于第一种 <code>GoF</code> 的理解方式，弄懂定义中 “抽象” 和 “实现” 两个概念，是理解它的关键。</p><p>定义中的 “抽象” ，指的并非 “抽象类” 或 “接口” ，而是被抽象出来的一套 “类库” ，它只包含骨架代码，真正的业务逻辑需要委派给定义中的 “实现” 来完成。而定义中的 “实现” ，也并非 “接口的实现类” ，而是一套独立的 “类库” 。“抽象” 和 “实现” 独立开发，通过对象之间的组合关系，组装在一起。</p><h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a><strong>感谢</strong></h1><blockquote><p><a href="https://time.geekbang.org/column/intro/250?utm_source=pinpaizhuanqu&utm_medium=geektime&utm_campaign=guanwang&utm_term=guanwang&utm_content=0511" target="_blank" rel="noopener">设计模式之美</a></p><p>《Android 源码设计模式解析与实战》</p><p>以及上文中的链接</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-结构型-代理模式</title>
      <link href="/2020/design-pattern-proxy.html"/>
      <url>/2020/design-pattern-proxy.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-静态代理"><a href="#1-静态代理" class="headerlink" title="1 静态代理"></a>1 静态代理</h1><p>在不改变原始类（或叫被代理类）代码的情况下，通过引入代理类来给原始类附加功能。</p><p>举个栗子🌰 监控登录注册接口调用时长。</p><p><code>MetricsCollector</code> 类用来收集接口请求的原始数据，比如访问时间、处理时长等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...省略其他属性和方法...</span></span><br><span class="line">  <span class="keyword">private</span> MetricsCollector metricsCollector; <span class="comment">// 依赖注入</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> UserVo <span class="title">login</span><span class="params">(String telephone, String password)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> startTimestamp = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 省略login逻辑...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> endTimeStamp = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> responseTime = endTimeStamp - startTimestamp;</span><br><span class="line">    RequestInfo requestInfo = <span class="keyword">new</span> RequestInfo(<span class="string">"login"</span>, responseTime, startTimestamp);</span><br><span class="line">    metricsCollector.recordRequest(requestInfo);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...返回UserVo数据...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> UserVo <span class="title">register</span><span class="params">(String telephone, String password)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> startTimestamp = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 省略register逻辑...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> endTimeStamp = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> responseTime = endTimeStamp - startTimestamp;</span><br><span class="line">    RequestInfo requestInfo = <span class="keyword">new</span> RequestInfo(<span class="string">"register"</span>, responseTime, startTimestamp);</span><br><span class="line">    metricsCollector.recordRequest(requestInfo);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...返回UserVo数据...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显，上面的写法有两个问题。</p><ul><li>性能计数器框架代码侵入到业务代码中，跟业务代码高度耦合。如果未来需要替换这个框架，那替换的成本会比较大。</li><li>收集接口请求的代码跟业务代码无关，本就不应该放到一个类中。业务类最好职责更加单一，只聚焦业务处理。</li></ul><p>为了将框架代码和业务代码解耦，代理模式就派上用场了。</p><p>代理类 <code>UserControllerProxy</code> 和原始类 <code>UserController</code> 实现相同的接口 <code>IUserController</code>。<code>UserController</code> 类只负责业务功能。代理类 <code>UserControllerProxy</code> 负责在业务代码执行前后附加其他逻辑代码，并通过委托的方式调用原始类来执行业务代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUserController</span> </span>&#123;</span><br><span class="line">  <span class="function">UserVo <span class="title">login</span><span class="params">(String telephone, String password)</span></span>;</span><br><span class="line">  <span class="function">UserVo <span class="title">register</span><span class="params">(String telephone, String password)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> <span class="keyword">implements</span> <span class="title">IUserController</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...省略其他属性和方法...</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> UserVo <span class="title">login</span><span class="params">(String telephone, String password)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...省略login逻辑...</span></span><br><span class="line">    <span class="comment">//...返回UserVo数据...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> UserVo <span class="title">register</span><span class="params">(String telephone, String password)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...省略register逻辑...</span></span><br><span class="line">    <span class="comment">//...返回UserVo数据...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserControllerProxy</span> <span class="keyword">implements</span> <span class="title">IUserController</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> MetricsCollector metricsCollector;</span><br><span class="line">  <span class="keyword">private</span> UserController userController;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">UserControllerProxy</span><span class="params">(UserController userController)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.userController = userController;</span><br><span class="line">    <span class="keyword">this</span>.metricsCollector = <span class="keyword">new</span> MetricsCollector();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> UserVo <span class="title">login</span><span class="params">(String telephone, String password)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> startTimestamp = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 委托</span></span><br><span class="line">    UserVo userVo = userController.login(telephone, password);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> endTimeStamp = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> responseTime = endTimeStamp - startTimestamp;</span><br><span class="line">    RequestInfo requestInfo = <span class="keyword">new</span> RequestInfo(<span class="string">"login"</span>, responseTime, startTimestamp);</span><br><span class="line">    metricsCollector.recordRequest(requestInfo);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> userVo;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> UserVo <span class="title">register</span><span class="params">(String telephone, String password)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> startTimestamp = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    UserVo userVo = userController.register(telephone, password);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> endTimeStamp = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> responseTime = endTimeStamp - startTimestamp;</span><br><span class="line">    RequestInfo requestInfo = <span class="keyword">new</span> RequestInfo(<span class="string">"register"</span>, responseTime, startTimestamp);</span><br><span class="line">    metricsCollector.recordRequest(requestInfo);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> userVo;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//UserControllerProxy使用举例</span></span><br><span class="line"><span class="comment">//因为原始类和代理类实现相同的接口，是基于接口而非实现编程</span></span><br><span class="line"><span class="comment">//将UserController类对象替换为UserControllerProxy类对象，不需要改动太多代码</span></span><br><span class="line">IUserController userController = <span class="keyword">new</span> UserControllerProxy(<span class="keyword">new</span> UserController());</span><br></pre></td></tr></table></figure><p>参照基于接口而非实现编程的设计思想，将原始类对象替换为代理类对象的时候，为了让代码改动尽量少，在刚刚的代理模式的代码实现中，代理类和原始类需要实现相同的接口。<br>但是，如果原始类并没有定义接口，并且原始类代码并不是我们开发维护的（比如它来自一个第三方的类库），我们也没办法直接修改原始类，给它重新定义一个接口。在这种情况下，我们该如何实现代理模式呢？</p><p>对于这种外部类的扩展，我们一般都是采用继承的方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserControllerProxy</span> <span class="keyword">extends</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> MetricsCollector metricsCollector;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">UserControllerProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.metricsCollector = <span class="keyword">new</span> MetricsCollector();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> UserVo <span class="title">login</span><span class="params">(String telephone, String password)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> startTimestamp = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    UserVo userVo = <span class="keyword">super</span>.login(telephone, password);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> endTimeStamp = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> responseTime = endTimeStamp - startTimestamp;</span><br><span class="line">    RequestInfo requestInfo = <span class="keyword">new</span> RequestInfo(<span class="string">"login"</span>, responseTime, startTimestamp);</span><br><span class="line">    metricsCollector.recordRequest(requestInfo);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> userVo;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> UserVo <span class="title">register</span><span class="params">(String telephone, String password)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> startTimestamp = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    UserVo userVo = <span class="keyword">super</span>.register(telephone, password);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> endTimeStamp = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> responseTime = endTimeStamp - startTimestamp;</span><br><span class="line">    RequestInfo requestInfo = <span class="keyword">new</span> RequestInfo(<span class="string">"register"</span>, responseTime, startTimestamp);</span><br><span class="line">    metricsCollector.recordRequest(requestInfo);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> userVo;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//UserControllerProxy使用举例</span></span><br><span class="line">UserController userController = <span class="keyword">new</span> UserControllerProxy();</span><br></pre></td></tr></table></figure><h1 id="2-动态代理"><a href="#2-动态代理" class="headerlink" title="2 动态代理"></a>2 动态代理</h1><p>可以发现，静态代理完美的分离了收集代码与请求业务代码，但是，如果我们需要收集的类过多时，每个类都要写一个代理类，这会导致项目中类的个数成倍增加，增加了代码维护成本。并且，每个代理类中的代码都有点像模板式的 “重复” 代码，也增加了不必要的开发成本。</p><p>现在就是动态代理的表现的时候，就是我们不事先为每个原始类编写代理类，而是在运行的时候，动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。<br>动态代理底层依赖的就是 <code>Java</code> 的反射语法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MetricsCollectorProxy</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> MetricsCollector metricsCollector;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MetricsCollectorProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.metricsCollector = <span class="keyword">new</span> MetricsCollector();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">createProxy</span><span class="params">(Object proxiedObject)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt;[] interfaces = proxiedObject.getClass().getInterfaces();</span><br><span class="line">    DynamicProxyHandler handler = <span class="keyword">new</span> DynamicProxyHandler(proxiedObject);</span><br><span class="line">    <span class="keyword">return</span> Proxy.newProxyInstance(proxiedObject.getClass().getClassLoader(), interfaces, handler);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxyHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object proxiedObject;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicProxyHandler</span><span class="params">(Object proxiedObject)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.proxiedObject = proxiedObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">      <span class="keyword">long</span> startTimestamp = System.currentTimeMillis();</span><br><span class="line">      Object result = method.invoke(proxiedObject, args);</span><br><span class="line">      <span class="keyword">long</span> endTimeStamp = System.currentTimeMillis();</span><br><span class="line">      <span class="keyword">long</span> responseTime = endTimeStamp - startTimestamp;</span><br><span class="line">      String apiName = proxiedObject.getClass().getName() + <span class="string">":"</span> + method.getName();</span><br><span class="line">      RequestInfo requestInfo = <span class="keyword">new</span> RequestInfo(apiName, responseTime, startTimestamp);</span><br><span class="line">      metricsCollector.recordRequest(requestInfo);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//MetricsCollectorProxy使用举例</span></span><br><span class="line">MetricsCollectorProxy proxy = <span class="keyword">new</span> MetricsCollectorProxy();</span><br><span class="line">IUserController userController = (IUserController) proxy.createProxy(<span class="keyword">new</span> UserController());</span><br></pre></td></tr></table></figure><p><code>android-aspectjx AOP</code> 底层的实现原理就是基于动态代理。</p><h1 id="3-Android-源码中的代理模式实现"><a href="#3-Android-源码中的代理模式实现" class="headerlink" title="3 Android 源码中的代理模式实现"></a>3 Android 源码中的代理模式实现</h1><p><a href="http://gityuan.com/2016/09/04/binder-start-service/" target="_blank" rel="noopener">彻底理解Android Binder通信架构</a> </p><p><a href="http://gityuan.com/2015/11/22/binder-use/" target="_blank" rel="noopener">Binder系列8—如何使用Binder</a> </p><p><a href="http://gityuan.com/2015/11/23/binder-aidl/" target="_blank" rel="noopener">Binder系列9—如何使用AIDL</a></p><h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h1><p>代理模式最常用的一个应用场景就是，在业务系统中开发一些非功能性需求，比如：监控、统计、鉴权、限流、事务、幂等、日志。我们将这些附加功能与业务功能解耦，放到代理类中统一处理，让程序员只需要关注业务方面的开发。实际上，前面举的搜集接口请求信息的例子，就是这个应用场景的一个典型例子。</p><h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a><strong>感谢</strong></h1><blockquote><p><a href="https://time.geekbang.org/column/intro/250?utm_source=pinpaizhuanqu&utm_medium=geektime&utm_campaign=guanwang&utm_term=guanwang&utm_content=0511" target="_blank" rel="noopener">设计模式之美</a></p><p>《Android 源码设计模式解析与实战》</p><p>以及上文中的链接</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-创建型-原型模式</title>
      <link href="/2020/design-pattern-prototype.html"/>
      <url>/2020/design-pattern-prototype.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-什么是原型模式？"><a href="#1-什么是原型模式？" class="headerlink" title="1 什么是原型模式？"></a>1 什么是原型模式？</h1><p>如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同），在这种情况下，我们可以利用对已有对象（原型）进行复制（或者叫拷贝）的方式，来创建新对象，以达到节省创建时间的目的。这种基于原型来创建对象的方式就叫作原型设计模式，简称原型模式。</p><p>实际上，创建对象包含的申请内存、给成员变量赋值这一过程，本身并不会花费太多时间，或者说对于大部分业务系统来说，这点时间完全是可以忽略的。应用一个复杂的模式，只得到一点点的性能提升，这就是所谓的过度设计，得不偿失。</p><p>但是，如果对象中的数据需要经过复杂的计算才能得到（比如排序、计算哈希值），或者需要从 <code>RPC</code>、网络、数据库、文件系统等非常慢速的 IO 中读取，这种情况下，我们就可以利用原型模式，从其他已有对象中直接拷贝得到，而不用每次在创建新对象的时候，都重复执行这些耗时的操作。</p><p>举个栗子🌰</p><p>我们在这个例子中首先创建了一个文档对象，即 <code>WordDocument</code> ，这个文档中含有文字和图片。<br>用户经过了长时间的内容编辑后，打算对该文档做进一步的编辑，但是，这个编辑后的文档是否会被采用还不确定，因此，为了安全起见，用户需要将当前文档拷贝一份，然后再在文档副本上进行修改，这与 <code>《Effective Java》</code> 一书中提到的<strong>保护性拷贝</strong>有些类似，如此，这个原始文档就是样板实例，也就是将要被 “克隆” 的对象，称为原型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordDocument</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String mText;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; mImages = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WordDocument <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            WordDocument doc = (WordDocument) <span class="keyword">super</span>.clone();</span><br><span class="line">            doc.mText = <span class="keyword">this</span>.mText;</span><br><span class="line">            doc.mImages = <span class="keyword">this</span>.mImages;</span><br><span class="line">            <span class="keyword">return</span> doc;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getmText</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mText;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setmText</span><span class="params">(String mText)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mText = mText;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">getmImages</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mImages;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addImages</span><span class="params">(String mImages)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mImages.add(mImages);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showDocument</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"----------Word Content Start------------"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Text :"</span> + mText);</span><br><span class="line">        System.out.println(<span class="string">"Image List :"</span>);</span><br><span class="line">        <span class="keyword">for</span> (String mImage : mImages) &#123;</span><br><span class="line">            System.out.println(<span class="string">"image name :"</span> + mImage);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"----------Word Content End------------"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>WordDocumen</code> 类模拟了 <code>Word</code> 文档中的基本元素，即文字和图片 。 <code>WordDocument</code> 中的 <code>clone</code> 方法用以实现对象克隆。注意，这个方法并不是 <code>Cloneable</code> 接口中的，而是 <code>Object</code> 中的方法。 <code>Cloneable</code> 也是一个标识接口，它表明这个类的对象是可拷贝的。如果没有实现 <code>Cloneable</code> 接口却调用了 <code>clone（）</code>函数将抛出异常。在这个示例中，通过实现 <code>Cloneable</code> 接口和覆写 <code>clone</code> 方法实现原型模式。<br> <code>Client</code> 端的使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        WordDocument originDoc = <span class="keyword">new</span> WordDocument();</span><br><span class="line">        originDoc.setmText(<span class="string">"这是一篇文档"</span>);</span><br><span class="line">        originDoc.addImages(<span class="string">"图片 1"</span>);</span><br><span class="line">        originDoc.addImages(<span class="string">"图片 2"</span>);</span><br><span class="line">        originDoc.addImages(<span class="string">"图片 3"</span>);</span><br><span class="line">        originDoc.showDocument();</span><br><span class="line"></span><br><span class="line">        WordDocument doc2 = originDoc.clone();</span><br><span class="line">        doc2.showDocument();</span><br><span class="line"></span><br><span class="line">        doc2.setmText(<span class="string">"修改"</span>);</span><br><span class="line">        doc2.addImages(<span class="string">"哈哈 123"</span>);</span><br><span class="line">        doc2.showDocument();</span><br><span class="line"></span><br><span class="line">        originDoc.showDocument();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">----------Word Content Start------------</span><br><span class="line">Text :这是一篇文档</span><br><span class="line">Image List :</span><br><span class="line">image name :图片 1</span><br><span class="line">image name :图片 2</span><br><span class="line">image name :图片 3</span><br><span class="line">----------Word Content End------------</span><br><span class="line">----------Word Content Start------------</span><br><span class="line">Text :这是一篇文档</span><br><span class="line">Image List :</span><br><span class="line">image name :图片 1</span><br><span class="line">image name :图片 2</span><br><span class="line">image name :图片 3</span><br><span class="line">----------Word Content End------------</span><br><span class="line">----------Word Content Start------------</span><br><span class="line">Text :修改</span><br><span class="line">Image List :</span><br><span class="line">image name :图片 1</span><br><span class="line">image name :图片 2</span><br><span class="line">image name :图片 3</span><br><span class="line">image name :哈哈 123</span><br><span class="line">----------Word Content End------------</span><br><span class="line">----------Word Content Start------------</span><br><span class="line">Text :这是一篇文档</span><br><span class="line">Image List :</span><br><span class="line">image name :图片 1</span><br><span class="line">image name :图片 2</span><br><span class="line">image name :图片 3</span><br><span class="line">image name :哈哈 123</span><br><span class="line">----------Word Content End------------</span><br></pre></td></tr></table></figure><p>从输出中可以看到，<code>doc2</code> 是通过 <code>originDoc.clone()</code> 创建的，并且 <code>doc2</code> 第一次输出的时候和 <code>originDoc</code> 输出是一样的，即 <code>doc2</code> 是 <code>originDoc</code> 的一份拷贝，它们的内容是一样的，而 <code>doc2</code> 修改了文本内容以后并不会影响 <code>originDoc</code> 的文本内容，这就保证了 <code>originDoc</code> 的安全性。还需要注意的是，通过 <code>clone</code> 拷贝对象时并不会执行构造函数！因此，如果在构造函数中需要一些特殊的初始化操作的类型，在使用 <code>Cloneable</code> 实现拷贝时，需要注意构造函数不会执行的问题。</p><h1 id="2-深拷贝浅拷贝"><a href="#2-深拷贝浅拷贝" class="headerlink" title="2 深拷贝浅拷贝"></a>2 深拷贝浅拷贝</h1><p>上述原型模式的实现实际上只是一个浅拷贝，也称为影子拷贝，这份拷贝实际上并不是将原始文档的所有字段都重新构造了一份，而是副本文档的字段引用原始文档的字段</p><p>仔细查看，发现 <code>doc2</code> 添加照片之后，<code>originDoc</code> 也被修改了。这是怎么回事呢？<br>这是因为上文中 <code>WordDocument</code> 的 <code>clone</code> 方法中只是简单地进行浅拷贝，引用类型的新对象 <code>doc2</code> 的 <code>mlmages</code> 只是单纯地指向了 <code>this.mlmages</code> 引用，并没有重新构造一个 <code>mlimages</code>  对象，然后将原始文档中的图片添加到新的 <code>mlmages</code> 对象中，这样就导致 <code>doc2</code> 中的 <code>mlmages</code> 与原始文档中的是同一个对象，因此，修改了其中一个文档中的图片，另一个文档也会受影响。那如何解决这个问题呢？答案就是采用深拷贝，即在拷贝对象时，对于引用型的字段也要采用拷贝的形式，而不是单纯引用的形式。<code>clone</code> 方法修改如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> WordDocument <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        WordDocument doc = (WordDocument) <span class="keyword">super</span>.clone();</span><br><span class="line">        doc.mText = <span class="keyword">this</span>.mText;</span><br><span class="line">        doc.mImages = (ArrayList&lt;String&gt;) <span class="keyword">this</span>.mImages.clone();</span><br><span class="line">        <span class="keyword">return</span> doc;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以了，为什么 <code>Text</code>  不会被影响？</p><p>因为他是一个 <code>String</code> 类型，赋值的时候可能创建一个或者不创建对象，如果赋值的内容在 <code>java String</code> 池里不存在，会在 <code>java String</code> 池里创建一个创建一个 <code>String</code> 对象，然后指向这个内存地址。而不是去修改当前地址，因为 <code>String</code> 是不可修改的。之后再赋同样的值的时候就不会创建新的对象。</p><h1 id="3-Android-源码中的原型模式实现"><a href="#3-Android-源码中的原型模式实现" class="headerlink" title="3 Android 源码中的原型模式实现"></a>3 Android 源码中的原型模式实现</h1><p>在上述的文档深拷贝示例中，<code>mlmages</code> 对象调用了 <code>clone0</code> 方法，这就是原型模式。我们知道，<code>mlmages</code> 的实际类型为 <code>ArrayList</code> ，相关源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) <span class="keyword">super</span>.clone();</span><br><span class="line">        v.elementData = Arrays.copyOf(elementData, size);</span><br><span class="line">        v.modCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="comment">// this shouldn't happen, since we are Cloneable</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>Android</code> 中，<code>Intent</code> 可能是我们最早接触的几个类型之一，它用于跳转 <code>Activity</code> 、启动服务、发布广播等功能，它是 <code>Android</code> 系统各组件之间的纽带，也是组件之间传递数据的载体，正是Intent的存在才使得 <code>Android</code>各个组件之间的耦合性很低，Android的组件才如此灵活。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Uri uri = Uri.parse(<span class="string">"smsto:0800000123"</span>);</span><br><span class="line">Intent shareIntent = <span class="keyword">new</span> Intent(Intent.ACTION_SENDTO,uri);</span><br><span class="line">shareIntent.putExtra(<span class="string">"sms_body"</span>,<span class="string">"The SMS test"</span>);</span><br><span class="line"></span><br><span class="line">Intent intent= (Intent) shareIntent.clone();</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure><p>首先构造了一个发送短信的 <code>Intent</code> 对象，并且设置了短信内容，然后通过原始 <code>Intent</code> 的 <code>clone0</code> 方法构建了一个副本 <code>Intent</code> ，再使用这个副本 <code>Intent</code> 进行跳转</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Intent(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 <code>clone</code> 方法实际上在内部并没有调用 <code>super.clone()</code>方法来实现对象拷贝，而是调用了 <code>new Intent（this）</code> 。使用 <code>clone</code> 和 <code>new</code> 需要根据构造对象的成本来决定，如果对象的构造成本比较高或者构造较为麻烦，那么使用 <code>clone() 函数效率较高，否则可以使用</code> <code>new</code> 的形式。</p><p><a href="https://www.jianshu.com/p/420395facf88" target="_blank" rel="noopener">Android 源码 Intent 的查找和匹配</a>  <code>parseBaseApplication</code> 方法是解析 <code>application</code>，可以在文章中搜索。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>优点<br>原型模式是在内存中二进制流的拷贝，要比直接 <code>new</code> 一个对象性能好很多，特别是要在一个循环体内产生大量的对象时，原型模式可以更好地体现其优点。</li><li>缺点<br>这既是它的优点也是缺点，直接在内存中拷贝，构造函数是不会执行的，在实际开发当中应该注意这个潜在的问题。优点就是减少了约束，缺点也是减少了约束，需要在实际应用时考虑。</li></ul><h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a><strong>感谢</strong></h1><blockquote><p><a href="https://time.geekbang.org/column/intro/250?utm_source=pinpaizhuanqu&utm_medium=geektime&utm_campaign=guanwang&utm_term=guanwang&utm_content=0511" target="_blank" rel="noopener">设计模式之美</a></p><p>《Android 源码设计模式解析与实战》</p><p>以及上文中的链接</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-创建型-Builder 模式</title>
      <link href="/2020/design-pattern-builder.html"/>
      <url>/2020/design-pattern-builder.html</url>
      
        <content type="html"><![CDATA[<p><strong>Builder 模式</strong>一个比较常用的创建型设计模式，中文翻译为<strong>建造者模式</strong>或者<strong>构建者模式</strong>，也有人叫它<strong>生成器模式</strong>。</p><h1 id="1-为什么需要建造者模式？"><a href="#1-为什么需要建造者模式？" class="headerlink" title="1 为什么需要建造者模式？"></a>1 为什么需要建造者模式？</h1><p>举个栗子🌰 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourcePoolConfig</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MAX_TOTAL = <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MAX_IDLE = <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MIN_IDLE = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> maxTotal = DEFAULT_MAX_TOTAL;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> maxIdle = DEFAULT_MAX_IDLE;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> minIdle = DEFAULT_MIN_IDLE;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ResourcePoolConfig</span><span class="params">(String name, Integer maxTotal, Integer maxIdle, Integer minIdle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(name)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"name should not be empty."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (maxTotal != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (maxTotal &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"maxTotal should be positive."</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.maxTotal = maxTotal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (maxIdle != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (maxIdle &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"maxIdle should not be negative."</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.maxIdle = maxIdle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (minIdle != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (minIdle &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"minIdle should not be negative."</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.minIdle = minIdle;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...省略getter方法...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是构建一个对象最常见、最容易想到的实现思路，因为 <code>maxTotal</code>、<code>maxIdle</code>、<code>minIdle</code> 不是必填变量，所以在创建 <code>ResourcePoolConfig</code> 对象的时候，我们通过往构造函数中，给这几个参数传递 <code>null</code> 值，来表示使用默认值。</p><p>但是，如果可配置项逐渐增多，变成了 <code>8</code> 个、<code>10</code> 个，甚至更多，那继续沿用现在的设计思路，构造函数的参数列表会变得很长，代码在可读性和易用性上都会变差。<br>在使用构造函数的时候，我们就容易搞错各参数的顺序，传递进错误的参数值，导致非常隐蔽的 <code>bug</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数太多，导致可读性差、参数可能传递错误</span></span><br><span class="line">ResourcePoolConfig config = <span class="keyword">new</span> ResourcePoolConfig(<span class="string">"dbconnectionpool"</span>, <span class="number">16</span>, <span class="keyword">null</span>, <span class="number">8</span>, <span class="keyword">null</span>, <span class="keyword">false</span> , <span class="keyword">true</span>, <span class="number">10</span>, <span class="number">20</span>，<span class="keyword">false</span>， <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><p>解决这种问题，我们可以用 <code>set()</code> 函数来给成员变量赋值，以替代冗长的构造函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourcePoolConfig</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MAX_TOTAL = <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MAX_IDLE = <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MIN_IDLE = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> maxTotal = DEFAULT_MAX_TOTAL;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> maxIdle = DEFAULT_MAX_IDLE;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> minIdle = DEFAULT_MIN_IDLE;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ResourcePoolConfig</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(name)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"name should not be empty."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMaxTotal</span><span class="params">(<span class="keyword">int</span> maxTotal)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (maxTotal &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"maxTotal should be positive."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.maxTotal = maxTotal;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMaxIdle</span><span class="params">(<span class="keyword">int</span> maxIdle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (maxIdle &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"maxIdle should not be negative."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.maxIdle = maxIdle;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMinIdle</span><span class="params">(<span class="keyword">int</span> minIdle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minIdle &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"minIdle should not be negative."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.minIdle = minIdle;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...省略getter方法...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>name</code> 是必填项，所有还就在了构造函数里。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ResourcePoolConfig使用举例</span></span><br><span class="line">ResourcePoolConfig config = <span class="keyword">new</span> ResourcePoolConfig(<span class="string">"dbconnectionpool"</span>);</span><br><span class="line">config.setMaxTotal(<span class="number">16</span>);</span><br><span class="line">config.setMaxIdle(<span class="number">8</span>);</span><br></pre></td></tr></table></figure><p>没有了冗长的函数调用和参数列表，代码在可读性和易用性上提高了很多。</p><p>但是还有几个问题：</p><ul><li><code>name</code> 是必填的，所以，我们把它放到构造函数中，强制创建对象的时候就设置。如果必填的配置项有很多，把这些必填配置项都放到构造函数中设置，那构造函数就又会出现参数列表很长的问题。如果我们把必填项也通过 <code>set()</code> 方法设置，那校验这些必填项是否已经填写的逻辑就无处安放了。</li><li>如果属性之间有依赖关系，比如，如果用户设置了 <code>maxTotal</code>、<code>maxIdle</code>、<code>minIdle</code> 其中一个，就必须显式地设置另外两个；或者配置项之间有一定的约束条件，比如，<code>maxIdle</code> 和 <code>minIdle</code> 要小于等于 <code>maxTotal</code>。如果我们继续使用现在的设计思路，那这些配置项之间的依赖关系或者约束条件的校验逻辑就无处安放了。</li><li>如果我们希望 <code>ResourcePoolConfig</code> 类对象是不可变对象，也就是说，对象在创建好之后，就不能再修改内部的属性值。要实现这个功能，我们就不能在 <code>ResourcePoolConfig</code> 类中暴露 <code>set()</code> 方法。</li></ul><p><strong>现在建造者模式就派上用场了。</strong>🗼🗼</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourcePoolConfig</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> maxTotal;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> maxIdle;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> minIdle;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">ResourcePoolConfig</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = builder.name;</span><br><span class="line">    <span class="keyword">this</span>.maxTotal = builder.maxTotal;</span><br><span class="line">    <span class="keyword">this</span>.maxIdle = builder.maxIdle;</span><br><span class="line">    <span class="keyword">this</span>.minIdle = builder.minIdle;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...省略getter方法...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//我们将Builder类设计成了ResourcePoolConfig的内部类。</span></span><br><span class="line">  <span class="comment">//我们也可以将Builder类设计成独立的非内部类ResourcePoolConfigBuilder。</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MAX_TOTAL = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MAX_IDLE = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MIN_IDLE = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxTotal = DEFAULT_MAX_TOTAL;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxIdle = DEFAULT_MAX_IDLE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> minIdle = DEFAULT_MIN_IDLE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResourcePoolConfig <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 校验逻辑放到这里来做，包括必填项校验、依赖关系校验、约束条件校验等</span></span><br><span class="line">      <span class="keyword">if</span> (StringUtils.isBlank(name)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"..."</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (maxIdle &gt; maxTotal) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"..."</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (minIdle &gt; maxTotal || minIdle &gt; maxIdle) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"..."</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ResourcePoolConfig(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (StringUtils.isBlank(name)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"..."</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">setMaxTotal</span><span class="params">(<span class="keyword">int</span> maxTotal)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (maxTotal &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"..."</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.maxTotal = maxTotal;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">setMaxIdle</span><span class="params">(<span class="keyword">int</span> maxIdle)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (maxIdle &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"..."</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.maxIdle = maxIdle;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">setMinIdle</span><span class="params">(<span class="keyword">int</span> minIdle)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (minIdle &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"..."</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.minIdle = minIdle;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这段代码会抛出IllegalArgumentException，因为minIdle&gt;maxIdle</span></span><br><span class="line">ResourcePoolConfig config = <span class="keyword">new</span> ResourcePoolConfig.Builder()</span><br><span class="line">        .setName(<span class="string">"dbconnectionpool"</span>)</span><br><span class="line">        .setMaxTotal(<span class="number">16</span>)</span><br><span class="line">        .setMaxIdle(<span class="number">10</span>)</span><br><span class="line">        .setMinIdle(<span class="number">12</span>)</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure><p>这样就解决了上面三个问题。使用建造者模式创建对象，还能避免对象存在无效状态。比如我们定义了一个长方形类，如果不使用建造者模式，采用先创建后 <code>set</code> 的方式，那就会导致在第一个 <code>set</code> 之后，对象处于无效状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Rectangle r = <span class="keyword">new</span> Rectange(); <span class="comment">// r is invalid</span></span><br><span class="line">r.setWidth(<span class="number">2</span>); <span class="comment">// r is invalid</span></span><br><span class="line">r.setHeight(<span class="number">3</span>); <span class="comment">// r is valid</span></span><br></pre></td></tr></table></figure><p>为了避免这种无效状态的存在，我们就需要使用构造函数一次性初始化好所有的成员变量。如果构造函数参数过多，我们就需要考虑使用建造者模式，先设置建造者的变量，然后再一次性地创建对象，让对象一直处于有效状态。</p><h1 id="2-与工厂模式有何区别？"><a href="#2-与工厂模式有何区别？" class="headerlink" title="2 与工厂模式有何区别？"></a>2 与工厂模式有何区别？</h1><p>建造者模式是让建造者类来负责对象的创建工作。工厂模式，是由工厂类来负责对象创建的工作。那它们之间有什么区别呢？</p><p>工厂模式是用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。<br>建造者模式是用来创建一种类型的复杂对象，通过设置不同的可选参数，“定制化”地创建不同的对象。</p><p>网上有一个经典的例子很好地解释了两者的区别。顾客走进一家餐馆点餐，我们利用工厂模式，根据用户不同的选择，来制作不同的食物，比如披萨、汉堡、沙拉。对于披萨来说，用户又有各种配料可以定制，比如奶酪、西红柿、起司，我们通过建造者模式根据用户选择的不同配料来制作披萨。</p><h1 id="3-Android-源码中的建造者模式"><a href="#3-Android-源码中的建造者模式" class="headerlink" title="3 Android 源码中的建造者模式"></a>3 Android 源码中的建造者模式</h1><p>在 <code>Android</code> 源码中，最常用到的 <code>Builder</code> 模式就是 <code>AlertDialog.Builder</code>，使用该 <code>Builder</code> 来构建复杂的 <code>AlertDialog</code> 对象。在开发过程中，我们经常用到 <code>AlertDialog</code>，具体示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">builder.setIcon(R.mipmap.ic_launcher)</span><br><span class="line">        .setTitle(<span class="string">"Title"</span>)</span><br><span class="line">        .setMessage(<span class="string">"Message"</span>)</span><br><span class="line">        .setPositiveButton(<span class="string">"Button1"</span>, <span class="keyword">new</span> DialogInterface.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(DialogInterface dialog, <span class="keyword">int</span> which)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).create().show();</span><br></pre></td></tr></table></figure><p>从类名就可以看出这就是一个 <code>Builder</code> 模式，通过 <code>Builder</code> 对象来组装<code>Dialog</code> 的各个部分，如 <code>title</code> 、<code>buttons</code> 、<code>Message</code> 等，将 <code>Dialog</code> 的构造和表示进行分离。</p><p> <code>AlertDialog</code> 的相关源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AlertDialog</span> <span class="keyword">extends</span> <span class="title">Dialog</span> <span class="keyword">implements</span> <span class="title">DialogInterface</span> </span>&#123;</span><br><span class="line"><span class="comment">//在 create 时接收 Builder 成员变量 P 中的各个参数。</span></span><br><span class="line">    <span class="keyword">private</span> AlertController mAlert;</span><br><span class="line">  </span><br><span class="line">    AlertDialog(Context context, <span class="meta">@StyleRes</span> <span class="keyword">int</span> themeResId, <span class="keyword">boolean</span> createContextThemeWrapper) &#123;</span><br><span class="line">        <span class="keyword">super</span>(context, createContextThemeWrapper ? resolveDialogTheme(context, themeResId) : <span class="number">0</span>,createContextThemeWrapper);</span><br><span class="line">        mWindow.alwaysReadCloseOnTouchAttr();</span><br><span class="line">        mAlert = AlertController.create(getContext(), <span class="keyword">this</span>, getWindow());</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTitle</span><span class="params">(CharSequence title)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setTitle(title);</span><br><span class="line">        <span class="comment">//实际操作的是 mAlert 的 setTitle</span></span><br><span class="line">        mAlert.setTitle(title);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessage</span><span class="params">(CharSequence message)</span> </span>&#123;</span><br><span class="line">        mAlert.setMessage(message);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 存储 AlertDialog 的各个参数，如 Title、Message、icon 等。</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AlertController.AlertParams P;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setTitle</span><span class="params">(@StringRes <span class="keyword">int</span> titleId)</span> </span>&#123;</span><br><span class="line">          <span class="comment">//设置 P 的参数。</span></span><br><span class="line">            P.mTitle = P.mContext.getText(titleId);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setTitle</span><span class="params">(CharSequence title)</span> </span>&#123;</span><br><span class="line">            P.mTitle = title;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="function"><span class="keyword">public</span> AlertDialog <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 调用 new AlertDialog 构造对象，并且将参数传递给个体 AlertDialog</span></span><br><span class="line">            <span class="keyword">final</span> AlertDialog dialog = <span class="keyword">new</span> AlertDialog(P.mContext, <span class="number">0</span>, <span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">//将 p 中的参数应用到 dialog 中的 mAlert 对象中</span></span><br><span class="line">            P.apply(dialog.mAlert);</span><br><span class="line">            dialog.setCancelable(P.mCancelable);</span><br><span class="line">            <span class="keyword">if</span> (P.mCancelable) &#123;</span><br><span class="line">                dialog.setCanceledOnTouchOutside(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            dialog.setOnCancelListener(P.mOnCancelListener);</span><br><span class="line">            dialog.setOnDismissListener(P.mOnDismissListener);</span><br><span class="line">            <span class="keyword">if</span> (P.mOnKeyListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                dialog.setOnKeyListener(P.mOnKeyListener);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> dialog;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，<code>Builder</code> 类可以设置 <code>AlertDialog</code> 中的 <code>title</code> 、<code>message</code> 、<code>button</code> 等参数，这些参数都存储在类型为 <code>AlertController.AlertParams</code> 的成员变量 <code>P</code> 中，<code>AlertController.AlertParams</code> 中包含了与 <code>AlertDialog</code> 视图中对应的成员变量。在调用 <code>Builder</code> 类的 <code>create</code> 函数时会创建<code>AlertDialog</code> ，并且将 <code>Builder</code> 成员变量P中保存的参数应用到 <code>AlertDialog</code> 的 <code>mAlert</code> 对象中，即 <code>P.apply（dialog.mAlert）</code> 代码段。</p><p><code>apply</code> 函数的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(AlertController dialog)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mCustomTitleView != <span class="keyword">null</span>) &#123;</span><br><span class="line">        dialog.setCustomTitle(mCustomTitleView);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mTitle != <span class="keyword">null</span>) &#123;</span><br><span class="line">            dialog.setTitle(mTitle);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mIcon != <span class="keyword">null</span>) &#123;</span><br><span class="line">            dialog.setIcon(mIcon);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mIconId != <span class="number">0</span>) &#123;</span><br><span class="line">            dialog.setIcon(mIconId);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mIconAttrId != <span class="number">0</span>) &#123;</span><br><span class="line">            dialog.setIcon(dialog.getIconAttributeResId(mIconAttrId));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mMessage != <span class="keyword">null</span>) &#123;</span><br><span class="line">        dialog.setMessage(mMessage);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mPositiveButtonText != <span class="keyword">null</span> || mPositiveButtonIcon != <span class="keyword">null</span>) &#123;</span><br><span class="line">        dialog.setButton(DialogInterface.BUTTON_POSITIVE, mPositiveButtonText,</span><br><span class="line">                mPositiveButtonListener, <span class="keyword">null</span>, mPositiveButtonIcon);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mNegativeButtonText != <span class="keyword">null</span> || mNegativeButtonIcon != <span class="keyword">null</span>) &#123;</span><br><span class="line">        dialog.setButton(DialogInterface.BUTTON_NEGATIVE, mNegativeButtonText,</span><br><span class="line">                mNegativeButtonListener, <span class="keyword">null</span>, mNegativeButtonIcon);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mNeutralButtonText != <span class="keyword">null</span> || mNeutralButtonIcon != <span class="keyword">null</span>) &#123;</span><br><span class="line">        dialog.setButton(DialogInterface.BUTTON_NEUTRAL, mNeutralButtonText,</span><br><span class="line">                mNeutralButtonListener, <span class="keyword">null</span>, mNeutralButtonIcon);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// For a list, the client can either supply an array of items or an</span></span><br><span class="line">    <span class="comment">// adapter or a cursor</span></span><br><span class="line">    <span class="keyword">if</span> ((mItems != <span class="keyword">null</span>) || (mCursor != <span class="keyword">null</span>) || (mAdapter != <span class="keyword">null</span>)) &#123;</span><br><span class="line">        createListView(dialog);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mView != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mViewSpacingSpecified) &#123;</span><br><span class="line">            dialog.setView(mView, mViewSpacingLeft, mViewSpacingTop, mViewSpacingRight,</span><br><span class="line">                    mViewSpacingBottom);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dialog.setView(mView);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mViewLayoutResId != <span class="number">0</span>) &#123;</span><br><span class="line">        dialog.setView(mViewLayoutResId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>apply</code> 函数中，只是将 <code>AlertParams</code> 参数设置到 <code>AlertController</code> 中，例如，将标题设置到 <code>Dialog</code> 对应的标题视图中，将 <code>Message</code> 设置到内容视图中等。当我们获取到 <code>AlertDialog</code> 对象后，通过 <code>show</code> 函数就可以显示这个对话框。 <code>Dialog</code> 的 <code>show</code> 函数（该函数在 <code>Dialog</code> 类中）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mShowing) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mDecor != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mWindow.hasFeature(Window.FEATURE_ACTION_BAR)) &#123;</span><br><span class="line">                mWindow.invalidatePanelMenu(Window.FEATURE_ACTION_BAR);</span><br><span class="line">            &#125;</span><br><span class="line">            mDecor.setVisibility(View.VISIBLE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mCanceled = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mCreated) &#123;</span><br><span class="line">        dispatchOnCreate(<span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Fill the DecorView in on any configuration changes that</span></span><br><span class="line">        <span class="comment">// may have occured while it was removed from the WindowManager.</span></span><br><span class="line">        <span class="keyword">final</span> Configuration config = mContext.getResources().getConfiguration();</span><br><span class="line">        mWindow.getDecorView().dispatchConfigurationChanged(config);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    onStart();</span><br><span class="line">    mDecor = mWindow.getDecorView();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mActionBar == <span class="keyword">null</span> &amp;&amp; mWindow.hasFeature(Window.FEATURE_ACTION_BAR)) &#123;</span><br><span class="line">        <span class="keyword">final</span> ApplicationInfo info = mContext.getApplicationInfo();</span><br><span class="line">        mWindow.setDefaultIcon(info.icon);</span><br><span class="line">        mWindow.setDefaultLogo(info.logo);</span><br><span class="line">        mActionBar = <span class="keyword">new</span> WindowDecorActionBar(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    WindowManager.LayoutParams l = mWindow.getAttributes();</span><br><span class="line">    <span class="keyword">boolean</span> restoreSoftInputMode = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> ((l.softInputMode</span><br><span class="line">            &amp; WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION) == <span class="number">0</span>) &#123;</span><br><span class="line">        l.softInputMode |=</span><br><span class="line">                WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;</span><br><span class="line">        restoreSoftInputMode = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mWindowManager.addView(mDecor, l);</span><br><span class="line">    <span class="keyword">if</span> (restoreSoftInputMode) &#123;</span><br><span class="line">        l.softInputMode &amp;=</span><br><span class="line">                ~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mShowing = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    sendShowMessage();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>show</code> 函数中主要做了如下几个事情：</p><ul><li>通过 <code>dispatchOnCreate</code> 函数来调用 <code>AlertDialog</code> 的 <code>onCreate</code> 函数；</li><li>然后调用 <code>AlertDialog</code> 的 <code>onStart</code> 函数；</li><li>最后将 <code>Dialog</code> 的 <code>DecorView</code> 添加到 <code>WindowManager</code> 中。</li></ul><p>很明显，这就是一系列典型的生命周期函数。那么按照惯例，<code>AlertDialog</code> 的内容视图构建按理应该在 <code>onCreate</code> 函数中；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        mAlert.installContent();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">AlertController.java</span><br><span class="line">  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">installContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> contentView = selectContentView();</span><br><span class="line">        mDialog.setContentView(contentView);</span><br><span class="line">        setupView();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">AppCompatDialog.java</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(@LayoutRes <span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">        getDelegate().setContentView(layoutResID);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里就和 <code>Activity</code> 中的 <code>setContentView</code> 逻辑一样了。</p><p><code>setContentView</code> 后续 <a href="https://juejin.im/post/5b1202de6fb9a01e5f3e1467#heading-0" target="_blank" rel="noopener">Android setContentView源码解析</a> </p><h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a><strong>感谢</strong></h1><blockquote><p><a href="https://time.geekbang.org/column/intro/250?utm_source=pinpaizhuanqu&utm_medium=geektime&utm_campaign=guanwang&utm_term=guanwang&utm_content=0511" target="_blank" rel="noopener">设计模式之美</a></p><p>《Android 源码设计模式解析与实战》</p><p>以及上文中的链接</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-创建型-工厂模式</title>
      <link href="/2020/design-pattern-factory.html"/>
      <url>/2020/design-pattern-factory.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-简单工厂模式"><a href="#1-简单工厂模式" class="headerlink" title="1 简单工厂模式"></a>1 简单工厂模式</h1><p>举个栗子🌰 我们根据配置文件的后缀（<code>json</code>、<code>xml</code>、<code>yaml</code>、<code>properties</code>），选择不同的解析器（<code>JsonRuleConfigParser</code>、<code>XmlRuleConfigParser</code>……），将存储在文件中的配置解析成内存对象 <code>RuleConfig</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuleConfigSource</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> RuleConfig <span class="title">load</span><span class="params">(String ruleConfigFilePath)</span> </span>&#123;</span><br><span class="line">    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);</span><br><span class="line">    IRuleConfigParser parser = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"json"</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class="line">      parser = <span class="keyword">new</span> JsonRuleConfigParser();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"xml"</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class="line">      parser = <span class="keyword">new</span> XmlRuleConfigParser();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"yaml"</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class="line">      parser = <span class="keyword">new</span> YamlRuleConfigParser();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"properties"</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class="line">      parser = <span class="keyword">new</span> PropertiesRuleConfigParser();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> InvalidRuleConfigException(</span><br><span class="line">             <span class="string">"Rule config file format is not supported: "</span> + ruleConfigFilePath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String configText = <span class="string">""</span>;</span><br><span class="line">    <span class="comment">//从ruleConfigFilePath文件中读取配置文本到configText中</span></span><br><span class="line">    RuleConfig ruleConfig = parser.parse(configText);</span><br><span class="line">    <span class="keyword">return</span> ruleConfig;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> String <span class="title">getFileExtension</span><span class="params">(String filePath)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...解析文件名获取扩展名，比如rule.json，返回json</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"json"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这块代码都耦合进了 <code>load()</code> 函数中，为了让类的职责更加单一、代码更加清晰，我们可以将功能独立到一个类中，让这个类只负责对象的创建。而这个类就是我们现在要讲的简单工厂模式类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuleConfigSource</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> RuleConfig <span class="title">load</span><span class="params">(String ruleConfigFilePath)</span> </span>&#123;</span><br><span class="line">    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);</span><br><span class="line">    IRuleConfigParser parser = RuleConfigParserFactory.createParser(ruleConfigFileExtension);</span><br><span class="line">    <span class="keyword">if</span> (parser == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> InvalidRuleConfigException(</span><br><span class="line">              <span class="string">"Rule config file format is not supported: "</span> + ruleConfigFilePath);</span><br><span class="line">    &#125;</span><br><span class="line">    String configText = <span class="string">""</span>;</span><br><span class="line">    <span class="comment">//从ruleConfigFilePath文件中读取配置文本到configText中</span></span><br><span class="line">    RuleConfig ruleConfig = parser.parse(configText);</span><br><span class="line">    <span class="keyword">return</span> ruleConfig;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> String <span class="title">getFileExtension</span><span class="params">(String filePath)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...解析文件名获取扩展名，比如rule.json，返回json</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"json"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuleConfigParserFactory</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IRuleConfigParser <span class="title">createParser</span><span class="params">(String configFormat)</span> </span>&#123;</span><br><span class="line">    IRuleConfigParser parser = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"json"</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class="line">      parser = <span class="keyword">new</span> JsonRuleConfigParser();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"xml"</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class="line">      parser = <span class="keyword">new</span> XmlRuleConfigParser();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"yaml"</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class="line">      parser = <span class="keyword">new</span> YamlRuleConfigParser();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"properties"</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class="line">      parser = <span class="keyword">new</span> PropertiesRuleConfigParser();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parser;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大部分工厂类都是以 <code>“Factory”</code> 这个单词结尾的，但也不是必须的，比如 <code>Java</code> 中的 <code>DateFormat</code>、<code>Calender</code>。<br>除此之外，工厂类中创建对象的方法一般都是 <code>create</code> 开头，比如代码中的 <code>createParser()</code>，但有的也命名为 <code>getInstance()</code>、<code>createInstance()</code>、<code>newInstance()</code>，有的甚至命名为 <code>valueOf()</code>（比如 <code>Java String</code> 类的 <code>valueOf()</code> 函数）等等。</p><p>我们还可以将单例结合进来，像之前单例中讲的那样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuleConfigParserFactory</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, RuleConfigParser&gt; cachedParsers = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    cachedParsers.put(<span class="string">"json"</span>, <span class="keyword">new</span> JsonRuleConfigParser());</span><br><span class="line">    cachedParsers.put(<span class="string">"xml"</span>, <span class="keyword">new</span> XmlRuleConfigParser());</span><br><span class="line">    cachedParsers.put(<span class="string">"yaml"</span>, <span class="keyword">new</span> YamlRuleConfigParser());</span><br><span class="line">    cachedParsers.put(<span class="string">"properties"</span>, <span class="keyword">new</span> PropertiesRuleConfigParser());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IRuleConfigParser <span class="title">createParser</span><span class="params">(String configFormat)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (configFormat == <span class="keyword">null</span> || configFormat.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">//返回null还是IllegalArgumentException全凭你自己说了算</span></span><br><span class="line">    &#125;</span><br><span class="line">    IRuleConfigParser parser = cachedParsers.get(configFormat.toLowerCase());</span><br><span class="line">    <span class="keyword">return</span> parser;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-工厂方法"><a href="#2-工厂方法" class="headerlink" title="2 工厂方法"></a>2 工厂方法</h1><p>现在在初始化 <code>RuleConfigParserFactory</code>  的时候已经将所有的 <code>Parser</code> 对象都实例化了。我们可以利用多态，延迟初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IRuleConfigParserFactory</span> </span>&#123;</span><br><span class="line">  <span class="function">IRuleConfigParser <span class="title">createParser</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonRuleConfigParserFactory</span> <span class="keyword">implements</span> <span class="title">IRuleConfigParserFactory</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> IRuleConfigParser <span class="title">createParser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> JsonRuleConfigParser();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XmlRuleConfigParserFactory</span> <span class="keyword">implements</span> <span class="title">IRuleConfigParserFactory</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> IRuleConfigParser <span class="title">createParser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> XmlRuleConfigParser();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略YamlConfigParserFactory和PropertiesConfigParserFactory代码</span></span><br></pre></td></tr></table></figure><p>这样当我们新增一种 <code>parser</code> 的时候，只需要新增一个实现了 <code>IRuleConfigParserFactory</code> 接口的 <code>Factory</code> 类即可。<br>所以，工厂方法模式比起简单工厂模式更加符合开闭原则。</p><p>可以仿照 <code>LayoutInflater</code> 中 <code>createService</code> 逻辑实现复用。先调用 <code>getService</code> 去获取有没有缓存，没有再 <code>create</code>。</p><p>我们可以为工厂类再创建一个简单工厂，也就是工厂的工厂，用来创建工厂类对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuleConfigSource</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> RuleConfig <span class="title">load</span><span class="params">(String ruleConfigFilePath)</span> </span>&#123;</span><br><span class="line">    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);</span><br><span class="line"></span><br><span class="line">    IRuleConfigParserFactory parserFactory = RuleConfigParserFactoryMap.getParserFactory(ruleConfigFileExtension);</span><br><span class="line">    <span class="keyword">if</span> (parserFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> InvalidRuleConfigException(<span class="string">"Rule config file format is not supported: "</span> + ruleConfigFilePath);</span><br><span class="line">    &#125;</span><br><span class="line">    IRuleConfigParser parser = parserFactory.createParser();</span><br><span class="line"></span><br><span class="line">    String configText = <span class="string">""</span>;</span><br><span class="line">    <span class="comment">//从ruleConfigFilePath文件中读取配置文本到configText中</span></span><br><span class="line">    RuleConfig ruleConfig = parser.parse(configText);</span><br><span class="line">    <span class="keyword">return</span> ruleConfig;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> String <span class="title">getFileExtension</span><span class="params">(String filePath)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...解析文件名获取扩展名，比如rule.json，返回json</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"json"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//因为工厂类只包含方法，不包含成员变量，完全可以复用，</span></span><br><span class="line"><span class="comment">//不需要每次都创建新的工厂类对象，所以，简单工厂模式的第二种实现思路更加合适。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuleConfigParserFactoryMap</span> </span>&#123; <span class="comment">//工厂的工厂</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, IRuleConfigParserFactory&gt; cachedFactories = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    cachedFactories.put(<span class="string">"json"</span>, <span class="keyword">new</span> JsonRuleConfigParserFactory());</span><br><span class="line">    cachedFactories.put(<span class="string">"xml"</span>, <span class="keyword">new</span> XmlRuleConfigParserFactory());</span><br><span class="line">    cachedFactories.put(<span class="string">"yaml"</span>, <span class="keyword">new</span> YamlRuleConfigParserFactory());</span><br><span class="line">    cachedFactories.put(<span class="string">"properties"</span>, <span class="keyword">new</span> PropertiesRuleConfigParserFactory());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IRuleConfigParserFactory <span class="title">getParserFactory</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (type == <span class="keyword">null</span> || type.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    IRuleConfigParserFactory parserFactory = cachedFactories.get(type.toLowerCase());</span><br><span class="line">    <span class="keyword">return</span> parserFactory;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们需要添加新的规则配置解析器的时候，我们只需要创建新的 <code>parser</code> 类和 <code>parser factory</code> 类，并且在 <code>RuleConfigParserFactoryMap</code> 类中，将新的 <code>parser factory</code> 对象添加到 <code>cachedFactories</code> 中即可。代码的改动非常少，基本上符合开闭原则。</p><p>我们还可以用反射来创建具体工厂，这样就不需要那么多工厂类，传入相应的 <code>JsonRuleConfigParser</code> 或 <code>XmlRuleConfigParser</code> 就可以。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuleConfigParserFactory</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> &lt;T extends IRuleConfigParser&gt; <span class="function">T <span class="title">createParser</span><span class="params">(Class&lt;T&gt; clz)</span></span>&#123;</span><br><span class="line">    IRuleConfigParser parser = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      parser = (IRuleConfigParser) Class.forName(clz.getName()).newInstance();</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-1-工厂方法-Android-实战"><a href="#2-1-工厂方法-Android-实战" class="headerlink" title="2.1 工厂方法 Android 实战"></a>2.1 工厂方法 Android 实战</h2><p>工厂方法模式比较简单，可以在很多编程实战的地方应用到它，以一个数据存储为例，大家知道 <code>Android</code> 数据持久化有很多种方式，可以使用 <code>Android</code> 为我们提供的 <code>SharedPreferences</code> 和 <code>SQLite</code> ，也可以使用常规的文件存储，但是，对数据操作的方法无非就是增、删、改、查，我们可以将每一种数据操作的方式作为一个产品类，在抽象产品类中定义操作的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">IOHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加一条个人信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id 身份证号码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 名字</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String id, String name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除一条个人信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(String id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新一条个人信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String id, String name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询身份证对应的人名字</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">query</span><span class="params">(String id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每一种持久化方式我们定义一个具体的 <code>IO</code> 处理类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileHandler</span> <span class="keyword">extends</span> <span class="title">IOHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String id, String name)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(String id)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String id, String name)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">query</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"file"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XMLHandler</span> <span class="keyword">extends</span> <span class="title">IOHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String id, String name)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(String id)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String id, String name)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">query</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"xml"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里只是 <code>query</code> 做了区分。接下里是工厂类的定义，这里使用反射。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IOFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends IOHandler&gt; <span class="function">T <span class="title">getIOHandler</span><span class="params">(Class&lt;T&gt; clz)</span> </span>&#123;</span><br><span class="line">        IOHandler handler = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            handler = (IOHandler) Class.forName(clz.getName()).newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (T) handler;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后的使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IOHandler handler = IOFactory.getIOHandler(FileHandler<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">handler.query(<span class="string">"handler"</span>);</span><br><span class="line">IOHandler handler2 = IOFactory.getIOHandler(XMLHandler<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">handler2.query(<span class="string">"handler"</span>);</span><br></pre></td></tr></table></figure><p>最后会输出不同的值。</p><h1 id="3-抽象工厂"><a href="#3-抽象工厂" class="headerlink" title="3 抽象工厂"></a>3 抽象工厂</h1><p>抽象工厂模式的应用场景比较特殊，没有前两种常用。</p><p>在简单工厂和工厂方法中，类只有一种分类方式。<br>比如，在规则配置解析那个例子中，解析器类只会根据配置文件格式<code>（Json、Xml、Yaml……）</code>来分类。<br>但是，如果类有两种分类方式，比如，我们既可以按照配置文件格式来分类，也可以按照解析的对象（<code>Rule</code> 规则配置还是 <code>System</code> 系统配置）来分类，那就会对应下面这 <code>8</code> 个 <code>parser</code> 类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">针对规则配置的解析器：基于接口IRuleConfigParser</span><br><span class="line">JsonRuleConfigParser</span><br><span class="line">XmlRuleConfigParser</span><br><span class="line">YamlRuleConfigParser</span><br><span class="line">PropertiesRuleConfigParser</span><br><span class="line"></span><br><span class="line">针对系统配置的解析器：基于接口ISystemConfigParser</span><br><span class="line">JsonSystemConfigParser</span><br><span class="line">XmlSystemConfigParser</span><br><span class="line">YamlSystemConfigParser</span><br><span class="line">PropertiesSystemConfigParser</span><br></pre></td></tr></table></figure><p>如果还是继续用工厂方法来实现的话，我们要针对每个 <code>parser</code> 都编写一个工厂类，也就是要编写 <code>8</code> 个工厂类。</p><p>抽象工厂就是针对这种非常特殊的场景而诞生的。我们可以让一个工厂负责创建多个不同类型的对象（<code>IRuleConfigParser</code>、<code>ISystemConfigParser</code> 等），而不是只创建一种 <code>parser</code> 对象。这样就可以有效地减少工厂类的个数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IConfigParserFactory</span> </span>&#123;</span><br><span class="line">  <span class="function">IRuleConfigParser <span class="title">createRuleParser</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">ISystemConfigParser <span class="title">createSystemParser</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">//此处可以扩展新的parser类型，比如IBizConfigParser</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonConfigParserFactory</span> <span class="keyword">implements</span> <span class="title">IConfigParserFactory</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> IRuleConfigParser <span class="title">createRuleParser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> JsonRuleConfigParser();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ISystemConfigParser <span class="title">createSystemParser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> JsonSystemConfigParser();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XmlConfigParserFactory</span> <span class="keyword">implements</span> <span class="title">IConfigParserFactory</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> IRuleConfigParser <span class="title">createRuleParser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> XmlRuleConfigParser();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ISystemConfigParser <span class="title">createSystemParser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> XmlSystemConfigParser();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略YamlConfigParserFactory和PropertiesConfigParserFactory代码</span></span><br></pre></td></tr></table></figure><h2 id="3-1-抽象工厂-Android-实战"><a href="#3-1-抽象工厂-Android-实战" class="headerlink" title="3.1 抽象工厂 Android 实战"></a>3.1 抽象工厂 Android 实战</h2><p>这里模拟一个车场，分别生产 <code>Q3  Q7</code>是一个车系，但是零部件都不一样。</p><p>首先是轮胎部件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ITire</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 轮胎</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tire</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NormalTire</span> <span class="keyword">implements</span> <span class="title">ITire</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LogUtils.i(<span class="string">"普通轮胎"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SUVTire</span> <span class="keyword">implements</span> <span class="title">ITire</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LogUtils.i(<span class="string">"越野轮胎"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是发动机部件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IEngine</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发动机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">engine</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DomesticEngine</span> <span class="keyword">implements</span> <span class="title">IEngine</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">engine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LogUtils.i(<span class="string">"国产发动机"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImportEngine</span> <span class="keyword">implements</span> <span class="title">IEngine</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">engine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LogUtils.i(<span class="string">"进口发动机"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是制动系统。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IBrake</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 制动系统</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">brake</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NormalBrake</span> <span class="keyword">implements</span> <span class="title">IBrake</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">brake</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LogUtils.i(<span class="string">"普通制动"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeniorBrake</span> <span class="keyword">implements</span> <span class="title">IBrake</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">brake</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LogUtils.i(<span class="string">"高级制动"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后是汽车制造工厂类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CarFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产轮胎</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ITire <span class="title">createTire</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产发动机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> IEngine <span class="title">createEngine</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产制动系统</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> IBrake <span class="title">createBrake</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不同的车间生成不同的车，生产方式一样，但是部件不同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Q3Factory</span> <span class="keyword">extends</span> <span class="title">CarFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ITire <span class="title">createTire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NormalTire();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEngine <span class="title">createEngine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DomesticEngine();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBrake <span class="title">createBrake</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NormalBrake();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Q7Factory</span> <span class="keyword">extends</span> <span class="title">CarFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ITire <span class="title">createTire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SUVTire();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEngine <span class="title">createEngine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ImportEngine();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBrake <span class="title">createBrake</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SeniorBrake();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CarFactory factoryQ3=<span class="keyword">new</span> Q3Factory();</span><br><span class="line">factoryQ3.createTire().tire();</span><br><span class="line">factoryQ3.createEngine().engine();</span><br><span class="line">factoryQ3.createBrake().brake();</span><br></pre></td></tr></table></figure><h1 id="6-Android-源码的工厂模式"><a href="#6-Android-源码的工厂模式" class="headerlink" title="6 Android 源码的工厂模式"></a>6 Android 源码的工厂模式</h1><p>其实平时工作中也偷偷使用着工厂方法模式。以 <code>List</code> 和 <code>Set</code> 为例，<code>List</code> 和 <code>Set</code> 都继承于 <code>Collection</code> 接口，而 <code>Collection</code> 接口继承于 <code>Iterable</code> 接口，<code>Iterable</code> 接口很简单，就一个 <code>iterator</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="function">Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这意味着 <code>List</code> 和 <code>Set</code> 接口也会继承该方法，平时比较常用的两个间接实现类 <code>ArrayList</code> 和 <code>HashSet</code> 中 <code>iterator</code> 方法的实现就是构造并返回一个迭代器对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">int</span> limit = ArrayList.<span class="keyword">this</span>.size;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> cursor;       <span class="comment">// index of next element to return</span></span><br><span class="line">        <span class="keyword">int</span> lastRet = -<span class="number">1</span>; <span class="comment">// index of last element returned; -1 if no such</span></span><br><span class="line">        <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> cursor &lt; limit;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; consumer)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>HashSet</code> 的 <code>iterator</code> 方法中会返回成员变量 <code>map</code> 中对应 <code>HashSet</code> 对象元素的迭代器对象，最终返回的是 <code>KeySet</code> 中的一个迭代器对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.keySet().iterator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;K&gt; <span class="title">iterator</span><span class="params">()</span>     </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> KeyIterator(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ArrayList</code> 和 <code>HashSet HashMap</code>  中的 <code>iterator</code> 方法其实相当于一个工厂方法，专为 <code>new</code> 对象而生，这里 <code>iterator</code> 方法是构造并返回一个具体的迭代器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle bundle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(bundle);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再仔细看 <code>onCreate</code> 方法，感觉也像一个工厂方法模式，因为我们每个 <code>Activity</code> 都会重新 <code>onCreate</code> 设置不同的布局，这不就是一个工厂模式的结构吗？</p><p>关于 <code>onCreate</code> <a href="http://gityuan.com/2016/03/12/start-activity/" target="_blank" rel="noopener">startActivity启动过程分析</a></p><h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a><strong>感谢</strong></h1><blockquote><p><a href="https://time.geekbang.org/column/intro/250?utm_source=pinpaizhuanqu&utm_medium=geektime&utm_campaign=guanwang&utm_term=guanwang&utm_content=0511" target="_blank" rel="noopener">设计模式之美</a></p><p>《Android 源码设计模式解析与实战》</p><p>以及上文中的链接</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-创建型-单例模式</title>
      <link href="/2020/design-pattern-singleton.html"/>
      <url>/2020/design-pattern-singleton.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-为什么要使用单例？"><a href="#1-为什么要使用单例？" class="headerlink" title="1 为什么要使用单例？"></a>1 为什么要使用单例？</h1><p>为什么我们需要单例这种设计模式？它能解决哪些问题？</p><ul><li>处理资源访问冲突</li></ul><p>比如文件访问、数据库访问。</p><p>在多线程环境下，如果两个线程同时给同一个共享变量加 <code>1</code>，因为共享变量是竞争资源，所以，共享变量最后的结果有可能并不是加了 <code>2</code>，而是只加了 <code>1</code>。</p><p>我们可以用<strong>类级别锁</strong>来解决这个问题，因为在不同线程创建不同的对象，所以<strong>对象锁</strong>是没有用的。</p><p>我们还可以使用并发队列 <code>BlockingQueue</code> ，但是实现起来比较麻烦。</p><p>最后比较简单的解决思路就是使用<strong>单例模式</strong>了，<strong>单例模式</strong>相对于之前<strong>类级别锁</strong>的好处是，不用创建那么多对象，一方面节省内存空间，另一方面节省系统文件句柄（对于操作系统来说，文件句柄也是一种资源，不能随便浪费）。</p><p>举个栗子🌰 文件日志，在多线程情况下肯定也会出现上面的问题，线程同时执行，会覆盖前一次的写入。但是单例就没问题了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> FileWriter writer;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger instance = <span class="keyword">new</span> Logger();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Logger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">"/Users/wangzheng/log.txt"</span>);</span><br><span class="line">    writer = <span class="keyword">new</span> FileWriter(file, <span class="keyword">true</span>); <span class="comment">//true表示追加写入</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Logger <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">    writer.write(mesasge);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Logger类的应用示例：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">(String username, String password)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...省略业务逻辑代码...</span></span><br><span class="line">    Logger.getInstance().log(username + <span class="string">" logined!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderController</span> </span>&#123;  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">(OrderVo order)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...省略业务逻辑代码...</span></span><br><span class="line">    Logger.getInstance().log(<span class="string">"Created a order: "</span> + order.toString());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>表示全局唯一类</li></ul><p>从业务概念上，如果有些数据在系统中只应保存一份，那就比较适合设计为单例类。</p><p>举个栗子🌰，唯一递增 <code>ID</code> 号码生成器，如果程序中有两个对象，那就会存在生成重复 ID 的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicLong;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdGenerator</span> </span>&#123;</span><br><span class="line">  <span class="comment">// AtomicLong是一个Java并发库中提供的一个原子变量类型,</span></span><br><span class="line">  <span class="comment">// 它将一些线程不安全需要加锁的复合操作封装为了线程安全的原子操作，</span></span><br><span class="line">  <span class="comment">// 比如下面会用到的incrementAndGet().</span></span><br><span class="line">  <span class="keyword">private</span> AtomicLong id = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> IdGenerator instance = <span class="keyword">new</span> IdGenerator();</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">IdGenerator</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IdGenerator <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> id.incrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IdGenerator使用举例</span></span><br><span class="line"><span class="keyword">long</span> id = IdGenerator.getInstance().getId();</span><br></pre></td></tr></table></figure><h1 id="2-如何实现一个单例？"><a href="#2-如何实现一个单例？" class="headerlink" title="2 如何实现一个单例？"></a>2 如何实现一个单例？</h1><h2 id="2-1-饿汉式"><a href="#2-1-饿汉式" class="headerlink" title="2.1 饿汉式"></a>2.1 饿汉式</h2><p>在类加载的时候，<code>instance</code> 静态实例就已经创建并初始化好了，所以，<code>instance</code> 实例的创建过程是线程安全的。不过，这样的实现方式不支持延迟加载（不是在真正用到 <code>IdGenerator</code> 的时候创建实例），从名字中我们也可以看出这一点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdGenerator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> AtomicLong id = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> IdGenerator instance = <span class="keyword">new</span> IdGenerator();</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">IdGenerator</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IdGenerator <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> id.incrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为不支持延迟加载，导致实例占用资源多（比如占用内存多）或初始化耗时长（比如需要加载各种配置文件），提前初始化实例是一种浪费资源的行为。最好的方法应该在用到的时候再去初始化。有些需要提前初始化的时候可以这样用，在真正使用的时候节省了时间。</p><h2 id="2-2-懒汉式"><a href="#2-2-懒汉式" class="headerlink" title="2.2 懒汉式"></a>2.2 懒汉式</h2><p>有饿汉式，对应的，就有懒汉式。懒汉式相对于饿汉式的优势是支持延迟加载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdGenerator</span> </span>&#123; </span><br><span class="line">  <span class="keyword">private</span> AtomicLong id = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> IdGenerator instance;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">IdGenerator</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> IdGenerator <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">      instance = <span class="keyword">new</span> IdGenerator();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> id.incrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过懒汉式的缺点也很明显，我们给 <code>getInstance()</code> 这个方法加了一把大锁（<code>synchronzed</code>），导致这个函数的并发度很低。<br>如果这个单例类偶尔会被用到，那这种实现方式还可以接受。<br>但是，如果频繁地用到，那频繁加锁、释放锁及并发度低等问题，会导致性能瓶颈，这种实现方式就不可取了。</p><h2 id="2-3-双重检测"><a href="#2-3-双重检测" class="headerlink" title="2.3 双重检测"></a>2.3 双重检测</h2><p>饿汉式不支持延迟加载，懒汉式有性能问题，不支持高并发。那我们再来看一种既支持延迟加载、又支持高并发的单例实现方式，也就是双重检测实现方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdGenerator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> AtomicLong id = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> IdGenerator instance;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">IdGenerator</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IdGenerator <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span>(IdGenerator<span class="class">.<span class="keyword">class</span>) </span>&#123; <span class="comment">// 此处为类级别的锁</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">          instance = <span class="keyword">new</span> IdGenerator();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> id.incrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种实现方式中，只要 <code>instance</code> 被创建之后，即便再调用 <code>getInstance()</code> 函数也不会再进入到加锁逻辑中了。</p><p>这里有一个问题，在低版本 <code>Java</code> 中，因为指令重排序，可能会导致 <code>IdGenerator</code> 对象被 <code>new</code> 出来，并且赋值给 <code>instance</code> 之后，还没来得及初始化（执行构造函数中的代码逻辑），就被另一个线程使用了。<br>要解决这个问题，我们需要给 <code>instance</code> 成员变量加上 <code>volatile</code> 关键字，禁止指令重排序才行。</p><h2 id="2-4-静态内部类"><a href="#2-4-静态内部类" class="headerlink" title="2.4 静态内部类"></a>2.4 静态内部类</h2><p>静态内部类比双重检测更加简单，利用 <code>Java</code> 静态内部类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdGenerator</span> </span>&#123; </span><br><span class="line">  <span class="keyword">private</span> AtomicLong id = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">IdGenerator</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> IdGenerator instance = <span class="keyword">new</span> IdGenerator();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IdGenerator <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SingletonHolder.instance;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> id.incrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有当调用 <code>getInstance()</code> 方法时，<code>SingletonHolder</code> 才会被加载，这个时候才会创建 <code>instance</code>。<code>instance</code> 的唯一性、创建过程的线程安全性，都由 <code>JVM</code> 来保证。所以，这种实现方法既保证了线程安全，又能做到延迟加载。</p><h2 id="2-5-枚举"><a href="#2-5-枚举" class="headerlink" title="2.5 枚举"></a>2.5 枚举</h2><p>还有一种最简单的实现方式，基于枚举类型的单例实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> IdGenerator &#123;</span><br><span class="line">  INSTANCE;</span><br><span class="line">  <span class="keyword">private</span> AtomicLong id = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> id.incrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种实现方式通过 <code>Java</code> 枚举类型本身的特性，保证了实例创建的线程安全性和实例的唯一性。</p><h1 id="3-如何实现线程唯一的单例？"><a href="#3-如何实现线程唯一的单例？" class="headerlink" title="3 如何实现线程唯一的单例？"></a>3 如何实现线程唯一的单例？</h1><p>定义中提到， “一个类只允许创建唯一一个对象” 。那对象的唯一性的作用范围是什么呢？是指线程内只允许创建一个对象，还是指进程内只允许创建一个对象？答案是后者，也就是说，单例模式创建的对象是进程唯一的。</p><p>那如何实现一个线程唯一的单例呢？</p><p>在代码中，我们通过一个 <code>HashMap</code> 来存储对象，其中 <code>key</code> 是线程 <code>ID</code>，<code>value</code> 是对象。这样我们就可以做到，不同的线程对应不同的对象，同一个线程只能对应一个对象。实际上，<code>Java</code> 语言本身提供了 <code>ThreadLocal</code> 工具类，可以更加轻松地实现线程唯一单例。不过，<code>ThreadLocal</code> 底层实现原理也是基于下面代码中所示的 <code>HashMap</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdGenerator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> AtomicLong id = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentHashMap&lt;Long, IdGenerator&gt; instances</span><br><span class="line">          = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">IdGenerator</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IdGenerator <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Long currentThreadId = Thread.currentThread().getId();</span><br><span class="line">    instances.putIfAbsent(currentThreadId, <span class="keyword">new</span> IdGenerator());</span><br><span class="line">    <span class="keyword">return</span> instances.get(currentThreadId);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> id.incrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-单例存在哪些问题"><a href="#4-单例存在哪些问题" class="headerlink" title="4 单例存在哪些问题?"></a>4 单例存在哪些问题?</h1><p>大部分情况下，我们在项目中使用单例，都是用它来表示一些全局唯一类，比如配置信息类、公共类等。<br>单例模式书写简洁、使用方便，在代码中，我们不需要创建对象，直接通过类似 <code>IdGenerator.getInstance().getId()</code> 这样的方法来调用就可以了。<br>但是，这种使用方法有点类似硬编码（<code>hard code</code>），会带来诸多问题。</p><h2 id="4-1-单例对代码的扩展性不友好"><a href="#4-1-单例对代码的扩展性不友好" class="headerlink" title="4.1 单例对代码的扩展性不友好"></a>4.1 单例对代码的扩展性不友好</h2><p>单例这种设计模式对于抽象、继承、多态都支持得不好。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">long</span> id = IdGenerator.getInstance().getId();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">long</span> id = IdGenerator.getInstance().getId();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果未来某一天，我们希望针对不同的业务采用不同的 <code>ID</code> 生成算法。比如，订单 <code>ID</code> 和用户 <code>ID</code> 采用不同的 <code>ID</code> 生成器来生成。为了应对这个需求变化，我们需要修改所有用到 <code>IdGenerator</code> 类的地方，这样代码的改动就会比较大。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">long</span> id = IdGenerator.getInstance().getId();</span><br><span class="line">    <span class="comment">// 需要将上面一行代码，替换为下面一行代码</span></span><br><span class="line">    <span class="keyword">long</span> id = OrderIdGenerator.getIntance().getId();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">long</span> id = IdGenerator.getInstance().getId();</span><br><span class="line">    <span class="comment">// 需要将上面一行代码，替换为下面一行代码</span></span><br><span class="line">    <span class="keyword">long</span> id = UserIdGenerator.getIntance().getId();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-2-单例对代码的可测试性不友好"><a href="#4-2-单例对代码的可测试性不友好" class="headerlink" title="4.2 单例对代码的可测试性不友好"></a>4.2 单例对代码的可测试性不友好</h2><p>单例模式的使用会影响到代码的可测试性。如果单例类依赖比较重的外部资源，比如 <code>DB</code>，我们在写单元测试的时候，希望能通过 <code>mock</code> 的方式将它替换掉。而单例类这种硬编码式的使用方式，导致无法实现 <code>mock</code> 替换。</p><p>除此之外，如果单例类持有成员变量（比如 <code>IdGenerator</code> 中的 <code>id</code> 成员变量），那它实际上相当于一种全局变量，被所有的代码共享。如果这个全局变量是一个可变全局变量，也就是说，它的成员变量是可以被修改的，那我们在编写单元测试的时候，还需要注意不同测试用例之间，修改了单例类中的同一个成员变量的值，从而导致测试结果互相影响的问题。</p><h1 id="5-如何实现一个多例模式？"><a href="#5-如何实现一个多例模式？" class="headerlink" title="5 如何实现一个多例模式？"></a>5 如何实现一个多例模式？</h1><p>跟单例模式概念相对应的还有一个多例模式。那如何实现一个多例模式呢？</p><p>“单例” 指的是，一个类只能创建一个对象。对应地，“多例” 指的就是，一个类可以创建多个对象，但是个数是有限制的，比如只能创建 <code>3</code> 个对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BackendServer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> serverNo;</span><br><span class="line">  <span class="keyword">private</span> String serverAddress;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SERVER_COUNT = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Long, BackendServer&gt; serverInstances = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    serverInstances.put(<span class="number">1L</span>, <span class="keyword">new</span> BackendServer(<span class="number">1L</span>, <span class="string">"192.134.22.138:8080"</span>));</span><br><span class="line">    serverInstances.put(<span class="number">2L</span>, <span class="keyword">new</span> BackendServer(<span class="number">2L</span>, <span class="string">"192.134.22.139:8080"</span>));</span><br><span class="line">    serverInstances.put(<span class="number">3L</span>, <span class="keyword">new</span> BackendServer(<span class="number">3L</span>, <span class="string">"192.134.22.140:8080"</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">BackendServer</span><span class="params">(<span class="keyword">long</span> serverNo, String serverAddress)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.serverNo = serverNo;</span><br><span class="line">    <span class="keyword">this</span>.serverAddress = serverAddress;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> BackendServer <span class="title">getInstance</span><span class="params">(<span class="keyword">long</span> serverNo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> serverInstances.get(serverNo);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> BackendServer <span class="title">getRandomInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Random r = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">int</span> no = r.nextInt(SERVER_COUNT)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> serverInstances.get(no);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一种理解方式：同一类型的只能创建一个对象，不同类型的可以创建多个对象。这里的 “类型” 如何理解呢？</p><p>在代码中，<code>logger name</code> 就是刚刚说的 “类型” ，同一个 <code>logger name</code> 获取到的对象实例是相同的，不同的 <code>logger name</code> 获取到的对象实例是不同的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, Logger&gt; instances</span><br><span class="line">          = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Logger</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Logger <span class="title">getInstance</span><span class="params">(String loggerName)</span> </span>&#123;</span><br><span class="line">    instances.putIfAbsent(loggerName, <span class="keyword">new</span> Logger());</span><br><span class="line">    <span class="keyword">return</span> instances.get(loggerName);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//l1==l2, l1!=l3</span></span><br><span class="line">Logger l1 = Logger.getInstance(<span class="string">"User.class"</span>);</span><br><span class="line">Logger l2 = Logger.getInstance(<span class="string">"User.class"</span>);</span><br><span class="line">Logger l3 = Logger.getInstance(<span class="string">"Order.class"</span>);</span><br></pre></td></tr></table></figure><p>这种多例模式的理解方式有点类似工厂模式。<br>它跟工厂模式的不同之处是，多例模式创建的对象都是同一个类的对象，而工厂模式创建的是不同子类的对象</p><p>在上面的问题中如果 <code>IdGenerator</code> 分为 <code>OrderIdGenerator</code> 和 <code>UserIdGenerator</code> ，有什么办法解决呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IIdGenerator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Order实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderIdGenerator</span> <span class="keyword">implements</span> <span class="title">IIdGenerator</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//User实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserIdGenerator</span> <span class="keyword">implements</span> <span class="title">IIdGenerator</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//多例操作类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdGeneratorPresenter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Long, IIdGenerator&gt; imgInstances = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Long ORDER = <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Long USER = <span class="number">2L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        imgInstances.put(ORDER, <span class="keyword">new</span> OrderIdGenerator());</span><br><span class="line">        imgInstances.put(USER, <span class="keyword">new</span> UserIdGenerator());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IIdGenerator <span class="title">getInstance</span><span class="params">(Long type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> imgInstances.get(type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">IdGeneratorPresenter.getInstance(IdGeneratorPresenter.ORDER).getId()</span><br><span class="line">IdGeneratorPresenter.getInstance(IdGeneratorPresenter.USER).getId()</span><br></pre></td></tr></table></figure><p>类似于简单工厂和单例的结合。</p><h1 id="6-Android-源码中的单例模式实现"><a href="#6-Android-源码中的单例模式实现" class="headerlink" title="6 Android 源码中的单例模式实现"></a>6 Android 源码中的单例模式实现</h1><p>我们来看看 <code>LayoutInflater</code> 是如何拿到的。</p><p>通常我们使用 <code>LayoutInflater.from(Context)</code> 来获取 <code>LayoutInflater</code> 服务, 下面我们看看 <code>LayoutInflater.from(Context)</code> 的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Obtains the LayoutInflater from the given context.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LayoutInflater <span class="title">from</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    LayoutInflater LayoutInflater =(LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);</span><br><span class="line">    <span class="keyword">if</span> (LayoutInflater == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"LayoutInflater not found."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> LayoutInflater;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 <code>from(Context)</code> 函数内部调用的是 <code>Context</code> 类的 <code>getSystemService(String key)</code> 方法，我们跟踪到 <code>Context</code> 类看到，该类是抽象类。<code>Context</code>的实现类为 <code>ComtextImpl</code> 类。我们继续跟踪到 <code>ContextImpl</code> 类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSystemService</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SystemServiceRegistry.getSystemService(<span class="keyword">this</span>, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看 <code>SystemServiceRegistry</code> 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 : service容器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HashMap&lt;String, ServiceFetcher&lt;?&gt;&gt; SYSTEM_SERVICE_FETCHERS =</span><br><span class="line">          <span class="keyword">new</span> HashMap&lt;String, ServiceFetcher&lt;?&gt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2: 注册服务器</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">registerService</span><span class="params">(String serviceName, Class&lt;T&gt; serviceClass,</span></span></span><br><span class="line"><span class="function"><span class="params">          ServiceFetcher&lt;T&gt; serviceFetcher)</span> </span>&#123;</span><br><span class="line">      SYSTEM_SERVICE_NAMES.put(serviceClass, serviceName);</span><br><span class="line">      SYSTEM_SERVICE_FETCHERS.put(serviceName, serviceFetcher);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3: 静态语句块, 第一次加载该类时执行 ( 只执行一次, 保证实例的唯一性. )</span></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">      <span class="comment">//  代码省略</span></span><br><span class="line">      <span class="comment">// 注册Activity Servicer</span></span><br><span class="line">      registerService(Context.ACTIVITY_SERVICE, ActivityManager<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line"><span class="class">              <span class="title">new</span> <span class="title">CachedServiceFetcher</span>&lt;<span class="title">ActivityManager</span>&gt;() </span>&#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> ActivityManager <span class="title">createService</span><span class="params">(ContextImpl ctx)</span> </span>&#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">new</span> ActivityManager(ctx.getOuterContext(), ctx.mMainThread.getHandler());</span><br><span class="line">          &#125;&#125;);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 注册LayoutInflater service</span></span><br><span class="line">registerService(Context.LAYOUT_INFLATER_SERVICE, LayoutInflater<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line"><span class="class">              <span class="title">new</span> <span class="title">CachedServiceFetcher</span>&lt;<span class="title">LayoutInflater</span>&gt;() </span>&#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> LayoutInflater <span class="title">createService</span><span class="params">(ContextImpl ctx)</span> </span>&#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">new</span> PhoneLayoutInflater(ctx.getOuterContext());</span><br><span class="line">        &#125;&#125;);</span><br><span class="line">      <span class="comment">// ....代码省略</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4: 根据key获取对应的服务, </span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getSystemService</span><span class="params">(ContextImpl ctx, String name)</span> </span>&#123;</span><br><span class="line">      ServiceFetcher&lt;?&gt; fetcher = SYSTEM_SERVICE_FETCHERS.get(name);</span><br><span class="line">      <span class="keyword">return</span> fetcher != <span class="keyword">null</span> ? fetcher.getService(ctx) : <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>从 <code>ContextImpl</code> 类的部分代码中可以看到，在虚拟机第一次加载该类时会注册各种服务，其中就包含了 <code>LayoutInflater Service</code>，将这些服务以键值对的形式存储在一个 <code>HashMap</code> 中，用户使用时只需要根据 <code>key</code> 来获取到对应的服务，从而达到单例的效果。</p><p>源码中和我之前写的 <code>IIdGenerator</code> 类似<br>但是源码在初始化的时候并没有真正的 <code>new PhoneLayoutInflater()</code> 而在 <code>getSystemService</code> 的时候才去创建实例（ <code>getService</code> 中的 <code>service</code> 不会创建第二次），所以我之前写的代码还可以优化延迟加载。<br>源码中在实例化的时候封装了一层属于<strong>多对象单例</strong>，我写的属于利用多态实现的<strong>单对象多例</strong>。</p><p>系统核心服务以单例形式存在，并且延迟加载，减少了资源消耗。再次为源码点赞！</p><h1 id="7-总结"><a href="#7-总结" class="headerlink" title="7 总结"></a>7 总结</h1><p><strong>优点</strong></p><ul><li>由于单例模式在内存中只有一个实例，减少了内存开支，特别是一个对象需要频繁地创建、销毁时，而且创建或销毁时性能又无法优化，单例模式的优势就非常明显。</li><li>由于单例模式只生成一个实例，所以减少了系统的性能开销，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后用永久驻留内存的方式来解决；</li><li>单例模式可以避免对资源的多重占用，例如一个写文件动作，由于只有一个实例存在内存中，避免对同一个资源文件的同时写操作。</li><li>单例模式可以在系统设置全局的访问点，优化和共享资源访问，例如可以设计一个单例类，负责所有数据表的映射处理。</li></ul><p><strong>缺点</strong></p><ul><li>单例模式一般没有接口，扩展很困难，若要扩展，除了修改代码基本上没有第二种途径可以实现。</li></ul><h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a><strong>感谢</strong></h1><blockquote><p><a href="https://time.geekbang.org/column/intro/250?utm_source=pinpaizhuanqu&utm_medium=geektime&utm_campaign=guanwang&utm_term=guanwang&utm_content=0511" target="_blank" rel="noopener">设计模式之美</a></p><p>《Android 源码设计模式解析与实战》</p><p>以及上文中的链接</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-编码规范篇</title>
      <link href="/2020/code-standards.html"/>
      <url>/2020/code-standards.html</url>
      
        <content type="html"><![CDATA[<h1 id="本文主要记载"><a href="#本文主要记载" class="headerlink" title="本文主要记载"></a>本文主要记载</h1><ul><li>1 命名多长最合适？</li><li>2 利用上下文简化命名</li><li>3 命名要可读、可搜索</li><li>4 如何命名接口和抽象类？</li><li>5 注释到底该写什么？</li><li>6 注释是不是越多越好？</li><li>7 类、函数多大才合适？</li><li>8 一行代码多长最合适？</li><li>9 善用空行分割单元块</li><li>10 四格缩进还是两格缩进？</li><li>11 大括号是否要另起一行？</li><li>12 类中成员的排列顺序</li><li>13 把代码分割成更小的单元块</li><li>14 避免函数参数过多</li><li>15 勿用函数参数来控制逻辑</li><li>16 函数设计要职责单一</li><li>17 移除过深的嵌套层次</li><li>18 常量取代魔法数字</li><li>19 使用解释性变量来解释复杂表达式</li><li>20 统一编码规范</li></ul><p>编码规范大部分都简单明了，在代码细节方面，能立竿见影地改善质量。</p><h1 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h1><p>大到项目名、模块名、包名、对外暴露的接口，小到类名、函数名、变量名、参数名，只要是做开发，我们就逃不过“起名字”这一关。<br>命名的好坏，对于代码的可读性来说非常重要，甚至可以说是起决定性作用的。<br>除此之外，命名能力也体现了一个程序员的基本编程素养。</p><p>那具体应该怎么命名呢？好的命名有啥标准吗？</p><h2 id="1-命名多长最合适？"><a href="#1-命名多长最合适？" class="headerlink" title="1 命名多长最合适？"></a>1 命名多长最合适？</h2><p>有的人喜欢很长的命名方式，觉得命名一定要准确达意，哪怕长一点也没关系，所以，这类同事的项目里，类名、函数名都很长。<br>有的人喜欢短的命名方式，能用缩写就尽量用缩写，所以，项目里到处都是包含各种缩写的命名。<br>这两种命名方式，哪种更值得推荐呢？</p><p>实际上，在足够表达其含义的情况下，命名当然是越短越好。但是，大部分情况下，短的命名都没有长的命名更能达意。<br>可以使用大家都熟知的缩写，比如，<code>sec</code> 表示 <code>second</code>、<code>str</code> 表示 <code>string</code>、<code>num</code> 表示 <code>number</code>、<code>doc</code> 表示 <code>document</code>。<br>对于作用域比较小的变量，我们可以使用相对短的命名，比如一些函数内的临时变量。<br>相反，对于类名这种作用域比较大的，我更推荐用长的命名方式。</p><p>总之，命名的一个原则就是可以能够准确达意思为目标。<br>命名的时候，我们一定要学会换位思考，假设自己不熟悉这块代码，从代码阅读者的角度去考量命名是否足够直观。</p><h2 id="2-利用上下文简化命名"><a href="#2-利用上下文简化命名" class="headerlink" title="2 利用上下文简化命名"></a>2 利用上下文简化命名</h2><p>看一个简单的例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String userName;</span><br><span class="line">  <span class="keyword">private</span> String userPassword;</span><br><span class="line">  <span class="keyword">private</span> String userAvatarUrl;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>User</code> 类这样一个上下文中，我们没有在成员变量的命名中重复添加 “user” 这样一个前缀单词，而是直接命名为 <code>name</code>、<code>password</code>、<code>avatarUrl</code>。<br>在使用这些属性时候，我们能借助对象这样一个上下文，表意也足够明确。<br>具体代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line">user.getName(); <span class="comment">// 借助user对象这个上下文</span></span><br></pre></td></tr></table></figure><p>除了类之外，函数参数也可以借助函数这个上下文来简化命名。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uploadUserAvatarImageToAliyun</span><span class="params">(String userAvatarImageUri)</span></span>;</span><br><span class="line"><span class="comment">//利用上下文简化为：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uploadUserAvatarImageToAliyun</span><span class="params">(String imageUri)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="3-命名要可读、可搜索"><a href="#3-命名要可读、可搜索" class="headerlink" title="3 命名要可读、可搜索"></a>3 命名要可读、可搜索</h2><p>这里所说的 “可读” ，指的是不要用一些特别生僻、难发音的英文单词来命名。</p><p>这个单词最好是简单的，你不一定知道它表示什么意思，但基本上都能读得上来，不影响沟通交流，这就算是一个比较好的命名。</p><p>我们在命名的时候，统一规约是很重要的，能减少很多不必要的麻烦。<br>大家都用 <code>“selectXXX”</code> 表示查询，你就不要用 <code>“queryXXX”</code> ；大家都用 <code>“insertXXX”</code> 表示插入一条数据，你就要不用 <code>“addXXX”</code> </p><h2 id="4-如何命名接口和抽象类？"><a href="#4-如何命名接口和抽象类？" class="headerlink" title="4 如何命名接口和抽象类？"></a>4 如何命名接口和抽象类？</h2><p>对于接口的命名，一般有两种比较常见的方式。一种是加前缀 <code>“I”</code> ，表示一个 <code>Interface</code> 。比如 <code>IUserService</code> ，对应的实现类命名为 <code>UserService</code> 。另一种是不加前缀，比如 <code>UserService</code> ，对应的实现类加后缀 <code>“Impl”</code> ，比如 <code>UserServiceImpl</code>。</p><p>对于抽象类的命名，也有两种方式，一种是带上前缀 <code>“Abstract”</code>，比如 <code>AbstractConfiguration</code>；另一种是不带前缀 <code>“Abstract”</code>。实际上，对于接口和抽象类，选择哪种命名方式都是可以的，只要项目里能够统一就行。</p><h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p>命名很重要，注释跟命名同等重要。<br>很多书籍认为，好的命名完全可以替代注释。如果需要注释，那说明命名不够好，需要在命名上下功夫，而不是添加注释。<br>但是命名再好，毕竟有长度限制，不可能足够详尽，而这个时候，注释就是一个很好的补充。</p><h2 id="5-注释到底该写什么？"><a href="#5-注释到底该写什么？" class="headerlink" title="5 注释到底该写什么？"></a>5 注释到底该写什么？</h2><p>注释的目的就是让代码更容易看懂。只要符合这个要求的内容，你就可以将它写到注释里。<br>总结一下，注释的内容主要包含这样三个方面：做什么<code>（what）</code>、为什么<code>（why）</code>、怎么做<code>（how）</code>。</p><p>对于一些复杂的类和接口，我们可能还需要写明 “如何用” 。</p><h2 id="6-注释是不是越多越好？"><a href="#6-注释是不是越多越好？" class="headerlink" title="6 注释是不是越多越好？"></a>6 注释是不是越多越好？</h2><p>注释太多和太少都有问题。<br>太多，有可能意味着代码写得不够可读，需要写很多注释来补充。除此之外，注释太多也会对代码本身的阅读起到干扰。而且，后期的维护成本也比较高，有时候代码改了，注释忘了同步修改，就会让代码阅读者更加迷惑。<br>如果代码中一行注释都没有，那只能说明这个程序员很懒，我们要适当督促一下，让他注意添加一些必要的注释。</p><p>类和函数一定要写注释，而且要写得尽可能全面、详细，而函数内部的注释要相对少一些，一般都是靠好的命名、提炼函数、解释性变量、总结性注释来提高代码的可读性。</p><h1 id="代码风格"><a href="#代码风格" class="headerlink" title="代码风格"></a>代码风格</h1><h2 id="7-类、函数多大才合适？"><a href="#7-类、函数多大才合适？" class="headerlink" title="7 类、函数多大才合适？"></a>7 类、函数多大才合适？</h2><p>总体上来讲，类或函数的代码行数不能太多，但也不能太少。<br>类或函数的代码行数太多，一个类上千行，一个函数几百行，逻辑过于繁杂，阅读代码的时候，很容易就会看了后面忘了前面。<br>相反，类或函数的代码行数太少，在代码总量相同的情况下，被分割成的类和函数就会相应增多，调用关系就会变得更复杂，阅读某个代码逻辑的时候，需要频繁地在 <code>n</code> 多类或者 <code>n</code> 多函数之间跳来跳去，阅读体验也不好。</p><p>对于函数代码行数的最大限制，网上有一种说法，那就是不要超过一个显示屏的垂直高度。<br>比如，在我的电脑上，如果要让一个函数的代码完整地显示在 <code>IDE</code> 中，那最大代码行数不能超过 <code>50</code><br>因为超过一屏之后，在阅读代码的时候，为了串联前后的代码逻辑，就可能需要频繁地上下滚动屏幕，阅读体验不好不说，还容易出错。</p><h2 id="8-一行代码多长最合适？"><a href="#8-一行代码多长最合适？" class="headerlink" title="8 一行代码多长最合适？"></a>8 一行代码多长最合适？</h2><p>在 <a href="https://google.github.io/styleguide/javaguide.html" target="_blank" rel="noopener">Google Java Style Guide</a> 文档中，一行代码最长限制为 <code>100</code> 个字符。<br>不过，不同的编程语言、不同的规范、不同的项目团队，对此的限制可能都不相同。<br>不管这个限制是多少，总体上来讲要遵循的一个原则是：一行代码最长不能超过 <code>IDE</code> 显示的宽度。需要滚动鼠标才能查看一行的全部代码，显然不利于代码的阅读。当然，这个限制也不能太小，太小会导致很多稍长点的语句被折成两行，也会影响到代码的整洁，不利于阅读。</p><h2 id="9-善用空行分割单元块"><a href="#9-善用空行分割单元块" class="headerlink" title="9 善用空行分割单元块"></a>9 善用空行分割单元块</h2><p>对于比较长的函数，如果逻辑上可以分为几个独立的代码块，在不方便将这些独立的代码块抽取成小函数的情况下，为了让逻辑更加清晰，除了之前提到的用注释的方法之外，我们还可以使用空行来分割各个代码块。</p><p>除此之外，在类的成员变量与函数之间、静态成员变量与普通成员变量之间、各函数之间、甚至各成员变量之间，我们都可以通过添加空行的方式，让这些不同模块的代码之间，界限更加明确。写代码就类似写文章，善于应用空行，可以让代码的整体结构看起来更加有清晰、有条理。</p><h2 id="10-四格缩进还是两格缩进？"><a href="#10-四格缩进还是两格缩进？" class="headerlink" title="10 四格缩进还是两格缩进？"></a>10 四格缩进还是两格缩进？</h2><h2 id="11-大括号是否要另起一行？"><a href="#11-大括号是否要另起一行？" class="headerlink" title="11 大括号是否要另起一行？"></a>11 大括号是否要另起一行？</h2><h2 id="12-类中成员的排列顺序"><a href="#12-类中成员的排列顺序" class="headerlink" title="12 类中成员的排列顺序"></a>12 类中成员的排列顺序</h2><p>因为是代码风格，所以每个人意见都是不同的，只要团队统一、自己看着舒服就好，项目里添加统一的 <code>format</code> 规则，格式化后显示相同代码<br>然后有一个叫 <code>Alibaba Java Coding Guidelines</code> 的插件，可以按照插件中的要求编码。</p><h1 id="编程技巧"><a href="#编程技巧" class="headerlink" title="编程技巧"></a>编程技巧</h1><h2 id="13-把代码分割成更小的单元块"><a href="#13-把代码分割成更小的单元块" class="headerlink" title="13 把代码分割成更小的单元块"></a>13 把代码分割成更小的单元块</h2><p>大部分人阅读代码的习惯都是，先看整体再看细节。<br>所以，我们要有模块化和抽象思维，善于将大块的复杂逻辑提炼成类或者函数，屏蔽掉细节，让阅读代码的人不至于迷失在细节中，这样能极大地提高代码的可读性。<br>不过，只有代码逻辑比较复杂的时候，我们其实才建议提炼类或者函数。毕竟如果提炼出的函数只包含两三行代码，在阅读代码的时候，还得跳过去看一下，这样反倒增加了阅读成本。</p><p>举个栗子🌰</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重构前的代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invest</span><span class="params">(<span class="keyword">long</span> userId, <span class="keyword">long</span> financialProductId)</span> </span>&#123;</span><br><span class="line">  Calendar calendar = Calendar.getInstance();</span><br><span class="line">  calendar.setTime(date);</span><br><span class="line">  calendar.set(Calendar.DATE, (calendar.get(Calendar.DATE) + <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">if</span> (calendar.get(Calendar.DAY_OF_MONTH) == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重构后的代码：提炼函数之后逻辑更加清晰</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invest</span><span class="params">(<span class="keyword">long</span> userId, <span class="keyword">long</span> financialProductId)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isLastDayOfMonth(<span class="keyword">new</span> Date())) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLastDayOfMonth</span><span class="params">(Date date)</span> </span>&#123;</span><br><span class="line">  Calendar calendar = Calendar.getInstance();</span><br><span class="line">  calendar.setTime(date);</span><br><span class="line">  calendar.set(Calendar.DATE, (calendar.get(Calendar.DATE) + <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">if</span> (calendar.get(Calendar.DAY_OF_MONTH) == <span class="number">1</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码重构之后，我们将这部分逻辑抽象成一个函数，并且命名为 <code>isLastDayOfMonth</code>，从名字就能清晰地了解它的功能，判断今天是不是当月的最后一天。这里，我们就是通过将复杂的逻辑代码提炼成函数，大大提高了代码的可读性。</p><h2 id="14-避免函数参数过多"><a href="#14-避免函数参数过多" class="headerlink" title="14 避免函数参数过多"></a>14 避免函数参数过多</h2><p>参数过多，会影响到代码的可读性，使用起来也不方便。针对参数过多的情况，一般有 2 种处理方法。</p><ul><li><p>考虑函数是否职责单一，是否能通过拆分成多个函数的方式来减少参数。示例代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(String username, String telephone, String email)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拆分成多个函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUserByUsername</span><span class="params">(String username)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUserByTelephone</span><span class="params">(String telephone)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUserByEmail</span><span class="params">(String email)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>将函数的参数封装成对象。</p><p>如果函数是对外暴露的远程接口，将参数封装成对象，还可以提高接口的兼容性。在往接口中添加新的参数的时候，老的远程接口调用者有可能就不需要修改代码来兼容新的接口了。</p></li></ul><h2 id="15-勿用函数参数来控制逻辑"><a href="#15-勿用函数参数来控制逻辑" class="headerlink" title="15 勿用函数参数来控制逻辑"></a>15 勿用函数参数来控制逻辑</h2><p>不要在函数中使用布尔类型的标识参数来控制内部逻辑，<code>true</code> 的时候走这块逻辑，<code>false</code> 的时候走另一块逻辑。<br>这明显违背了单一职责原则和接口隔离原则。<br>可以将其拆成两个函数，可读性上也要更好。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buyCourse</span><span class="params">(<span class="keyword">long</span> userId, <span class="keyword">long</span> courseId, <span class="keyword">boolean</span> isVip)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将其拆分成两个函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buyCourse</span><span class="params">(<span class="keyword">long</span> userId, <span class="keyword">long</span> courseId)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buyCourseForVip</span><span class="params">(<span class="keyword">long</span> userId, <span class="keyword">long</span> courseId)</span></span>;</span><br></pre></td></tr></table></figure><p>还有一种 “根据参数是否为 <code>null</code>” 来控制逻辑的情况。<br>针对这种情况，我们也应该将其拆分成多个函数。拆分之后的函数职责更明确，不容易用错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Transaction&gt; <span class="title">selectTransactions</span><span class="params">(Long userId, Date startDate, Date endDate)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (startDate != <span class="keyword">null</span> &amp;&amp; endDate != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 查询两个时间区间的transactions</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (startDate != <span class="keyword">null</span> &amp;&amp; endDate == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 查询startDate之后的所有transactions</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (startDate == <span class="keyword">null</span> &amp;&amp; endDate != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 查询endDate之前的所有transactions</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (startDate == <span class="keyword">null</span> &amp;&amp; endDate == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 查询所有的transactions</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拆分成多个public函数，更加清晰、易用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Transaction&gt; <span class="title">selectTransactionsBetween</span><span class="params">(Long userId, Date startDate, Date endDate)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> selectTransactions(userId, startDate, endDate);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Transaction&gt; <span class="title">selectTransactionsStartWith</span><span class="params">(Long userId, Date startDate)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> selectTransactions(userId, startDate, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Transaction&gt; <span class="title">selectTransactionsEndWith</span><span class="params">(Long userId, Date endDate)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> selectTransactions(userId, <span class="keyword">null</span>, endDate);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Transaction&gt; <span class="title">selectAllTransactions</span><span class="params">(Long userId)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> selectTransactions(userId, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;Transaction&gt; <span class="title">selectTransactions</span><span class="params">(Long userId, Date startDate, Date endDate)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="16-函数设计要职责单一"><a href="#16-函数设计要职责单一" class="headerlink" title="16 函数设计要职责单一"></a>16 函数设计要职责单一</h2><p>单一职责原则针对的是类、模块这样的应用对象。<br>实际上，对于函数的设计来说，更要满足单一职责原则。相对于类和模块，函数的粒度比较小，代码行数少，所以在应用单一职责原则的时候，没有像应用到类或者模块那样模棱两可，能多单一就多单一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkUserIfExisting</span><span class="params">(String telephone, String username, String email)</span>  </span>&#123; </span><br><span class="line">  <span class="keyword">if</span> (!StringUtils.isBlank(telephone)) &#123;</span><br><span class="line">    User user = userRepo.selectUserByTelephone(telephone);</span><br><span class="line">    <span class="keyword">return</span> user != <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (!StringUtils.isBlank(username)) &#123;</span><br><span class="line">    User user = userRepo.selectUserByUsername(username);</span><br><span class="line">    <span class="keyword">return</span> user != <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (!StringUtils.isBlank(email)) &#123;</span><br><span class="line">    User user = userRepo.selectUserByEmail(email);</span><br><span class="line">    <span class="keyword">return</span> user != <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拆分成三个函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkUserIfExistingByTelephone</span><span class="params">(String telephone)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkUserIfExistingByUsername</span><span class="params">(String username)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkUserIfExistingByEmail</span><span class="params">(String email)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="17-移除过深的嵌套层次"><a href="#17-移除过深的嵌套层次" class="headerlink" title="17 移除过深的嵌套层次"></a>17 移除过深的嵌套层次</h2><ul><li><p>去掉多余的 <code>if</code> 或 <code>else</code> 语句。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例一</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">caculateTotalAmount</span><span class="params">(List&lt;Order&gt; orders)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (orders == <span class="keyword">null</span> || orders.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 此处的else可以去掉</span></span><br><span class="line">    <span class="keyword">double</span> amount = <span class="number">0.0</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> amount;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例二</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">matchStrings</span><span class="params">(List&lt;String&gt; strList,String substr)</span> </span>&#123;</span><br><span class="line">  List&lt;String&gt; matchedStrings = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">if</span> (strList != <span class="keyword">null</span> &amp;&amp; substr != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (String str : strList) &#123;</span><br><span class="line">      <span class="keyword">if</span> (str != <span class="keyword">null</span>) &#123; <span class="comment">// 跟下面的if语句可以合并在一起</span></span><br><span class="line">        <span class="keyword">if</span> (str.contains(substr)) &#123;</span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> matchedStrings;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用编程语言提供的 <code>continue</code>、<code>break</code>、<code>return</code> 关键字，提前退出嵌套。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重构后的代码：使用continue提前退出</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">matchStrings</span><span class="params">(List&lt;String&gt; strList,String substr)</span> </span>&#123;</span><br><span class="line">  List&lt;String&gt; matchedStrings = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">if</span> (strList != <span class="keyword">null</span> &amp;&amp; substr != <span class="keyword">null</span>)&#123; </span><br><span class="line">    <span class="keyword">for</span> (String str : strList) &#123;</span><br><span class="line">      <span class="keyword">if</span> (str == <span class="keyword">null</span> || !str.contains(substr)) &#123;</span><br><span class="line">        <span class="keyword">continue</span>; </span><br><span class="line">      &#125;</span><br><span class="line">      matchedStrings.add(str);</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> matchedStrings;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>调整执行顺序来减少嵌套。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重构后的代码：使用continue提前退出</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">matchStrings</span><span class="params">(List&lt;String&gt; strList,String substr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (strList == <span class="keyword">null</span> || substr == <span class="keyword">null</span>) &#123;<span class="comment">//先判空 </span></span><br><span class="line">    <span class="keyword">return</span> Collections.emptyList(); </span><br><span class="line">  &#125;</span><br><span class="line">  List&lt;String&gt; matchedStrings = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (String str : strList) &#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span> || !str.contains(substr)) &#123;</span><br><span class="line">      <span class="keyword">continue</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    matchedStrings.add(str);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> matchedStrings;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将部分嵌套逻辑封装成函数调用，以此来减少嵌套。</p></li><li><p>常用的还有通过使用多态来替代 if-else、switch-case 条件判断的方法。</p></li></ul><h2 id="18-常量取代魔法数字"><a href="#18-常量取代魔法数字" class="headerlink" title="18 常量取代魔法数字"></a>18 常量取代魔法数字</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">CalculateCircularArea</span><span class="params">(<span class="keyword">double</span> radius)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="number">3.1415</span>) * radius * radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常量替代魔法数字</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Double PI = <span class="number">3.1415</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">CalculateCircularArea</span><span class="params">(<span class="keyword">double</span> radius)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> PI * radius * radius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="19-使用解释性变量来解释复杂表达式"><a href="#19-使用解释性变量来解释复杂表达式" class="headerlink" title="19 使用解释性变量来解释复杂表达式"></a>19 使用解释性变量来解释复杂表达式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (date.after(SUMMER_START) &amp;&amp; date.before(SUMMER_END)) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入解释性变量后逻辑更加清晰</span></span><br><span class="line"><span class="keyword">boolean</span> isSummer = date.after(SUMMER_START)&amp;&amp;date.before(SUMMER_END);</span><br><span class="line"><span class="keyword">if</span> (isSummer) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="20-统一编码规范"><a href="#20-统一编码规范" class="headerlink" title="20 统一编码规范"></a>20 统一编码规范</h2><p>最后，还有一条非常重要的，那就是，项目、团队，甚至公司，一定要制定统一的编码规范，并且通过 <code>Code Review</code> 督促执行，这对提高代码质量有立竿见影的效果。</p>]]></content>
      
      
      <categories>
          
          <category> 编码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式篇-单元测试</title>
      <link href="/2020/unit-testing.html"/>
      <url>/2020/unit-testing.html</url>
      
        <content type="html"><![CDATA[<h1 id="本文主要记载"><a href="#本文主要记载" class="headerlink" title="本文主要记载"></a>本文主要记载</h1><ul><li><strong>什么是单元测试？</strong></li><li><strong>为什么要写单元测试？</strong></li><li><strong>如何编写单元测试？</strong><ul><li>重构代码适配单元测试例子</li></ul></li></ul><h1 id="1-什么是单元测试？"><a href="#1-什么是单元测试？" class="headerlink" title="1 什么是单元测试？"></a>1 什么是单元测试？</h1><p>单元测试由研发工程师自己来编写，用来测试自己写的代码的正确性。我们常常将它跟集成测试放到一块来对比。</p><p>单元测试相对于集成测试 <code>（Integration Testing）</code> 来说，测试的粒度更小一些。</p><p>集成测试的测试对象是整个系统或者某个功能模块，比如测试用户注册、登录功能是否正常，是一种端到端 <code>（end to end）</code> 的测试。</p><p>而单元测试的测试对象是类或者函数，用来测试一个类和函数是否都按照预期的逻辑执行。这是代码层级的测试。</p><h1 id="2-为什么要写单元测试？"><a href="#2-为什么要写单元测试？" class="headerlink" title="2 为什么要写单元测试？"></a>2 为什么要写单元测试？</h1><p>单元测试除了能有效地为重构保驾护航之外，也是保证代码质量最有效的两个手段之一（另一个是 Code Review）。</p><ul><li><p><strong>单元测试能有效地帮你发现代码中的 bug</strong></p><p>能否写出 <code>bug free</code> 的代码，是判断工程师编码能力的重要标准之一，也是很多大厂面试考察的重点，单元测试可以帮助开发者快速方便的测试逻辑代码。</p><p>坚持写单元测试是保证代码质量的一个 “杀手锏” ，也是帮助自己拉开与其他人差距的一个 “小秘密” 。</p></li><li><p><strong>写单元测试能帮你发现代码设计上的问题</strong></p><p>代码的可测试性是评判代码质量的一个重要标准。对于一段代码，如果很难为其编写单元测试，或者单元测试写起来很吃力，需要依靠单元测试框架里很高级的特性才能完成，那往往就意味着代码设计得不够合理，比如，没有使用依赖注入、大量使用静态函数、全局变量、代码高度耦合等。</p></li><li><p><strong>单元测试是对集成测试的有力补充</strong></p><p>程序运行的 <code>bug</code> 往往出现在一些边界条件、异常情况下，比如，除数未判空、网络超时。而大部分异常情况都比较难在测试环境中模拟。单元测试可以利用 <code>mock</code> 的方式，控制 <code>mock</code> 的对象返回我们需要模拟的异常，来测试代码在这些异常情况的表现。</p></li><li><p><strong>写单元测试的过程本身就是代码重构的过程</strong></p><p>要把持续重构作为开发的一部分来执行，那写单元测试实际上就是落地执行持续重构的一个有效途径。编写单元测试就相当于对代码的一次自我 <code>Code Review</code> ，在这个过程中，我们可以发现一些设计上的问题（比如代码设计的不可测试）以及代码编写方面的问题（比如一些边界条件处理不当）等，然后针对性的进行重构。</p></li><li><p><strong>阅读单元测试能帮助你快速熟悉代码</strong></p><p>阅读代码最有效的手段，就是先了解它的业务背景和设计思路，然后再去看代码，这样代码读起来就会轻松很多。</p><p>程序员都不怎么喜欢写文档和注释，而大部分程序员写的代码又很难做到 “不言自明” 。</p><p>在没有文档和注释的情况下，单元测试就起了替代性作用。</p><p>单元测试用例实际上就是用户用例，反映了代码的功能和如何使用。借助单元测试，我们不需要深入的阅读代码，便能知道代码实现了什么功能，有哪些特殊情况需要考虑，有哪些边界条件需要处理。</p></li></ul><h1 id="3-如何编写单元测试？"><a href="#3-如何编写单元测试？" class="headerlink" title="3 如何编写单元测试？"></a>3 如何编写单元测试？</h1><p>举个栗子🌰 </p><p><code>Transaction</code> 是经过抽象简化之后的一个电商系统的交易类，用来记录每笔订单交易的情况。<br><code>Transaction</code> 类中的 <code>execute()</code> 函数负责执行转账操作，将钱从买家的钱包转到卖家的钱包中。<br>真正的转账操作是通过调用 <code>WalletRpcService RPC</code> 服务来完成的。<br>除此之外，代码中还涉及一个分布式锁 <code>DistributedLock</code> 单例类，用来避免 <code>Transaction</code> 并发执行，导致用户的钱被重复转出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Transaction</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String id;</span><br><span class="line">  <span class="keyword">private</span> Long buyerId;</span><br><span class="line">  <span class="keyword">private</span> Long sellerId;</span><br><span class="line">  <span class="keyword">private</span> Long productId;</span><br><span class="line">  <span class="keyword">private</span> String orderId;</span><br><span class="line">  <span class="keyword">private</span> Long createTimestamp;</span><br><span class="line">  <span class="keyword">private</span> Double amount;</span><br><span class="line">  <span class="keyword">private</span> STATUS status;</span><br><span class="line">  <span class="keyword">private</span> String walletTransactionId;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...get() methods...</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Transaction</span><span class="params">(String preAssignedId, Long buyerId, Long sellerId, Long productId, String orderId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (preAssignedId != <span class="keyword">null</span> &amp;&amp; !preAssignedId.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">this</span>.id = preAssignedId;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.id = IdGenerator.generateTransactionId();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.id.startWith(<span class="string">"t_"</span>)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.id = <span class="string">"t_"</span> + preAssignedId;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.buyerId = buyerId;</span><br><span class="line">    <span class="keyword">this</span>.sellerId = sellerId;</span><br><span class="line">    <span class="keyword">this</span>.productId = productId;</span><br><span class="line">    <span class="keyword">this</span>.orderId = orderId;</span><br><span class="line">    <span class="keyword">this</span>.status = STATUS.TO_BE_EXECUTD;</span><br><span class="line">    <span class="keyword">this</span>.createTimestamp = System.currentTimestamp();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> InvalidTransactionException </span>&#123;</span><br><span class="line">    <span class="comment">//TODO 2 buyerId、sellerId 为 null、amount 小于 0，返回 InvalidTransactionException。</span></span><br><span class="line">    <span class="keyword">if</span> ((buyerId == <span class="keyword">null</span> || (sellerId == <span class="keyword">null</span> || amount &lt; <span class="number">0.0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> InvalidTransactionException(...);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//TODO 4 交易已经执行了（status==EXECUTED），不再重复执行转钱逻辑，返回 true。</span></span><br><span class="line">    <span class="keyword">if</span> (status == STATUS.EXECUTED) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">boolean</span> isLocked = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      isLocked = RedisDistributedLock.getSingletonIntance().lockTransction(id);</span><br><span class="line">      <span class="keyword">if</span> (!isLocked) &#123;</span><br><span class="line">        <span class="comment">//TODO 6 交易正在执行着，不会被重复执行，函数直接返回 false。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 锁定未成功，返回false，job兜底执行</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (status == STATUS.EXECUTED) <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// double check</span></span><br><span class="line">      <span class="keyword">long</span> executionInvokedTimestamp = System.currentTimestamp();</span><br><span class="line">      <span class="keyword">if</span> (executionInvokedTimestamp - createdTimestap &gt; <span class="number">14</span>days) &#123;</span><br><span class="line">        <span class="keyword">this</span>.status = STATUS.EXPIRED;</span><br><span class="line">        <span class="comment">//TODO 3 交易已过期（createTimestamp 超过 14 天），交易状态设置为 EXPIRED，返回 false。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//TODO 1 mock 点</span></span><br><span class="line">      WalletRpcService walletRpcService = <span class="keyword">new</span> WalletRpcService();</span><br><span class="line">      String walletTransactionId = walletRpcService.moveMoney(id, buyerId, sellerId, amount);</span><br><span class="line">      <span class="keyword">if</span> (walletTransactionId != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.walletTransactionId = walletTransactionId;</span><br><span class="line">        <span class="keyword">this</span>.status = STATUS.EXECUTED;</span><br><span class="line">        <span class="comment">//TODO 1 正常情况下，交易执行成功，回填用于对账（交易与钱包的交易流水）用的 walletTransactionId，交易状态设置为 EXECUTED，函数返回 true。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//TODO 5 钱包（WalletRpcService）转钱失败，交易状态设置为 FAILED，函数返回 false。</span></span><br><span class="line">        <span class="keyword">this</span>.status = STATUS.FAILED;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (isLocked) &#123;</span><br><span class="line">       RedisDistributedLock.getSingletonIntance().unlockTransction(id);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对这个函数，设计了下面 <code>6</code> 个测试用例。</p><ol><li>正常情况下，交易执行成功，回填用于对账（交易与钱包的交易流水）用的 <code>walletTransactionId</code>，交易状态设置为 <code>EXECUTED</code>，函数返回 <code>true</code>。</li><li><code>buyerId</code>、<code>sellerId</code> 为 <code>null</code> 、<code>amount</code> 小于 <code>0</code>，返回 <code>InvalidTransactionException</code>。</li><li>交易已过期（<code>createTimestamp</code> 超过 14 天），交易状态设置为 <code>EXPIRED</code>，返回 <code>false</code>。</li><li>交易已经执行了（<code>status==EXECUTED</code>），不再重复执行转钱逻辑，返回 <code>true</code>。</li><li>钱包（<code>WalletRpcService</code>）转钱失败，交易状态设置为 <code>FAILED</code>，函数返回 <code>false</code>。</li><li>交易正在执行着，不会被重复执行，函数直接返回 <code>false</code>。</li></ol><p>测试用例写完了，然后就是如何写单元测试。</p><h2 id="3-1-重构代码适配单元测试例子"><a href="#3-1-重构代码适配单元测试例子" class="headerlink" title="3.1 重构代码适配单元测试例子"></a>3.1 重构代码适配单元测试例子</h2><p>先思考第一个测试用例的单元测试代码实现<br>正常情况下，上面代码我们需要依赖两个外部的服务，一个是 <code>RedisDistributedLock</code>，一个 <code>WalletRpcService</code>。</p><ul><li>如果要让这个单元测试能够运行，我们需要搭建 <code>Redis</code> 服务和 <code>Wallet RPC</code> 服务。搭建和维护的成本比较高。</li><li>我们还需要保证将伪造的 <code>transaction</code> 数据发送给 <code>Wallet RPC</code> 服务之后，能够正确返回我们期望的结果，然而 <code>Wallet RPC</code> 服务有可能是第三方（另一个团队开发维护的）的服务，并不是我们可控的。换句话说，并不是我们想让它返回什么数据就返回什么。</li><li><code>Transaction</code> 的执行跟 <code>Redis</code>、<code>RPC</code> 服务通信，需要走网络，耗时可能会比较长，对单元测试本身的执行性能也会有影响。</li><li>网络的中断、超时、<code>Redis</code>、<code>RPC</code> 服务的不可用，都会影响单元测试的执行。</li></ul><p>我们需要将被测代码与外部系统解依赖，而这种解依赖的方法就叫作 “mock” 。所谓的 <code>mock</code>  就是用一个 “假” 的服务替换真正的服务。<code>mock</code> 的服务完全在我们的控制之下，模拟输出我们想要的数据。这里展示的是手动 <code>mock</code>。</p><p>我们通过继承 <code>WalletRpcService1</code> 类，并且重写其中的 <code>moveMoney()</code> 函数的方式来实现 <code>mock</code>。具体的代码实现如下所示。通过 <code>mock</code> 的方式，我们可以让 <code>moveMoney()</code> 返回任意我们想要的数据，完全在我们的控制范围内，并且不需要真正进行网络通信。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MockWalletRpcServiceOne</span> <span class="keyword">extends</span> <span class="title">WalletRpcService</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">moveMoney</span><span class="params">(Long id, Long fromUserId, Long toUserId, Double amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"123bac"</span>;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MockWalletRpcServiceTwo</span> <span class="keyword">extends</span> <span class="title">WalletRpcService</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">moveMoney</span><span class="params">(Long id, Long fromUserId, Long toUserId, Double amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运用依赖注入，将 <code>WalletRpcService</code> 对象的创建反转给上层逻辑，在外部创建好之后，再注入到 Transaction 类中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Transaction</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...省略其他代码...</span></span><br><span class="line">  <span class="comment">// 添加一个成员变量及其set方法</span></span><br><span class="line">  <span class="keyword">private</span> WalletRpcService walletRpcService;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWalletRpcService</span><span class="params">(WalletRpcService walletRpcService)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.walletRpcService = walletRpcService;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 删除下面这一行代码</span></span><br><span class="line">    <span class="comment">// WalletRpcService walletRpcService = new WalletRpcService();</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单元测试就可以这样写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testExecute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Long buyerId = <span class="number">123L</span>;</span><br><span class="line">  Long sellerId = <span class="number">234L</span>;</span><br><span class="line">  Long productId = <span class="number">345L</span>;</span><br><span class="line">  Long orderId = <span class="number">456L</span>;</span><br><span class="line">  Transction transaction = <span class="keyword">new</span> Transaction(<span class="keyword">null</span>, buyerId, sellerId, productId, orderId);</span><br><span class="line">  <span class="comment">// 使用mock对象来替代真正的RPC服务</span></span><br><span class="line">  transaction.setWalletRpcService(<span class="keyword">new</span> MockWalletRpcServiceOne()):</span><br><span class="line">  <span class="keyword">boolean</span> executedResult = transaction.execute();</span><br><span class="line">  assertTrue(executedResult);</span><br><span class="line">  assertEquals(STATUS.EXECUTED, transaction.getStatus());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>WalletRpcService</code> 问题解决了，那 <code>RedisDistributedLock</code> 它是一个单例类，单例相当于一个全局变量，我们无法 mock（无法继承和重写方法），也无法通过依赖注入的方式来替换。</p><p>如何在不改动该单例类，或者说是根本就无法改动该类的情况下，实现单元测试呢？</p><p>我们可以对 <code>transaction</code> 上锁这部分逻辑重新封装一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionLock</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> RedisDistributedLock.getSingletonIntance().lockTransction(id);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RedisDistributedLock.getSingletonIntance().unlockTransction(id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Transaction</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...省略其他代码...</span></span><br><span class="line">  <span class="keyword">private</span> TransactionLock lock;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTransactionLock</span><span class="params">(TransactionLock lock)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.lock = lock;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      isLocked = lock.lock();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (isLocked) &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们就又可以注入了~ </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testExecute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Long buyerId = <span class="number">123L</span>;</span><br><span class="line">  Long sellerId = <span class="number">234L</span>;</span><br><span class="line">  Long productId = <span class="number">345L</span>;</span><br><span class="line">  Long orderId = <span class="number">456L</span>;</span><br><span class="line">  </span><br><span class="line">  TransactionLock mockLock = <span class="keyword">new</span> TransactionLock() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  Transction transaction = <span class="keyword">new</span> Transaction(<span class="keyword">null</span>, buyerId, sellerId, productId, orderId);</span><br><span class="line">  transaction.setWalletRpcService(<span class="keyword">new</span> MockWalletRpcServiceOne());</span><br><span class="line">  transaction.setTransactionLock(mockLock);</span><br><span class="line">  <span class="keyword">boolean</span> executedResult = transaction.execute();</span><br><span class="line">  assertTrue(executedResult);</span><br><span class="line">  assertEquals(STATUS.EXECUTED, transaction.getStatus());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，测试用例 <code>1</code> 就算写好了。我们通过依赖注入和 <code>mock</code>，让单元测试代码不依赖任何不可控的外部服务。</p><p>用例 <code>2</code> 就比较简单了，用例 <code>4、5、6</code> 通过用例 <code>1</code> 的修改也方便了。 现在来看用例 <code>3</code> </p><p>用例 <code>3</code> 不就改个 <code>createdTimestap</code>  就可以测试了吗？添加一个 <code>set</code> 方法就可以~ </p><p>实际上，这样就违反了类的封装特性。在 <code>Transaction</code> 类的设计中，<code>createTimestamp</code> 是在交易生成时（也就是构造函数中）自动获取的系统时间，本来就不应该人为地轻易修改，所以，暴露 <code>createTimestamp</code> 的 <code>set</code> 方法，虽然带来了灵活性，但也带来了不可控性。因为，我们无法控制使用者是否会调用 <code>set</code> 方法重设 <code>createTimestamp</code>，而重设 <code>createTimestamp</code> 并非我们的预期行为。</p><p>这属于跟 “时间” 有关的 “未决行为” 逻辑。我们一般的处理方式是将这种未决行为逻辑重新封装。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Transaction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isExpired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> executionInvokedTimestamp = System.currentTimestamp();</span><br><span class="line">    <span class="keyword">return</span> executionInvokedTimestamp - createdTimestamp &gt; <span class="number">14L</span> * <span class="number">24</span> * <span class="number">3600</span> * <span class="number">1000</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> InvalidTransactionException </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">      <span class="keyword">if</span> (isExpired()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.status = STATUS.EXPIRED;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对用例 <code>3</code> 重构后的单元测试代码是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testExecute_with_TransactionIsExpired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Long buyerId = <span class="number">123L</span>;</span><br><span class="line">  Long sellerId = <span class="number">234L</span>;</span><br><span class="line">  Long productId = <span class="number">345L</span>;</span><br><span class="line">  Long orderId = <span class="number">456L</span>;</span><br><span class="line">  Transction transaction = <span class="keyword">new</span> Transaction(<span class="keyword">null</span>, buyerId, sellerId, productId, orderId) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isExpired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">boolean</span> actualResult = transaction.execute();</span><br><span class="line">  assertFalse(actualResult);</span><br><span class="line">  assertEquals(STATUS.EXPIRED, transaction.getStatus());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多相关：</p><ul><li><p><a href="http://blog.csdn.net/qq_17766199/article/details/78243176" target="_blank" rel="noopener">Android单元测试(一)：JUnit框架的使用</a></p></li><li><p><a href="http://blog.csdn.net/qq_17766199/article/details/78450007" target="_blank" rel="noopener">Android单元测试(二)：Mockito框架的使用</a></p></li><li><p><a href="http://blog.csdn.net/qq_17766199/article/details/78573390" target="_blank" rel="noopener">Android单元测试(三)：PowerMock框架的使用</a></p></li><li><p><a href="http://blog.csdn.net/qq_17766199/article/details/78710177" target="_blank" rel="noopener">Android单元测试(四)：Robolectric框架的使用</a></p></li><li><p><a href="http://blog.csdn.net/qq_17766199/article/details/78881992" target="_blank" rel="noopener">Android单元测试(五)：网络接口测试</a> </p></li><li><p><a href="http://blog.csdn.net/qq_17766199/article/details/78989664" target="_blank" rel="noopener">Android单元测试(六)：RxJava测试</a></p></li><li><p><a href="http://blog.csdn.net/qq_17766199/article/details/79183901" target="_blank" rel="noopener">Android单元测试(七)：MVP与单元测试</a></p></li><li><p><a href="http://blog.csdn.net/qq_17766199/article/details/79277483" target="_blank" rel="noopener">Android单元测试(八)：Dagger与单元测试</a></p></li><li><p><a href="https://blog.csdn.net/qq_17766199/article/details/80321318" target="_blank" rel="noopener">Android单元测试(九)：查漏补缺篇</a></p></li><li><p><a href="https://weilu.blog.csdn.net/article/details/102992559" target="_blank" rel="noopener">Android单元测试(十)：内容更新篇</a></p></li></ul><h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h1><blockquote><p><a href="https://time.geekbang.org/column/intro/250?utm_source=pinpaizhuanqu&utm_medium=geektime&utm_campaign=guanwang&utm_term=guanwang&utm_content=0511" target="_blank" rel="noopener">设计模式之美</a></p><p><a href="https://github.com/simplezhli/AndroidUT" target="_blank" rel="noopener">唯鹿 github</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式篇-面向对象</title>
      <link href="/2020/oop.html"/>
      <url>/2020/oop.html</url>
      
        <content type="html"><![CDATA[<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><ul><li><strong>面向对象编程<code>(Object Oriented Programming OOP)</code></strong></li></ul><p>是一种编程范式或编程风格。它以类或对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性，作为代码设计和实现的基石 。</p><p>面向对象编程中有两个非常重要、非常基础的概念，那就是类<code>（class）</code>和对象<code>（object）</code>。</p><ul><li><strong>面向对象编程语言<code>(Object Oriented Programming Language OOPL)</code></strong></li></ul><p>是支持类或对象的语法机制，并有现成的语法机制，能方便地实现面向对象编程四大特性（封装、抽象、继承、多态）的编程语言。</p><ul><li><strong>封装（Encapsulation）</strong></li></ul><p><strong>What：</strong>隐藏信息，保护数据访问。<br><strong>How：</strong>类通过暴露有限的访问接口，授权外部仅能通过类提供的方式来访问内部信息或者数据。它需要编程语言提供权限访问控制语法来支持，例如 <code>Java</code> 中的 <code>private</code>、<code>protected</code>、<code>public</code> 关键字。<br><strong>Why：</strong>保护数据不被随意修改，提高代码可维护性；降低接口复杂度，提高类的易用性。</p><ul><li><strong>抽象（Abstraction）</strong></li></ul><p><strong>What：</strong>隐藏具体实现，使用者只需关心功能，无需关心实现。<br><strong>How：</strong>通过接口类或者抽象类实现，特殊语法机制非必须。<br><strong>Why：</strong>提高代码的扩展性、维护性；降低复杂度，减少细节负担。</p><ul><li><strong>继承（Inheritance）</strong></li></ul><p><strong>What：</strong>表示 <code>is-a</code> 关系，分为单继承和多继承。<br><strong>How：</strong>需要编程语言提供特殊语法机制。例如 <code>Java</code> 的 <code>extends</code>，<code>C++</code> 的 <code>:</code> 。<br><strong>Why：</strong>解决代码复用问题。</p><ul><li><strong>多态（Polymorphism）</strong></li></ul><p><strong>What：</strong>子类替换父类，在运行时调用子类的实现。<br><strong>How：</strong>需要编程语言提供特殊的语法机制。比如继承、接口类、<code>duck-typing</code>。<br><strong>Why：</strong>提高代码扩展性和复用性。</p><h2 id="面向过程"><a href="#面向过程" class="headerlink" title="面向过程"></a>面向过程</h2><p>面向对象编程以类为组织代码的基本单元，而面向过程编程也是一种编程范式或编程风格。它以过程（可以理解为方法、函数、操作）作为组织代码的基本单元，以数据（可以理解为成员变量、属性）与方法相分离为最主要的特点。面向过程风格是一种流程化的编程风格，通过拼接一组顺序执行的方法来操作数据完成一项功能。</p><h2 id="面向对象编程相比面向过程编程有哪些优势？"><a href="#面向对象编程相比面向过程编程有哪些优势？" class="headerlink" title="面向对象编程相比面向过程编程有哪些优势？"></a>面向对象编程相比面向过程编程有哪些优势？</h2><p>为什么面向对象编程晚于面向过程编程出现，却能取而代之，成为现在主流的编程范式？面向对象编程跟面向过程编程比起来，到底有哪些优势？</p><ul><li>对于大规模复杂程序的开发，程序的处理流程并非单一的一条主线，而是错综复杂的网状结构。面向对象编程比起面向过程编程，更能应对这种复杂类型的程序开发。</li><li>面向对象编程相比面向过程编程，具有更加丰富的特性（封装、抽象、继承、多态）。利用这些特性编写出来的代码，更加易扩展、易复用、易维护。</li><li>从编程语言跟机器打交道的方式的演进规律中，我们可以总结出：面向对象编程语言比起面向过程编程语言，更加人性化、更加高级、更加智能。</li></ul><h2 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h2><ul><li><strong>定义</strong></li></ul><p>抽象类：不允许实例化，只能被继承；可包含属性和方法，包含抽象方法；子类继承抽象类必须重写抽象方法。</p><p>接口：不允许实例化，只能被实现；不包含属性和普通方法，包含抽象方法、静态方法、<code>default</code> 方法，枚举类型，接口中还可以定义接口（嵌套）；类实现接口时，必须实现抽象方法。</p><ul><li><strong>意义</strong></li></ul><p>抽象类：解决复用问题，适用于 <code>is-a</code> 的关系。</p><p>接口：表示具有某一组行为特性，是为了解决解耦问题，隔离接口和具体的实现，提高代码的扩展性，适用于 <code>has-a</code> 的关系。</p><ul><li><strong>应用</strong></li></ul><p>什么时候该用抽象类？什么时候该用接口？为了解决代码复用问题，我们就用抽象类；为了解决抽象而非代码复用问题，那我们就用接口。</p><h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h1><blockquote><p><a href="https://time.geekbang.org/column/intro/250?utm_source=pinpaizhuanqu&utm_medium=geektime&utm_campaign=guanwang&utm_term=guanwang&utm_content=0511" target="_blank" rel="noopener">设计模式之美</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式篇</title>
      <link href="/2020/design-mode.html"/>
      <url>/2020/design-mode.html</url>
      
        <content type="html"><![CDATA[<h1 id="面向对象-more"><a href="#面向对象-more" class="headerlink" title="面向对象 more"></a><a href="https://calmcenter.club/2020/oop.html">面向对象 more</a></h1><ul><li>面向对象</li><li>面向过程</li><li>面向对象编程相比面向过程有哪些优势？</li><li>抽象类和接口</li></ul><h1 id="设计原则-more"><a href="#设计原则-more" class="headerlink" title="设计原则 more"></a><a href="https://calmcenter.club/2020/design-philosophy.html">设计原则 more</a></h1><p>设计原则包括 <code>SOLID</code>、<code>KISS</code>、<code>YAGNI</code>、<code>DRY</code>、<code>LOD</code></p><ul><li><p><code>SOLID</code> 原则：</p><ul><li>单一职责原则 (Single Responsibility Principe 简称 SRP)</li><li>开闭原则 (Open-Closed Principle 简称 OCP)</li><li>里氏替换原则 (Liskov Substitution Principle 简称 LSP)</li><li>接口隔离原则 (Interface Segregation Principle 简称 ISP)</li><li>依赖反转原则 (Dependency Inversion Principe 简称 DIP)</li></ul></li><li><p><code>KISS</code> 原则</p></li><li><p><code>DRY</code> 原则</p></li><li><p>迪米特法则（Law of Demeter LOD）</p></li></ul><h1 id="单元测试-more"><a href="#单元测试-more" class="headerlink" title="单元测试 more"></a><a href="https://calmcenter.club/2020/unit-testing.html">单元测试 more</a></h1><ul><li>什么是单元测试？</li><li>为什么要写单元测试？</li><li>如何编写单元测试？</li></ul><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><ul><li><p>创建型</p><ul><li><p><a href="https://calmcenter.club/2020/design-pattern-singleton.html">单例模式 more</a></p></li><li><p><a href="https://calmcenter.club/2020/design-pattern-factory.html">工厂模式 more</a></p></li><li><p><a href="https://calmcenter.club/2020/design-pattern-builder.html">建造者模式 more</a></p></li><li><p><a href="https://calmcenter.club/2020/design-pattern-prototype.html">原型模式 more</a></p></li></ul></li><li><p>结构型</p><ul><li><p><a href="https://calmcenter.club/2020/design-pattern-proxy.html">代理模式 more</a></p><p>代理模式在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能，这是它跟装饰器模式最大的不同。</p></li><li><p><a href="https://calmcenter.club/2020/design-pattern-bridge.html">桥接模式 more</a></p><p>桥接模式的目的是将接口部分和实现部分分离，从而让它们可以较为容易、也相对独立地加以改变。</p></li><li><p><a href="https://calmcenter.club/2020/design-pattern-decorator.html">装饰器模式 more</a></p><p>装饰者模式在不改变原始类接口的情况下，对原始类功能进行增强，并且支持多个装饰器的嵌套使用。</p></li><li><p><a href="https://calmcenter.club/2020/design-pattern-adapter.html">适配器模式 more</a></p><p>适配器模式是一种事后的补救策略。适配器提供跟原始类不同的接口，而代理模式、装饰器模式提供的都是跟原始类相同的接口。</p></li><li><p><a href="https://calmcenter.club/2020/design-pattern-composite.html">组合模式 more</a></p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-设计原则篇</title>
      <link href="/2020/design-philosophy.html"/>
      <url>/2020/design-philosophy.html</url>
      
        <content type="html"><![CDATA[<h1 id="本文主要记载"><a href="#本文主要记载" class="headerlink" title="本文主要记载"></a>本文主要记载</h1><ul><li><strong>单一责任原则</strong><ul><li>如何理解 “单一职责原则”？</li><li>如何判断类的职责是否足够单一？</li><li>类的职责是否设计的越单一越好？</li></ul></li><li><strong>开闭原则</strong><ul><li>如何理解 “对扩展开放、修改关闭”？</li><li>如何做到 “对扩展开放、修改关闭”？</li><li>如何正在项目中灵活应用开闭原则？</li></ul></li><li><strong>里式替换原则</strong><ul><li>如何理解 “里式替换原则”？</li><li>如何做到 “里式替换原则”？</li><li>接口隔离原则和单一职责原则的区别</li></ul></li><li><strong>依赖反转原则</strong><ul><li>控制反转</li><li>依赖注入</li><li>依赖反转原则</li></ul></li><li><strong>KISS 原则</strong><ul><li>代码行数越少越 “简单” 吗？</li><li>代码逻辑复杂就违背 KISS 原则吗？</li><li>如何写出满足 KISS 原则的代码？</li><li>YANGNI 原则跟 KISS 原则说的是一回事吗？</li></ul></li><li><strong>DRY 原则</strong><ul><li>实现逻辑重复</li><li>功能语义重复</li><li>代码执行重复</li><li>怎么提高代码复用性？</li><li>思考和灵活应用</li></ul></li><li><strong>迪米特法则</strong><ul><li>何为 “高内聚，松耦合”？</li><li>不该有直接依赖关系的类之间，不要有依赖</li><li>有依赖关系的类之间，尽量只依赖必要的接口</li></ul></li></ul><hr><h1 id="🚩单一责任原则"><a href="#🚩单一责任原则" class="headerlink" title="🚩单一责任原则"></a>🚩单一责任原则</h1><p> (Single Responsibility Principle SRP)</p><h2 id="1-如何理解-“单一职责原则”-？"><a href="#1-如何理解-“单一职责原则”-？" class="headerlink" title="1 如何理解 “单一职责原则” ？"></a>1 如何理解 “单一职责原则” ？</h2><p><code>A class or module should have a single reponsibility(一个类或者模块只负责完成一个职责（或者功能）)</code></p><p>一个类只负责完成一个职责或者功能。不要设计大而全的类，要设计粒度小、功能单一的类。单一职责原则是为了实现代码高内聚、低耦合，提高代码的复用性、可读性、可维护性。</p><p><strong>就一个类而言，应该仅有一个引起变化的原因</strong>  </p><p><strong>把因为相同的原因而改变的事物聚集在一起。把那些因为不同原因而改变的东西分开。</strong></p><h2 id="2-如何判断类的职责是否足够单一？"><a href="#2-如何判断类的职责是否足够单一？" class="headerlink" title="2 如何判断类的职责是否足够单一？"></a>2 如何判断类的职责是否足够单一？</h2><p>不同的应用场景、不同阶段的需求背景、不同的业务层面，对同一个类的职责是否单一，可能会有不同的判定结果。举个栗子🌰</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> userId;</span><br><span class="line">  <span class="keyword">private</span> String username;</span><br><span class="line">  <span class="keyword">private</span> String email;</span><br><span class="line">  <span class="keyword">private</span> String telephone;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> createTime;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> lastLoginTime;</span><br><span class="line">  <span class="keyword">private</span> String avatarUrl;</span><br><span class="line">  <span class="keyword">private</span> String provinceOfAddress; <span class="comment">// 省</span></span><br><span class="line">  <span class="keyword">private</span> String cityOfAddress; <span class="comment">// 市</span></span><br><span class="line">  <span class="keyword">private</span> String regionOfAddress; <span class="comment">// 区 </span></span><br><span class="line">  <span class="keyword">private</span> String detailedAddress; <span class="comment">// 详细地址</span></span><br><span class="line">  <span class="comment">// ...省略其他属性和方法...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>UserInfo</code> 类的设计是否满足单一职责原则呢？</p><p>对于这个问题，有两种不同的观点。一种观点是，<code>UserInfo</code> 类包含的都是跟用户相关的信息，所有的属性和方法都隶属于用户这样一个业务模型，满足单一职责原则；另一种观点是，地址信息在 <code>UserInfo</code> 类中，所占的比重比较高，可以继续拆分成独立的 <code>UserAddress</code> 类，<code>UserInfo</code> 只保留除 <code>Address</code> 之外的其他信息，拆分之后的两个类的职责更加单一。</p><p>哪种观点更对呢？实际上，要从中做出选择，我们不能脱离具体的应用场景。如果在这个社交产品中，用户的地址信息跟其他信息一样，只是单纯地用来展示，那 <code>UserInfo</code> 现在的设计就是合理的。但是，如果这个社交产品发展得比较好，之后又在产品中添加了电商的模块，用户的地址信息还会用在电商物流中，那我们最好将地址信息从 <code>UserInfo</code> 中拆分出来，独立成用户物流信息（或者叫地址信息、收货信息等）。</p><p>一些侧面的判断指标更具有指导意义和可执行性，比如，出现下面这些情况就有可能说明这类的设计不满足单一职责原则：</p><ul><li>类中的代码行数、函数或者属性过多；</li><li>类依赖的其他类过多，或者依赖类的其他类过多；</li><li>私有方法过多；</li><li>比较难给类起一个合适的名字；</li><li>类中大量的方法都是集中操作类中的某几个属性；</li></ul><p>至于如何判断 <em>过多</em> ，实际上，这个问题并不好定量地回答，就像你问大厨 “放盐少许” 中的 “少许” 是多少，大厨也很难告诉你一个特别具体的量值，都是经验与感觉。</p><p>从另一个角度来看，当一个类的代码，读起来让你头大了，实现某个功能时不知道该用哪个函数了，想用哪个函数翻半天都找不到了，只用到一个小功能要引入整个类（类中包含很多无关此功能实现的函数）的时候，这就说明类的行数、函数、属性过多了。项目做多了，代码写多了，在开发中慢慢 “品尝” ，自然就知道什么是 “放盐少许” 了，这就是所谓的 “专业第六感” 。</p><h2 id="3-类的职责是否设计得越单一越好？"><a href="#3-类的职责是否设计得越单一越好？" class="headerlink" title="3 类的职责是否设计得越单一越好？"></a>3 类的职责是否设计得越单一越好？</h2><p>为了满足单一职责原则，是不是把类拆得越细就越好呢？答案是否定的。</p><p>单一职责原则通过避免设计大而全的类，避免将不相关的功能耦合在一起，来提高类的内聚性。<br>同时，类职责单一，类依赖的和被依赖的其他类也会变少，减少了代码的耦合性，以此来实现代码的高内聚、低耦合。<br>但是，如果拆分得过细，实际上会适得其反，反倒会降低内聚性，也会影响代码的可维护性。</p><p>举个栗子🌰 <code>Serialization</code> 类实现了一个 简单协议 的 序列化 和 反序列 功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Serialization</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(Map&lt;String, String&gt; object)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title">deserialize</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们想让类的职责更加单一，我们对 <code>Serialization</code> 类进一步拆分，拆分成一个只负责序列化工作的 <code>Serializer</code> 类和另一个只负责反序列化工作的 <code>Deserializer</code> 类。但是，现在如果我们修改了协议的格式，或者序列化方式从 <code>JSON</code> 改为了 <code>XML</code> ，那 <code>Serializer</code> 类和 <code>Deserializer</code> 类都需要做相应的修改，代码的内聚性显然没有原来 <code>Serialization</code> 高了。拆分之后，代码的可维护性变差了。</p><hr><h1 id="🚩开闭原则"><a href="#🚩开闭原则" class="headerlink" title="🚩开闭原则"></a>🚩开闭原则</h1><p>开闭原则 <code>(Open-Closed Principle 简称 OCP)</code> 是 <code>SOLID</code> 中最难理解、最难掌握，同时也是最有用的一条原则。</p><h2 id="1-如何理解-“对扩展开放、修改关闭”-？"><a href="#1-如何理解-“对扩展开放、修改关闭”-？" class="headerlink" title="1 如何理解 “对扩展开放、修改关闭”  ？"></a>1 如何理解 “对扩展开放、修改关闭”  ？</h2><p><code>software entities (modules, classes, functions, etc.) should be open for extension , but closed for modification(软件实体（模块、类、方法等）应该“对扩展开放、对修改关闭”。)</code></p><p>添加一个新的功能，应该是通过在已有代码基础上扩展代码（新增模块、类、方法、属性等），而非修改已有代码（修改模块、类、方法、属性等）的方式来完成。</p><ul><li>开闭原则并不是说完全杜绝修改，而是以最小的修改代码的代价来完成新功能的开发。</li><li>同样的代码改动，在粗代码粒度下，可能被认定为“修改”；在细代码粒度下，可能又被认定为“扩展”。</li></ul><h2 id="2-如何做到-“对扩展开放、修改关闭”-？"><a href="#2-如何做到-“对扩展开放、修改关闭”-？" class="headerlink" title="2 如何做到 “对扩展开放、修改关闭” ？"></a>2 如何做到 “对扩展开放、修改关闭” ？</h2><p>举个栗子🌰 一个警告通知系统，通过各种判断是否需要通知。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Alert</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> AlertRule rule;</span><br><span class="line">  <span class="keyword">private</span> Notification notification;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Alert</span><span class="params">(AlertRule rule, Notification notification)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.rule = rule;</span><br><span class="line">    <span class="keyword">this</span>.notification = notification;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(String api, <span class="keyword">long</span> requestCount, <span class="keyword">long</span> errorCount, <span class="keyword">long</span> durationOfSeconds)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> tps = requestCount / durationOfSeconds;</span><br><span class="line">    <span class="keyword">if</span> (tps &gt; rule.getMatchedRule(api).getMaxTps()) &#123;<span class="comment">//TPS 是否超过某个预先设置的最大值</span></span><br><span class="line">      notification.notify(NotificationEmergencyLevel.URGENCY, <span class="string">"..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (errorCount &gt; rule.getMatchedRule(api).getMaxErrorCount()) &#123;<span class="comment">//错误数 是否超过某个预先设置的最大值</span></span><br><span class="line">      notification.notify(NotificationEmergencyLevel.SEVERE, <span class="string">"..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>业务逻辑主要集中在 <code>check()</code> 函数中。现在，如果我们需要添加一个警告功能，当每秒钟接口超时请求个数，超过某个预先设置的最大阈值时，我们也要触发告警发送通知。这个时候，我们该如何改动代码呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Alert</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...省略AlertRule/Notification属性和构造函数...</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 改动一：添加参数timeoutCount</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(String api, <span class="keyword">long</span> requestCount, <span class="keyword">long</span> errorCount, <span class="keyword">long</span> timeoutCount, <span class="keyword">long</span> durationOfSeconds)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> tps = requestCount / durationOfSeconds;</span><br><span class="line">    <span class="keyword">if</span> (tps &gt; rule.getMatchedRule(api).getMaxTps()) &#123;...&#125;<span class="comment">//TPS 是否超过某个预先设置的最大值</span></span><br><span class="line">    <span class="keyword">if</span> (errorCount &gt; rule.getMatchedRule(api).getMaxErrorCount()) &#123;...&#125;<span class="comment">//错误数 是否超过某个预先设置的最大值</span></span><br><span class="line">    <span class="comment">// 改动二：添加接口超时处理逻辑</span></span><br><span class="line">    <span class="keyword">long</span> timeoutTps = timeoutCount / durationOfSeconds;</span><br><span class="line">    <span class="keyword">if</span> (timeoutTps &gt; rule.getMatchedRule(api).getMaxTimeoutTps()) &#123;</span><br><span class="line">      notification.notify(NotificationEmergencyLevel.URGENCY, <span class="string">"..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的代码修改实际上存在挺多问题的。</p><ul><li>一方面，我们对接口进行了修改，这就意味着调用这个接口的代码都要做相应的修改。</li><li>另一方面，修改了 <code>check()</code> 函数，相应的单元测试都需要修改</li></ul><p>这个代码改动是基于 “修改” 的方式来实现新功能的。如果我们遵循开闭原则，也就是 “对扩展开放、对修改关闭” 。那如何通过 “扩展” 的方式，来实现同样的功能呢？</p><p>先重构一下之前的 <code>Alert</code> 代码，让它的扩展性更好一些。重构的内容主要包含两部分：</p><ul><li>第一部分是将 <code>check()</code> 函数的多个入参封装成 <code>ApiStatInfo</code> 类；</li><li>第二部分是引入 <code>handler</code> 的概念，将 if 判断逻辑分散在各个 <code>handler</code> 中。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Alert</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> List&lt;AlertHandler&gt; alertHandlers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAlertHandler</span><span class="params">(AlertHandler alertHandler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.alertHandlers.add(alertHandler);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(ApiStatInfo apiStatInfo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (AlertHandler handler : alertHandlers) &#123;</span><br><span class="line">      handler.check(apiStatInfo);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiStatInfo</span> </span>&#123;<span class="comment">//省略constructor/getter/setter方法</span></span><br><span class="line">  <span class="keyword">private</span> String api;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> requestCount;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> errorCount;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> durationOfSeconds;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AlertHandler</span> </span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> AlertRule rule;</span><br><span class="line">  <span class="keyword">protected</span> Notification notification;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">AlertHandler</span><span class="params">(AlertRule rule, Notification notification)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.rule = rule;</span><br><span class="line">    <span class="keyword">this</span>.notification = notification;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(ApiStatInfo apiStatInfo)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TpsAlertHandler</span> <span class="keyword">extends</span> <span class="title">AlertHandler</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TpsAlertHandler</span><span class="params">(AlertRule rule, Notification notification)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(rule, notification);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(ApiStatInfo apiStatInfo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> tps = apiStatInfo.getRequestCount()/ apiStatInfo.getDurationOfSeconds();</span><br><span class="line">    <span class="keyword">if</span> (tps &gt; rule.getMatchedRule(apiStatInfo.getApi()).getMaxTps()) &#123;<span class="comment">//TPS 是否超过某个预先设置的最大值</span></span><br><span class="line">      notification.notify(NotificationEmergencyLevel.URGENCY, <span class="string">"..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErrorAlertHandler</span> <span class="keyword">extends</span> <span class="title">AlertHandler</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ErrorAlertHandler</span><span class="params">(AlertRule rule, Notification notification)</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(rule, notification);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(ApiStatInfo apiStatInfo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (apiStatInfo.getErrorCount() &gt; rule.getMatchedRule(apiStatInfo.getApi()).getMaxErrorCount()) &#123;<span class="comment">//错误数 是否超过某个预先设置的最大值</span></span><br><span class="line">      notification.notify(NotificationEmergencyLevel.SEVERE, <span class="string">"..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再写一个单例提供配置和使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationContext</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> AlertRule alertRule;</span><br><span class="line">  <span class="keyword">private</span> Notification notification;</span><br><span class="line">  <span class="keyword">private</span> Alert alert;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initializeBeans</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    alertRule = <span class="keyword">new</span> AlertRule(<span class="comment">/*.省略参数.*/</span>); <span class="comment">//省略一些初始化代码</span></span><br><span class="line">    notification = <span class="keyword">new</span> Notification(<span class="comment">/*.省略参数.*/</span>); <span class="comment">//省略一些初始化代码</span></span><br><span class="line">    alert = <span class="keyword">new</span> Alert();<span class="comment">//添加警告方式</span></span><br><span class="line">    alert.addAlertHandler(<span class="keyword">new</span> TpsAlertHandler(alertRule, notification));</span><br><span class="line">    alert.addAlertHandler(<span class="keyword">new</span> ErrorAlertHandler(alertRule, notification));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Alert <span class="title">getAlert</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> alert; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 饿汉式单例</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ApplicationContext instance = <span class="keyword">new</span> ApplicationContext();</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">ApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    instance.initializeBeans();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ApplicationContext <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ApiStatInfo apiStatInfo = <span class="keyword">new</span> ApiStatInfo();</span><br><span class="line">    <span class="comment">// apiStatInfo.setxxx() ...省略设置apiStatInfo数据值的代码</span></span><br><span class="line">    ApplicationContext.getInstance().getAlert().check(apiStatInfo);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果再添加上面的那个新功能，每秒钟接口超时请求个数超过某个最大阈值就告警，我们又该如何改动代码呢？</p><ul><li>第一处改动是：在 <code>ApiStatInfo</code> 类中添加新的属性 <code>timeoutCount</code>。</li><li>第二处改动是：添加新的 <code>TimeoutAlertHander</code> 类。</li><li>第三处改动是：在 <code>ApplicationContext</code> 类的 <code>initializeBeans()</code> 方法中，往 alert 对象中注册新的 <code>timeoutAlertHandler</code>。</li><li>第四处改动是：在使用 <code>Alert</code> 类的时候，需要给 <code>check()</code> 函数的入参 <code>apiStatInfo</code> 对象设置 <code>timeoutCount</code> 的值。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Alert</span> </span>&#123; <span class="comment">// 代码未改动... &#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiStatInfo</span> </span>&#123;<span class="comment">//省略constructor/getter/setter方法</span></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> timeoutCount; <span class="comment">// 改动一：添加新字段</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AlertHandler</span> </span>&#123; <span class="comment">//代码未改动... &#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TpsAlertHandler</span> <span class="keyword">extends</span> <span class="title">AlertHandler</span> </span>&#123;<span class="comment">//代码未改动...&#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErrorAlertHandler</span> <span class="keyword">extends</span> <span class="title">AlertHandler</span> </span>&#123;<span class="comment">//代码未改动...&#125;</span></span><br><span class="line"><span class="comment">// 改动二：添加新的handler</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeoutAlertHandler</span> <span class="keyword">extends</span> <span class="title">AlertHandler</span> </span>&#123;<span class="comment">//省略代码...&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationContext</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initializeBeans</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    alert = <span class="keyword">new</span> Alert();</span><br><span class="line">    alert.addAlertHandler(<span class="keyword">new</span> TpsAlertHandler(alertRule, notification));</span><br><span class="line">    alert.addAlertHandler(<span class="keyword">new</span> ErrorAlertHandler(alertRule, notification));</span><br><span class="line">    <span class="comment">// 改动三：注册handler</span></span><br><span class="line">    alert.addAlertHandler(<span class="keyword">new</span> TimeoutAlertHandler(alertRule, notification));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...省略其他未改动代码...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ApiStatInfo apiStatInfo = <span class="keyword">new</span> ApiStatInfo();</span><br><span class="line">    <span class="comment">// ...省略apiStatInfo的set字段代码</span></span><br><span class="line">    apiStatInfo.setTimeoutCount(<span class="number">289</span>); <span class="comment">// 改动四：设置tiemoutCount值</span></span><br><span class="line">    ApplicationContext.getInstance().getAlert().check(apiStatInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重构之后的代码更加灵活和易扩展。如果我们要想添加新的告警逻辑，只需要基于扩展的方式创建新的 <code>handler</code> 类即可，不需要改动原来的 <code>check()</code> 函数的逻辑。而且，我们只需要为新的 handler 类添加单元测试，老的单元测试都不会失败，也不用修改。</p><h2 id="3-如何在项目中灵活应用开闭原则？"><a href="#3-如何在项目中灵活应用开闭原则？" class="headerlink" title="3 如何在项目中灵活应用开闭原则？"></a>3 如何在项目中灵活应用开闭原则？</h2><p>写出支持 “对扩展开放、对修改关闭” 的代码的关键是预留 <strong>扩展点</strong> 。那问题是如何才能识别出所有可能的扩展点呢？</p><p>要想识别出尽可能多的扩展点，就要对业务有足够的了解，能够知道当下以及未来可能要支持的业务需求。不过，有一句话说得好，“唯一不变的只有变化本身”。即便我们对业务、对系统有足够的了解，那也不可能识别出所有的扩展点，即便你能识别出所有的扩展点，为这些地方都预留扩展点，这样做的成本也是不可接受的。我们没必要为一些遥远的、不一定发生的需求去提前买单，做过度设计。</p><p>而且，开闭原则也并不是免费的。有些情况下，代码的扩展性会跟可读性相冲突。比如，我们之前举的 <code>Alert</code> 报警的例子。为了更好地支持扩展性，我们对代码进行了重构，重构之后的代码要比之前的代码复杂很多，理解起来也更加有难度。</p><p>总之，这里没有一个放之四海而皆准的参考标准，全凭实际的应用场景来决定。</p><hr><h1 id="🚩里氏替换原则"><a href="#🚩里氏替换原则" class="headerlink" title="🚩里氏替换原则"></a>🚩里氏替换原则</h1><p><code>(Liskov Substitution Principle 简称 LSP)</code></p><h2 id="1-如何理解-“里式替换原则”-？"><a href="#1-如何理解-“里式替换原则”-？" class="headerlink" title="1 如何理解 “里式替换原则” ？"></a>1 如何理解 “里式替换原则” ？</h2><p><code>If S is a subtype of T, then objects of type T may be replaced with objects of type S, without breaking the program。</code></p><p><code>Functions that use pointers of references to base classes must be able to use objects of derived classes without knowing it。</code></p><p><code>(子类对象能够替换程序中父类对象出现的任何地方，并且保证原来程序的逻辑行为不变及正确性不被破坏。)</code></p><p>里式替换原则更像是一个多态的规范。里式替换原则是用多态实现的，多态实现的子类不一定符合里式替换原则。</p><h2 id="2-如何做到-“里式替换原则”-？"><a href="#2-如何做到-“里式替换原则”-？" class="headerlink" title="2 如何做到 “里式替换原则” ？"></a>2 如何做到 “里式替换原则” ？</h2><p>举个栗子🌰 子类 <code>SecurityTransporter</code> 继承父类 <code>Transporter</code>，增加了额外的功能，支持传输 <code>appId</code> 和 <code>appToken</code> 安全认证信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Transporter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> HttpClient httpClient;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Transporter</span><span class="params">(HttpClient httpClient)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.httpClient = httpClient;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Response <span class="title">sendRequest</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...use httpClient to send request</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityTransporter</span> <span class="keyword">extends</span> <span class="title">Transporter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String appId;</span><br><span class="line">  <span class="keyword">private</span> String appToken;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SecurityTransporter</span><span class="params">(HttpClient httpClient, String appId, String appToken)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(httpClient);</span><br><span class="line">    <span class="keyword">this</span>.appId = appId;</span><br><span class="line">    <span class="keyword">this</span>.appToken = appToken;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Response <span class="title">sendRequest</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isNotBlank(appId) &amp;&amp; StringUtils.isNotBlank(appToken)) &#123;</span><br><span class="line">      request.addPayload(<span class="string">"app-id"</span>, appId);</span><br><span class="line">      request.addPayload(<span class="string">"app-token"</span>, appToken);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.sendRequest(request);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demoFunction</span><span class="params">(Transporter transporter)</span> </span>&#123;    </span><br><span class="line">    Reuqest request = <span class="keyword">new</span> Request();</span><br><span class="line">    <span class="comment">//...省略设置request中数据值的代码...</span></span><br><span class="line">    Response response = transporter.sendRequest(request);</span><br><span class="line">    <span class="comment">//...省略其他逻辑...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 里式替换原则</span></span><br><span class="line">Demo demo = <span class="keyword">new</span> Demo();</span><br><span class="line">demo.demofunction(<span class="keyword">new</span> SecurityTransporter(<span class="comment">/*省略参数*/</span>););</span><br></pre></td></tr></table></figure><p>在上面的代码中，子类 SecurityTransporter 的设计完全符合里式替换原则，可以替换父类出现的任何位置，并且原来代码的逻辑行为不变且正确性也没有被破坏。</p><p>如果我们对 <code>SecurityTransporter</code> 类中 <code>sendRequest()</code> 函数稍加改造一下。改造前，如果 <code>appId</code> 或者 <code>appToken</code> 没有设置，我们就不做校验；改造后，如果 <code>appId</code> 或者 <code>appToken</code> 没有设置，则直接抛出 <code>NoAuthorizationRuntimeException</code> 未授权异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 改造后：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityTransporter</span> <span class="keyword">extends</span> <span class="title">Transporter</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...省略其他代码..</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Response <span class="title">sendRequest</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(appId) || StringUtils.isBlank(appToken)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoAuthorizationRuntimeException(...);</span><br><span class="line">    &#125;</span><br><span class="line">    request.addPayload(<span class="string">"app-id"</span>, appId);</span><br><span class="line">    request.addPayload(<span class="string">"app-token"</span>, appToken);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.sendRequest(request);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在改造之后的代码中，如果传递进 <code>demoFunction()</code> 函数的是父类 <code>Transporter</code> 对象，那 <code>demoFunction()</code> 函数并不会有异常抛出。<br>但如果传递给 <code>demoFunction()</code> 函数的是子类 <code>SecurityTransporter</code> 对象，那 <code>demoFunction()</code> 有可能会有异常抛出。<br>子类替换父类传递进 <code>demoFunction</code> 函数之后，整个程序的逻辑行为有了改变。这样就违背了里式替换原则，但是他还是由多态实现的。</p><p>多态 和 里式替换 有点类似，但它们关注的角度是不一样的。<br>多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法。它是一种代码实现的思路。<br>而里式替换是一种设计原则，是用来指导继承关系中子类该如何设计的，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑以及不破坏原有程序的正确性。</p><h2 id="3-哪些代码明显违背了-LSP？"><a href="#3-哪些代码明显违背了-LSP？" class="headerlink" title="3 哪些代码明显违背了 LSP？"></a>3 哪些代码明显违背了 LSP？</h2><ul><li><p>子类违背父类声明要实现的功能</p><p>父类中提供的 <code>sortOrdersByAmount()</code> 订单排序函数，是按照金额从小到大来给订单排序的，而子类重写这个 <code>sortOrdersByAmount()</code> 订单排序函数之后，是按照创建日期来给订单排序的。那子类的设计就违背里式替换原则。</p></li><li><p>子类违背父类对输入、输出、异常的约定</p><p>在父类中，某个函数约定：运行出错的时候返回 <code>null</code>；获取数据为空的时候返回空集合 <code>（empty collection）</code> 。而子类重载函数之后，实现变了，运行出错返回异常 <code>（exception）</code> ，获取不到数据返回 <code>null</code> 。那子类的设计就违背里式替换原则。</p><p>在父类中，某个函数约定，输入数据可以是任意整数，但子类实现的时候，只允许输入数据是正整数，负数就抛出，也就是说，子类对输入的数据的校验比父类更加严格，那子类的设计就违背了里式替换原则。</p><p>在父类中，某个函数约定，只会抛出 <code>ArgumentNullException</code> 异常，那子类的设计实现中只允许抛出 <code>ArgumentNullException</code> 异常，任何其他异常的抛出，都会导致子类违背里式替换原则。</p></li><li><p>子类违背父类注释中所罗列的任何特殊说明</p><p>父类中定义的 <code>withdraw()</code> 提现函数的注释是这么写的：“用户的提现金额不得超过账户余额……”，而子类重写 <code>withdraw()</code> 函数之后，针对 <code>VIP</code> 账号实现了透支提现的功能，也就是提现金额可以大于账户余额，那这个子类的设计也是不符合里式替换原则的。</p></li></ul><hr><h1 id="🚩接口隔离原则"><a href="#🚩接口隔离原则" class="headerlink" title="🚩接口隔离原则"></a>🚩接口隔离原则</h1><p><code>(Interface Segregation Principle 简称 ISP)</code></p><h2 id="1-如何理解-“接口隔离原则”-？"><a href="#1-如何理解-“接口隔离原则”-？" class="headerlink" title="1 如何理解 “接口隔离原则” ？"></a>1 如何理解 “接口隔离原则” ？</h2><p><code>Clients should not be forced to depend upon interfaces that they do not use (客户端不应该被强迫依赖它不需要的接口。其中的“客户端”，可以理解为接口的调用者或者使用者)</code></p><p>在这条原则中，我们可以把“接口”理解为下面三种东西：</p><ul><li>一组 <code>API</code> 接口集合</li><li>单个 <code>API</code> 接口或函数</li><li><code>OOP</code> 中的接口概念</li></ul><h2 id="2-如何做到-“接口隔离原则”-？"><a href="#2-如何做到-“接口隔离原则”-？" class="headerlink" title="2 如何做到 “接口隔离原则” ？"></a>2 如何做到 “接口隔离原则” ？</h2><ul><li>一组 <code>API</code> 接口集合</li></ul><p>微服务用户系统提供了一组跟用户相关的 <code>API</code> 给其他系统使用，比如：注册、登录、获取用户信息等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">register</span><span class="params">(String cellphone, String password)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">login</span><span class="params">(String cellphone, String password)</span></span>;</span><br><span class="line">  <span class="function">UserInfo <span class="title">getUserInfoById</span><span class="params">(<span class="keyword">long</span> id)</span></span>;</span><br><span class="line">  <span class="function">UserInfo <span class="title">getUserInfoByCellphone</span><span class="params">(String cellphone)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们的后台管理系统要实现删除用户的功能，希望用户系统提供一个删除用户的接口。</p><p>删除用户是一个非常慎重的操作，我们只希望通过后台管理系统来执行，所以这个接口只限于给后台管理系统使用。如果我们把它放到 <code>UserService</code> 中，那所有使用到 <code>UserService</code> 的系统，都可以调用这个接口。不加限制地被其他业务系统调用，就有可能导致误删用户。</p><p>我们参照接口隔离原则，调用者不应该强迫依赖它不需要的接口，将删除接口单独放到另外一个接口 <code>RestrictedUserService</code> 中，然后将 <code>RestrictedUserService</code> 只打包提供给后台管理系统来使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RestrictedUserService</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">deleteUserByCellphone</span><span class="params">(String cellphone)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">deleteUserById</span><span class="params">(<span class="keyword">long</span> id)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span>, <span class="title">RestrictedUserService</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...省略实现代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在刚刚的这个例子中，我们把接口隔离原则中的接口，理解为一组接口集合，它可以是某个微服务的接口，也可以是某个类库的接口等等。</p><ul><li>单个 <code>API</code> 接口或函数</li></ul><p>把接口理解为单个接口或函数，那接口隔离原则就可以理解为：函数的设计要功能单一，不要将多个不同的功能逻辑在一个函数中实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Statistics</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Long max;</span><br><span class="line">  <span class="keyword">private</span> Long min;</span><br><span class="line">  <span class="keyword">private</span> Long average;</span><br><span class="line">  <span class="keyword">private</span> Long sum;</span><br><span class="line">  <span class="keyword">private</span> Long percentile99;</span><br><span class="line">  <span class="keyword">private</span> Long percentile999;</span><br><span class="line">  <span class="comment">//...省略constructor/getter/setter等方法...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Statistics <span class="title">count</span><span class="params">(Collection&lt;Long&gt; dataSet)</span> </span>&#123;</span><br><span class="line">  Statistics statistics = <span class="keyword">new</span> Statistics();</span><br><span class="line">  <span class="comment">//...省略计算逻辑 求最大值、最小值、平均值...</span></span><br><span class="line">  <span class="keyword">return</span> statistics;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照接口隔离原则，我们应该把 <code>count()</code>  函数拆成几个更小粒度的函数，每个函数负责一个独立的统计功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">max</span><span class="params">(Collection&lt;Long&gt; dataSet)</span> </span>&#123; <span class="comment">//... &#125;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">min</span><span class="params">(Collection&lt;Long&gt; dataSet)</span> </span>&#123; <span class="comment">//... &#125; </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">average</span><span class="params">(Colletion&lt;Long&gt; dataSet)</span> </span>&#123; <span class="comment">//... &#125;</span></span><br><span class="line"><span class="comment">// ...省略其他统计函数...</span></span><br></pre></td></tr></table></figure><p>在某种意义上讲，<code>count()</code> 函数也不能算是职责不够单一，毕竟它做的事情只跟统计相关。判定功能是否单一，除了很强的主观性，还需要结合具体的场景。</p><p>如果在项目中，对每个统计需求，<code>Statistics</code> 定义的那几个统计信息都有涉及，那 <code>count()</code> 函数的设计就是合理的。如果每个统计需求只涉及 <code>Statistics</code> 罗列的统计信息中一部分，就会做很多无用功，势必影响代码的性能，特别是在需要统计的数据量很大的时候。<code>count()</code> 函数的设计就有点不合理了。</p><ul><li><code>OOP</code> 中的接口概念</li></ul><p>我们还可以把“接口”理解为 <code>OOP</code> 中的接口概念，比如 <code>Java</code> 中的 <code>interface</code>。</p><p>举个栗子🌰 假设我们的项目中用到了三个外部系统：<code>Redis</code>、<code>MySQL</code>、<code>Kafka</code>。每个系统都对应一系列配置信息，比如地址、端口、访问超时时间等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ConfigSource configSource; <span class="comment">//配置中心（比如zookeeper）</span></span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> timeout;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxTotal;</span><br><span class="line">    <span class="comment">//省略其他配置: maxWaitMillis,maxIdle,minIdle...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedisConfig</span><span class="params">(ConfigSource configSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.configSource = configSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.address;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...省略其他get()、init()方法...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//从configSource加载配置到address/timeout/maxTotal...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaConfig</span> </span>&#123; <span class="comment">//...省略... &#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MysqlConfig</span> </span>&#123; <span class="comment">//...省略... &#125;</span></span><br></pre></td></tr></table></figure><p>现在，我们有一个新的功能需求，以固定时间频率（<code>periodInSeconds</code>）来调用 <code>RedisConfig</code>、<code>KafkaConfig</code> 的 <code>update()</code> 方法更新配置信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Updater</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> <span class="title">implemets</span> <span class="title">Updater</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...省略其他属性和方法...</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123; <span class="comment">//... &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaConfig</span> <span class="keyword">implements</span> <span class="title">Updater</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...省略其他属性和方法...</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123; <span class="comment">//... &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MysqlConfig</span> </span>&#123; <span class="comment">//...省略其他属性和方法... &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledUpdater</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> initialDelayInSeconds;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> periodInSeconds;</span><br><span class="line">    <span class="keyword">private</span> Updater updater;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ScheduleUpdater</span><span class="params">(Updater updater, <span class="keyword">long</span> initialDelayInSeconds, <span class="keyword">long</span> periodInSeconds)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.updater = updater;</span><br><span class="line">        <span class="keyword">this</span>.initialDelayInSeconds = initialDelayInSeconds;</span><br><span class="line">        <span class="keyword">this</span>.periodInSeconds = periodInSeconds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        executor.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                updater.update();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="keyword">this</span>.initialDelayInSeconds, <span class="keyword">this</span>.periodInSeconds, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">  ConfigSource configSource = <span class="keyword">new</span> ZookeeperConfigSource(<span class="comment">/*省略参数*/</span>);</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> RedisConfig redisConfig = <span class="keyword">new</span> RedisConfig(configSource);</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> KafkaConfig kafkaConfig = <span class="keyword">new</span> KakfaConfig(configSource);</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> MySqlConfig mysqlConfig = <span class="keyword">new</span> MysqlConfig(configSource);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ScheduledUpdater redisConfigUpdater = <span class="keyword">new</span> ScheduledUpdater(redisConfig, <span class="number">300</span>, <span class="number">300</span>);</span><br><span class="line">    redisConfigUpdater.run();</span><br><span class="line">    </span><br><span class="line">    ScheduledUpdater kafkaConfigUpdater = <span class="keyword">new</span> ScheduledUpdater(kafkaConfig, <span class="number">60</span>, <span class="number">60</span>);</span><br><span class="line">    redisConfigUpdater.run();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新的 <code>ScheduledUpdater</code> 类，只依赖 <code>Updater</code> 这个相关的接口，不需要被强迫去依赖不需要的 <code>Viewer</code> 接口，满足接口隔离原则。功能是定时调用传入的 <code>Updater</code> 的 <code>update</code>  方法。</p><p>现在，我们又有了一个新的监控功能需求。我们想暴露 <code>MySQL</code> 和 <code>Redis</code> 的配置信息，输出项目的配置信息到一个固定的 HTTP 地址。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Viewer</span> </span>&#123;</span><br><span class="line">  <span class="function">String <span class="title">outputInPlainText</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">Map&lt;String, String&gt; <span class="title">output</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> <span class="title">implemets</span> <span class="title">Updater</span>, <span class="title">Viewer</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...省略其他属性和方法...</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123; <span class="comment">//... &#125;</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">outputInPlainText</span><span class="params">()</span> </span>&#123; <span class="comment">//... &#125;</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title">output</span><span class="params">()</span> </span>&#123; <span class="comment">//...&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaConfig</span> <span class="keyword">implements</span> <span class="title">Updater</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...省略其他属性和方法...</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123; <span class="comment">//... &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MysqlConfig</span> <span class="keyword">implements</span> <span class="title">Viewer</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...省略其他属性和方法...</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">outputInPlainText</span><span class="params">()</span> </span>&#123; <span class="comment">//... &#125;</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title">output</span><span class="params">()</span> </span>&#123; <span class="comment">//...&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleHttpServer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String host;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line">  <span class="keyword">private</span> Map&lt;String, List&lt;Viewer&gt;&gt; viewers = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SimpleHttpServer</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;<span class="comment">//...&#125;</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addViewers</span><span class="params">(String urlDirectory, Viewer viewer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!viewers.containsKey(urlDirectory)) &#123;</span><br><span class="line">      viewers.put(urlDirectory, <span class="keyword">new</span> ArrayList&lt;Viewer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.viewers.get(urlDirectory).add(viewer);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="comment">//... &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    ConfigSource configSource = <span class="keyword">new</span> ZookeeperConfigSource();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> RedisConfig redisConfig = <span class="keyword">new</span> RedisConfig(configSource);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> KafkaConfig kafkaConfig = <span class="keyword">new</span> KakfaConfig(configSource);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> MySqlConfig mysqlConfig = <span class="keyword">new</span> MySqlConfig(configSource);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ScheduledUpdater redisConfigUpdater =<span class="keyword">new</span> ScheduledUpdater(redisConfig, <span class="number">300</span>, <span class="number">300</span>);</span><br><span class="line">        redisConfigUpdater.run();</span><br><span class="line">        </span><br><span class="line">        ScheduledUpdater kafkaConfigUpdater =<span class="keyword">new</span> ScheduledUpdater(kafkaConfig, <span class="number">60</span>, <span class="number">60</span>);</span><br><span class="line">        kafkaConfigUpdater.run();</span><br><span class="line">        </span><br><span class="line">        SimpleHttpServer simpleHttpServer = <span class="keyword">new</span> SimpleHttpServer(“<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>”, <span class="number">2389</span>);</span><br><span class="line">        simpleHttpServer.addViewer(<span class="string">"/config"</span>, redisConfig);</span><br><span class="line">        simpleHttpServer.addViewer(<span class="string">"/config"</span>, mysqlConfig);</span><br><span class="line">        simpleHttpServer.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SimpleHttpServer</code> 只依赖跟查看信息相关的 <code>Viewer</code> 接口，不依赖不需要的 <code>Updater</code> 接口，也满足接口隔离原则。</p><p>这种方式比普通大而全的 <code>Config</code> 接口更加灵活、易扩展、易复用，因为 <code>Updater</code>、<code>Viewer</code> 职责更加单一，添加新需求也容易应对。同时也防止了重写无用的接口，可读性更高。</p><h2 id="3-接口隔离原则与单一职责原则的区别"><a href="#3-接口隔离原则与单一职责原则的区别" class="headerlink" title="3 接口隔离原则与单一职责原则的区别"></a>3 接口隔离原则与单一职责原则的区别</h2><p>单一职责原则针对的是模块、类、接口的设计。</p><p>接口隔离原则相对于单一职责原则，一方面更侧重于接口的设计，另一方面它的思考角度也是不同的。</p><p>接口隔离原则提供了一种判断接口的职责是否单一的标准：通过调用者如何使用接口来间接地判定。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。</p><hr><h1 id="🚩依赖反转原则"><a href="#🚩依赖反转原则" class="headerlink" title="🚩依赖反转原则"></a>🚩依赖反转原则</h1><p>在讲 “依赖反转原则 <code>(Dependency Inversion Principe 简称 DIP)</code>” 之前，我们先讲一讲基础知识。</p><h2 id="1-控制反转"><a href="#1-控制反转" class="headerlink" title="1 控制反转"></a>1 控制反转</h2><p><code>（ Inversion Of Control IOC）</code></p><p>这里的 ”控制” 指的是对程序执行流程的控制，而 “反转” 指的是在没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流程可以通过框架来控制。流程的控制权从程序员 “反转” 到了框架。</p><p>举个栗子🌰 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">doTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;<span class="comment">//这部分逻辑可以放到框架中</span></span><br><span class="line">    <span class="keyword">if</span> (doTest()) &#123;</span><br><span class="line">      System.out.println(<span class="string">"Test succeed."</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">"Test failed."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，所有的流程都由程序员来控制。我们再来看，如何利用 ”控制反转“ 来实现同样的功能。</p><p>首先是框架代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCase</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (doTest()) &#123;</span><br><span class="line">      System.out.println(<span class="string">"Test succeed."</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">"Test failed."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">doTest</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JunitApplication</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;TestCase&gt; testCases = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(TestCase testCase)</span> </span>&#123;</span><br><span class="line">    testCases.add(testCase);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (TestCase <span class="keyword">case</span>: testCases) &#123;</span><br><span class="line">      <span class="keyword">case</span>.run();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>我们只需要在框架预留的扩展点，也就是 <code>TestCase</code> 类中的 <code>doTest()</code> 抽象函数中，填充具体的测试代码就可以实现之前的功能了，完全不需要写负责执行流程的 <code>main()</code> 函数了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceTest</span> <span class="keyword">extends</span> <span class="title">TestCase</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">doTest</span><span class="params">()</span> </span>&#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册操作还可以通过配置的方式来实现，不需要程序员显示调用register()</span></span><br><span class="line">JunitApplication.register(<span class="keyword">new</span> UserServiceTest();</span><br></pre></td></tr></table></figure><p>这就是典型的通过框架来实现 “控制反转” 的例子。</p><p>框架提供了一个可扩展的代码骨架，用来组装对象、管理整个执行流程。<br>程序员利用框架进行开发的时候，只需要往预留的扩展点上，添加跟自己业务相关的代码，就可以利用框架来驱动整个程序流程的执行。</p><p>控制反转并不是一种具体的实现技巧，而是一个比较笼统的设计思想，一般用来指导框架层面的设计。</p><h2 id="2-依赖注入"><a href="#2-依赖注入" class="headerlink" title="2 依赖注入"></a>2 依赖注入</h2><p><code>（Dependency Injection DI）</code></p><p>有一个非常形象的说法，那就是：依赖注入是一个标价 <code>25</code> 美元，实际上只值 <code>5</code> 美分的概念。也就是说，这个概念听起来很 “高大上” ，实际上，理解、应用起来非常简单。</p><p>那到底什么是依赖注入呢？<br>我们用一句话来概括就是：不通过 <code>new()</code> 的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类使用。</p><p>举个栗子🌰 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Notification</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> MessageSender messageSender;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 通过构造函数将messageSender传递进来</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Notification</span><span class="params">(MessageSender messageSender)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.messageSender = messageSender;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String cellphone, String message)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...省略校验逻辑等...</span></span><br><span class="line">    <span class="keyword">this</span>.messageSender.send(cellphone, message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用Notification</span></span><br><span class="line">MessageSender messageSender = <span class="keyword">new</span> MessageSender();</span><br><span class="line">Notification notification = <span class="keyword">new</span> Notification(messageSender);</span><br></pre></td></tr></table></figure><p>通过依赖注入的方式来将依赖的类对象传递进来，这样就提高了代码的扩展性，我们可以灵活地替换依赖的类。</p><p>这一点在我们之前讲 “开闭原则” 的时候也提到过。</p><p>上面代码还有继续优化的空间，我们还可以把 MessageSender 定义成接口，<strong>基于接口而非实现编程</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Notification</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> MessageSender messageSender;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Notification</span><span class="params">(MessageSender messageSender)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.messageSender = messageSender;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String cellphone, String message)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.messageSender.send(cellphone, message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MessageSender</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(String cellphone, String message)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 短信发送类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsSender</span> <span class="keyword">implements</span> <span class="title">MessageSender</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String cellphone, String message)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 站内信发送类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InboxSender</span> <span class="keyword">implements</span> <span class="title">MessageSender</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String cellphone, String message)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用Notification</span></span><br><span class="line">MessageSender messageSender = <span class="keyword">new</span> SmsSender();</span><br><span class="line">Notification notification = <span class="keyword">new</span> Notification(messageSender);</span><br></pre></td></tr></table></figure><p>依赖注入非常简单，但却非常有用！！它是编写可测试性代码最有效的手段。</p><p><strong>“基于接口而非实现编程” 跟 “依赖注入” ，看起来非常类似，那它俩有什么区别和联系呢？</strong></p><p>二者都是从外部传入依赖对象而不是在内部去 <code>new</code> 一个出来。</p><p>区别是 “基于接口而非实现编程” 强调的是 “接口” ，强调依赖的对象是接口，而不是具体的实现类；而 “依赖注入” 不强调这个，类或接口都可以，只要是从外部传入不是在内部 <code>new</code> 出来都可以称为依赖注入。</p><h2 id="3-依赖反转原则"><a href="#3-依赖反转原则" class="headerlink" title="3 依赖反转原则"></a>3 依赖反转原则</h2><p><code>（Dependency Inversion Principle DIP）</code></p><p><code>High-level modules shouldn’t depend on low-level modules. Both modules should depend on abstractions. In addition, abstractions shouldn’t depend on details. Details depend on abstractions. (高层模块（high-level modules）不要依赖低层模块（low-level）。高层模块和低层模块应该通过抽象（abstractions）来互相依赖。除此之外，抽象（abstractions）不要依赖具体实现细节（details），具体实现细节（details）依赖抽象（abstractions）。)</code></p><p>所谓高层模块和低层模块的划分，简单来说就是，在调用链上，<strong>调用者</strong> 属于高层，<strong>被调用者</strong> 属于低层。</p><p>依赖反转原则也叫作依赖倒置原则。这条原则跟控制反转有点类似，主要用来指导框架层面的设计。</p><p>举个栗子🌰 </p><p><code>Tomcat</code> 是运行 <code>Java Web</code> 应用程序的容器。<br>我们编写的 <code>Web</code> 应用程序代码只需要部署在 <code>Tomcat</code> 容器下，便可以被 <code>Tomcat</code> 容器调用执行。按照之前的划分原则，<code>Tomcat</code> 就是高层模块，我们编写的 <code>Web</code> 应用程序代码就是低层模块。<code>Tomcat</code> 和应用程序代码之间并没有直接的依赖关系，两者都依赖同一个 “抽象” ，也就是 <code>Servlet</code> 规范。<code>Servlet</code> 规范不依赖具体的 <code>Tomcat</code> 容器和应用程序的实现细节，而 <code>Tomcat</code> 容器和应用程序依赖 <code>Servlet</code> 规范。</p><hr><h1 id="🚩KISS-原则"><a href="#🚩KISS-原则" class="headerlink" title="🚩KISS 原则"></a>🚩KISS 原则</h1><p><code>Keep It Simple and Stupid.</code>  </p><p><code>Keep It Short and Simple.</code>   </p><p><code>Keep It Simple and Straightforward.</code> </p><p><code>(尽量保持简单。)</code></p><p>代码的可读性和可维护性是衡量代码质量非常重要的两个标准。而 <code>KISS</code> 原则就是保持代码可读和可维护的重要手段。代码足够简单，也就意味着很容易读懂，<code>bug</code> 比较难隐藏。即便出现 <code>bug</code>，修复起来也比较简单。</p><h2 id="1-代码行数越少就越“简单”吗？"><a href="#1-代码行数越少就越“简单”吗？" class="headerlink" title="1 代码行数越少就越“简单”吗？"></a>1 代码行数越少就越“简单”吗？</h2><p>举几个栗子🌰 对比一下。 检查输入的字符串 <code>ipAddress</code> 是否是合法的 IP 地址。一个合法的 <code>IP</code> 地址由四个数字组成，并且通过 “.” 来进行分割。每组数字的取值范围是 <code>0~255</code>。第一组数字比较特殊，不允许为 <code>0</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种实现方式: 使用正则表达式</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidIpAddressV1</span><span class="params">(String ipAddress)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (StringUtils.isBlank(ipAddress)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  String regex = <span class="string">"^(1\\d&#123;2&#125;|2[0-4]\\d|25[0-5]|[1-9]\\d|[1-9])\\."</span></span><br><span class="line">          + <span class="string">"(1\\d&#123;2&#125;|2[0-4]\\d|25[0-5]|[1-9]\\d|\\d)\\."</span></span><br><span class="line">          + <span class="string">"(1\\d&#123;2&#125;|2[0-4]\\d|25[0-5]|[1-9]\\d|\\d)\\."</span></span><br><span class="line">          + <span class="string">"(1\\d&#123;2&#125;|2[0-4]\\d|25[0-5]|[1-9]\\d|\\d)$"</span>;</span><br><span class="line">  <span class="keyword">return</span> ipAddress.matches(regex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种实现方式: 使用现成的工具类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidIpAddressV2</span><span class="params">(String ipAddress)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (StringUtils.isBlank(ipAddress)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  String[] ipUnits = StringUtils.split(ipAddress, <span class="string">'.'</span>);</span><br><span class="line">  <span class="keyword">if</span> (ipUnits.length != <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> ipUnitIntValue;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      ipUnitIntValue = Integer.parseInt(ipUnits[i]);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ipUnitIntValue &lt; <span class="number">0</span> || ipUnitIntValue &gt; <span class="number">255</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; ipUnitIntValue == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三种实现方式: 不使用任何工具类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidIpAddressV3</span><span class="params">(String ipAddress)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span>[] ipChars = ipAddress.toCharArray();</span><br><span class="line">  <span class="keyword">int</span> length = ipChars.length;</span><br><span class="line">  <span class="keyword">int</span> ipUnitIntValue = -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">boolean</span> isFirstUnit = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">int</span> unitsCount = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">    <span class="keyword">char</span> c = ipChars[i];</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">'.'</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (ipUnitIntValue &lt; <span class="number">0</span> || ipUnitIntValue &gt; <span class="number">255</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (isFirstUnit &amp;&amp; ipUnitIntValue == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (isFirstUnit) isFirstUnit = <span class="keyword">false</span>;</span><br><span class="line">      ipUnitIntValue = -<span class="number">1</span>;</span><br><span class="line">      unitsCount++;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ipUnitIntValue == -<span class="number">1</span>) ipUnitIntValue = <span class="number">0</span>;</span><br><span class="line">    ipUnitIntValue = ipUnitIntValue * <span class="number">10</span> + (c - <span class="string">'0'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (ipUnitIntValue &lt; <span class="number">0</span> || ipUnitIntValue &gt; <span class="number">255</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (unitsCount != <span class="number">3</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>第一种实现方式利用的是正则表达式<br>只用三行代码就把这个问题搞定了。它的代码行数最少，那是不是就最符合 KISS 原则呢？答案是否定的。虽然代码行数最少，看似最简单，实际上却很复杂。这正是因为它使用了正则表达式。</p><p>一方面，正则表达式本身是比较复杂的，写出完全没有 <code>bug</code> 的正则表达本身就比较有挑战；另一方面，并不是每个程序员都精通正则表达式。这种实现方式会导致代码的可读性和可维护性变差，所以，从 <code>KISS</code> 原则的设计初衷上来讲，这种实现方式并不符合 <code>KISS</code> 原则。</p></li><li><p>第二种实现方式使用了 <code>StringUtils</code> 类、<code>Integer</code> 类提供的一些现成的工具函数处理 <code>IP</code> 地址字符串。</p></li><li><p>第三种实现方式，不使用任何工具函数，而是通过逐一处理 <code>IP</code> 地址中的字符，来判断是否合法。</p><p>第三种实现方式完全是自己操作底层字符，只针对 <code>IP</code> 地址这一种格式的数据输入来做处理，没有太多多余的函数调用和其他不必要的处理逻辑，所以，在执行效率上，这种类似定制化的处理代码方式肯定比通用的工具类要高些。</p><p>从性能上来说，尽管第三种实现方式性能更高些，但还是更倾向于选择第二种实现方法。那是因为第三种实现方式实际上是一种过度优化。除非 <code>isValidIpAddress()</code> 函数是影响系统性能的瓶颈代码，否则，这样优化的投入产出比并不高，增加了代码实现的难度、牺牲了代码的可读性，性能上的提升却并不明显。</p><p>从代码行数上来说，这两种方式差不多。但是，第三种要比第二种更加有难度，更容易写出 <code>bug</code>。</p><p>从可读性上来说，第二种实现方式的代码逻辑更清晰、更好理解。</p><p>所以，在这两种实现方式中，第二种实现方式更加 “简单” ，更加符合 <code>KISS</code> 原则。</p></li></ul><h2 id="2-代码逻辑复杂就违背-KISS-原则吗？"><a href="#2-代码逻辑复杂就违背-KISS-原则吗？" class="headerlink" title="2 代码逻辑复杂就违背 KISS 原则吗？"></a>2 代码逻辑复杂就违背 KISS 原则吗？</h2><p>刚刚我们提到，并不是代码行数越少就越“简单”，还要考虑逻辑复杂度、实现难度、代码的可读性等。那如果一段代码的逻辑复杂、实现难度大、可读性也不太好，是不是就一定违背 <code>KISS</code> 原则呢？其实这也是由业务场景决定的。举个栗子🌰 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// KMP algorithm: a, b分别是主串和模式串；n, m分别是主串和模式串的长度。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kmp</span><span class="params">(<span class="keyword">char</span>[] a, <span class="keyword">int</span> n, <span class="keyword">char</span>[] b, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[] next = getNexts(b, m);</span><br><span class="line">  <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; a[i] != b[j]) &#123; <span class="comment">// 一直找到a[i]和b[j]</span></span><br><span class="line">      j = next[j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a[i] == b[j]) &#123;</span><br><span class="line">      ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j == m) &#123; <span class="comment">// 找到匹配模式串的了</span></span><br><span class="line">      <span class="keyword">return</span> i - m + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b表示模式串，m表示模式串的长度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getNexts(<span class="keyword">char</span>[] b, <span class="keyword">int</span> m) &#123;</span><br><span class="line">  <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">  next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> k = -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">    <span class="keyword">while</span> (k != -<span class="number">1</span> &amp;&amp; b[k + <span class="number">1</span>] != b[i]) &#123;</span><br><span class="line">      k = next[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (b[k + <span class="number">1</span>] == b[i]) &#123;</span><br><span class="line">      ++k;</span><br><span class="line">    &#125;</span><br><span class="line">    next[i] = k;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一段 <code>KMP</code> 字符串匹配算法，它以快速高效著称。<code>KMP</code> 字符串匹配算法完全符合我们刚提到的逻辑复杂、实现难度大、可读性差的特点，但当我们需要处理长文本字符串匹配问题（几百 <code>MB</code> 大小文本内容的匹配），或者字符串匹配是某个产品的核心功能（比如 <code>Vim</code>、<code>Word</code> 等文本编辑器），又或者字符串匹配算法是系统性能瓶颈的时候，这时它并不违反 <code>KISS</code> 原则。</p><p>本身就复杂的问题，用复杂的方法解决，并不违背 <code>KISS</code> 原则。</p><p>不过，平时的项目开发中涉及的字符串匹配问题，大部分都是针对比较小的文本。在这种情况下，直接调用编程语言提供的现成的字符串匹配函数就足够了。如果非得用 <code>KMP</code> 算法、BM 算法来实现字符串匹配，那就真的违背 <code>KISS</code> 原则了。</p><p>也就是说，同样的代码，在某个业务场景下满足 <code>KISS</code> 原则，换一个应用场景可能就不满足了。</p><h2 id="3-如何写出满足-KISS-原则的代码？"><a href="#3-如何写出满足-KISS-原则的代码？" class="headerlink" title="3 如何写出满足 KISS 原则的代码？"></a>3 如何写出满足 KISS 原则的代码？</h2><ul><li>不要使用同事可能不懂的技术来实现代码。比如前面例子中的正则表达式，还有一些编程语言中过于高级的语法等。</li><li>不要重复造轮子，要善于使用已经有的工具类库。经验证明，自己去实现这些类库，出 <code>bug</code> 的概率会更高，维护的成本也比较高。</li><li>不要过度优化。不要过度使用一些奇技淫巧（比如，位运算代替算术运算、复杂的条件语句代替 <code>if-else</code>、使用一些过于底层的函数等）来优化代码，牺牲代码的可读性。</li></ul><p>评判代码是否简单，有一个很有效的间接方法，那就是 <code>code review</code>。如果在 <code>code review</code> 的时候，同事对你的代码有很多疑问，那就说明你的代码有可能不够 “简单” ，需要优化啦。</p><p>我们在做开发的时候，一定不要过度设计，不要觉得简单的东西就没有技术含量。实际上，越是能用简单的方法解决复杂的问题，越能体现一个人的能力。</p><h2 id="4-YAGNI-原则跟-KISS-原则说的是一回事吗？"><a href="#4-YAGNI-原则跟-KISS-原则说的是一回事吗？" class="headerlink" title="4 YAGNI 原则跟 KISS 原则说的是一回事吗？"></a>4 YAGNI 原则跟 KISS 原则说的是一回事吗？</h2><p><code>You Ain’t Gonna Need It(你不会需要它)</code> </p><p>不要去设计当前用不到的功能；不要去编写当前用不到的代码。实际上，这条原则的核心思想就是：不要做过度设计。</p><p>对于 <code>Java</code> 程序员来说，我们经常使用 <code>Maven</code> 或者 <code>Gradle</code> 来管理依赖的类库（<code>library</code>），有些同事为了避免开发中 <code>library</code> 包缺失而频繁地修改 <code>Maven</code> 或者 <code>Gradle</code> 配置文件，提前往项目里引入大量常用的 <code>library</code> 包。实际上，这样的做法也是违背 YAGNI 原则的。</p><p><code>KISS</code> 原则讲的是 “如何做” 的问题（尽量保持简单），而 <code>YAGNI</code> 原则说的是 “要不要做” 的问题（当前不需要的就不要做）。</p><hr><h1 id="🚩DRY-原则"><a href="#🚩DRY-原则" class="headerlink" title="🚩DRY 原则"></a>🚩DRY 原则</h1><p><code>Don’t Repeat Yourself(不要重复自己)</code> </p><p>可以理解为：不要写重复的代码。</p><p>你可能会觉得，这条原则非常简单、非常容易应用。只要两段代码长得一样，那就是违反 <code>DRY</code> 原则了。真的是这样吗？<br>答案是否定的。这是很多人对这条原则存在的误解。实际上，重复的代码不一定违反 <code>DRY</code> 原则，而且有些看似不重复的代码也有可能违反 <code>DRY</code> 原则。</p><h2 id="1-实现逻辑重复"><a href="#1-实现逻辑重复" class="headerlink" title="1 实现逻辑重复"></a>1 实现逻辑重复</h2><p>举个栗子🌰 有两处非常明显的重复的代码片段：<code>isValidUserName()</code> 函数和 <code>isValidPassword()</code> 函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserAuthenticator</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">authenticate</span><span class="params">(String username, String password)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isValidUsername(username)) &#123;</span><br><span class="line">      <span class="comment">// ...throw InvalidUsernameException...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isValidPassword(password)) &#123;</span><br><span class="line">      <span class="comment">// ...throw InvalidPasswordException...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...省略其他代码...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValidUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// check not null, not empty</span></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(username)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// check length: 4~64</span></span><br><span class="line">    <span class="keyword">int</span> length = username.length();</span><br><span class="line">    <span class="keyword">if</span> (length &lt; <span class="number">4</span> || length &gt; <span class="number">64</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// contains only lowcase characters</span></span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.isAllLowerCase(username)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// contains only a~z,0~9,dot</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">      <span class="keyword">char</span> c = username.charAt(i);</span><br><span class="line">      <span class="keyword">if</span> (!(c &gt;= <span class="string">'a'</span> &amp;&amp; c &lt;= <span class="string">'z'</span>) || (c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) || c == <span class="string">'.'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValidPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// check not null, not empty</span></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(password)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// check length: 4~64</span></span><br><span class="line">    <span class="keyword">int</span> length = password.length();</span><br><span class="line">    <span class="keyword">if</span> (length &lt; <span class="number">4</span> || length &gt; <span class="number">64</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// contains only lowcase characters</span></span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.isAllLowerCase(password)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// contains only a~z,0~9,dot</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">      <span class="keyword">char</span> c = password.charAt(i);</span><br><span class="line">      <span class="keyword">if</span> (!(c &gt;= <span class="string">'a'</span> &amp;&amp; c &lt;= <span class="string">'z'</span>) || (c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) || c == <span class="string">'.'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重复的代码被敲了两遍，或者简单 <code>copy-paste</code> 了一下，看起来明显违反 <code>DRY</code> 原则。为了移除重复的代码，我们对上面的代码做下重构，将 <code>isValidUserName()</code> 函数和 <code>isValidPassword()</code> 函数，合并为一个更通用的函数 <code>isValidUserNameOrPassword()</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserAuthenticatorV2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">authenticate</span><span class="params">(String userName, String password)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isValidUsernameOrPassword(userName)) &#123;</span><br><span class="line">      <span class="comment">// ...throw InvalidUsernameException...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isValidUsernameOrPassword(password)) &#123;</span><br><span class="line">      <span class="comment">// ...throw InvalidPasswordException...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValidUsernameOrPassword</span><span class="params">(String usernameOrPassword)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//省略实现逻辑</span></span><br><span class="line">    <span class="comment">//跟原来的isValidUsername()或isValidPassword()的实现逻辑一样...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过重构之后，代码行数减少了，也没有重复的代码了，是不是更好了呢？答案是否定的！！</p><p>合并之后的 <code>isValidUserNameOrPassword()</code> 函数，负责两件事情：验证用户名和验证密码，违反了 “单一职责原则” 和 “接口隔离原则” 。</p><p>从代码实现逻辑上看起来是重复的，但是从语义上并不重复。所谓 “语义不重复” 指的是：从功能上来看，这两个函数干的是完全不重复的两件事情，一个是校验用户名，另一个是校验密码。<br>经过重构之后，在未来的某一天，如果我们修改了密码的校验逻辑，我们就要把合并后的函数，重新拆成合并前的那两个函数。</p><p>尽管代码的实现逻辑是相同的，但语义不同，我们判定它并不违反 <code>DRY</code> 原则。对于包含重复代码的问题，我们可以通过抽象成更细粒度函数的方式来解决。</p><h2 id="2-功能语义重复"><a href="#2-功能语义重复" class="headerlink" title="2 功能语义重复"></a>2 功能语义重复</h2><p>在同一个项目代码中有下面两个函数：<code>isValidIp()</code> 和 <code>checkIfIpValid()</code>。尽管两个函数的命名不同，实现逻辑不同，但功能是相同的，都是用来判定 <code>IP</code>地址是否合法的。</p><p>之所以在同一个项目中会有两个功能相同的函数，那是因为这两个函数是由两个不同的同事开发的，这时经常遇到的，其中一个同事在不知道已经存在相同功能的情况下又写了一个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidIp</span><span class="params">(String ipAddress)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (StringUtils.isBlank(ipAddress)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  String regex = <span class="string">"^(1\\d&#123;2&#125;|2[0-4]\\d|25[0-5]|[1-9]\\d|[1-9])\\."</span></span><br><span class="line">          + <span class="string">"(1\\d&#123;2&#125;|2[0-4]\\d|25[0-5]|[1-9]\\d|\\d)\\."</span></span><br><span class="line">          + <span class="string">"(1\\d&#123;2&#125;|2[0-4]\\d|25[0-5]|[1-9]\\d|\\d)\\."</span></span><br><span class="line">          + <span class="string">"(1\\d&#123;2&#125;|2[0-4]\\d|25[0-5]|[1-9]\\d|\\d)$"</span>;</span><br><span class="line">  <span class="keyword">return</span> ipAddress.matches(regex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkIfIpValid</span><span class="params">(String ipAddress)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (StringUtils.isBlank(ipAddress)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  String[] ipUnits = StringUtils.split(ipAddress, <span class="string">'.'</span>);</span><br><span class="line">  <span class="keyword">if</span> (ipUnits.length != <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> ipUnitIntValue;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      ipUnitIntValue = Integer.parseInt(ipUnits[i]);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ipUnitIntValue &lt; <span class="number">0</span> || ipUnitIntValue &gt; <span class="number">255</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; ipUnitIntValue == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，尽管两段代码的实现逻辑不重复，但语义重复，也就是功能重复，我们认为它违反了 DRY 原则。我们应该在项目中，统一一种实现思路，所有用到判断 <code>IP</code> 地址是否合法的地方，都统一调用同一个函数。</p><p>假设我们不统一实现思路，给不熟悉这部分代码的同事增加了阅读的难度。同事有可能研究了半天，觉得功能是一样的，但又有点疑惑，觉得是不是有更高深的考量，才定义了两个功能类似的函数，最终发现居然是代码设计的问题。</p><p>除此之外，如果哪天项目中 <code>IP</code> 地址是否合法的判定规则改变了，相应地，我们对 <code>isValidIp()</code> 的实现逻辑做了相应的修改，但却忘记了修改 <code>checkIfIpValid()</code> 函数。又或者，我们压根就不知道还存在一个功能相同的 <code>checkIfIpValid()</code> 函数，这样就会导致有些代码仍然使用老的 <code>IP</code> 地址判断逻辑，导致出现一些莫名其妙的 <code>bug</code>。</p><h2 id="3-代码执行重复"><a href="#3-代码执行重复" class="headerlink" title="3 代码执行重复"></a>3 代码执行重复</h2><p>第三个栗子🌰 <code>UserService</code> 中 <code>login()</code> 函数用来校验用户登录是否成功。如果失败，就返回异常；如果成功，就返回用户信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> UserRepo userRepo;<span class="comment">//通过依赖注入或者IOC框架注入</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> User <span class="title">login</span><span class="params">(String email, String password)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> existed = userRepo.checkIfUserExisted(email, password);</span><br><span class="line">    <span class="keyword">if</span> (!existed) &#123;<span class="comment">/*...throw AuthenticationFailureException...*/</span>&#125;</span><br><span class="line">    User user = userRepo.getUserByEmail(email);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRepo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkIfUserExisted</span><span class="params">(String email, String password)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!EmailValidation.validate(email)) &#123;<span class="comment">/*...throw InvalidEmailException...*/</span>&#125;</span><br><span class="line">    <span class="keyword">if</span> (!PasswordValidation.validate(password)) &#123;<span class="comment">/*...throw InvalidPasswordException...*/</span>&#125;</span><br><span class="line">    <span class="comment">//...query db to check if email&amp;password exists...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> User <span class="title">getUserByEmail</span><span class="params">(String email)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!EmailValidation.validate(email)) &#123;<span class="comment">/*...throw InvalidEmailException...*/</span>&#125;</span><br><span class="line">    <span class="comment">//...query db to get user by email...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码，既没有逻辑重复，也没有语义重复，但仍然违反了 <code>DRY</code> 原则。这是因为代码中存在 “执行重复” 。</p><p><code>email</code> 的校验逻辑被执行了两次。一次是在调用 <code>checkIfUserExisted()</code> 函数的时候，另一次是调用 <code>getUserByEmail()</code> 函数的时候。我们只需要将校验逻辑从 <code>UserRepo</code> 中移除，统一放到 <code>UserService</code> 中就可以了。</p><p>代码中还有一处比较隐蔽的执行重复，<code>login()</code> 函数并不需要调用 <code>checkIfUserExisted()</code> 函数，只需要调用一次 <code>getUserByEmail()</code> 函数，从数据库中获取到用户的 <code>email</code>、<code>password</code> 等信息，然后跟用户输入的 <code>email</code>、<code>password</code> 信息做对比，依次判断是否登录成功。</p><p>这样的优化是很有必要的。因为 <code>checkIfUserExisted()</code> 函数和 <code>getUserByEmail()</code> 函数都需要查询数据库，而数据库这类的 <code>I/O</code> 操作是比较耗时的。我们在写代码的时候，应当尽量减少这类 <code>I/O</code> 操作。</p><p>按照刚刚的修改思路，我们把代码重构一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> UserRepo userRepo;<span class="comment">//通过依赖注入或者IOC框架注入</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> User <span class="title">login</span><span class="params">(String email, String password)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!EmailValidation.validate(email)) &#123;<span class="comment">/*...throw InvalidEmailException...*/</span>&#125;</span><br><span class="line">    <span class="keyword">if</span> (!PasswordValidation.validate(password)) &#123;<span class="comment">/*...throw InvalidPasswordException...*/</span>&#125;</span><br><span class="line"></span><br><span class="line">    User user = userRepo.getUserByEmail(email);</span><br><span class="line">    <span class="keyword">if</span> (user == <span class="keyword">null</span> || !password.equals(user.getPassword())  &#123;<span class="comment">/*...throw AuthenticationFailureException...*/</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRepo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> User <span class="title">getUserByEmail</span><span class="params">(String email)</span> </span>&#123;<span class="comment">/*...query db to get user by email...*/</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-怎么提高代码复用性？"><a href="#4-怎么提高代码复用性？" class="headerlink" title="4 怎么提高代码复用性？"></a>4 怎么提高代码复用性？</h2><ul><li><p>减少代码耦合</p><p>对于高度耦合的代码，当我们希望复用其中的一个功能，想把这个功能的代码抽取出来成为一个独立的模块、类或者函数的时候，往往会发现牵一发而动全身。移动一点代码，就要牵连到很多其他相关的代码。所以，高度耦合的代码会影响到代码的复用性，我们要尽量减少代码耦合。</p></li><li><p>满足单一职责原则</p><p>如果职责不够单一，模块、类设计得大而全，那依赖它的代码或者它依赖的代码就会比较多，进而增加了代码的耦合。根据上一点，也就会影响到代码的复用性。相反，越细粒度的代码，代码的通用性会越好，越容易被复用。</p></li><li><p>模块化</p><p>这里的 “模块” ，不单单指一组类构成的模块，还可以理解为单个类、函数。我们要善于将功能独立的代码，封装成模块。独立的模块就像一块一块的积木，更加容易复用，可以直接拿来搭建更加复杂的系统。</p></li><li><p>业务与非业务逻辑分离</p><p>越是跟业务无关的代码越是容易复用，越是针对特定业务的代码越难复用。所以，为了复用跟业务无关的代码，我们将业务和非业务逻辑代码分离，抽取成一些通用的框架、类库、组件等。</p></li><li><p>通用代码下沉</p><p>从分层的角度来看，越底层的代码越通用、会被越多的模块调用，越应该设计得足够可复用。一般情况下，在代码分层之后，为了避免交叉调用导致调用关系混乱，我们只允许上层代码调用下层代码及同层代码之间的调用，杜绝下层代码调用上层代码。所以，通用的代码我们尽量下沉到更下层。</p></li><li><p>继承、多态、抽象、封装</p><p>利用继承，可以将公共的代码抽取到父类，子类复用父类的属性和方法。利用多态，我们可以动态地替换一段代码的部分逻辑，让这段代码可复用。除此之外，抽象和封装，从更加广义的层面、而非狭义的面向对象特性的层面来理解的话，越抽象、越不依赖具体的实现，越容易复用。代码封装成模块，隐藏可变的细节、暴露不变的接口，就越容易复用。</p></li><li><p>应用模板等设计模式</p><p>一些设计模式，也能提高代码的复用性。比如，模板模式利用了多态来实现，可以灵活地替换其中的部分代码，整个流程模板代码可复用。</p></li></ul><h2 id="5-辩证思考和灵活应用"><a href="#5-辩证思考和灵活应用" class="headerlink" title="5 辩证思考和灵活应用"></a>5 辩证思考和灵活应用</h2><p>实际上，编写可复用的代码并不简单。<br>除非有非常明确的复用需求，否则，为了暂时用不到的复用需求，花费太多的时间、精力，投入太多的开发成本，并不是一个值得推荐的做法。这也违反我们之前讲到的 <code>YAGNI</code> 原则。</p><p>有一个著名的原则，叫作 <code>“Rule of Three”</code> 。这条原则可以用在很多行业和场景中，我们在第一次写代码的时候，如果当下没有复用的需求，而未来的复用需求也不是特别明确，并且开发可复用代码的成本比较高，那我们就不需要考虑代码的复用性。<br>在之后我们开发新的功能的时候，发现可以复用之前写的这段代码，那我们就重构这段代码，让其变得更加可复用。</p><p>也就是说，第一次编写代码的时候，我们不考虑复用性；第二次遇到复用场景的时候，再进行重构使其复用。需要注意的是，<code>“Rule of Three”</code> 中的 <code>“Three”</code> 并不是真的就指确切的 <code>“三”</code> 。</p><hr><h1 id="🚩迪米特法则"><a href="#🚩迪米特法则" class="headerlink" title="🚩迪米特法则"></a>🚩迪米特法则</h1><p><code>Law of Demeter LOD</code></p><p><code>Each unit should have only limited knowledge about other units: only units “closely” related to the current unit. Or: Each unit should only talk to its friends; Don’t talk to strangers.(每个模块（unit）只应该了解那些与它关系密切的模块（units: only units “closely” related to the current unit）的有限知识（knowledge）。或者说，每个模块只和自己的朋友“说话”（talk），不和陌生人“说话”（talk）。)</code></p><p><code>不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口（也就是定义中的“有限知识”）。</code></p><p>迪米特法则。尽管它不像 <code>SOLID</code>、<code>KISS</code>、<code>DRY</code> 原则那样，人尽皆知，但它却非常实用。利用这个原则，能够帮我们实现代码的 “高内聚、松耦合” 。</p><h2 id="1-何为-“高内聚、松耦合”-？"><a href="#1-何为-“高内聚、松耦合”-？" class="headerlink" title="1 何为 “高内聚、松耦合” ？"></a>1 何为 “高内聚、松耦合” ？</h2><p>在这个设计思想中，“高内聚” 用来指导类本身的设计，“松耦合” 用来指导类与类之间依赖关系的设计。不过，这两者并非完全独立不相干。高内聚有助于松耦合，松耦合又需要高内聚的支持。</p><ul><li><p>所谓高内聚，就是指相近的功能应该放到同一个类中，不相近的功能不要放到同一个类中。</p><p>相近的功能往往会被同时修改，放到同一个类中，修改会比较集中，代码容易维护。实际上，单一职责原则是实现代码高内聚非常有效的设计原则。</p></li><li><p>所谓松耦合是说，在代码中，类与类之间的依赖关系简单清晰。</p><p>即使两个类有依赖关系，一个类的代码改动不会或者很少导致依赖类的代码改动。实际上，我们前面讲的依赖注入、接口隔离、基于接口而非实现编程，以及迪米特法则，都是为了实现代码的松耦合。</p></li></ul><p>##2 不该有直接依赖关系的类之间，不要有依赖</p><p>迪米特法则的前半部分，</p><h2 id="2-不该有直接依赖关系的类之间，不要有依赖"><a href="#2-不该有直接依赖关系的类之间，不要有依赖" class="headerlink" title="2 不该有直接依赖关系的类之间，不要有依赖"></a>2 不该有直接依赖关系的类之间，不要有依赖</h2><p>举个栗子🌰 代码中包含三个主要的类。其中，<code>NetworkTransporter</code> 类负责底层网络通信，根据请求获取数据；<code>HtmlDownloader</code> 类用来通过 <code>URL</code> 获取网页；<code>Document</code> 表示网页文档，后续的网页内容抽取、分词、索引都是以此为处理对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NetworkTransporter</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略属性和其他方法...</span></span><br><span class="line">    <span class="keyword">public</span> Byte[] send(HtmlRequest htmlRequest) &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HtmlDownloader</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> NetworkTransporter transporter;<span class="comment">//通过构造函数或IOC注入</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Html <span class="title">downloadHtml</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">    Byte[] rawHtml = transporter.send(<span class="keyword">new</span> HtmlRequest(url));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Html(rawHtml);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Document</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Html html;</span><br><span class="line">  <span class="keyword">private</span> String url;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Document</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.url = url;</span><br><span class="line">    HtmlDownloader downloader = <span class="keyword">new</span> HtmlDownloader();</span><br><span class="line">    <span class="keyword">this</span>.html = downloader.downloadHtml(url);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>首先看 <code>NetworkTransporter</code> 类</strong></p><p>作为一个底层网络通信类，我们希望它的功能尽可能通用，而不只是服务于下载 <code>HTML</code>，所有这里的参数 <code>HtmlRequest</code> 就限制了这个功能，我们不应该直接依赖太具体的发送对象 <code>HtmlRequest</code>。从这一点上讲，<code>NetworkTransporter</code> 类的设计违背迪米特法则，依赖了不该有直接依赖关系的 <code>HtmlRequest</code> 类。</p><p>有一个很形象的比喻。假如你现在要去商店买东西，你肯定不会直接把钱包给收银员，让收银员自己从里面拿钱，而是你从钱包里把钱拿出来交给收银员。这里的 <code>HtmlRequest</code> 对象就相当于钱包，<code>HtmlRequest</code> 里的 <code>address</code> 和 <code>content</code> 对象就相当于钱。我们应该把 <code>address</code> 和 <code>content</code> 交给 <code>NetworkTransporter</code>，而非是直接把 <code>HtmlRequest</code> 交给 <code>NetworkTransporter</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NetworkTransporter</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略属性和其他方法...</span></span><br><span class="line">    <span class="keyword">public</span> Byte[] send(String address, Byte[] data) &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>再来看 <code>HtmlDownloader</code> 类</strong></p><p>根据 <code>NetworkTransporter</code> 的修改 <code>HtmlDownloader</code> 也得做相应的修改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HtmlDownloader</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> NetworkTransporter transporter;<span class="comment">//通过构造函数或IOC注入</span></span><br><span class="line">  <span class="comment">// HtmlDownloader这里也要有相应的修改</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Html <span class="title">downloadHtml</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">    HtmlRequest htmlRequest = <span class="keyword">new</span> HtmlRequest(url);</span><br><span class="line">    Byte[] rawHtml = transporter.send(</span><br><span class="line">      htmlRequest.getAddress(), htmlRequest.getContent().getBytes());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Html(rawHtml);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>最后是 <code>Document</code> 类</strong></p><p>主要有三点。<br>第一，构造函数中的 <code>downloader.downloadHtml()</code> 逻辑复杂，耗时长，不应该放到构造函数中，会影响代码的可测试性<br>第二，<code>HtmlDownloader</code> 对象在构造函数中通过 <code>new</code> 来创建，违反了基于接口而非实现编程的设计思想，也会影响到代码的可测试性<br>第三，从业务含义上来讲，<code>Document</code> 网页文档没必要依赖 HtmlDownloader 类，违背了迪米特法则。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Document</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Html html;</span><br><span class="line">  <span class="keyword">private</span> String url;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Document</span><span class="params">(String url, Html html)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.html = html;</span><br><span class="line">    <span class="keyword">this</span>.url = url;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过一个工厂方法来创建Document</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DocumentFactory</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> HtmlDownloader downloader;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DocumentFactory</span><span class="params">(HtmlDownloader downloader)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.downloader = downloader;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Document <span class="title">createDocument</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">    Html html = downloader.downloadHtml(url);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Document(url, html);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就很好的解决了三个问题。</p></li></ul><h2 id="3-有依赖关系的类之间，尽量只依赖必要的接口"><a href="#3-有依赖关系的类之间，尽量只依赖必要的接口" class="headerlink" title="3 有依赖关系的类之间，尽量只依赖必要的接口"></a>3 有依赖关系的类之间，尽量只依赖必要的接口</h2><p>举个之前的栗子🌰  <code>Serialization</code> 类负责对象的序列化和反序列化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Serialization</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">    String serializedResult = ...;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> serializedResult;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">deserialize</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    Object deserializedResult = ...;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> deserializedResult;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单看这个类的设计，没有一点问题。<br>假设在我们的项目中，有些类只用到了序列化操作，而另一些类只用到反序列化操作。那基于迪米特法则后半部分 “有依赖关系的类之间，尽量只依赖必要的接口” ，只用到序列化操作的那部分类不应该依赖反序列化接口。同理，只用到反序列化操作的那部分类不应该依赖序列化接口。<br>那我们是不是又得把这个类拆开成两个类？那不就和之前在单一职责中说的冲突了吗？之前我们就说拆分后代码的内聚性显然没有原来 <code>Serialization</code> 高了。那有没有既不违背高内聚的设计思想，也不违背迪米特法则的方法呢？🤔🤔<br>既然在这说了，肯定是有的😁<br>我们可以利用 “接口隔离原则” 来解决这个问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  <span class="function">String <span class="title">serialize</span><span class="params">(Object object)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Deserializable</span> </span>&#123;</span><br><span class="line">  <span class="function">Object <span class="title">deserialize</span><span class="params">(String text)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Serialization</span> <span class="keyword">implements</span> <span class="title">Serializable</span>, <span class="title">Deserializable</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">    String serializedResult = ...;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> serializedResult;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">deserialize</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    Object deserializedResult = ...;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> deserializedResult;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoClass_1</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Serializable serializer;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Demo</span><span class="params">(Serializable serializer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.serializer = serializer;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoClass_2</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Deserializable deserializer;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Demo</span><span class="params">(Deserializable deserializer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.deserializer = deserializer;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管我们还是要往 <code>DemoClass_1</code> 的构造函数中，传入包含序列化和反序列化的 <code>Serialization</code> 实现类，但是，我们依赖的 <code>Serializable</code> 接口只包含序列化操作，<code>DemoClass_1</code> 无法使用 <code>Serialization</code> 类中的反序列化接口，对反序列化操作无感知，这也就符合了迪米特法则后半部分所说的 “依赖有限接口”的要求 。</p><p>上面的代码实现思路，也体现了 “基于接口而非实现编程” 的设计原则，结合迪米特法则，我们可以总结出一条新的设计原则，那就是 “基于最小接口而非最大实现编程”。</p><p>新的设计模式和设计原则是怎么创造出来的，实际上，就是在大量的实践中，针对开发痛点总结归纳出来的套路。</p><h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h1><blockquote><p><a href="https://time.geekbang.org/column/intro/250?utm_source=pinpaizhuanqu&utm_medium=geektime&utm_campaign=guanwang&utm_term=guanwang&utm_content=0511" target="_blank" rel="noopener">设计模式之美</a></p><p><a href="https://juejin.im/post/5d669bfc6fb9a06b1b19d25e" target="_blank" rel="noopener">通过代码示例来学习面向对象六大原则</a></p><p><a href="https://blog.cleancoder.com/" target="_blank" rel="noopener">The Clean Code Blog</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>稳定性优化</title>
      <link href="/2020/stability-optimization.html"/>
      <url>/2020/stability-optimization.html</url>
      
        <content type="html"><![CDATA[<h1 id="本文主要记载"><a href="#本文主要记载" class="headerlink" title="本文主要记载"></a>本文主要记载</h1><hr><p><code>Android</code> 稳定性优化主要注意一下几点：</p><ul><li><p><strong>执行超时 <code>(Timeout)</code></strong></p><p>长时间无法执行完成。对于 <code>Android</code> 系统来说,比较常见的便是 <code>Service</code> 、<code>Broadcast</code>、<code>provider</code> 以及 <code>input</code> , 当普通 <code>app</code> 进程超过一定时间没有执行完, 则会弹出应用无响应 <code>(Application Not Responding, ANR)</code> 的对话框。如果该 <code>app</code> 运行在 <code>system</code> 进程，更准确的来说,应该是 <code>(System Not Responding, SNR)</code> 。 虽然有 <code>ANR</code> 和 <code>SNR</code> 之分, 但习惯上大家都统称为 <code>ANR</code> 问题。</p><ul><li><strong>Service Timeout：</strong>比如前台服务在 <code>20s</code> 内未执行完成。</li><li><strong>broadcast Timeout：</strong>比如前台广播在 <code>10s</code> 内未执行完成。</li><li><strong>ContentProvider Timeout：</strong>内容提供者执行超时。</li><li><strong>InputDispatching Timeout：</strong>输入事件分发超时 <code>5s</code> ，包括按键和触摸事件。</li></ul></li><li><p>*<em>异常崩溃 <code>(Crash)</code> *</em></p><p>异常崩溃 <code>(Crash)</code> 的问题, 毫无疑问这不是时间上能解决的问题, 而是出现了未知的异常. 一旦触发崩溃会出现相应的调用栈, 但不糊输出各个进程的<code>traces</code>。</p><ul><li><p><strong><code>Java</code> 崩溃</strong> </p><p><a href="http://gityuan.com/2016/06/24/app-crash/" target="_blank" rel="noopener"> 理解Java Crash处理流程</a> </p><p>往往是抛出了一个未捕获的异常 <code>uncaughtException</code> 而导致的崩溃. 那是不是把所有的异常都 <code>catch</code> 住系统就没有问题呢？这个是要分情况的，有时候的异常强制崩溃可能会留下更大的问题，有些异常的抛出是需要深入分析 <code>Root Cause</code> ，从根源来解决问题, 而非简单粗糙的捕获住所有的异常.</p></li><li><p><strong><code>Native</code> 崩溃</strong></p><p><a href="http://gityuan.com/2016/06/25/android-native-crash/" target="_blank" rel="noopener">理解Native Crash处理流程</a> </p><p>由于进程收到 <code>signal</code>信号而引发的崩溃。当进程收到信号，并会触发信号处理函数，通过 <code>socket</code> 发送信息到 <code>debuggerd</code> 进程，<code>debuggerd</code> 进程收到事件后通过 <code>ptrace attach</code> 到目标进程, 获取 <code>cpu/memory/traces</code> 等关键信息后 <code>dettach</code> 。<code>Native crash</code> 情况比较多, 其中最为场景便是<code>SIGSEGV</code> 段错误异常，往往是内存出现异常，比如访问了权限不足的内存地址等。</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>App 刷脂</title>
      <link href="/2020/package-optimization.html"/>
      <url>/2020/package-optimization.html</url>
      
        <content type="html"><![CDATA[<h1 id="本文主要记载"><a href="#本文主要记载" class="headerlink" title="本文主要记载"></a>本文主要记载</h1><ul><li><strong>1 为什么要优化包体积？</strong></li><li><strong>2 包体积与应用性能有关系吗？</strong></li><li><strong>3 根据 APK 组成分析优化</strong><ul><li>3.1 代码相关<ul><li>3.1.1 Dex 探秘</li><li>3.1.2 Proguard</li><li>3.1.3 D8 与 R8 优化</li><li>3.1.4 去除 debug 信息与行号信息</li><li>3.1.5 Dex 分包<ul><li>Redex Ubuntu 具体实践</li></ul></li><li>3.1.6 使用 XZ Utils 进行 Dex 压缩</li><li>3.1.7 其他</li></ul></li><li>3.2 资源相关<ul><li>3.2.1 使用 Lint 的 Remove Unused Resource</li><li>3.2.2 shrinkResources</li><li>3.2.3 AndResGuard 工具<ul><li>实践</li></ul></li></ul></li><li>3.3 Native Library 相关<ul><li>3.3.1 Library 压缩</li><li>3.3.2 Library 合并与裁剪</li></ul></li></ul></li></ul><hr><h1 id="1-为什么要优化包体积？"><a href="#1-为什么要优化包体积？" class="headerlink" title="1 为什么要优化包体积？"></a>1 为什么要优化包体积？</h1><ol><li><p><strong>下载转化率。</strong> </p><p><code>APK</code> 刷脂在 <strong>初创项目</strong> 中优先级是比较低的，相对于 <strong>启动优化、卡顿优化</strong> 它的好处不是那么明显，包体积优化最主要的好处是对应用 <strong>下载转化率</strong> 的影响，它是 <code>App</code> 业务运营的重要指标之一，在项目精细化运营的阶段是非常重要的。在 <code>2018</code> 年的 <code>Google I/O</code>，<code>Google</code> 透露了 <code>Google Play</code> 上安装包体积与下载转化率的关系图。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/f8a5e264dee4ee6879cd6c30d4bbf368.png" alt="图片来源于 Android 开发高手课"></p><p>从这张图上看，大体来说，安装包越小，转化率越高这个结论成立。包体积越小，用户下载等待的时间也会越短，所以下载转换成功率也就越高，一个 <code>100MB</code> 的应用，用户即使点了下载，也可能因为网络速度慢、突然反悔下载失败。对于一个 <code>10MB</code> 的应用，用户点了下载之后，在犹豫要不要下的时候已经下载完了。但是正如上图的数据，安装包大小与转化率的关系是非常微妙的。<code>10MB</code> 跟 <code>15MB</code> 可能差距不大，但是 <code>10MB</code> 跟 <code>40MB</code> 的差距还是非常明显的。</p><p>而且，现在很多大型的 <code>App</code> 一般都会有一个极速版本的 <code>App</code>，这个也是出于下载转化率方面的考虑。</p></li><li><p><strong>推广成本。</strong>一般来说，包体积对渠道推广和厂商预装的单价会有非常大的影响。特别是厂商预装，这主要是因为厂商留给预装应用的总空间是有限的。如果你的包体积非常大，那就会影响厂商预装其他应用。</p></li><li><p><strong>应用市场。</strong> <code>Google Play</code> 要求超过 <code>100MB</code> 的应用只能使用 <a href="https://developer.android.google.cn/google/play/expansion-files" target="_blank" rel="noopener">APK 扩展文件方式</a> 上传，由此可见应用包体积对应用市场的服务器带宽成本还是会有一点压力的。如果想避免使用扩展文件，并且想要应用程序的下载大小大于 <code>100 MB</code>，则应该使用 <code>Android App Bundles</code> 上传应用程序。</p><p><a href="https://www.jianshu.com/p/3754d4e7f4e5" target="_blank" rel="noopener">Android App Bundle</a> </p></li></ol><hr><h1 id="2-包体积与应用性能有关系吗？"><a href="#2-包体积与应用性能有关系吗？" class="headerlink" title="2 包体积与应用性能有关系吗？"></a>2 包体积与应用性能有关系吗？</h1><p>包体积除了转化率的影响，主要还会对 <code>App</code> 三个方面 的性能有一定的影响</p><ul><li><strong>安装时间：</strong>文件拷贝、<code>Library</code> 解压，并且，在编译 <code>ODEX</code> 的时候，特别是对于 <code>Android 5.0</code> 和 <code>6.0</code> 系统来说，耗费的时间比较久，而 <code>Android 7.0</code> 之后有了 混合编译，所以还可以接受。最后，<code>App</code> 变大后，其签名校验的时间也会变长。微信 <code>13</code> 个 <code>Dex</code> 光是编译 <code>ODEX</code> 的时间可能就要 <code>5</code> 分钟。</li><li><strong>运行内存：</strong>在内存优化的时候我们就说过，<code>Resource</code> 资源、<code>Library</code> 以及 <code>Dex</code> 类加载这些都会占用不少的内存。</li><li><strong>ROM 空间：</strong>如果应用的安装包大小为 <code>50MB</code>，那么启动解压之后很可能就已经超过 <code>100MB</code> 了。并且，如果 闪存空间不足，很可能出现 “写入放大” 的情况。具体情况将在 <code>I/O 优化</code> 中讲解。</li></ul><hr><h1 id="3-根据-APK-组成分析优化"><a href="#3-根据-APK-组成分析优化" class="headerlink" title="3 根据 APK 组成分析优化"></a>3 根据 APK 组成分析优化</h1><p>我们都知道，<code>Android</code> 项目最终会编译成一个 <code>.apk</code> 后缀的文件，实际上它就是一个 压缩包。因此，它内部还有很多不同类型的文件，这些文件，按照大小，共分为 代码优化、资源优化、<code>So</code> 优化。</p><h2 id="3-1-代码相关"><a href="#3-1-代码相关" class="headerlink" title="3.1 代码相关"></a>3.1 代码相关</h2><p><code>classes.dex</code>，我们在项目中所编写的 <code>java</code> 文件，经过编译之后会生成一个 <code>.class</code> 文件，而这些所有的 <code>.class</code> 文件呢，它最终会经过 <code>dx</code> 工具编译生成一个 <code>classes.dex</code>。</p><p>对于大部分应用来说，<code>Dex</code> 都是包体积中的大头。日常开发中 <code>Dex</code> 数量从 1 个增长到 10 多个，我们的代码量真的增长了那么多倍吗？而且 Dex 的数量对用户安装时间也是一个非常大的挑战，在不砍功能的前提下，我们看看有哪些方法可以减少这部分空间。</p><p>与传统 <code>jar</code> 文件相比，<code>Dex</code> 文件的大小能够缩减 <code>50%</code> 左右。关于 <code>Class</code> 文件与 <code>Dex</code> 文件的结果对比图如下所示：</p><h3 id="3-1-1-Dex-探秘"><a href="#3-1-1-Dex-探秘" class="headerlink" title="3.1.1 Dex 探秘"></a>3.1.1 Dex 探秘</h3><p><code>Dex</code> 是 <code>Android</code> 系统的可执行文件，包含 应用程序的全部操作指令以及运行时数据。因为 <code>Dalvik</code> 是一种针对嵌入式设备而特殊设计的 <code>Java</code> 虚拟机，所以 <code>Dex</code> 文件与标准的 <code>Class</code> 文件在结构设计上有着本质的区别。</p><p>当 <code>Java</code> 程序被编译成 <code>class</code> 文件之后，还需要使用 <code>dx</code> 工具将所有的 class 文件整合到一个 <code>dex</code> 文件中，这样 <code>dex</code> 文件就将原来每个 <code>class</code> 文件中都有的共有信息合成了一体，这样做的目的是 保证其中的每个类都能够共享数据，这在一定程度上降低了信息冗余，同时也使得文件结构更加紧凑。</p><p><a href="https://www.jianshu.com/p/f7f0a712ddfe" target="_blank" rel="noopener">Dex文件格式详解</a> </p><p><code>Dex</code> 一般在应用包体积中占据了不少比重，并且 <code>Dex</code> 数量越多，<code>App</code> 的安装时间也会越长。所以，优化它们可以说是重中之重。下面就来看看有哪些方式可以优化 <code>Dex</code> 这部分的体积。</p><hr><h3 id="3-1-2-ProGuard"><a href="#3-1-2-ProGuard" class="headerlink" title="3.1.2 ProGuard"></a>3.1.2 ProGuard</h3><ol><li><p><strong>代码混淆的形式</strong></p><p>目前，代码混淆的形式主要有三种，如下所示：</p><ul><li>将代码中的各个元素，比如类、函数、变量的名字改变成无意义的名字。例如将 <code>hasValue</code> 转换成单个的字母 <code>a</code>。这样，反编译阅读的人就无法通过名字来猜测用途。</li><li>重写代码中的部分逻辑，将它变成功能上等价，但是又难以理解的形式。比如它会改变循环的指令、结构体。</li><li>打乱代码的格式，比如多加一些空格或删除空格，或者将一行代码写成多行，将多行代码改成一行。</li></ul></li><li><p><strong><code>Proguard</code> 的作用</strong></p><p>在 <code>Android SDK</code> 里面集成了一个工具 — <code>Proguard</code>，它是一个免费的 <code>Java</code> 类文件压缩、优化、混淆、预先校验的工具。它的主要作用大概可以概括为两点，如下所示：</p><ul><li><p><strong>瘦身</strong>：它可以检测并移除未使用到的类、方法、字段以及指令、冗余代码，并能够对字节码进行深度优化。最后，它还会将类中的字段、方法、类的名称改成简短无意义的名字。</p><ul><li><p><strong>压缩：</strong>默认开启，以减小应用体积，移除未被使用的类和成员，并且会在优化动作执行之后再次执行，因为优化后可能会再次暴露一些未被使用的类和成员。我们可以使用如下规则来关闭压缩：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭压缩</span></span><br><span class="line"><span class="attr">-dontshrink</span></span><br></pre></td></tr></table></figure></li><li><p><strong>优化：</strong>默认开启，在字节码级别执行优化，让应用运行的更快。使用如下规则可进行优化相关操作：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭优化</span></span><br><span class="line"><span class="attr">-dontoptimize</span></span><br><span class="line"><span class="comment"># 表示proguard对代码进行迭代优化的次数，Android一般为5</span></span><br><span class="line"><span class="meta">-optimizationpasses</span> <span class="string">5</span></span><br></pre></td></tr></table></figure><p><strong>优化细节包括：</strong>内联、修饰符、合并类、方法、 <code>Gson</code> 库的使用、把类都标记为 <code>final</code>、把枚举类型简化为常量、把一些类都垂直合并进当前类的结构中、把一些类都水平合并进当前类的结构中、移除 <code>write-only</code> 字段、把类标记为私有的、把字段的值跨方法地进行传递、把一些方法标记为私有、静态或 <code>final</code>、解除方法的 <code>synchronized</code> 标记、移除没有使用的方法参数等 30 多种优化项</p></li></ul></li><li><p><strong>安全：</strong>增加代码被反编译的难度，一定程度上保证代码的安全。</p><ul><li><p><strong>混淆：</strong>默认开启，增大反编译难度，类和类成员会被随机命名，除非用 优化字节码 等规则进行保护。使用如下规则可以关闭混淆：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭混淆</span></span><br><span class="line"><span class="attr">-dontobfuscate</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><p>所以说，混淆不仅是保障 <strong>Android 程序源码安全</strong> 的 <strong>第一道门槛</strong>，还可以优化字节码的大小</p></li><li><p><code>Proguard</code> 的配置</p><p>混淆之后，默认会在工程目录 <code>app/build/outputs/mapping/release</code> 下生成一个 <code>mapping.txt</code> 文件，这就是混淆规则，所以我们可以根据这个文件把混淆后的代码反推回原本的代码。要使用混淆，我们只需配置如下代码即可：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">buildTypes &#123;</span><br><span class="line">    release &#123;</span><br><span class="line">        <span class="comment">// 1、是否进行混淆</span></span><br><span class="line">        minifyEnabled <span class="literal">true</span></span><br><span class="line">        <span class="comment">// 2、开启zipAlign可以让安装包中的资源按4字节对齐，这样可以减少应用在运行时的内存消耗</span></span><br><span class="line">        zipAlignEnabled <span class="literal">true</span></span><br><span class="line">        <span class="comment">// 3、移除无用的resource文件：当ProGuard 把部分无用代码移除的时候，</span></span><br><span class="line">        <span class="comment">// 这些代码所引用的资源也会被标记为无用资源，然后</span></span><br><span class="line">        <span class="comment">// 系统通过资源压缩功能将它们移除。</span></span><br><span class="line">        <span class="comment">// 需要注意的是目前资源压缩器目前不会移除values/文件夹中</span></span><br><span class="line">        <span class="comment">// 定义的资源（例如字符串、尺寸、样式和颜色）</span></span><br><span class="line">        <span class="comment">// 开启后，Android构建工具会通过ResourceUsageAnalyzer来检查</span></span><br><span class="line">        <span class="comment">// 哪些资源是无用的，当检查到无用的资源时会把该资源替换</span></span><br><span class="line">        <span class="comment">// 成预定义的版本。主要是针对.png、.9.png、.xml提供了</span></span><br><span class="line">        <span class="comment">// TINY_PNG、TINY_9PNG、TINY_XML这3个byte数组的预定义版本。</span></span><br><span class="line">        <span class="comment">// 资源压缩工具默认是采用安全压缩模式来运行，可以通过开启严格压缩模式来达到更好的瘦身效果。</span></span><br><span class="line">        shrinkResources <span class="literal">true</span></span><br><span class="line">        <span class="comment">// 4、混淆文件的位置，其中 proguard-android.txt 为sdk默认的混淆配置，</span></span><br><span class="line">        <span class="comment">// 它的位置位于android-sdk/tools/proguard/proguard-android.txt，</span></span><br><span class="line">        <span class="comment">// 此外，proguard-android-optimize.txt 也为sdk默认的混淆配置，</span></span><br><span class="line">        <span class="comment">// 但是它默认打开了优化开关。并且，我们可在配置混淆文件将android.util.Log置为无效代码，</span></span><br><span class="line">        <span class="comment">// 以去除apk中打印日志的代码。而 proguard-rules.pro 是该模块下的混淆配置。</span></span><br><span class="line">      <span class="comment">// 如果想让各个 library 的 proguard-rules 也生效使用  consumerProguardFiles 'proguard-rules.pro'</span></span><br><span class="line">        proguardFiles getDefaultProguardFile(<span class="string">'proguard-android-optimize.txt'</span>), <span class="string">'proguard-rules.pro'</span></span><br><span class="line">        signingConfig signingConfigs.release</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在执行完 <code>ProGuard</code> 之后，<code>ProGuard</code> 都会在 <code>${project.buildDir}/outputs/mapping/${flavorDir}/</code> 生成以下文件：</p><table><thead><tr><th><strong>文件名</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>dump.txt</td><td>APK 中所有类文件的内部结构</td></tr><tr><td>mapping.txt</td><td>提供原始与混淆过的类、方法和字段名称之间的转换，<br />可以通过 proguard.obfuscate.MappingReader 来解析</td></tr><tr><td>seeds.txt</td><td>列出未进行混淆的类和成员</td></tr><tr><td>usage.txt</td><td>列出从 APK 移除的代码</td></tr></tbody></table></li></ol><ol start="4"><li><p><strong>混淆的基本规则</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># * 表示仅保持该包下的类名，而子包下的类名还是会被混淆</span></span><br><span class="line"><span class="meta">-keep</span> <span class="string">class com.json.chao.wanandroid.*</span></span><br><span class="line"><span class="comment"># ** 表示把本包和所含子包下的类名都保持</span></span><br><span class="line"><span class="meta">-keep</span> <span class="string">class com.json.chao.wanandroid.**</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 既保持类名，又保持里面的内容不被混淆</span></span><br><span class="line"><span class="meta">-keep</span> <span class="string">class com.json.chao.wanandroid.* &#123;*;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以使用Java的基本规则来保护特定类不被混淆，比如extend，implement等这些Java规则</span></span><br><span class="line"><span class="meta">-keep</span> <span class="string">public class * extends android.app.Activity</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 保留MainPagerFragment内部类JavaScriptInterface中的所有public内容不被混淆</span></span><br><span class="line"><span class="meta">-keepclassmembers</span> <span class="string">class com.json.chao.wanandroid.ui.fragment.MainPagerFragment$JavaScriptInterface &#123;</span></span><br><span class="line">    <span class="attr">public</span> <span class="string">*;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 仅希望保护类下的特定内容时需使用匹配符</span></span><br><span class="line"><span class="meta">&lt;init&gt;;</span>     <span class="string">//匹配所有构造器</span></span><br><span class="line"><span class="meta">&lt;fields&gt;;</span>   <span class="string">//匹配所有字段</span></span><br><span class="line"><span class="meta">&lt;methods&gt;;</span>  <span class="string">//匹配所有方法</span></span><br><span class="line"><span class="comment"># 还可以在上述匹配符前面加上private 、public、native等来进一步指定不被混淆的内 容</span></span><br><span class="line"><span class="meta">-keep</span> <span class="string">class com.json.chao.wanandroid.app.WanAndroidApp &#123;</span></span><br><span class="line">    <span class="attr">public</span> <span class="string">&lt;fields&gt;;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"><span class="comment"># 也可以加入参数，以下表示用java.lang.String作为入参的构造函数不会被混淆</span></span><br><span class="line"><span class="meta">-keep</span> <span class="string">class com.json.chao.wanandroid.app.WanAndroidApp &#123;</span></span><br><span class="line">    <span class="attr">public</span> <span class="string">&lt;init&gt;(java.lang.String);</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不需要保持类名，仅需要把该类下的特定成员保持不被混淆时使用keepclassmembers</span></span><br><span class="line"><span class="comment"># 如果拥有某成员，要保留类和类成员使用-keepclasseswithmembers</span></span><br></pre></td></tr></table></figure><p>添加在 <code>AndroidMainfest</code> 中的类默认不会被混淆，所以四大组件和 <code>Application</code> 的子类和 <code>Framework</code> 层下所有的类默认不会进行混淆，自定义的 <code>View</code> 默认也不会被混淆。所以下面代码加不加都可以</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">-keep</span> <span class="string">public class * extends android.app.Activity</span></span><br><span class="line"><span class="meta">-keep</span> <span class="string">public class * extends android.app.Application</span></span><br><span class="line"><span class="meta">-keep</span> <span class="string">public class * extends android.app.Service</span></span><br><span class="line"><span class="meta">-keep</span> <span class="string">public class * extends android.content.BroadcastReceiver</span></span><br><span class="line"><span class="meta">-keep</span> <span class="string">public class * extends android.content.ContentProvider</span></span><br><span class="line"><span class="meta">-keep</span> <span class="string">public class * extends android.view.View</span></span><br></pre></td></tr></table></figure><p>“十个 <code>ProGuard</code> 配置九个坑”，特别是各种第三方 <code>SDK</code>。我们需要仔细检查最终合并的 <code>ProGuard</code> 配置文件，是不是存在过度 <code>keep</code> 的现象。</p><p>可以通过下面的方法输出 <code>ProGuard</code> 的最终配置，尤其需要注意各种的 <code>keep *</code>，很多情况下我们只需要 <code>keep</code> 其中的某个包、某个方法，或者是类名就可以了。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">-printconfiguration</span>  <span class="string">configuration.txt</span></span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="3-1-3-D8-与-R8-优化"><a href="#3-1-3-D8-与-R8-优化" class="headerlink" title="3.1.3 D8 与 R8 优化"></a>3.1.3 D8 与 R8 优化</h3><ul><li><p><strong>D8 优化</strong></p><p>1, <code>Dex</code>编译时间更短</p><p>2, <code>.dex</code> 文件大小更小</p><p>3, <code>D8</code> 编译的 <code>.dex</code> 文件将拥有相同或者是更好的运行时性能</p><p>4, 包含 <code>Java 8</code> 语言支持的处理</p></li></ul><p>在 <code>gradle.properties</code> 文件中新增如下代码。<code>Android Studio 3.1</code> 或之后的版本 <code>D8</code> 将会被作为默认的 <code>Dex</code> 编译器。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android.enableD8 = <span class="literal">true</span></span><br></pre></td></tr></table></figure><ul><li><strong>R8 优化</strong></li></ul><p>如果我们当前使用的是 <code>Android Studio 3.4</code> 或 <code>Android Gradle</code> 插件 <code>3.4.0</code> 及其更高版本， <a href="https://www.guardsquare.com/en/blog/proguard-and-r8" target="_blank" rel="noopener">R8</a>  会作为默认编译器。否则，我们必须要在 <code>gradle.properties</code> 中配置如下代码让 <code>App</code> 的混淆去支持 <code>R8</code>，如下所示：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">android.enableR8</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">android.enableR8.libraries</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure><ul><li><strong>R8 与混淆相比优势在哪里呢</strong></li></ul><p><code>ProGuard</code> 和 <code>R8</code> 都应用了基本名称混淆：它们都使用简短，无意义的名称重命名类，字段和方法。他们还可以删除调试属性。但是，<code>R8</code> 在 <code>inline</code> 内联容器类中更有效，并且在删除未使用的类，字段和方法上则更具侵略性。例如，<code>R8</code> 本身集成在 <code>ProGuard V6.1.1</code> 版本中，在压缩 <code>apk</code> 的大小方面，与 <code>ProGuard</code> 的 <code>8.5％</code> 相比，使用 <code>R8 apk</code> 尺寸减小了约 <code>10％</code>。并且，随着 <code>Kotlin</code> 现在成为 <code>Android</code> 的第一语言，<code>R8</code> 进行了 <code>ProGuard</code> 尚未提供的一些 <code>Kotlin</code> 的特定的优化。</p><p>想对 <code>D8</code> 与 <code>R8</code> 的实现细节有更多地了解前往 <a href="https://jakewharton.com/" target="_blank" rel="noopener">Jake Wharton 个人博客</a>。</p><hr><h3 id="3-1-4-去除-debug-信息与行号信息"><a href="#3-1-4-去除-debug-信息与行号信息" class="headerlink" title="3.1.4 去除 debug 信息与行号信息"></a>3.1.4 去除 debug 信息与行号信息</h3><p>在讲解什么是 <code>deubg</code> 信息与行号信息之前，我们需要先了解 <code>Dex</code> 的一些知识。</p><p>我们都知道，<code>JVM</code> 运行时加载的是 <code>.class</code> 文件，而 <code>Android</code> 为了使包大小更加紧凑、运行时更加高效就发明了 <code>Dalvik</code> 和 <code>ART</code> 虚拟机，两种虚拟机运行的都是 <code>.dex</code> 文件，当然 <code>ART</code> 虚拟机还可以同时运行 <code>oat</code> 文件。</p><p>所以 <code>Dex</code> 文件里的信息内容和 <code>Class</code> 文件包含的信息是一样的，不同的是 <code>Dex</code> 文件对 <code>Class</code> 中的信息做了去重，一个 <code>Dex</code> 包含了很多的 <code>Class</code> 文件，并且在结构上有比较大的差异，<code>Class</code> 是流式的结构，<code>Dex</code>  是分区结构，<code>Dex</code> 内部的各个区块间通过 <code>offset</code> 来进行索引。</p><p>某个应用通过相同的 <code>ProGuard</code> 规则生成一个 <code>Debug</code> 包和 <code>Release</code> 包，其中 <code>Debug</code> 包的大小是 <code>4MB</code>，<code>Release</code> 包只有 <code>3.5MB</code>。</p><p>既然它们 <code>ProGuard</code> 的混淆与优化的规则是一样的，那它们之间的差异在哪里呢？那就是 <code>DebugItem</code>。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/69ec4986053903876d55fbd37d47a710.webp" alt="图片来源于 Android 开发高手课"></p><p>从图中可以看到，<code>Dex</code> 文件的结构主要分为四大块：<code>header</code> 区，索引区，<code>data</code> 区，<code>map</code> 区。而我们的 <code>debug</code> 与行号信息就保存在 <code>data</code> 区中的 <code>DebugItems</code> 区域。</p><p><code>DebugItem</code> 里面主要包含两种信息：</p><ul><li><strong>调试的信息。</strong>函数的参数变量和所有的局部变量。</li><li><strong>排查问题的信息。</strong>所有的指令集行号和源文件行号的对应关系。</li></ul><p>为了在应用出现问题时，我们能在调试的时候去显示相应的调试信息或者上报 <code>crash</code> 或者主动获取调用堆栈的时候能通过 <code>debugItem</code> 来获取对应的行号，我们都会在混淆配置中加上下面的规则：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">-keepattributes</span> <span class="string">SourceFile, LineNumberTable</span></span><br></pre></td></tr></table></figure><p>对于去除 <code>debuginfo</code> 以及行号信息更详细的分析，看一下支付宝的一篇文章<a href="https://mp.weixin.qq.com/s/_gnT2kjqpfMFs0kqAg4Qig" target="_blank" rel="noopener">《Android 包大小极致压缩》</a> 。通过这个方法，我们可以实现既保留行号，但是又可以减少大约 <code>5%</code> 的 <code>Dex</code> 体积。</p><p>事实上，支付宝参考的是 <code>Facebook</code> 的一个开源编译工具 <a href="https://github.com/facebook/redex" target="_blank" rel="noopener">ReDex</a> 。<code>ReDex</code> 除了没有文档之外，绝对是客户端领域非常硬核的一个开源库，非常值得去认真研究。<code>ReDex</code> 这个库去除 <code>Debug</code> 信息是通过 <code>StripDebugInfoPass</code> 完成。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"redex"</span> : &#123;</span><br><span class="line">    <span class="attr">"passes"</span> : [</span><br><span class="line">      <span class="string">"StripDebugInfoPass"</span>,</span><br><span class="line">      <span class="string">"RegAllocPass"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"StripDebugInfoPass"</span> : &#123;</span><br><span class="line">    <span class="attr">"drop_all_dbg_info"</span> : <span class="literal">false</span>,     <span class="comment">// 去除所有的debug信息，0表示不去除</span></span><br><span class="line">    <span class="attr">"drop_local_variables"</span> : <span class="literal">true</span>,  <span class="comment">// 去除所有局部变量，1表示去除</span></span><br><span class="line">    <span class="attr">"drop_line_numbers"</span> : <span class="literal">false</span>,     <span class="comment">// 去除行号，0表示不去除</span></span><br><span class="line">    <span class="attr">"drop_src_files"</span> : <span class="literal">false</span>,        </span><br><span class="line">    <span class="attr">"use_whitelist"</span> : <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"drop_prologue_end"</span> : <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"drop_epilogue_begin"</span> : <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"drop_all_dbg_info_if_empty"</span> : <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"RegAllocPass"</span> : &#123;</span><br><span class="line">  <span class="attr">"live_range_splitting"</span>: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="3-1-5-Dex-分包"><a href="#3-1-5-Dex-分包" class="headerlink" title="3.1.5 Dex 分包"></a>3.1.5 Dex 分包</h3><p>当我们的 <code>APK</code> 过大时，<code>Dex</code> 的方法数就会超过 <code>65536</code> 个，因此，必须采用 <code>mutildex</code> 进行分包，但是此时每一个 <code>Dex</code> 可能会调用到其它 <code>Dex</code> 中的方法，这种跨 <code>Dex</code> 调用的方式会造成许多冗余信息，</p><p>简单来说，如下图所示如果将 <code>Class A</code> 与 <code>Class B</code> 分别编译到不同的 <code>Dex</code> 中，由于 <code>method a</code> 调用了 <code>method b</code>，所以在 <code>classes2.dex</code> 中也需要加上 <code>method b</code> 的 <code>id</code>。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/96d08f01c5fe27c74bfcd5ac529232d5.webp" alt="图片来源于 Android 开发高手课"></p><p>因为跨 <code>Dex</code> 调用造成的这些冗余信息，它对我们 <code>Dex</code> 的大小会造成下如下两点：</p><ul><li><strong>method id 爆表：</strong>每个 <code>Dex</code> 的 <code>method id</code> 需要小于 <code>65536</code>，因为 <code>method id</code> 的大量冗余导致每个 <code>Dex</code> 真正可以放的 <code>Class</code> 变少，这是造成最终编译的 <code>Dex</code> 数量增多。</li><li><strong>信息冗余：</strong>因为需要记录跨 <code>Dex</code> 调用的方法的详细信息，所以在 <code>classes2.dex</code> 我们还需要记录 <code>Class B</code> 以及 <code>method b</code> 的定义，造成 <code>string_ids</code>、<code>type_ids</code>、<code>proto_ids</code> 这几部分信息的冗余。</li></ul><p>为了进一步减少 <code>Dex</code> 的数量，我们希望每个 <code>Dex</code> 的方法数都是满的，即分配了 <code>65536</code> 个方法。最好保证 Dex 有效率应该在 80% 以上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Dex信息有效率 &#x3D; define methods数量&#x2F;reference methods数量</span><br></pre></td></tr></table></figure><p><code>define methods</code> 与 <code>reference methods</code> 可以通过 <code>Android Studio</code> 查看 <code>APK</code> 选择一个 <code>dex</code> 文件查看。<code>define classes and methods</code> 是指真正在这个 <code>Dex</code> 中定义的类以及它们的方法。而 <code>reference methods</code> 指的是 <code>define methods</code> 以及 <code>define methods</code> 引用到的方法。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/fbd2ebe2b0ffc43447e414994c56d6c4.webp" alt="图片来源于 Android 开发高手课"></p><p>关于 Dex 的格式以及各个字段的定义，可以参考 <a href="https://www.jianshu.com/p/f7f0a712ddfe" target="_blank" rel="noopener">Dex文件格式详解</a></p><p><strong>那如何实现 Dex 信息有效率提升呢？</strong></p><p>关键在于我们需要将有调用关系的类和方法分配到同一个 <code>Dex</code> 中，即减少跨 <code>Dex</code> 的调用的情况。但是由于类的调用关系非常复杂，我们不太可能可以计算出最优解，只能得到局部的最优解。</p><p>所幸的是，<code>ReDex</code> 的 <a href="https://github.com/facebook/redex/blob/master/opt/interdex/CrossDexRefMinimizer.cpp" target="_blank" rel="noopener">CrossDexDefMinimizer</a> 类分析了类之间的调用关系，并使用了贪心算法去计算局部的最优解（编译效果和 <code>dex</code> 优化效果之间的某一个平衡点）。使用 <code>InterDexPass</code> 配置项可以把互相引用的类尽量放在同个 <code>Dex</code>，增加类的 <code>pre-verify</code>，以此提升应用的冷启动速度。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"redex"</span> : &#123;</span><br><span class="line">    <span class="attr">"passes"</span> : [</span><br><span class="line">      <span class="string">"InterDexPass"</span>,</span><br><span class="line">      <span class="string">"RegAllocPass"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"InterDexPass"</span> : &#123;</span><br><span class="line">    <span class="attr">"minimize_cross_dex_refs"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"minimize_cross_dex_refs_method_ref_weight"</span>: <span class="number">100</span>,</span><br><span class="line">    <span class="attr">"minimize_cross_dex_refs_field_ref_weight"</span>: <span class="number">90</span>,</span><br><span class="line">    <span class="attr">"minimize_cross_dex_refs_type_ref_weight"</span>: <span class="number">100</span>,</span><br><span class="line">    <span class="attr">"minimize_cross_dex_refs_string_ref_weight"</span>: <span class="number">90</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"RegAllocPass"</span> : &#123;</span><br><span class="line">        <span class="attr">"live_range_splitting"</span>: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Redex-Ubuntu-具体实践"><a href="#Redex-Ubuntu-具体实践" class="headerlink" title="Redex Ubuntu 具体实践"></a>Redex Ubuntu 具体实践</h4><p><a href="http://mirrors.aliyun.com/ubuntu-releases/" target="_blank" rel="noopener">ubuntu 下载</a> 我试过 16、18、20 的 <code>Ubuntu</code> 最终 <code>20</code> 的编译成功了。</p><p><a href="https://fbredex.com/docs/installation" target="_blank" rel="noopener">Redex 文档</a></p><ol><li><p>首先我们安装必要东西</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install \</span><br><span class="line">    g++ \</span><br><span class="line">    automake \</span><br><span class="line">    autoconf \</span><br><span class="line">    autoconf-archive \</span><br><span class="line">    libtool \</span><br><span class="line">    liblz4-dev \</span><br><span class="line">    liblzma-dev \</span><br><span class="line">    make \</span><br><span class="line">    zlib1g-dev \</span><br><span class="line">    binutils-dev \</span><br><span class="line">    libjemalloc-dev \</span><br><span class="line">    libiberty-dev \</span><br><span class="line">    libjsoncpp-dev</span><br></pre></td></tr></table></figure></li><li><p>然后拉取代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;facebook&#x2F;redex.git</span><br><span class="line">cd redex</span><br></pre></td></tr></table></figure></li><li><p>一般情况下都需要升级 <code>boost</code> ，可以先执行以下编译试试~ </p><p>   <code>-j4</code> 表示使用 <code>4</code> 个线程编译。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># if you&#39;re using gcc, please use gcc-5</span><br><span class="line">autoreconf -ivf &amp;&amp; .&#x2F;configure &amp;&amp; make -j4</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure></li><li><p>如果提示 <code>error boost</code> 版本的问题，升级 <code>boost</code> ，在 <code>redex</code> 目录内输入如下命令，然后重新执行第三步</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo .&#x2F;get_boost.sh</span><br></pre></td></tr></table></figure><pre><code>在第三步编译过程中 18 版本的 `Ubuntu` 一直报错，各种办法未解决，`16` 版本 `boost` 升级配置不上。</code></pre></li><li><p><code>config</code> 配置</p><p>在 <code>Redex</code> 在运行的时候，它是根据 <code>redex/config/default.config</code> 这个配置文件中的通道 <code>passes</code> 中添加不同的优化项来对 <code>APK</code> 的 <code>Dex</code> 进行处理的，我们可以参考 <code>redex/config/default.config</code> 这个默认的配置，里面的 <code>passes</code> 中不同的配置项都有特定的优化。为了优化 <code>App</code> 的包体积，我们再加上 <code>interdex_stripdebuginfo.config</code> 中的配置项去删除 <code>debugInfo</code> 和减少跨 <code>Dex</code> 调用的情况，最终的 <code>interdex_stripdebuginfo.config</code> 配置代码 如下所示：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"redex"</span> : &#123;</span><br><span class="line">        <span class="attr">"passes"</span> : [</span><br><span class="line">            <span class="string">"StripDebugInfoPass"</span>,</span><br><span class="line">            <span class="string">"InterDexPass"</span>,</span><br><span class="line">            <span class="string">"RegAllocPass"</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"StripDebugInfoPass"</span> : &#123;</span><br><span class="line">        <span class="attr">"drop_all_dbg_info"</span> : <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">"drop_local_variables"</span> : <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">"drop_line_numbers"</span> : <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">"drop_src_files"</span> : <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">"use_whitelist"</span> : <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">"cls_whitelist"</span> : [],</span><br><span class="line">        <span class="attr">"method_whitelist"</span> : [],</span><br><span class="line">        <span class="attr">"drop_prologue_end"</span> : <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">"drop_epilogue_begin"</span> : <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">"drop_all_dbg_info_if_empty"</span> : <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"InterDexPass"</span> : &#123;</span><br><span class="line">        <span class="attr">"minimize_cross_dex_refs"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">"minimize_cross_dex_refs_method_ref_weight"</span>: <span class="number">100</span>,</span><br><span class="line">        <span class="attr">"minimize_cross_dex_refs_field_ref_weight"</span>: <span class="number">90</span>,</span><br><span class="line">        <span class="attr">"minimize_cross_dex_refs_type_ref_weight"</span>: <span class="number">100</span>,</span><br><span class="line">        <span class="attr">"minimize_cross_dex_refs_string_ref_weight"</span>: <span class="number">90</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"RegAllocPass"</span> : &#123;</span><br><span class="line">        <span class="attr">"live_range_splitting"</span>: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"string_sort_mode"</span> : <span class="string">"class_order"</span>,</span><br><span class="line">    <span class="attr">"bytecode_sort_mode"</span> : <span class="string">"class_order"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>最后，执行相应的 <code>redex</code> 优化命令</strong></p><p>它使用了贪心这种局部最优解的方式去减少跨 <code>Dex</code> 调用造成的信息冗余，命令如下所示（注意，在 <code>redex</code> 的前面可能需要加上 <code>Android sdk</code> 的路径，因为 <code>redex</code> 中使用到了 <code>sdk</code> 下的 <code>zipalign</code> 工具）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ANDROID_SDK&#x3D;&#x2F;usr&#x2F;lib&#x2F;android-sdk redex --sign -s &lt;xxx&gt;.jks -a &lt;alias&gt; -p 123456 -c redex&#x2F;config&#x2F;interdex_stripdebuginfo.config -P proguard-rules.pro &lt;youapk&gt;.apk -o redexSign.apk</span><br></pre></td></tr></table></figure><p>上述 <code>redex</code> 命令的 <code>关键参数含义</code> 如下所示：</p><ul><li><strong>–sign：</strong> 对生成的 <code>apk</code> 进行签名。</li><li><strong>-s：</strong> 配置应用的签名文件。</li><li><strong>-a：</strong> 配置应用签名的 <code>key_alias</code>。</li><li><strong>-p：</strong> 配置应用签名的 <code>key_password</code>。</li><li><strong>-c：</strong> 指定 <code>redex</code> 进行 <code>Dex</code> 处理时需要依据的 <code>CONFIG</code> 配置文件。</li><li><strong>-o：</strong> 指定生成 <code>APK</code> 的全路径。</li><li><strong>-P：</strong> 是混淆文件</li></ul></li><li><p>补充：</p><ul><li><code>Linux</code> 中下载 <code>android-sdk</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update &amp;&amp; sudo apt install android-sdk</span><br></pre></td></tr></table></figure></li></ul><p>我最后在 <code>/usr/lib/android-sdk</code> 中找到</p><ul><li><p>运行 test 需要在 <code>redex</code> 目录下执行 <code>./test/setup.sh</code> 文件中有个 <code>pushd test</code> ，还需要安装 <code>curl</code> 和 <code>unzip</code></p></li><li><p>如果报错 <code>fatal error:Killed signal terminated program cc1plus</code> 是内存不足了，请分配足够大的内存，还有可能 <code>cpu</code> 太高，请适当减少运行线程，<code>autoreconf -ivf &amp;&amp; ./configure &amp;&amp; make -j4</code> 这句话中 <code>-j4</code> 表示开启 <code>4</code> 个线程，如果不是多核的开线程没有用。我最后用 <code>make -j2</code> 给了 <code>4G</code> 内存执行成功。</p></li></ul></li></ol><p>经过三天努力，终于编译成功，但是在 <code>release</code> 包下 体积并没有减少， <code>debug</code> 有变少。</p><p>通过搜索，可能是没有做到压缩，只做了 <code>dex</code> 重排加速了启动，所以体积可能不小反而变大一点点。</p><p>也有可能项目太小发挥不了作用。</p><p>还会再继续探究 ~</p><hr><h3 id="3-1-6-使用-XZ-Utils-进行-Dex-压缩"><a href="#3-1-6-使用-XZ-Utils-进行-Dex-压缩" class="headerlink" title="3.1.6 使用 XZ Utils 进行 Dex 压缩"></a>3.1.6 使用 XZ Utils 进行 Dex 压缩</h3><p><a href="https://tukaani.org/xz/" target="_blank" rel="noopener">XZ Utils</a> 和 <code>7-Zip</code> 一样，内部使用的都是 <code>LZMA</code> 算法。<code>LZMA</code> 提供了高压缩比和快速解压缩，因此非常适合嵌入式应用。对于 <code>Dex</code> 格式来说，<code>XZ</code> 的压缩率可以比 <code>Zip</code> 高 <code>30%</code> 左右。</p><p>在 <code>FaceBook</code> 的 <code>App</code> 中就使用了 <code>Dex 压缩</code> 的方式，而且它将 <code>Dex</code> 压缩后的文件都放在了 <code>assets</code> 目录中</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/008dc38d277aab4eabfb580ccac7aef7.webp" alt="图片来源于 Android 开发高手课"></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/66abe10ca8e67e86ced07087555b8f22.webp" alt="图片来源于 Android 开发高手课"></p><p>我们先看到上图中的 <code>classes.dex</code>，其中仅包含了启动时要用到的类，这样可以为 <code>Dex</code> 压缩文件 <code>secondary.dex.jar.xzs</code> 的解压争取时间。</p><p>但是，这套方案还存在一些问题：</p><ul><li><strong>首次启动解压</strong>：应用首次启动的时候，需要将 <code>secondary.dex.jar.xzs</code> 解压缩，<code>Facebook</code> 使用多线程解压的方式，这个耗时在高端机是几百毫秒左右，在低端机可能需要 3～5 秒。</li><li><strong>ODEX 文件生成</strong>：当 <code>Dex</code> 非常多的时候会增加应用的安装时间，如果还使用了压缩 <code>Dex</code> 的方式，那么首次生成 <code>ODEX</code> 的时间可能就会超过 1 分钟。<code>Facebook</code> 为了解决这个问题，使用了 <code>ReDex</code> 另外一个超级硬核的方法，那就是 <a href="https://github.com/facebook/redex/tree/master/tools/oatmeal" target="_blank" rel="noopener">oatmeal</a> 。<ul><li>对于正常的流程，我们需要 <code>fork</code> 进程来生成 <code>dex2oat</code>，这个耗时一般都比较大。通过 <code>oatmeal</code>，我们直接在本进程生成 <code>ODEX</code> 文件。一个 <code>10MB</code> 的 <code>Dex</code>，如果在 <code>Android 5.0</code> 生成一个 <code>ODEX</code> 的耗时大约在 <code>10</code> 秒以上，在 <code>Android 8.0</code> 使用 <code>speed</code> 模式大约在 1 秒左右，而通过 <code>oatmeal</code> 这个耗时大约在 <code>100</code> 毫秒左右。</li></ul></li></ul><p><code>ReDex</code> 提供的功能：</p><ol><li><strong>Interdex：</strong>类重排和文件重排、<code>Dex</code> 分包优化。</li><li><strong>Oatmeal：</strong> 直接生成 <code>Odex</code> 文件。</li><li><strong>StripDebugInfo：</strong> 去除 <code>Dex</code> 中的 <code>Debug</code> 信息。</li><li><strong>源码中 access-marking 模块：</strong> 删除 <code>Java access</code> 方法 。</li><li><strong>源码中 type-erasure 模块：</strong>类型擦除。</li></ol><hr><h3 id="3-1-7-其他"><a href="#3-1-7-其他" class="headerlink" title="3.1.7 其他"></a>3.1.7 其他</h3><ul><li><p><strong>使用 Lint 检测无效代码</strong></p><p><code>步骤：点击菜单栏 Analyze -&gt; Run Inspection by Name -&gt; unused declaration -&gt; Moudule ‘app’ -&gt; OK</code></p></li><li><p><strong>避免产生 access 方法的方式</strong></p><p><a href="https://mp.weixin.qq.com/s/ZHisCVjO_ZrtvvEWBYUQFQ" target="_blank" rel="noopener">西瓜视频 apk 瘦身之 Java access 方法删除</a> </p><p>编译阶段去除 <code>access</code> 方法</p><p><a href="https://github.com/bytedance/ByteX" target="_blank" rel="noopener"> 抖音 Android 团队 ByteX</a> </p><p>已集成的插件</p><ul><li><a href="https://github.com/bytedance/ByteX/blob/master/access-inline-plugin/README-zh.md" target="_blank" rel="noopener">access-inline-plugin</a>（<code>access</code> 方法内联）</li><li><a href="https://github.com/bytedance/ByteX/blob/master/shrink-r-plugin/README-zh.md" target="_blank" rel="noopener">shrink-r-plugin</a>（<code>R</code> 文件瘦身和无用资源检查）</li><li><a href="https://github.com/bytedance/ByteX/blob/master/closeable-check-plugin/README-zh.md" target="_blank" rel="noopener">closeable-check-plugin</a>（文件流的 <code>close</code> 检查）</li><li><a href="https://github.com/bytedance/ByteX/blob/master/const-inline-plugin/README-zh.md" target="_blank" rel="noopener">const-inline-plugin</a>（常量内联）</li><li><a href="https://github.com/bytedance/ByteX/blob/master/field-assign-opt-plugin/README-zh.md" target="_blank" rel="noopener">field-assign-opt-plugin</a>（优化多余赋值指令）</li><li><a href="https://github.com/bytedance/ByteX/blob/master/getter-setter-inline-plugin/README-zh.md" target="_blank" rel="noopener">getter-setter-inline-plugin</a> （<code>getter</code> 和 <code>setter</code> 方法内联）</li><li><a href="https://github.com/bytedance/ByteX/blob/master/method-call-opt-plugin/README-zh.md" target="_blank" rel="noopener">method-call-opt-plugin</a>（干净地删除某些方法调用，如 <code>Log.d</code>）</li><li><a href="https://github.com/bytedance/ByteX/blob/master/coverage/README-zh.md" target="_blank" rel="noopener">coverage-plugin</a>（线上代码覆盖率）</li><li><a href="https://github.com/bytedance/ByteX/blob/master/refer-check-plugin/README-zh.md" target="_blank" rel="noopener">refer-check-plugin</a>（检查是否有调用不存在的方法和引用不存在的字段）</li><li><a href="https://github.com/bytedance/ByteX/blob/master/serialization-check-plugin/README-zh.md" target="_blank" rel="noopener">serialization-check-plugin</a>（序列化检查）</li><li><a href="https://github.com/bytedance/ByteX/blob/master/SourceFileKiller/README-zh.md" target="_blank" rel="noopener">SourceFileKiller</a>（删除 <code>SourceFile</code> 和行号属性，作为示例）</li><li><a href="https://github.com/bytedance/ByteX/blob/master/butterknife-check-plugin/README-zh.md" target="_blank" rel="noopener">ButterKnifeChecker</a>（检测跨 <code>module</code> 使用 <code>ButterKnife</code> 可能导致的问题）</li><li><a href="https://github.com/bytedance/ByteX/blob/master/shrink-r-plugin/RFileKnife-README-zh.md" target="_blank" rel="noopener">RFileKnife</a>（修复 <code>R.java</code> 太大编译报 <code>code too large</code> 的问题）</li></ul></li></ul><hr><h2 id="3-2-资源相关"><a href="#3-2-资源相关" class="headerlink" title="3.2 资源相关"></a>3.2 资源相关</h2><p><code>res</code>、<code>assets</code>、编译后的二进制资源文件 <code>resources.arsc</code> 和 清单文件 等等。<code>res</code> 和 <code>assets</code> 的不同在于 <code>res</code> 目录下的文件会在 <code>.R</code> 文件中生成对应的资源 <code>ID</code>，而 <code>assets</code> 不会自动生成对应的 <code>ID</code>，而是通过 <code>AssetManager</code> 类的接口来获取。此外，每当在 <code>res</code> 文件夹下放一个文件时，<code>aapt</code> 就会自动生成对应 <code>id</code> 并保存在 <code>.R</code> 文件中，但 <code>.R</code> 文件仅仅只是保证编译程序不会报错，实际上在应用运行时，系统会根据 <code>ID</code> 寻找对应的资源路径，而 <code>resources.arsc</code> 文件就是用来记录这些 <code>ID</code> 和 资源文件位置对应关系 的文件。</p><h3 id="3-2-1-使用-Lint-的-Remove-Unused-Resource"><a href="#3-2-1-使用-Lint-的-Remove-Unused-Resource" class="headerlink" title="3.2.1 使用 Lint 的 Remove Unused Resource"></a>3.2.1 使用 Lint 的 Remove Unused Resource</h3><p><code>Refactor -&gt; Remove Unused Resource -&gt; preview</code> 可以预览找到的无用资源</p><p>需要注意的，<code>Android Lint</code> 不会分析 <code>assets</code> 文件夹下的资源，因为 <code>assets</code> 文件可以通过文件名直接访问，不需要通过具体的引用，<code>Lint</code> 无法判断资源是否被用到。</p><h3 id="3-2-2-shrinkResources"><a href="#3-2-2-shrinkResources" class="headerlink" title="3.2.2 shrinkResources"></a>3.2.2 shrinkResources</h3><p>Android <code>shrinkResources</code> 资源压缩功能，它需要配合 <code>ProGurad</code> 的 <code>minifyEnabled</code> 功能同时使用。如果 <code>ProGuard</code> 把部分无用代码移除，这些代码所引用的资源也会被标记为无用资源，然后通过资源压缩功能将它们移除。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            shrinkResources <span class="literal">true</span></span><br><span class="line">            minifyEnabled <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是看起来很完美，但是目前的 <code>shrinkResources</code> 实现起来还有几个缺陷。</p><ul><li><strong>没有处理 resources.arsc 文件。</strong> 这样导致大量无用的 <code>String</code>、<code>ID</code>、<code>Attr</code>、<code>Dimen</code> 等资源并没有被删除。</li><li><strong>没有真正删除资源文件。</strong> 对于 <code>Drawable</code>、<code>Layout</code> 这些无用资源，<code>shrinkResources</code> 也没有真正把它们删掉，而是仅仅替换为一个空文件。为什么不能删除呢？主要还是因为 <code>resources.arsc</code> 里面还有这些文件的路径，具体你可以查看这个 <a href="https://issuetracker.google.com/issues/37010152" target="_blank" rel="noopener">issues</a> 。</li></ul><p>如果想解答系统为什么不能直接把这些资源删除，我们需要先回过头来重温一下 <code>Android</code> 的编译流程。</p><ul><li>由于 <code>Java</code> 代码需要用到资源的 <code>R.java</code> 文件，所以我们就需要把 <code>R.java</code> 提前准备好。</li><li>在编译 <code>Java</code> 代码过程，已经根据 <code>R.java</code> 文件，直接将代码中资源的引用替换为常量，例如将 <code>R.String.sample</code> 替换为 <code>0x7f0c0003</code>。</li><li><code>.ap_</code> 资源文件的同步编译，例如 <code>resources.arsc</code>、XML 文件的处理等。</li></ul><p>如果我们在这个过程强行把无用资源文件删除，<code>resources.arsc</code> 和 <code>R.java</code> 文件的资源 <code>ID</code> 都会改变（因为默认都是连续的），这个时候代码中已经替换过的 <code>0x7f0c0003</code> 就会出现资源错乱或者找不到的情况。</p><p>因此系统为了避免发生这种情况，采用了折中的方法，并没有二次处理 <code>resources.arsc</code> 文件，只是仅仅把无用的 <code>Drawable</code> 和 <code>Layout</code> 文件替换为空文件。</p><p>那怎么样才能真正实现无用资源的删除功能呢？我们可以利用 <code>resources.arsc</code> 中 <code>Public ID</code> 的机制，实现非连续的资源 ID。</p><p>简单来说，就是 <code>keep</code> 住保留资源的 <code>ID</code>，保证已经编译完的代码可以正常找到对应的资源。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/20200531194630.webp" alt="图片来源于 Android 开发高手课"></p><p>但是重写 <code>resources.arsc</code> 的方法会比资源混淆更加复杂，我们既要从这个文件中抹去所有的无用资源相关信息，还要 <code>keep</code> 住所有保留资源的 <code>ID</code>，相当于把整个文件都重写了。</p><p>正因为异常复杂，所以目前 <code>Android</code> 还没有提供这套方案的完整实现。</p><p><a href="https://juejin.im/post/5e7ad1c0e51d450edc0cf053#heading-68" target="_blank" rel="noopener">深入探索 Android 包体积优化 优化 shrinkResources 流程真正去除无用资源</a>  一文中给出一个方法。</p><p><code>matrix</code> 也实现了相关内容 <a href="https://github.com/Tencent/matrix/blob/master/matrix/matrix-android/matrix-apk-canary/src/main/java/com/tencent/matrix/apk/model/task/UnusedAssetsTask.java" target="_blank" rel="noopener">UnusedAssetsTask</a> </p><h3 id="3-2-3-AndResGuard-工具"><a href="#3-2-3-AndResGuard-工具" class="headerlink" title="3.2.3 AndResGuard 工具"></a>3.2.3 AndResGuard 工具</h3><p>在我们的安装包中，资源相关的文件具体有下面这几个，它们都是我们需要优化的目标文件。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/dd5c7efb6074ff0f2bd18296f9ecf1b7.webp" alt="图片来源于 Android 开发高手课"></p><p><a href="https://github.com/shwenzhang/AndResGuard" target="_blank" rel="noopener">AndResGuard</a> 工具它主要有两个功能，一个是资源混淆，一个是资源的极限压缩。</p><ol><li><p><strong>资源混淆</strong></p><p>资源混淆的思路其实非常简单，就是把资源和文件的名字混淆成短路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Proguard          -&gt; Resource Proguard</span><br><span class="line">R.string.name     -&gt; R.string.a   </span><br><span class="line">res&#x2F;drawable&#x2F;icon -&gt; res&#x2F;s&#x2F;a</span><br></pre></td></tr></table></figure><p>那么这样的实现究竟对哪些资源文件有优化作用呢？</p><ul><li><strong>resources.arsc。</strong>因为资源索引文件 <code>resources.arsc</code> 需要记录资源文件的名称与路径，使用混淆后的短路径 <code>res/s/a</code>，可以减少整个文件的大小。</li><li><strong>metadata 签名文件。</strong><a href="https://cloud.tencent.com/developer/article/1354380" target="_blank" rel="noopener">签名文件 MF 与 SF</a> 都需要记录所有文件的路径以及它们的哈希值，使用短路径可以减少这两个文件的大小。</li><li><strong>ZIP 文件索引。</strong> <code>ZIP</code> 文件格式里面也需要记录每个文件 <code>Entry</code> 的路径、压缩算法、<code>CRC</code>、文件大小等信息。使用短路径，本身就可以减少记录文件路径的字符串大小。</li></ul></li><li><p><strong>极限压缩</strong></p><p><code>AndResGuard</code> 的另外一个优化就是极限压缩，它的极限压缩功能体现在两个方面：</p><ul><li><p><strong>更高的压缩率。</strong>虽然我们使用的还是 <code>Zip</code> 算法，但是利用了 <code>7-Zip</code> 的大字典优化，<code>APK</code> 的整体压缩率可以提升 <code>3%</code> 左右。</p></li><li><p><strong>压缩更多的文件。</strong> <code>Android</code> 编译过程中，下面这些格式的文件会指定不压缩；在 <code>AndResGuard</code> 中，我们支持针对 <code>resources.arsc</code>、<code>PNG</code>、<code>JPG</code> 以及 <code>GIF</code> 等文件的强制压缩。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* these formats are already compressed, or don&#39;t compress well *&#x2F;</span><br><span class="line">static const char* kNoCompressExt[] &#x3D; &#123;</span><br><span class="line">    &quot;.jpg&quot;, &quot;.jpeg&quot;, &quot;.png&quot;, &quot;.gif&quot;,</span><br><span class="line">    &quot;.wav&quot;, &quot;.mp2&quot;, &quot;.mp3&quot;, &quot;.ogg&quot;, &quot;.aac&quot;,</span><br><span class="line">    &quot;.mpg&quot;, &quot;.mpeg&quot;, &quot;.mid&quot;, &quot;.midi&quot;, &quot;.smf&quot;, &quot;.jet&quot;,</span><br><span class="line">    &quot;.rtttl&quot;, &quot;.imy&quot;, &quot;.xmf&quot;, &quot;.mp4&quot;, &quot;.m4a&quot;,</span><br><span class="line">    &quot;.m4v&quot;, &quot;.3gp&quot;, &quot;.3gpp&quot;, &quot;.3g2&quot;, &quot;.3gpp2&quot;,</span><br><span class="line">    &quot;.amr&quot;, &quot;.awb&quot;, &quot;.wma&quot;, &quot;.wmv&quot;, &quot;.webm&quot;, &quot;.mkv&quot;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>为什么 <code>Android</code> 系统会专门选择不去压缩这些文件呢？</p><ul><li><strong>压缩效果并不明显。</strong>这些格式的文件大部分本身已经压缩过，重新做 <code>Zip</code> 压缩效果并不明显。例如 <code>PNG</code> 和 <code>JPG</code> 格式，重新压缩只有 <code>3%～5%</code> 的收益，并不是十分明显。</li><li><strong>读取时间与内存的考虑。</strong>如果文件是没有压缩的，系统可以利用 <code>mmap</code> 的方式直接读取，而不需要一次性解压并放在内存中。</li></ul></li></ol><h4 id="AndResGuard-实践"><a href="#AndResGuard-实践" class="headerlink" title="AndResGuard 实践"></a>AndResGuard 实践</h4><p>配置根据 <a href="https://github.com/shwenzhang/AndResGuard" target="_blank" rel="noopener">AndResGuard</a> 走就可以</p><p>编译在 <code>Gradle -&gt; app -&gt; Tasks -&gt; andresguard-&gt; resguardRelease</code> 可以进行编译打包，结果生成在 <code>app -&gt; build -&gt; outputs -&gt; apk -&gt; release -&gt; AndResGuard_xxx</code> 下。</p><p>此外，抖音 <code>Android</code> 团队还开源了针对于海外市场 <code>App Bundle APK</code> 的 <a href="https://github.com/bytedance/AabResGuard/blob/develop/wiki/zh-cn/README.md" target="_blank" rel="noopener">AabResGuard 资源混淆工具</a> </p><p>在美团的一篇文章<a href="https://tech.meituan.com/2017/04/07/android-shrink-overall-solution.html" target="_blank" rel="noopener">《Android App 包瘦身优化实践》</a> 中，也讲到了很多资源优化相关的方法，例如 <code>WebP</code> 和 <code>SVG</code>、<code>R</code> 文件、无用资源、资源混淆以及语言压缩等。</p><h2 id="3-3-Native-Library-相关"><a href="#3-3-Native-Library-相关" class="headerlink" title="3.3 Native Library 相关"></a>3.3 Native Library 相关</h2><p>对于 Native Library，传统的优化方法可能就是去除 Debug 信息、使用 c++_shared 这些。那我们还有没有更好的优化方法呢？</p><h3 id="3-3-1-Library-压缩"><a href="#3-3-1-Library-压缩" class="headerlink" title="3.3.1 Library 压缩"></a>3.3.1 Library 压缩</h3><p>跟 <code>Dex</code> 压缩一样，Library 优化最有效果的方法也是使用 <code>XZ</code> 或者 <code>7-Zip</code> 压缩。</p><p>在默认的 <code>lib</code> 目录，我们只需要加载少数启动过程相关的 <code>Library</code>，其他的 <code>Library</code> 我们都在首次启动时解压。对于 <code>Library</code> 格式来说，压缩率同样可以比 <code>Zip</code> 高 <code>30%</code> 左右，效果十分惊人。</p><p><code>Facebook</code> 有一个 <code>So</code> 加载的开源库 <a href="https://github.com/facebook/SoLoader" target="_blank" rel="noopener">SoLoader</a> ，它可以跟这套方案配合使用。和 <code>Dex</code> 压缩一样，压缩方案的主要缺点在于首次启动的时间，毕竟对于低端机来说，多线程的意义并不大，因此我们要在包体积和用户体验之间做好平衡。</p><h3 id="3-3-2-Library-合并与裁剪"><a href="#3-3-2-Library-合并与裁剪" class="headerlink" title="3.3.2 Library 合并与裁剪"></a>3.3.2 Library 合并与裁剪</h3><p>对于 <code>Native Library</code>，<code>Facebook</code> 中的编译构建工具 <a href="https://buck.build/" target="_blank" rel="noopener">Buck</a> 也有两个比较硬核的高科技。当然在官方文档中是完全找不到的，它们都隐藏在 <a href="https://github.com/facebook/buck" target="_blank" rel="noopener">源码</a> 中。</p><ul><li><strong>Library 合并。</strong>在 <code>Android 4.3</code> 之前，进程加载的 <code>Library</code> 数量是有限制的。在编译过程，我们可以自动将部分 <code>Library</code> 合并成一个。具体思路可以参考文章<a href="https://engineering.fb.com/android/android-native-library-merging/" target="_blank" rel="noopener">《Android native library merging》</a> 以及 <a href="https://github.com/fbsamples/android-native-library-merging-demo" target="_blank" rel="noopener">Demo</a> 。</li><li><strong>Library 裁剪。</strong> <code>Buck</code> 里面有一个 <a href="https://github.com/facebook/buck/blob/master/src/com/facebook/buck/android/relinker/NativeRelinker.java" target="_blank" rel="noopener">relinker</a> 的功能，原理就是分析代码中 <code>JNI</code> 方法以及不同 <code>Library</code> 的方法调用，找到没有无用的导出 <code>symbol</code>，将它们删掉。这样 <code>linker</code> 在编译的时候也会把对应的无用代码同时删掉，这个方法相当于实现了 <code>Library</code> 的 <code>ProGuard Shrinking</code> 功能。</li></ul><h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h1><blockquote><p><a href="https://time.geekbang.org/column/article/74044" target="_blank" rel="noopener">极客时间 Android开发高手课</a>  </p><p><a href="https://juejin.im/post/5e7ad1c0e51d450edc0cf053" target="_blank" rel="noopener">深入探索 Android 包体积优化</a> </p><p><a href="https://blog.dreamtobe.cn/android_d8_r8/" target="_blank" rel="noopener">Android新Dex编译器D8与新混淆工具R8</a> </p><p>以及上文中的链接</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>App 网络优化🌞</title>
      <link href="/2020/network-optimization.html"/>
      <url>/2020/network-optimization.html</url>
      
        <content type="html"><![CDATA[<p>在 <code>PC</code> 互联网时代，网络优化已经是一项非常复杂的工作。对于移动网络来说，弱网络、网络切换、网络劫持这些问题更加突出，网络优化这项工作也变得更加艰巨。</p><h1 id="本文主要记载"><a href="#本文主要记载" class="headerlink" title="本文主要记载"></a>本文主要记载</h1><ul><li><strong>1 网络库实现哪家强？</strong></li><li><strong>2 网络需要优化哪些？</strong><ul><li>2.1 HTTPDNS</li><li>2.2 链接复用</li><li>2.3 压缩与加密</li><li>2.4 其他优化</li></ul></li><li><strong>3 如何监控网络</strong></li><li><strong>4 PLT HOOK Demo 练习</strong></li></ul><hr><h1 id="1-网络库实现哪家强？"><a href="#1-网络库实现哪家强？" class="headerlink" title="1 网络库实现哪家强？"></a>1 网络库实现哪家强？</h1><p>在实际的开发工作中，我们很少会像《UNIX 网络编程》那样直接去操作底层的网络接口，一般都会使用网络库。<code>Square</code> 出品的 <a href="https://github.com/square/okhttp" target="_blank" rel="noopener">OkHttp</a> 是目前最流行的 <code>Android</code> 网络库，它还被 <code>Google</code> 加入到 <code>Android</code> 系统内部，为广大开发者提供网络服务。</p><p>网络库的作用是屏蔽了下层复杂的网络接口，让我们可以更高效地使用网络请求。主要有以下三点：</p><ul><li><strong>统一编程接口：</strong>无论是同步还是异步请求，接口都非常简单易用。同时我们可以统一做策略管理，统一进行流解析（<code>JSON</code>、<code>XML</code>、<code>Protocol Buffers</code>）等。</li><li><strong>全局网络控制：</strong>在网络库内部我们可以做统一的网络调度、流量监控以及容灾管理等工作。</li><li><strong>高性能：</strong>既然我们把所有的网络请求都交给了网络库，那网络库是否实现高性能就至关重要。既然要实现高性能，那我会非常关注速度，<code>CPU</code>、内存、<code>I/O</code> 的使用，以及失败率、崩溃率、协议的兼容性等方面。</li></ul><p>接下来对比 <code>OkHttp</code>、<code>Chromium</code> 的 <a href="https://chromium.googlesource.com/chromium/src/+/master/components/cronet/" target="_blank" rel="noopener">Cronet</a> 以及微信 <a href="https://github.com/Tencent/mars" target="_blank" rel="noopener">Mars</a> 这三个网络库的内部实现。</p><p><a href="https://www.infoq.cn/article/mogujie-app-chromium-network-layer?useSponsorshipSuggestions=true%2F" target="_blank" rel="noopener">蘑菇街</a> 、头条、<code>UC</code> 浏览器、微信 <code>Mars</code> 都在 <code>Chromium</code> 网络库上做了二次开发，而微信 <code>Mars</code> 在弱网络方面做了大量优化，拼多多、虎牙、链家、美丽说这些应用都在使用 <code>Mars</code>。</p><p>为什么那么多大厂都在用<code>Chromium</code> 的 <a href="https://chromium.googlesource.com/chromium/src/+/master/components/cronet/" target="_blank" rel="noopener">Cronet</a> 做二次开发，而不用 <code>OkHTTP</code> 呢？主要因为它并不支持跨平台，对于大型应用来说跨平台是非常重要的。我们不希望所有的优化 <code>Android</code> 和 <code>iOS</code> 都要各自去实现一套，不仅浪费人力而且还容易出问题。对于 <a href="https://github.com/Tencent/mars" target="_blank" rel="noopener">Mars</a> 来说，它是一个跨平台的 <code>Socket</code> 层解决方案，并不支持完整的 <code>HTTP</code> 协议，所以 Mars 从严格意义上来讲并不是一个完整的网络库。但是它在弱网络和连接上做了大量的优化，并且支持长连接。</p><p><code>Chromium</code> 网络库作为标准的网络库，基本上可以说是找不到太大的缺点。而且我们可以享受 <code>Google</code> 后续网络优化的成果，类似 <code>TLS 1.3</code>、<code>QUIC</code> 支持等。但是它针对弱网络场景没有做太多定制的优化，也不支持长连接。</p><h1 id="2-网络需要优化哪些？"><a href="#2-网络需要优化哪些？" class="headerlink" title="2 网络需要优化哪些？"></a>2 网络需要优化哪些？</h1><p>在讲怎么去优化网络之前，先明确一下所谓的网络优化，究竟指的是什么？</p><ul><li><strong>速度：</strong>在网络正常或者良好的时候，怎样更好地利用带宽，进一步提升网络请求速度。</li><li><strong>弱网络：</strong>移动端网络复杂多变，在出现网络连接不稳定的时候，怎样最大程度保证网络的连通性。</li><li><strong>安全：</strong>网络安全不容忽视，怎样有效防止被第三方劫持、窃听甚至篡改。</li></ul><p><strong>网络请求的整个过程</strong></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/8d6e833f2a6c6d1e8beeb92d4579c38b.png" alt="图片来源于 Android 开发高手课"></p><ul><li><strong>DNS 解析：</strong>通过 <code>DNS</code> 服务器，拿到对应域名的 <code>IP</code> 地址。在这个步骤，我们比较关注 <code>DNS</code> 解析耗时情况、运营商 <code>LocalDNS</code> 的劫持、<code>DNS</code> 调度这些问题。</li><li><strong>创建连接：</strong>跟服务器建立连接，这里包括 <code>TCP</code> 三次握手、<code>TLS</code> 密钥协商等工作。多个 <code>IP/</code> 端口该如何选择、是否要使用 <code>HTTPS</code>、能否可以减少甚至省下创建连接的时间，这些问题都是我们优化的关键。</li><li><strong>发送 / 接收数据：</strong>在成功建立连接之后，就可以愉快地跟服务器交互，进行组装数据、发送数据、接收数据、解析数据。我们关注的是，如何根据网络状况将带宽利用好，怎么样快速地侦测到网络延时，在弱网络下如何调整包大小等问题。</li><li><strong>关闭连接：</strong>连接的关闭看起来非常简单，其实这里的水也很深。这里主要关注主动关闭和被动关闭两种情况，一般我们都希望客户端可以主动关闭连接。</li></ul><p>🔥🔥 <strong>所谓的网络优化，就是围绕速度、弱网络、安全这三个核心内容，减少每一个步骤的耗时，打造快速、稳定且安全的高质量网络。</strong></p><h2 id="2-1-HTTPDNS"><a href="#2-1-HTTPDNS" class="headerlink" title="2.1 HTTPDNS"></a>2.1 HTTPDNS</h2><p><code>DNS</code> 的解析是网络请求的第一项工作，默认使用运营商的 <code>LocalDNS</code> 服务。这块耗时在 <code>3G</code> 网络下可能是 <code>200～300ms</code>，<code>4G</code> 网络也需要 <code>100ms</code>。</p><p>解析慢并不是默认 <code>LocalDNS</code> 最大的 “原罪” ，它还存在一些其他问题：</p><ul><li><strong>稳定性：</strong><code>UDP</code> 协议，无状态，容易域名劫持（难复现、难定位、难解决），每天至少几百万个域名被劫持，一年至少十次大规模事件。</li><li><strong>准确性：</strong><code>LocalDNS</code> 调度经常出现不准确，比如北京的用户调度到广东 <code>IP</code>，移动的运营商调度到电信的 <code>IP</code>，跨运营商调度会导致访问慢，甚至访问不了。</li><li><strong>及时性：</strong>运营商可能会修改 <code>DNS</code> 的 <code>TTL</code>，导致 <code>DNS</code> 修改生效延迟。不同运营商的服务实现不一致，我们也很难保证 <code>DNS</code> 解析的耗时。</li></ul><p>为了解决这些问题，就有了 <code>HTTPDNS</code>。简单来说自己做域名解析的工作，通过 <code>HTTP</code> 请求后台去拿到域名对应的 <code>IP</code> 地址，直接解决上述所有问题。</p><p><a href="https://mp.weixin.qq.com/s/iaPtSF-twWz-AN66UJUBDg" target="_blank" rel="noopener">《百度App网络深度优化系列《一》DNS优化》</a> </p><p><a href="https://github.com/aliyun/alicloud-android-demo/tree/master/httpdns_android_demo" target="_blank" rel="noopener">阿里 HTTPDNS</a></p><p><a href="https://github.com/CNSRE/HTTPDNSLib" target="_blank" rel="noopener">新浪 HTTPDNS库</a>  |  <a href="https://www.jianshu.com/p/a7c750f27e53" target="_blank" rel="noopener">Android端HttpDNS优化方案</a>  |  <a href="https://blog.csdn.net/sbsujjbcy/article/details/51612832" target="_blank" rel="noopener">Android OkHttp实现HttpDns的最佳实践（非拦截器）</a> </p><h2 id="2-2-连接复用"><a href="#2-2-连接复用" class="headerlink" title="2.2 连接复用"></a>2.2 连接复用</h2><p>利用 <code>HTTP</code> 协议里的 <code>keep-alive</code>，而 <code>HTTP/2.0</code> 的多路复用则可以进一步的提升连接复用率。它复用的这条连接支持同时处理多条请求，所有请求都可以并发在这条连接上进行。</p><p>虽然 <code>H2</code> 十分强大，不过这里还有两个问题需要解决。</p><ul><li>一个是同一条 <code>H2</code> 连接只支持同一个域名</li><li>一个是后端支持 <code>HTTP/2.0</code> 需要额外的改造</li></ul><p>这个时候我们只需要在统一接入层（传说中的中台？）做改造，接入层将数据转换到 <code>HTTP/1.1</code> 再转发到对应域名的服务器。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/d7dc96541811392f2a669232582c0bc9.png" alt="图片来源于 Android 开发高手课"></p><p>这样所有的服务都不用做任何改造就可以享受 <code>HTTP/2.0</code> 的所有优化，不过这里需要注意的是 <code>H2</code> 的多路复用在本质上依然是同一条 <code>TCP</code>连接，如果所有的域名的请求都集中在某一条连接中，在网络拥塞的时候容易出现 <code>TCP</code> 队首阻塞问题。</p><h2 id="2-3-压缩与加密"><a href="#2-3-压缩与加密" class="headerlink" title="2.3 压缩与加密"></a>2.3 压缩与加密</h2><h3 id="2-3-1-压缩"><a href="#2-3-1-压缩" class="headerlink" title="2.3.1 压缩"></a>2.3.1 压缩</h3><p>首先对于 <code>HTTP</code> 请求来说，数据主要包括三个部分：请求 <code>URL</code>、请求 <code>header</code>、请求 <code>body</code>。</p><p>对于请求 <code>body</code> 来说，一方面是数据通信协议的选择，在网络传输中目前最流行的两种数据序列化方式是 <code>JSON</code> 和 <code>Protocol Buffers</code>。<code>Protocol Buffers</code> 使用起来更加复杂一些，但在数据压缩率、序列化与反序列化速度上面都有很大的优势。</p><p>另外一方面是压缩算法的选择，通用的压缩算法主要是如 <code>gzip</code>，<code>Google</code> 的 <a href="https://github.com/google/brotli" target="_blank" rel="noopener">Brotli</a> 或者 <code>Facebook</code> 的 <a href="https://github.com/facebook/zstd" target="_blank" rel="noopener">Z-standard</a> 等算法，用来减少流量消耗和传输时间。</p><p>针对图片我们可以使用 <code>webp</code>、<code>hevc</code>、<code>SharpP</code> 等压缩率更高的格式。</p><p><a href="http://i.lckiss.com/?p=4606" target="_blank" rel="noopener">关于Android okHttp Gzip的简单处理</a> </p><p><a href="https://www.jianshu.com/p/a9d861732445" target="_blank" rel="noopener">OkHttp使用gzip时的坑</a>   <a href="https://stackoverflow.com/questions/26360858/okhttp-gzip-post-body" target="_blank" rel="noopener">Gzip 手动解压</a> </p><p>还有就是 <code>gzip</code> 拦截器要添加到签名等操作拦截器之后，我们网络库在上传前需要使用 <code>body</code> 生成签名，如果在生成签名之前先使用 <code>gzip</code> 压缩了 <code>body</code> 体会什么也拿不到。</p><h3 id="2-3-2-安全"><a href="#2-3-2-安全" class="headerlink" title="2.3.2 安全"></a>2.3.2 安全</h3><p>数据安全也是网络重中之重的一个环节，在大网络平台中我们都是基于 <code>HTTPS</code> 的 <code>HTTP/2</code> 通道，已经有了 <code>TLS</code> 加密。</p><p><a href="https://blog.helong.info/blog/2015/09/07/tls-protocol-analysis-and-crypto-protocol-design/" target="_blank" rel="noopener">《TLS 协议分析》</a> </p><p>但是 <code>HTTPS</code> 带来的代价也是不小的，它需要 <code>2-RTT</code> 的协商成本，在弱网络下时延不可接受。同时后台服务解密的成本也十分高昂，在大型企业中需要单独的集群来做这个事情。</p><p><code>HTTPS</code> 的优化有下面几个思路：</p><ul><li><strong>连接复用率。</strong>通过多个域名共用同一个 HTTP/2 连接、长连接等方式提升连接复用率。</li><li><strong>减少握手次数。</strong> <a href="https://zhuanlan.zhihu.com/p/44980381" target="_blank" rel="noopener">TLS 1.3</a> 可以实现 <code>0-RTT</code> 协商，事实上在 <code>TLS 1.3 release</code> 之前，微信的 <a href="https://mp.weixin.qq.com/s/tvngTp6NoTZ15Yc206v8fQ" target="_blank" rel="noopener">mmtls</a>、<code>Facebook</code> 的<a href="https://mp.weixin.qq.com/s?__biz=MzI4MTY5NTk4Ng==&mid=2247489465&idx=1&sn=a54e3fe78fc559458fa47104845e764b&source=41#wechat_redirect" target="_blank" rel="noopener">fizz</a>、阿里的 <code>SlightSSL</code> 都已在企业内部大规模部署。</li><li><strong>性能提升。</strong>使用 <code>ecc</code> 证书代替 <code>RSA</code>，服务端签名的性能可以提升 <code>4～10</code> 倍，但是客户端校验性能降低了约 <code>20</code> 倍，从 <code>10</code> 微秒级降低到 <code>100</code> 微秒级。另外一方面可以通过 <code>Session Ticket</code> 会话复用，节省一个 <code>RTT</code> 耗时。</li></ul><p>使用 <code>HTTPS</code> 之后，整个通道是不是就一定高枕无忧呢？如果客户端设置了代理，<code>TLS</code> 加密的数据可以被解开并可能被利用 。这个时候我们可以在客户端将 <a href="https://sec.xiaomi.com/article/48" target="_blank" rel="noopener">证书锁定</a>（Certificate Pinning），为了老版本兼容和证书替换的灵活性，建议锁定根证书。</p><p>我们也可以对传输内容做二次加密，这块在统一接入层实现，业务服务器也同样无需关心这个流程。需要注意的是二次加密会增加客户端与服务器的处理耗时，我们需要在安全性与性能之间做一个取舍。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/20200524180753.png" alt="图片来源于 Android 开发高手课"></p><h2 id="2-4-其他优化"><a href="#2-4-其他优化" class="headerlink" title="2.4 其他优化"></a>2.4 其他优化</h2><ul><li><a href="https://toutiao.io/posts/6gb8ih/preview" target="_blank" rel="noopener">CDN 服务</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI4MTY5NTk4Ng==&mid=2247489182&idx=1&sn=e892855fd315ed2f1395f05b765f9c4e&source=41#wechat_redirect" target="_blank" rel="noopener">P2P 技术</a></li></ul><p>这个两个在直播场景经常使用</p><p>关于网络优化的手段还有很多，一些方案可能是需要用钱堆出来的，比如部署跨国的专线、加速点，多 <code>IDC</code> 就近接入等。</p><ul><li><p>QUIC </p><p><code>QUIC</code> 协议由 Google 在 2013 年实现，在 <code>2018</code> 年基于 <code>QUIC</code> 协议的 <code>HTTP</code> 更被确认为 <a href="https://zh.wikipedia.org/wiki/HTTP/3" target="_blank" rel="noopener">HTTP/3</a> 。在连接复用中说过 <code>HTTP/2 + TCP</code> 会存在队首阻塞的问题，基于 <code>UDP</code> 的 <code>QUIC</code> 才是终极解决方案。</p><p><code>QUIC</code> 简单理解为 <code>HTTP/2.0 + TLS 1.3 + UDP</code></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/20200524184937.png" alt="图片来源于 Android 开发高手课"></p></li></ul><h1 id="3-如何监控网络？"><a href="#3-如何监控网络？" class="headerlink" title="3 如何监控网络？"></a>3 如何监控网络？</h1><h2 id="3-1-NetWork-Profiler"><a href="#3-1-NetWork-Profiler" class="headerlink" title="3.1 NetWork Profiler"></a>3.1 NetWork Profiler</h2><p><a href="https://developer.android.google.cn/studio/profile/network-profiler" target="_blank" rel="noopener">利用网络性能剖析器检查网络流量</a>  </p><p><a href="https://juejin.im/post/5dea1efbe51d4557fe5941e7" target="_blank" rel="noopener">涨姿势：利用AndroidStudio自带的Network Profiler来查看网络请求的相关数据</a> </p><h2 id="3-2-Charles"><a href="#3-2-Charles" class="headerlink" title="3.2 Charles"></a>3.2 Charles</h2><p><a href="https://www.cnblogs.com/jiayuchn-test/p/8875105.html" target="_blank" rel="noopener">抓包工具Charles的使用教程</a> </p><p><a href="https://www.axihe.com/tools/charles/charles/tutorial.html" target="_blank" rel="noopener">Charles 使用教程</a></p><h2 id="3-3-插桩"><a href="#3-3-插桩" class="headerlink" title="3.3 插桩"></a>3.3 插桩</h2><p><code>360</code> 开源的性能监控工具  <a href="https://github.com/Qihoo360/ArgusAPM" target="_blank" rel="noopener">ArgusAPM</a> 就是利用 <code>Aspect</code> 切换插桩，实现监控系统和 <code>OkHttp</code> 网络库的请求。</p><p>系统网络库的插桩实现可以参考 <a href="https://github.com/Qihoo360/ArgusAPM/blob/bc03d63c65019cd3ffe2cbef9533c9228b3f2381/argus-apm/argus-apm-aop/src/main/java/com/argusapm/android/aop/TraceNetTrafficMonitor.java" target="_blank" rel="noopener">TraceNetTrafficMonitor</a>，主要利用 <a href="http://www.shouce.ren/api/spring2.5/ch06s02.html" target="_blank" rel="noopener">Aspect</a> 的切面功能。<code>OkHttp</code> 的拦截可以参考<a href="https://github.com/Qihoo360/ArgusAPM/blob/bc03d63c65019cd3ffe2cbef9533c9228b3f2381/argus-apm/argus-apm-okhttp/src/main/java/com/argusapm/android/okhttp3/OkHttp3Aspect.java" target="_blank" rel="noopener">OkHttp3Aspect</a>，它会更加简单一些，因为 <code>OkHttp</code> 本身就有代理机制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"call(public okhttp3.OkHttpClient build())"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Around</span>(<span class="string">"build()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">aroundBuild</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    Object target = joinPoint.getTarget();</span><br><span class="line">    <span class="keyword">if</span> (target <span class="keyword">instanceof</span> OkHttpClient.Builder &amp;&amp;    Client.isTaskRunning(ApmTask.TASK_NET)) &#123;</span><br><span class="line">        OkHttpClient.Builder builder = (OkHttpClient.Builder) target;</span><br><span class="line">        builder.addInterceptor(<span class="keyword">new</span> NetWorkInterceptor());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> joinPoint.proceed();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-4-Native-Hook"><a href="#3-4-Native-Hook" class="headerlink" title="3.4 Native Hook"></a>3.4 Native Hook</h2><p>网络相关的一般会 Hook 下面几个方法 ：</p><ul><li>连接相关：<code>connect</code>。</li><li>发送数据相关：<code>send</code> 和 <code>sendto</code>。</li><li>接收数据相关：<code>recv</code> 和 <code>recvfrom</code>。</li></ul><p>具体 <code>Demo</code> 见 <code>4 PLT HOOK Demo 练习</code></p><h1 id="4-PLT-HOOK-Demo-练习"><a href="#4-PLT-HOOK-Demo-练习" class="headerlink" title="4 PLT HOOK Demo 练习"></a>4 PLT HOOK Demo 练习</h1><p><a href="https://github.com/facebookincubator/profilo/tree/master/deps/plthooks" target="_blank" rel="noopener">face book plthooks</a></p><p><a href="https://github.com/AndroidAdvanceWithGeektime/Chapter17" target="_blank" rel="noopener">Chapter17</a>  </p><p>它的作用是不仅仅 <code>hook</code> 某个 <code>so</code> ，而是 <code>hook</code> 内存中的所有 <code>so</code> 。但是要排除掉方法本身定义的 <code>so</code> ，不然运行期间会出问题。</p><p><code>Demo</code> 中比较疑惑的点 ，<code>hook_plt_method_all_lib</code> 的第一个参数是要排除掉的 <code>so</code> 库。还在研究中。。。</p><p>通过 <code>connect</code> 函数的 <code>hook</code> ，我们可以做的东西很多，例如：</p><ul><li>禁用应用网络访问</li><li>过滤广告 <code>ip</code> </li><li>禁用定位功能</li></ul><h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h1><blockquote><p><a href="https://time.geekbang.org/column/article/74044" target="_blank" rel="noopener">极客时间 Android开发高手课</a>  </p><p>以及上文中的链接</p><p>更多理论和基础知识</p><p><a href="https://juejin.im/post/5ecf149af265da76ce577fbc" target="_blank" rel="noopener">深入探索 Android 网络优化（二、网络优化基础篇）上</a></p><p><a href="https://juejin.im/post/5ecda2b6f265da77084772a1" target="_blank" rel="noopener">深入探索 Android 网络优化（二、网络优化基础篇）下</a></p><p><a href="https://juejin.im/post/5edc594ef265da76ea2e988c" target="_blank" rel="noopener">深入探索 Android 网络优化（三、网络优化篇）上</a></p><p><a href="https://juejin.im/post/5ee1f2936fb9a04801706b77" target="_blank" rel="noopener">深入探索 Android 网络优化（三、网络优化篇）下</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>App 存储优化💦</title>
      <link href="/2020/storage-optimization.html"/>
      <url>/2020/storage-optimization.html</url>
      
        <content type="html"><![CDATA[<p>本文记录开发过程中常见存储方法的优缺点，希望可以在日常工作中如何做出更好的选择。</p><p><strong>注意：如果出现图片不显示问题请移步</strong> <a href="https://calmcenter.club/2019/PicNotShow.html">图片不显示问题</a></p><h1 id="本文主要记载"><a href="#本文主要记载" class="headerlink" title="本文主要记载"></a>本文主要记载</h1><ul><li><strong>1 如何选择持久化存储方案？</strong><ul><li>1.1 考察存储关键要素</li><li>1.2 SharedPreferences</li><li>1.3 ContentProvider</li><li>1.4 SQLite 优化那些事儿<ul><li>1.4.1 OCR</li><li>1.4.2 并发</li><li>1.4.3 索引查询优化</li><li>1.4.4 页大小与缓存大小</li><li>1.4.5 其他优化</li></ul></li><li>1.5 SQLite 的其他特征<ul><li>1.5.1 损坏与恢复</li><li>1.5.2 加密与安全</li></ul></li></ul></li><li><strong>2 如何优化数据存储？</strong><ul><li>2.1 对象的序列化<ul><li>2.1.1 Serializable<ul><li>Serializable 的原理</li><li>Serializable 的进阶</li><li>Serializable 的注意事项</li></ul></li><li>2.1.2 Parcelable<ul><li>Parcelable 的永久存储</li><li>Parcelable 的注意事项</li></ul></li><li>2.1.3 Serial</li></ul></li><li>2.2 数据的序列化<ul><li>2.2.1 Json</li><li>2.2.2 Protocol Buffers</li></ul></li></ul></li><li><strong>3 Demo 相关练习</strong><ul><li>3.1 重写 SharedPreferencesImpl</li></ul></li></ul><hr><h1 id="1-如何选择持久化存储方案？"><a href="#1-如何选择持久化存储方案？" class="headerlink" title="1 如何选择持久化存储方案？"></a>1 如何选择持久化存储方案？</h1><h2 id="1-1-考察存储关键要素"><a href="#1-1-考察存储关键要素" class="headerlink" title="1.1 考察存储关键要素"></a>1.1 考察存储关键要素</h2><ol><li><p><strong>正确性：</strong> 选择存储方案的时候，第一个需要判断它<strong>是否靠谱</strong>。这套存储方案<strong>设计是否完备</strong>，有没有支持<strong>多线程</strong>或者<strong>多进程</strong>操作。内部<strong>是否健壮</strong>，有没有考虑<strong>异常情况下数据的校验和恢复</strong>，比如采取双写或者备份文件策略，即使主文件因为系统底层导致损坏，也可以一定程度恢复大部分数据。</p></li><li><p><strong>时间开销：</strong>这里说的时间开销包括了 <code>CPU</code> 时间和 <code>I/O</code> 时间，在 <code>I/O</code> 优化中我就多次提到相比 <code>CPU</code> 和内存，<code>I/O</code> 存储的速度是非常慢的。但是如果存储方法中比如编解码或者加密/解密等设计的比较复杂，整个数据存储过程也会出现 <code>CPU</code> 时间变的更长的情况。</p></li><li><p><strong>控件开销：</strong>即使相同的数据如果使用不同的编码方式，最后占用的存储空间也会有所不同。举一个简单的例子，相同的数据所占的空间大小是 <code>XML&gt;JSON&gt;Protocol Buffer</code>。除了编码方式的差异，在一些场景我们可能还需要引入压缩策略来进一步减少存储空间，例如<code>zip</code>、<code>Izma</code> 等。数据存储的空间开销还需要考虑内存空间的占用量，整个存储过程会不会导致应用出现大量 <code>GC</code> 、<code>OOM</code> 等</p></li><li><p><strong>安全：</strong>应用中可能会有一些非常敏感的数据，即使它们存储在 <code>/data/data</code> 中，我们依然必须将它们加密。例如微信的聊天数据是存储在加密的数据库中，一些账号相关的数据我们也要单独做加密落地。根据加密强度的不同，可以选择 <code>RSA</code> 、<code>AES</code>、<code>chacha20</code>、<code>TEA</code>这些常用的加密算法</p></li><li><p><strong>开发成本：</strong>有些存储方案看起来非常高大上，但是需要业务做很大改造才能接入。这里我们当然希望能无缝的接入到业务中，在整个开发过程越简单越好</p></li><li><p><strong>兼容性：</strong>业务不停地向前演进，我们的存储字段或者格式有时候也会不得不有所变化。兼容性首先要考虑的是向前、向后的兼容性，老的数据在升级时能否迁移过来，新的数据在老版本能否降级使用。兼容性另外一个需要考虑的可能是多语言的问题，不同的语言是否支持转换</p></li></ol><p>数据存储方法不能脱离场景来考虑，我们不可能把这六个要素都做成最完美。如果首要考虑的是<strong>正确性</strong>，那我们可能需要采用冗余、双写等方案，那就要容忍对<strong>时间开销</strong>产生的额外影响。同样如果非常在意<strong>安全</strong>，加解密环节的<strong>开销</strong>也必不可小。如果想针对启动场景，我们希望选择在初始化时间和读取时间更有优势的方案。</p><hr><h2 id="1-2-SharedPreferences"><a href="#1-2-SharedPreferences" class="headerlink" title="1.2 SharedPreferences"></a>1.2 SharedPreferences</h2><p><code>SharedPreferences</code> 使用非常简便，但也是诟病比较多的存储方法。</p><ol><li><strong>跨进程不安全：</strong>由于没有使用跨进程的锁，就算使用 <code>MODE_MULTI_PROCESS</code>，<code>SharedPreferences</code> 在跨进程频繁读写有可能导致数据全部丢失。根据线上统计，<code>SP</code> 大约会有万分之一的损坏率。</li><li><strong>加载缓慢：</strong><code>SharedPreferences</code> 文件的加载使用了异步线程，而且加载线程并没有设置线程优先级，如果这个时候主线程读取数据就需要等待文件加载线程的结束。这就导致出现主线程等待低优先级线程锁的问题，比如一个 <code>100KB</code> 的 <code>SP</code> 文件读取等待时间大约需要 <code>50~100ms</code>，我建议提前用异步线程预加载启动过程用到的 SP 文件。</li><li><strong>全量写入：</strong>无论是调用 <code>commit()</code> 还是 <code>apply()</code>，即使我们只改动其中的一个条目，都会把整个内容全部写到文件。而且即使我们多次写入同一个文件，<code>SP</code> 也没有将多次修改合并为一次，这也是性能差的重要原因之一。</li><li><strong>卡顿：</strong>由于提供了异步落盘的 <code>apply</code> 机制，在崩溃或者其他一些异常情况可能会导致数据丢失。所以当应用收到系统广播，或者被调用 <code>onPause</code> 等一些时机，系统会强制把所有的 <code>SharedPreferences</code> 对象数据落地到磁盘。如果没有落地完成，这时候主线程会被一直阻塞。这样非常容易造成卡顿，甚至是 <code>ANR</code>，从线上数据来看 <code>SP</code> 卡顿占比一般会超过 <code>5%</code>。</li></ol><p>更多机制 <a href="https://juejin.im/entry/597446ed6fb9a06bac5bc630" target="_blank" rel="noopener">彻底搞懂 SharedPreferences</a></p><p>更好的替代 <code>SharedPreferences</code> 的存储方案微信的 <a href="https://github.com/Tencent/MMKV" target="_blank" rel="noopener">MMKV</a></p><hr><h2 id="1-3-ContentProvider"><a href="#1-3-ContentProvider" class="headerlink" title="1.3 ContentProvider"></a>1.3 ContentProvider</h2><p><code>ContentProvider</code> 作为 <code>Android</code> 四大组件中的一种，为我们提供了不同进程甚至是不同应用程序之间共享数据的机制。</p><p>为什么 <code>Android</code> 系统不把 <code>SharedPreferences</code> 设计成跨进程安全的呢？那是因为 <code>Android</code> 系统更希望我们在这个场景选择使用 <code>ContentProvider</code> 作为存储方式。</p><p><code>Android</code> 系统中比如相册、日历、音频、视频、通讯录等模块都提供了 <code>ContentProvider</code> 的访问支持。具体使用你可以参考其他文章。</p><p><code>ContentProvider</code> 的一些注意事项：</p><ol><li><p><strong>启动性能：</strong><code>ContentProvider</code> 的生命周期默认在 <code>Application onCreate()</code> 之前，而且都是在主线程创建的。我们自定义的 <code>ContentProvider</code> 类的构造函数、静态代码块、<code>onCreate</code> 函数都尽量不要做耗时的操作，会拖慢启动速度。</p></li><li><p><strong>稳定性：</strong><code>ContentProvider</code> 在进行跨进程数据传递时，利用了 <code>Android</code> 的 <code>Binder</code> 和匿名共享内存机制。就是通过 <code>Binder</code> 传递 <code>CursorWindow</code> 对象内部的匿名共享内存的文件描述符。这样在跨进程传输中，结果数据并不需要跨进程传输，而是在不同进程中通过传输的匿名共享内存文件描述符来操作同一块匿名内存，这样来实现不同进程访问相同数据的目的。</p><p>基于 <code>mmap</code> 的匿名共享内存机制也是有代价的。当传输的数据量非常小的时候，可能不一定划算。所以 <code>ContentProvider</code> 提供了一种 <code>call</code> 函数，它会直接通过 <code>Binder</code> 来传输数据。<code>Android</code> 的 <code>Binder</code> 传输是有大小限制的，一般来说限制是 <code>1~2MB</code>。<code>ContentProvider</code> 的接口调用参数和 call 函数调用并没有使用匿名共享机制，比如要批量插入很多数据，那么就会出现一个插入数据的数组，如果这个数组太大了，那么这个操作就可能会出现数据超大异常。</p></li><li><p><strong>安全性：</strong>虽然 <code>ContentProvider</code> 为应用程序之间的数据共享提供了很好的安全机制，但是如果 <code>ContentProvider</code> 是 <code>exported（是否可以被其他应用调用）</code>，当支持执行 <code>SQL</code> 语句时就需要注意 <code>SQL 注入</code> 的问题。另外如果我们传入的参数是一个文件路径，然后返回文件的内容，这个时候也要校验合法性，不然整个应用的私有数据都有可能被别人拿到，在 <code>intent</code>传递参数的时候可能经常会犯这个错误。</p></li></ol><p>总的来说，<code>ContentProvider</code> 这套方案实现相对比较笨重，适合传输大的数据。</p><hr><h2 id="1-4-SQLite-优化那些事儿"><a href="#1-4-SQLite-优化那些事儿" class="headerlink" title="1.4 SQLite 优化那些事儿"></a>1.4 SQLite 优化那些事儿</h2><h3 id="1-4-1-OCR"><a href="#1-4-1-OCR" class="headerlink" title="1.4.1 OCR"></a>1.4.1 OCR</h3><p>说到 <code>SQLite</code> Android 中最常用的开源库有 <a href="https://github.com/greenrobot/greenDAO" target="_blank" rel="noopener">greenDAO</a> 和 Google 官方的 <a href="https://developer.android.google.cn/topic/libraries/architecture/room" target="_blank" rel="noopener">Room</a> ，它们都是 <code>ORM 框架</code></p><p><code>ORM（Object Relational Mapping）</code>也就是对象关系映射，用面向对象的概念把数据库中表和对象关联起来，可以让我们不用关心数据库底层的实现。</p><p><code>ORM</code> 框架会带来什么问题?</p><p>使用 <code>ORM</code> 框架真的非常简单，但是简易性是需要牺牲部分执行效率为代价的，具体的损耗跟 <code>ORM</code> 框架写得好不好很有关系。但可能更大的问题是思维固化，最后可能连简单的 <code>SQL</code> 语句都不会写了。</p><p>这里推荐微信的 <a href="https://github.com/Tencent/wcdb/wiki" target="_blank" rel="noopener">WCDB</a> </p><p><code>SQLite</code> 优化：</p><h3 id="1-4-2-并发"><a href="#1-4-2-并发" class="headerlink" title="1.4.2 并发"></a>1.4.2 并发</h3><p><a href="http://huili.github.io/lockandimplement/machining.html" target="_blank" rel="noopener">SQLite 锁机制简介</a> <a href="https://www.cnblogs.com/cchust/p/4761814.html" target="_blank" rel="noopener">SQLite 封锁机制</a></p><p>为了进一步提高并发性能，我们还可以打开 <a href="https://www.sqlite.org/wal.html" target="_blank" rel="noopener">WAL</a>（Write-Ahead Logging）模式。<code>WAL</code> 模式会将修改的数据单独写到一个 <code>WAL</code> 文件中，同时也会引入了 <code>WAL</code> 日志文件锁。通过 <code>WAL</code> 模式读和写可以完全地并发执行，不会互相阻塞。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mSQLiteDataBase.rawExecSQL(&quot;PRAGMA schema.journal_mode &#x3D; WAL;&quot;)</span><br></pre></td></tr></table></figure><p>通过 <code>连接池</code> 与 <code>WAL</code> 模式，我们可以很大程度上增加 <code>SQLite</code> 的读写并发，大大减少由于并发导致的等待耗时。</p><h3 id="1-4-3-索引查询优化"><a href="#1-4-3-索引查询优化" class="headerlink" title="1.4.3 索引查询优化"></a>1.4.3 索引查询优化</h3><p><a href="https://www.cnblogs.com/huahuahu/p/sqlite-suo-yin-de-yuan-li-ji-ying-yong.html" target="_blank" rel="noopener">SQLite 索引的原理</a> <a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">MySQL 索引背后的数据结构及算法原理</a> <a href="https://www.sqlite.org/queryplanner.html#searching" target="_blank" rel="noopener">官方文档 Query Planning</a></p><p>这里的关键在于如何正确的建立索引，很多时候我们以为已经建立了索引，但事实上并没有真正生效。例如使用了 <code>BETWEEN</code>、<code>LIKE</code>、<code>OR</code> 这些操作符、使用表达式或者 <code>case when</code> 等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># BETWEEN：myfiedl索引无法生效</span><br><span class="line">SELECT * FROM mytable WHERE myfield BETWEEN 10 and 20;</span><br><span class="line"># 转换成：myfiedl索引可以生效</span><br><span class="line">SELECT * FROM mytable WHERE myfield &gt;&#x3D; 10 AND myfield &lt;&#x3D; 20;</span><br></pre></td></tr></table></figure><p>建立索引是有代价的，需要一直维护索引表的更新。比如对于一个很小的表来说就没必要建索引；如果一个表经常是执行插入更新操作，那么也需要节制的建立索引。总的来说有几个原则：</p><ul><li>建立正确的索引。这里不仅需要确保索引在查询中真正生效，我们还希望可以选择最高效的索引。如果一个表建立太多的索引，那么在查询的时候 <code>SQLite</code> 可能不会选择最好的来执行。</li><li>单列索引、多列索引与复合索引的选择。索引要综合数据表中不同的查询与排序语句一起考虑，如果查询结果集过大，还是希望可以通过复合索引直接在索引表返回查询结果。</li><li>索引字段的选择。整型类型索引效率会远高于字符串索引，而对于主键 <code>SQLite</code> 会默认帮我们建立索引，所以主键尽量不要用复杂字段。</li></ul><p>总的来说索引优化是 <code>SQLite</code> 优化中最简单同时也是最有效的，但是它并不是简单的建一个索引就可以了，有的时候我们需要进一步调整查询语句甚至是表的结构，这样才能达到最好的效果。</p><h3 id="1-4-4-页大小与缓存大小"><a href="#1-4-4-页大小与缓存大小" class="headerlink" title="1.4.4 页大小与缓存大小"></a>1.4.4 页大小与缓存大小</h3><p>在 <code>I/O</code> 文件系统中，数据库就像一个小文件系统一样，事实上它内部也有页和缓存的概念。</p><p>跟文件系统的页缓存（Page Cache）一样，<code>SQLite</code> 会将读过的页缓存起来，用来加快下一次读取速度。页大小默认是 <code>1024Byte</code>，缓存大小默认是 <code>1000</code> 页。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mSQLiteDataBase.rawExecSQL(<span class="string">"PRAGMA page_size = 1024;"</span>)</span><br><span class="line">mSQLiteDataBase.rawExecSQL(<span class="string">"PRAGMA cache_size = 1000;"</span>)</span><br></pre></td></tr></table></figure><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/f232cbaff34236a1933182a02c685a1c.png" alt="图片来源于 Android 开发高手课"></p><p><strong>注意：</strong>在微信的内部测试中，如果使用 <code>4KB</code> 的 <code>page size</code> 性能提升可以在 <code>5%～10%</code>。但是考虑到历史数据的迁移成本，最终还是使用 <code>1024Byte</code>。所以这里建议大家在新建数据库的时候，就提前选择 <code>4KB</code> 作为默认的 <code>page size</code> 以获得更好的性能。</p><h3 id="1-4-5-其他优化"><a href="#1-4-5-其他优化" class="headerlink" title="1.4.5 其他优化"></a>1.4.5 其他优化</h3><ul><li>慎用 <code>select*</code>，需要使用多少列，就选取多少列。</li><li>正确地使用事务。</li><li>预编译与参数绑定，缓存被编译后的 <code>SQL</code> 语句。</li><li>定期整理或者清理无用或可删除的数据，例如朋友圈数据库会删除比较久远的数据，如果用户访问到这部分数据，重新从网络拉取即可。</li></ul><p><strong>总结：通过引进 <code>ORM</code>，可以大大的提升我们的开发效率。通过正确的建立索引，可以提升 <code>SQLite</code> 的查询速度。通过 <code>WAL</code> 模式和连接池，可以提高 <code>SQLite</code> 的并发性能。通过调整默认的页大小和缓存大小，可以提升 <code>SQLite</code> 的整体性能。</strong></p><hr><h2 id="1-5-SQLite-的其他特征"><a href="#1-5-SQLite-的其他特征" class="headerlink" title="1.5 SQLite 的其他特征"></a>1.5 SQLite 的其他特征</h2><p>除了 <code>SQLite</code> 的优化经验，还有一些其他的</p><h3 id="1-5-1-损坏与恢复"><a href="#1-5-1-损坏与恢复" class="headerlink" title="1.5.1 损坏与恢复"></a>1.5.1 损坏与恢复</h3><p><a href="https://mp.weixin.qq.com/s/N1tuHTyg3xVfbaSd4du-tw" target="_blank" rel="noopener">微信 SQLite 数据库修复实践</a></p><p><a href="https://mp.weixin.qq.com/s/Ln7kNOn3zx589ACmn5ESQA" target="_blank" rel="noopener">微信移动端数据库组件WCDB系列（二） — 数据库修复三板斧</a></p><p><a href="https://github.com/Tencent/wcdb/wiki/Android数据库修复" target="_blank" rel="noopener">WCDB Android 数据库修复</a></p><h3 id="1-5-2-加密与安全"><a href="#1-5-2-加密与安全" class="headerlink" title="1.5.2 加密与安全"></a>1.5.2 加密与安全</h3><p>数据库的安全主要有两个方面，一个是防注入，一个是加密。防注入可以通过静态安全扫描的方式，而加密一般会使用 <code>SQLCipher</code> 支持。</p><p><code>SQLite</code> 的加解密都是以页为单位，默认会使用 <code>AES</code> 算法加密，加 / 解密的耗时跟选用的密钥长度有关。</p><p><a href="https://mp.weixin.qq.com/s/NFnYEXSxAaHBqpi7WofSPQ" target="_blank" rel="noopener">WCDB 加解密的使用</a></p><h3 id="1-5-3-全文搜索"><a href="#1-5-3-全文搜索" class="headerlink" title="1.5.3 全文搜索"></a>1.5.3 全文搜索</h3><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/d2a09d040d0d915e78d7598457d6d1d9.png" alt="图片来源于 Android 开发高手课"></p><p><a href="https://mp.weixin.qq.com/s/AhYECT3HVyn1ikB0YQ-UVg" target="_blank" rel="noopener">微信全文搜索优化之路</a></p><p><a href="https://mp.weixin.qq.com/s/GCznwCtjJ2XUszyMcbNz8Q" target="_blank" rel="noopener">移动客户端多音字搜索</a> </p><p><strong>总结：</strong>关于 <code>SQLite</code>的这些特性，我们需要根据自己的项目情况综合考虑。假如某个数据库存储的数据并不重要，这个时候万分之一的数据损坏率我们并不会关心。同样是否需要使用数据库加密，也要根据存储的数据是不是敏感内容。</p><p><a href="http://huili.github.io/sqlite/sqliteintro.html" target="_blank" rel="noopener">SQLite 源码分析</a></p><p><a href="https://github.com/AndroidAdvanceWithGeektime/Chapter14/blob/master/全面解析SQLite.pdf" target="_blank" rel="noopener">全面解析 SQLite</a></p><hr><h1 id="2-如何优化数据存储？"><a href="#2-如何优化数据存储？" class="headerlink" title="2 如何优化数据存储？"></a>2 如何优化数据存储？</h1><h2 id="2-1-对象的序列化"><a href="#2-1-对象的序列化" class="headerlink" title="2.1 对象的序列化"></a>2.1 对象的序列化</h2><p>应用程序中的对象存储在内存中，如果我们想把对象存储下来或者在网络上传输，这个时候就需要用到对象的序列化和反序列化。</p><p>对象序列化就是把一个 <code>Object</code> 对象所有的信息表示成一个字节序列，这包括 <code>Class</code> 信息、继承关系信息、访问权限、变量类型以及数值信息等。</p><h3 id="2-1-1-Serializable"><a href="#2-1-1-Serializable" class="headerlink" title="2.1.1 Serializable"></a>2.1.1 Serializable</h3><p><code>Serializable</code> 是 <code>Java</code> 原生的序列化机制，在 <code>Android</code> 中也有被广泛使用。我们可以通过 <code>Serializable</code> 将对象持久化存储，也可以通过 <code>Bundle</code> 传递 <code>Serializable</code> 的序列化数据。</p><h4 id="Serializable-的原理"><a href="#Serializable-的原理" class="headerlink" title="Serializable 的原理"></a><strong>Serializable 的原理</strong></h4><p><code>Serializable</code> 的原理是通过 <code>ObjectInputStream</code> 和 <code>ObjectOutputStream</code> 来实现的，以 Android 6.0 的源码为例，可以看到 <a href="http://androidxref.com/6.0.0_r1/xref/libcore/luni/src/main/java/java/io/ObjectOutputStream.java#927" target="_blank" rel="noopener">ObjectOutputStream</a> 的部分源码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeFieldValues</span><span class="params">(Object obj, ObjectStreamClass classDesc)</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (ObjectStreamField fieldDesc : classDesc.fields()) &#123;</span><br><span class="line">        ...</span><br><span class="line">        Field field = classDesc.checkAndGetReflectionField(fieldDesc);</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>整个序列化过程使用了大量的反射和临时变量，而且在序列化对象的时候，不仅会序列化当前对象本身，还需要递归序列化对象引用的其他对象。</p><p>整个过程计算非常复杂，而且因为存在大量反射和 <code>GC</code> 的影响，序列化的性能会比较差。另外一方面因为序列化文件需要包含的信息非常多，导致它的大小比 Class 文件本身还要大很多，这样又会导致 I/O 读写上的性能问题。</p><h4 id="Serializable-的进阶"><a href="#Serializable-的进阶" class="headerlink" title="Serializable 的进阶"></a><strong>Serializable 的进阶</strong></h4><p>既然 <code>Serializable</code> 性能那么差，那它有哪些优势呢？可能很多同学都不知道它还有一些进阶的用法，你可以参考<a href="https://www.ibm.com/developerworks/cn/java/j-5things1/index.html" target="_blank" rel="noopener">《Java 对象序列化，您不知道的 5 件事》</a> 这篇文章。</p><p>自定义序列化：</p><ul><li><code>writeObject</code> 和 <code>readObject</code> 方法。<code>Serializable</code> 序列化支持替代默认流程，它会先反射判断是否存在我们自己实现的序列化方法 <code>writeObject</code> 或反序列化方法 <code>readObject</code> 。<strong>通过这两个方法，我们可以对某些字段做一些特殊修改，也可以实现序列化的加密功能。</strong></li><li><code>writeReplace</code> 和 <code>readResolve</code> 方法。这两个方法代理序列化的对象，可以实现自定义返回的序列化实例。那它有什么用呢？我们可以通过它们实现对象序列化的版本兼容，例如通过 <code>readResolve</code> 方法可以把老版本的序列化对象转换成新版本的对象类型。</li></ul><p><code>Serializable</code> 的序列化与反序列化的调用流程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 序列化</span></span><br><span class="line">E/test:SerializableTestData writeReplace</span><br><span class="line">E/test:SerializableTestData writeObject</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反序列化</span></span><br><span class="line">E/test:SerializableTestData readObject</span><br><span class="line">E/test:SerializableTestData readResolve</span><br></pre></td></tr></table></figure><h4 id="Serializable-的注意事项"><a href="#Serializable-的注意事项" class="headerlink" title="Serializable 的注意事项"></a><strong>Serializable 的注意事项</strong></h4><p><code>Serializable</code> 虽然使用非常简单，但是也有一些需要注意的事项字段。</p><ul><li><p><strong>不被序列化的字段。</strong>类的 <code>static</code> 变量以及被声明为 <code>transient</code> 的字段，默认的序列化机制都会忽略该字段，不会进行序列化存储。当然我们也可以使用进阶的 <code>writeReplace</code> 和 <code>readResolve</code> 方法做自定义的序列化存储。</p></li><li><p><strong>serialVersionUID。</strong>在类实现了 <code>Serializable</code> 接口后，我们需要添加一个 <code>Serial Version ID</code>，它相当于类的版本号。这个 <code>ID</code> 我们可以显式声明也可以让编译器自己计算。通常我建议显式声明会更加稳妥，因为隐式声明假如类发生了一点点变化，进行反序列化都会由于 <code>serialVersionUID</code> 改变而导致 <code>InvalidClassException</code> 异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1234567890L</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>构造方法。</strong><code>Serializable</code> 的反序列默认是不会执行构造函数的，它是根据数据流中对 <code>Object</code> 的描述信息创建对象的。如果一些逻辑依赖构造函数，就可能会出现问题，例如一个静态变量只在构造函数中赋值，当然我们也可以通过进阶方法做自定义的反序列化修改。</p></li></ul><h3 id="2-1-2-Parcelable"><a href="#2-1-2-Parcelable" class="headerlink" title="2.1.2 Parcelable"></a>2.1.2 Parcelable</h3><p>由于 <code>Java</code> 的<code>Serializable</code> 的性能较低，<code>Android</code> 需要重新设计一套更加轻量且高效的对象序列化和反序列化机制。<code>Parcelable</code> 正是在这个背景下产生的，它核心的作用就是为了解决 <code>Android</code> 中大量跨进程通信的性能问题。</p><h4 id="Parcelable-的永久存储"><a href="#Parcelable-的永久存储" class="headerlink" title="Parcelable 的永久存储"></a>Parcelable 的永久存储</h4><p>Parcelable 的原理十分简单，它的核心实现都在 <a href="http://androidxref.com/6.0.0_r1/xref/frameworks/native/libs/binder/Parcel.cpp" target="_blank" rel="noopener">Parcel.cpp</a> 。 </p><p>你可以发现 <code>Parcel</code> 序列化和 <code>Java</code> 的 <code>Serializable</code> 序列化差别还是比较大的，<code>Parcelable</code> 只会在内存中进行序列化操作，并不会将数据存储到磁盘里。</p><p>当然我们也可以通过 <a href="http://androidxref.com/6.0.0_r1/xref/frameworks/base/core/java/android/os/Parcel.java" target="_blank" rel="noopener">Parcel.java</a> 的 <code>marshall</code> 方法获取 <code>byte</code> 数组，然后存在文件中从而实现 <code>Parcelable</code> 的永久存储。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Returns the raw bytes of the parcel.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] marshall() &#123;</span><br><span class="line">    <span class="keyword">return</span> nativeMarshall(mNativePtr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Set the bytes in data to be the raw bytes of this Parcel.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">unmarshall</span><span class="params">(<span class="keyword">byte</span>[] data, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    nativeUnmarshall(mNativePtr, data, offset, length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ProcessCpuTracker pct=<span class="keyword">new</span> ProcessCpuTracker();</span><br><span class="line">Parcel parcel = Parcel.obtain();</span><br><span class="line">parcel.writeValue(pct);</span><br><span class="line"><span class="keyword">byte</span>[] bytes = parcel.marshall();</span><br><span class="line">parcel.recycle();</span><br><span class="line"></span><br><span class="line">Parcel thatParcel = Parcel.obtain();</span><br><span class="line">thatParcel.unmarshall(bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">thatParcel.setDataPosition(<span class="number">0</span>);</span><br><span class="line">ProcessCpuTracker that = (ProcessCpuTracker)thatParcel.readValue(ProcessCpuTracker<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>())</span>;</span><br><span class="line">thatParcel.recycle();</span><br></pre></td></tr></table></figure><h4 id="Parcelable-的注意事项"><a href="#Parcelable-的注意事项" class="headerlink" title="Parcelable 的注意事项"></a>Parcelable 的注意事项</h4><p>在时间开销和使用成本的权衡上，<code>Parcelable</code> 机制选择的是性能优先。</p><p>所以它在写入和读取的时候都需要手动添加自定义代码，使用起来相比 <code>Serializable</code> 会复杂很多。但是正因为这样，<code>Parcelable</code> 才不需要采用反射的方式去实现序列化和反序列化。</p><p>虽然通过取巧的方法可以实现 <code>Parcelable</code> 的永久存储，但是它也存在两个问题。</p><ul><li>系统版本的兼容性。由于 <code>Parcelable</code> 设计本意是在内存中使用的，我们无法保证所有 <code>Android</code> 版本的 Parcel.cpp 实现都完全一致。如果不同系统版本实现有所差异，或者有厂商修改了实现，可能会存在问题。</li><li>数据前后兼容性。<code>Parcelable</code> 并没有版本管理的设计，如果我们类的版本出现升级，写入的顺序及字段类型的兼容都需要格外注意，这也带来了很大的维护成本。</li></ul><p>一般来说，如果需要持久化存储的话，一般还是不得不选择性能更差的 Serializable 方案。</p><h3 id="2-1-3-Serial"><a href="#2-1-3-Serial" class="headerlink" title="2.1.3 Serial"></a>2.1.3 Serial</h3><p>直击痛点的方案，<code>Twitter</code> 开源的 <a href="https://github.com/twitter/Serial/blob/master/README-CHINESE.rst/" target="_blank" rel="noopener">Serial</a> </p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/71e3e58ed10ecc09646101ec22e360df.png" alt="图片来源于 Android 开发高手课"></p><p>从图中数据上看来，<code>Serial</code> 在序列化与反序列化耗时，以及落地的文件大小都有很大的优势。从实现原理上看，<code>Serial</code> 就像是把 <code>Parcelable</code> 和 <code>Serializable</code> 的优点集合在一起的方案。</p><ul><li>由于没有使用反射，相比起传统的反射序列化方案更加高效，具体你可以参考上面的测试数据。</li><li>开发者对于序列化过程的控制较强，可定义哪些 <code>Object</code>、<code>Field</code> 需要被序列化。</li><li>有很强的 <code>debug</code> 能力，可以调试序列化的过程。</li><li>有很强的版本管理能力，可以通过版本号和 <code>OptionalFieldException</code> 做兼容。</li></ul><h2 id="2-2-数据的序列化"><a href="#2-2-数据的序列化" class="headerlink" title="2.2 数据的序列化"></a>2.2 数据的序列化</h2><p><code>Serial</code> 性能看起来还不错，但是对象的序列化要记录的信息还是比较多，在操作比较频繁的时候，对应用的影响还是不少的，这个时候我们可以选择使用数据的序列化。</p><h3 id="2-2-1-Json"><a href="#2-2-1-Json" class="headerlink" title="2.2.1 Json"></a>2.2.1 Json</h3><p><code>JSON</code> 是一种轻量级的数据交互格式，它被广泛使用在网络传输中，很多应用与服务端的通信都是使用 <code>JSON</code> 格式进行交互。</p><p>JSON 的确有很多得天独厚的优势，主要有：</p><ul><li>相比对象序列化方案，速度更快，体积更小。</li><li>相比二进制的序列化方案，结果可读，易于排查问题。</li><li>使用方便，支持跨平台、跨语言，支持嵌套引用。</li></ul><p>因为每个应用基本都会用到 <code>JSON</code>，所以每个大厂也基本都有自己的 “ 轮子 ” 。例如 <code>Android</code> 自带的 <code>JSON</code> 库、<code>Google</code> 的 <code>Gson</code> 、阿里巴巴的 <code>Fastjson</code> 、美团的 <code>MSON</code> 。</p><p>各个自研的 JSON 方案主要在下面两个方面进行优化：</p><ul><li><strong>便利性。</strong>例如支持 JSON 转换成 JavaBean 对象，支持注解，支持更多的数据类型等。</li><li><strong>性能。</strong>减少反射，减少序列化过程内存与 CPU 的使用，特别是在数据量比较大或者嵌套层级比较深的时候效果会比较明显。</li></ul><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/984bb5dc6300f25ba142c208bdca3178.png" alt="图片来源于 Android 开发高手课"></p><p>在数据量比较少的时候，系统自带的 <code>JSON</code> 库还稍微有一些优势。但在数据量大了之后，差距逐渐被拉开。总的来说，<code>Gson</code> 的兼容性最好，一般情况下它的性能与 <code>Fastjson</code> 相当。但是在数据量极大的时候，<code>Fastjson</code> 的性能更好。</p><h3 id="2-2-2-Protocol-Buffers"><a href="#2-2-2-Protocol-Buffers" class="headerlink" title="2.2.2 Protocol Buffers"></a>2.2.2 Protocol Buffers</h3><p>相比对象序列化方案，<code>JSON</code> 的确速度更快、体积更小。不过为了保证 <code>JSON</code> 的中间结果是可读的，它并没有做二进制的压缩，也因此 <code>JSON</code> 的性能还没有达到极致。</p><p>如果应用的数据量非常大，又或者对性能有更高的要求，此时 <a href="https://developers.google.com/protocol-buffers/docs/overview" target="_blank" rel="noopener">Protocol Buffers</a> 是一个非常好的选择。它是 <code>Google</code> 开源的跨语言编码协议，<code>Google</code> 内部的几乎所有 <code>RPC</code> 都在使用这个协议。</p><p>下面我来总结一下它的优缺点。</p><ul><li><strong>性能。</strong>使用了二进制编码压缩，相比 JSON 体积更小，编解码速度也更快，感兴趣的同学可以参考protocol-buffers 编码规则。</li><li><strong>兼容性。</strong>跨语言和前后兼容性都不错，也支持基本类型的自动转换，但是不支持继承与引用类型。</li><li><strong>使用成本。</strong><code>Protocol Buffers</code> 的开发成本很高，需要定义 <code>.proto</code> 文件，并用工具生成对应的辅助类。辅助类特有一些序列化的辅助方法，所有要序列化的对象，都需要先转化为辅助类的对象，这让序列化代码跟业务代码大量耦合，是侵入性较强的一种方式。</li></ul><p>对于 <code>Android</code> 来说，官方的 <code>Protocol Buffers</code> 会导致生成的方法数很多。我们可以修改它的自动代码生成工具，例如在微信中，每个 <code>.proto</code> 生成的类文件只会包含一个方法即 <code>op</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestProtocal</span> <span class="keyword">extends</span>  <span class="title">com</span>.<span class="title">tencent</span>.<span class="title">mm</span>.<span class="title">protocal</span>.<span class="title">protobuf</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">op</span><span class="params">(<span class="keyword">int</span> opCode, Object ...objs)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (opCode == OPCODE_WRITEFIELDS) &#123;</span><br><span class="line">           ... </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (opCode == OPCODE_COMPUTESIZE) &#123;</span><br><span class="line">           ...</span><br></pre></td></tr></table></figure><p><code>Google</code> 后面还推出了压缩率更高的 <code>FlatBuffers</code>，对于它的使用你可以参考<a href="https://www.race604.com/flatbuffers-intro/" target="_blank" rel="noopener">《FlatBuffers 体验》</a>。最后，我再结合 “六要素”，综合对比一下 <code>Serial</code>、<code>JSON</code>、<code>Protocol Buffers</code> 这三种序列化方案。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/1afba11681441b6a8ab8f0d86337ea28.png" alt="图片来源于 Android 开发高手课"></p><h1 id="3-Demo-相关练习"><a href="#3-Demo-相关练习" class="headerlink" title="3 Demo 相关练习"></a>3 Demo 相关练习</h1><h2 id="3-1-重写-SharedPreferencesImpl"><a href="#3-1-重写-SharedPreferencesImpl" class="headerlink" title="3.1 重写 SharedPreferencesImpl"></a>3.1 重写 <code>SharedPreferencesImpl</code></h2><p><a href="https://github.com/AndroidAdvanceWithGeektime/Chapter12" target="_blank" rel="noopener">Chapter12 SharedPreferencesImpl</a> 这是一个简单的示例。</p><p>通过继承 <code>SharedPreferences</code> 重写 <code>SharedPreferencesImpl</code> ，并通过 <code>Application</code> 的 <code>getSharedPreferences</code> 方法，替换系统 <code>SharedPreferences</code> 的具体实现。还可以替换它的存储结构、增加加密等其他自定义功能。</p><h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a><strong>感谢</strong></h1><blockquote><p><a href="https://time.geekbang.org/column/article/74044" target="_blank" rel="noopener">极客时间 Android开发高手课</a>  </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>App 电量优化</title>
      <link href="/2020/power-optimization.html"/>
      <url>/2020/power-optimization.html</url>
      
        <content type="html"><![CDATA[<p>耗电优化究竟需要做哪些工作？我们如何快速定位代码中的不合理调用，并且持续监控应用的耗电情况呢？</p><h1 id="本文主要记载"><a href="#本文主要记载" class="headerlink" title="本文主要记载"></a>本文主要记载</h1><ul><li><strong>1 优化哪些耗电行为？</strong></li><li><strong>2 耗电优化的难点以及方法</strong></li><li><strong>3 耗电监控</strong><ul><li>3.1 耗电监控都监控什么</li><li>3.2 Battery Historian</li><li>3.3 Android Vitals</li><li>3.4 Java Hook</li><li>3.5 插桩</li></ul></li><li>4 耗电量计算原理</li></ul><hr><h1 id="1-优化哪些耗电行为？"><a href="#1-优化哪些耗电行为？" class="headerlink" title="1 优化哪些耗电行为？"></a>1 优化哪些耗电行为？</h1><p>所谓的耗电优化不就是减少应用的耗电，增加用户的续航时间吗？但是落到实践中，如果应用需要播放视频、需要获取 <code>GPS</code> 信息、需要拍照，这些耗电看起来是无法避免的。</p><p>假设这个时候发现某个应用他根本没怎么使用（前台时间很少），但是耗电却非常多。这种情况会跟用户的预期差别很大，他可能就会想去投诉。</p><ul><li><p><strong>所以耗电优化的第一个方向是优化应用的后台耗电。</strong> 知道了系统是如何计算耗电的，那反过来看，我们也就可以知道应用在后台不应该做什么，例如长时间获取 <code>WakeLock</code>、<code>WiFi</code> 和蓝牙的扫描等。为什么说耗电优化第一个方向就是优化应用后台耗电，因为大部分厂商预装项目要求最严格的正是应用后台待机耗电。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/b01e359b45d22bd80efda51eee2f5f2b.png" alt="图片来源于 Android 开发高手课"></p></li><li><p><strong>耗电优化的第二个方向是符合系统的规则，让系统认为你耗电是正常的。</strong>而 <code>Android P</code> 是通过 <code>Android Vitals</code> 监控后台耗电，所以我们需要符合 <code>Android Vitals</code> 的规则，目前它的具体规则如下：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/620748a58e45e50fdea1098f15c77d15.png" alt="图片来源于 Android 开发高手课"></p><p>虽然上面的标准可能随时会改变，但是可以看到，<code>Android</code> 系统目前比较关心后台 <code>Alarm</code> 唤醒、后台网络、后台 <code>WiFi</code> 扫描以及部分长时间 <code>WakeLock</code> 阻止系统后台休眠。</p></li></ul><h1 id="2-耗电优化的难点以及方法"><a href="#2-耗电优化的难点以及方法" class="headerlink" title="2 耗电优化的难点以及方法"></a>2 耗电优化的难点以及方法</h1><p><strong>难点：</strong></p><ul><li><strong>缺乏现场，无法复现。</strong></li><li><strong>信息不全，难以定位。</strong></li><li><strong>无法评估结果。</strong>从 <code>Android 4.4</code> 开始，我们无法拿到应用的耗电信息。尽管我们解决了某个耗电问题，也很难去评估它是否已经生效，以及对用户产生的价值有多大。</li></ul><p><strong>耗电优化的方法和思路：</strong></p><ul><li><p><strong>代码的 Bug。</strong>因为某些逻辑考虑不周，可能导致 <code>GPS</code> 没有关闭、<code>WakeLock</code> 没有释放。</p></li><li><p><strong>找到需求场景的替代方案。</strong></p><ul><li>最普遍的场景就是推送，为了实现推送我们只能做各种各样的保活。在需求面前，用户的价值可能被排到第二位。我们是否可以更多地利用厂商通道，或者定时的拉取最新消息这种模式。如果真是迫不得已，是不是可以使用 <code>foreground service</code> 或者引导用户加入白名单。后台任务的总体指导思想是减少、延迟和合并，可以参考微信一个小伙写的<a href="https://blog.dreamtobe.cn/2016/08/15/android_scheduler_and_battery/" target="_blank" rel="noopener">《Android 后台调度任务与省电》</a>。</li></ul></li><li><p><strong>符合 Android 规则。</strong>首先系统的大部分耗电监控，都是在手机在没有充电的时候。我们可以选择在用户充电时才去做一些耗电的工作，具体方法可查看官方文档 <a href="https://developer.android.google.cn/training/monitoring-device-state/battery-monitoring" target="_blank" rel="noopener">监控电池电量和充电状态</a>  。其次是尽早适配最新的 <code>Target API</code>，因为高版本系统后台限制本来就非常严格，应用在后台耗电本身就变得比较困难了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">IntentFilter ifilter = <span class="keyword">new</span> IntentFilter(Intent.ACTION_BATTERY_CHANGED);</span><br><span class="line">Intent batteryStatus = context.registerReceiver(<span class="keyword">null</span>, ifilter);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取用户是否在充电的状态或者已经充满电了</span></span><br><span class="line"><span class="keyword">int</span> status = batteryStatus.getIntExtra(BatteryManager.EXTRA_STATUS, -<span class="number">1</span>);</span><br><span class="line"><span class="keyword">boolean</span> isCharging = status == BatteryManager.BATTERY_STATUS_CHARGING || status == BatteryManager.BATTERY_STATUS_FULL;</span><br></pre></td></tr></table></figure></li><li><p><strong>异常情况监控。</strong>即使是最严格的 <code>Android P</code> <a href="https://mp.weixin.qq.com/s/APhUH7MBDUZ6tQv0xDgaWQ" target="_blank" rel="noopener">Android P 电量管理</a> ，系统也会允许应用部分地使用后台网络、<code>Alarm</code> 以及 <code>JobSheduler</code> 事件（<a href="https://developer.android.google.cn/topic/performance/power/power-details" target="_blank" rel="noopener">不同的分组，限制次数不同</a>）。因此出现异常情况的可能性还是存在的，更不用说低版本的系统。对于异常的情况，我们需要类似 <code>Android Vitals</code> 电量监控一样，将规则抽象出来，并且增加上更多辅助我们定位问题的信息。</p></li></ul><h1 id="3-耗电监控"><a href="#3-耗电监控" class="headerlink" title="3 耗电监控"></a>3 耗电监控</h1><h2 id="3-1-耗电监控都监控什么"><a href="#3-1-耗电监控都监控什么" class="headerlink" title="3.1 耗电监控都监控什么"></a>3.1 耗电监控都监控什么</h2><ul><li><strong>监控信息。</strong> 简单来说系统关心什么，我们就监控什么，而且应该以<strong>后台耗电监控为主</strong>。类似 <code>Alarm wakeup</code>、<code>WakeLock</code>、<code>WiFi scans</code>、<code>Network</code> 都是必须的，其他的可以根据应用的实际情况。如果是地图应用，后台获取 <code>GPS</code> 是被允许的；如果是计步器应用，后台获取 <code>Sensor</code> 也没有太大问题。</li><li><strong>现场信息。</strong> 监控系统希望可以获得完整的堆栈信息，比如哪一行代码发起了 <code>WiFi scans</code>、哪一行代码申请了 <code>WakeLock</code> 等。还有当时手机是否在充电、手机的电量水平、应用前台和后台时间、<code>CPU</code> 状态等一些信息也可以帮助我们排查某些问题。</li><li><strong>提炼规则。</strong> 最后我们需要将监控的内容抽象成规则，当然不同应用监控的事项或者参数都不太一样。</li></ul><p>简单规则：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/d48b7e4d3fdceb101fa7716b5892b0be.png" alt="图片来源于 Android 开发高手课"></p><p>在安卓绿色联盟的会议中，华为公开过他们后台资源使用的 “红线” </p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/86a65ea0d9216a11a341d7224fce93ff.png" alt="图片来源于 Android 开发高手课"></p><h2 id="3-2-Battery-Historian"><a href="#3-2-Battery-Historian" class="headerlink" title="3.2 Battery Historian"></a>3.2 Battery Historian</h2><p><a href="https://www.jianshu.com/p/0fa57924f228" target="_blank" rel="noopener">Battery Historian 的使用与安装</a>  </p><p><a href="https://github.com/google/battery-historian" target="_blank" rel="noopener">Battery Historian</a> 是 <code>Android5.0</code> 之后 <code>Google</code> 开源的一款用于检测与电池有关的信息和事件的工具，从设备中收集电池数据，然后使用 <code>Battery Historian</code> 可以可视化分析相关指标如耗电比例、<code>Wifi</code>、蜂窝数据量、<code>WakeLock</code> 唤醒次数。随着 <code>Android 6.0</code> 更新了 <code>Battery Historian 2.0</code> 加入引起手机状态变化的应用。</p><p>通过 <code>Battery Historian</code> 可以方便的看到各耗电模块随着时间的耗电情况：包含操作类型、执行时间、对应 <code>App</code> 等；还可以进行筛选特定的 <code>App</code> ，给出一个总结性的说明，包括：<code>Network Information</code>、 <code>Syncs</code>、<code>WakeLock</code>、<code>Services</code>、<code>Process info</code>、<code>Scheduled Job</code>、<code>Sensor Use</code> 等，查看每一个模块的总结，可以看出来每一项的耗时以及执行次数。当发现异常的时候可以针对性的进行排查。</p><h2 id="3-3-Android-Vitals"><a href="#3-3-Android-Vitals" class="headerlink" title="3.3 Android Vitals"></a>3.3 Android Vitals</h2><p><code>Android Vitals</code> 的几个关于电量的监控方案与规则</p><p><a href="https://developer.android.google.cn/topic/performance/vitals/wakeup" target="_blank" rel="noopener">Alarm Manager wakeup 唤醒过多频繁</a></p><p><a href="https://developer.android.google.cn/topic/performance/vitals/wakelock" target="_blank" rel="noopener">使用局部唤醒锁</a></p><p><a href="https://developer.android.google.cn/topic/performance/vitals/bg-network-usage" target="_blank" rel="noopener">后台网络使用量过高</a></p><p><a href="https://developer.android.google.cn/topic/performance/vitals/bg-wifi" target="_blank" rel="noopener">后台 WiFi scans 过多</a></p><p><code>Android Vitals</code> 跟 <code>Battery Historian</code> 一样，我们只能拿到 <code>wakeup</code> 的标记的组件，拿不到申请的堆栈，也拿不到当时手机是否在充电、剩余电量等信息。</p><p>对于网络、<code>WiFi scans</code> 以及 <code>WakeLock</code> 也是如此。虽然 <code>Vitals</code> 帮助我们缩小了排查的范围，但是依然需要在茫茫的代码中寻找对应的可疑代码。</p><h2 id="3-4-Java-Hook"><a href="#3-4-Java-Hook" class="headerlink" title="3.4 Java Hook"></a>3.4 Java Hook</h2><ul><li><p><a href="https://developer.android.google.cn/training/scheduling/wakelock" target="_blank" rel="noopener">WakeLock</a> 。<code>WakeLock</code> 用来阻止 <code>CPU</code>、屏幕甚至是键盘的休眠。类似 <code>Alarm</code>、<code>JobService</code> 也会申请 <code>WakeLock</code> 来完成后台 <code>CPU</code> 操作。<code>WakeLock</code> 的核心控制代码都在 <a href="http://androidxref.com/7.0.0_r1/xref/frameworks/base/services/core/java/com/android/server/power/PowerManagerService.java" target="_blank" rel="noopener">PowerManagerService</a> 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代理PowerManagerService</span></span><br><span class="line">ProxyHook().proxyHook(context.getSystemService(Context.POWER_SERVICE), <span class="string">"mService"</span>, <span class="keyword">this</span>)；</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeInvoke</span><span class="params">(Method method, Object[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 申请Wakelock</span></span><br><span class="line">    <span class="keyword">if</span> (method.getName().equals(<span class="string">"acquireWakeLock"</span>)) &#123;</span><br><span class="line">    <span class="comment">//获取应用堆栈等等 </span></span><br><span class="line">        <span class="keyword">if</span> (isAppForeground()) &#123;</span><br><span class="line">            <span class="comment">// 应用前台逻辑，上面的规则    </span></span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 应用后台逻辑，上面的规则</span></span><br><span class="line">         &#125;</span><br><span class="line">    <span class="comment">// 释放Wakelock</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.getName().equals(<span class="string">"releaseWakeLock"</span>)) &#123;</span><br><span class="line">       <span class="comment">// 释放的逻辑    </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://developer.android.google.cn/training/scheduling/alarms" target="_blank" rel="noopener">Alarm</a> 。<code>Alarm</code> 用来做一些定时的重复任务，它一共有四个类型，其中 <a href="https://developer.android.google.cn/reference/android/app/AlarmManager.html#RTC_WAKEUP" target="_blank" rel="noopener">ELAPSED_REALTIME_WAKEUP</a> 和 <a href="https://developer.android.google.cn/reference/android/app/AlarmManager.html#ELAPSED_REALTIME_WAKEUP" target="_blank" rel="noopener">RTC_WAKEUP</a> 类型都会唤醒设备。同样，<code>Alarm</code> 的核心控制逻辑都在 <a href="http://androidxref.com/7.0.0_r1/xref/frameworks/base/services/core/java/com/android/server/AlarmManagerService.java" target="_blank" rel="noopener">AlarmManagerService</a> 中，实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代理AlarmManagerService</span></span><br><span class="line"><span class="keyword">new</span> ProxyHook().proxyHook(context.getSystemService</span><br><span class="line">(Context.ALARM_SERVICE), <span class="string">"mService"</span>, <span class="keyword">this</span>)；</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeInvoke</span><span class="params">(Method method, Object[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置Alarm</span></span><br><span class="line">    <span class="keyword">if</span> (method.getName().equals(<span class="string">"set"</span>)) &#123;</span><br><span class="line">        <span class="comment">// 不同版本参数类型的适配，获取应用堆栈等等</span></span><br><span class="line">    <span class="comment">// 清除Alarm</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.getName().equals(<span class="string">"remove"</span>)) &#123;</span><br><span class="line">        <span class="comment">// 清除的逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><a href="https://github.com/simplezhli/Chapter19" target="_blank" rel="noopener">唯鹿 Chapter19</a> </p><p>这个 <code>Demo</code> 使用 <code>Java Hook</code> 实现 <code>Alarm</code>、<code>WakeLock</code> 与 <code>GPS</code> 的耗电监控。</p><p>动态代理对应的 <a href="http://androidxref.com/7.0.0_r1/xref/frameworks/base/core/java/android/os/PowerManager.java" target="_blank" rel="noopener">PowerManager</a>、<a href="http://androidxref.com/7.0.0_r1/xref/frameworks/base/core/java/android/app/AlarmManager.java" target="_blank" rel="noopener">AlarmManager</a>、<a href="http://androidxref.com/7.0.0_r1/xref/frameworks/base/location/java/android/location/LocationManager.java" target="_blank" rel="noopener">LocationManager</a>的<code>mService</code>实现，要拦截的方法在 <a href="http://androidxref.com/7.0.0_r1/xref/frameworks/base/services/core/java/com/android/server/power/PowerManagerService.java" target="_blank" rel="noopener">PowerManagerService</a>、<a href="http://androidxref.com/7.0.0_r1/xref/frameworks/base/services/core/java/com/android/server/AlarmManagerService.java" target="_blank" rel="noopener">AlarmManagerService</a>、<a href="http://androidxref.com/7.0.0_r1/xref/frameworks/base/services/core/java/com/android/server/LocationManagerService.java" target="_blank" rel="noopener">LocationManagerService</a> 中。</p><p><a href="https://blog.csdn.net/qq_17766199/article/details/86770948" target="_blank" rel="noopener">唯鹿原文</a> </p><h2 id="3-5-插桩"><a href="#3-5-插桩" class="headerlink" title="3.5 插桩"></a>3.5 插桩</h2><p>在使用 <code>Hook</code> 的时候，某些规则可能不太容易找到合适的 <code>Hook</code> 点。而且在 <code>Android P</code> 之后，很多的 <code>Hook</code> 点都不支持了。</p><p>出于兼容性考虑，写一个基础类，然后在统一的调用接口中增加监控逻辑。以 <code>WakeLock</code> 为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WakelockMetrics</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Wakelock 申请</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(PowerManager.WakeLock wakelock)</span> </span>&#123;</span><br><span class="line">        wakeLock.acquire();</span><br><span class="line">        <span class="comment">// 在这里增加Wakelock 申请监控逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Wakelock 释放</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(PowerManager.WakeLock wakelock, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">        wakelock.release();</span><br><span class="line">        <span class="comment">// 在这里增加Wakelock 释放监控逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Facebook</code> 也有一个耗电监控的开源库 <a href="https://github.com/facebookincubator/Battery-Metrics" target="_blank" rel="noopener">Battery-Metrics</a> ，它监控的数据非常全，包括 <code>Alarm</code>、<code>WakeLock</code>、<code>Camera</code>、<code>CPU</code>、<code>Network</code> 等，而且也有收集电量充电状态、电量水平等信息。</p><p><code>Battery-Metrics</code> 只是提供了一系列的基础类，在实际使用中，接入者可能需要修改大量的源码。但对于一些第三方 <code>SDK</code> 或者后续增加的代码，我们可能就不太能保证可以监控到了。这些场景也就无法监控了，所以 <code>Facebook</code> 内部是使用插桩来动态替换。</p><p>插桩方案使用起来兼容性非常好，并且使用者也没有太大的接入成本。但是它并不是完美无缺的，对于系统的代码插桩方案是无法替换的，例如 <code>JobService</code> 申请 <code>PARTIAL_WAKE_LOCK</code> 的场景。</p><h1 id="4-耗电量计算原理"><a href="#4-耗电量计算原理" class="headerlink" title="4 耗电量计算原理"></a>4 耗电量计算原理</h1><p>根据物理学的知识，电能的计算公式为 <code>电能 = 电压 * 电流 * 时间</code>。对于手机来说电压一般不会改变，所以在电压恒定的前提下，只需要测量电流和时间就可以确定耗电。</p><p>最终不同模块的耗电情况可以通过下面的这个公式计算：<code>模块电量(mAh) = 模块电流(mA) * 模块耗时(h)</code> 模块耗时比较容易理解，但是模块电流应该怎样去获取呢？</p><p><code>Android</code> 系统要求不同的厂商必须在 <code>/frameworks/base/core/res/res/xml/power_profile.xml</code> 中提供组件的电源配置文件。</p><p><a href="https://android.googlesource.com/platform/frameworks/base/+/master/core/res/res/xml/power_profile.xml" target="_blank" rel="noopener">power_profiler.xml</a> 文件定义了不同模块的电流消耗值以及该模块在一段时间内大概消耗的电量，你也可以参考 <a href="https://source.android.com/devices/tech/power" target="_blank" rel="noopener">Android Developer</a> 文档《Android 电源配置文件》。当然电流的大小和模块的状态也有关系，例如屏幕在不同亮度时的电流肯定会不一样。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/fa38166961e917ea6a321f84d3d4d4c1.png" alt="图片来源于 Android开发高手课"></p><p>Android 系统的电量计算 <a href="http://androidxref.com/7.0.0_r1/s?defs=PowerProfile&project=frameworks" target="_blank" rel="noopener">PowerProfile</a> 也是通过读取 <code>power_profile.xml</code> 的数值而已，不同的厂商具体的数值都不太一样，我们可以通过下面的方法获取：</p><ul><li>从手机中导出 <code>/system/framework/framework-res.apk</code> 文件。</li><li>使用反编译工具（如 <code>apktool</code>）对导出文件 <code>framework-res.apk</code> 进行反编译。</li><li>查看 <code>power_profile.xml</code> 文件在 <code>framework-res</code> 反编译目录路径：<code>/res/xml/power_profile.xml</code>。</li></ul><p>对于系统的电量消耗情况，我们可以通过 <code>dumpsys batterystats</code> 导出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">adb shell dumpsys batterystats &gt; battery.txt</span><br><span class="line">&#x2F;&#x2F; 各个Uid的总耗电量，而且是粗略的电量计算估计。</span><br><span class="line">Estimated power use (mAh):</span><br><span class="line">    Capacity: 3450, Computed drain: 501, actual drain: 552-587</span><br><span class="line">    ...</span><br><span class="line">    Idle: 41.8</span><br><span class="line">    Uid 0: 135 ( cpu&#x3D;103 wake&#x3D;31.5 wifi&#x3D;0.346 )</span><br><span class="line">    Uid u0a208: 17.8 ( cpu&#x3D;17.7 wake&#x3D;0.00460 wifi&#x3D;0.0901 )</span><br><span class="line">    Uid u0a65: 17.5 ( cpu&#x3D;12.7 wake&#x3D;4.11 wifi&#x3D;0.436 gps&#x3D;0.309 )</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; reset电量统计</span><br><span class="line">adb shell dumpsys batterystats --reset</span><br></pre></td></tr></table></figure><p><a href="http://androidxref.com/7.0.0_r1/xref/frameworks/base/services/core/java/com/android/server/am/BatteryStatsService.java" target="_blank" rel="noopener">BatteryStatsService</a> 是对外的电量统计服务，但具体的统计工作是由 <a href="http://androidxref.com/7.0.0_r1/xref/frameworks/base/core/java/com/android/internal/os/BatteryStatsImpl.java" target="_blank" rel="noopener">BatteryStatsImpl</a> 来完成的，而 <a href="http://androidxref.com/7.0.0_r1/xref/frameworks/base/core/java/com/android/internal/os/BatteryStatsImpl.java" target="_blank" rel="noopener">BatteryStatsImpl</a> 内部使用的就是 <code>PowerProfile</code>。<code>BatteryStatsImpl</code> 会为每一个应用创建一个 <code>UID</code> 实例来监控应用的系统资源使用情况。</p><p>电量的使用也会跟环境有关，例如在零下十度的冬天电量会消耗得更快一些，系统提供的电量测量方法只是提供一个参考的数值。不过通过上面的这个方法，我们可以成功把电量的测量转化为功能模块的使用时间或者次数。</p><p>准确的测量电量并不是那么容易，在<a href="https://tech.meituan.com/2018/03/11/dianping-shortvideo-battery-testcase.html" target="_blank" rel="noopener">《大众点评 App 的短视频耗电量优化实战》</a> 一文中，总结了下面几种电量测试的方法。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/ae1b52340f802f25a09c31c13a2a22fe.png" alt="图片来源于 Android开发高手课"></p><h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a><strong>感谢</strong></h1><blockquote><p><a href="https://time.geekbang.org/column/article/74044" target="_blank" rel="noopener">极客时间 Android开发高手课</a>  </p><p><a href="https://blog.csdn.net/aa20616012/article/details/49781875" target="_blank" rel="noopener">Android 6.0新特性之Doze模式</a> </p><p><a href="https://www.jianshu.com/p/5d83d8649c98" target="_blank" rel="noopener">Android性能优化（九）之不可忽视的电量</a> </p><p>以及上文中的链接</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>App 直观感受-卡顿优化🌈</title>
      <link href="/2020/hobble-optimization.html"/>
      <url>/2020/hobble-optimization.html</url>
      
        <content type="html"><![CDATA[<p>对用户来说，<strong>内存占用高</strong>、<strong>耗费电量</strong>、<strong>耗费流量</strong> 可能不容易被发现，但是用户对 <strong>卡顿</strong> 特别敏感，很容易直观感受到。</p><p><strong>注意：如果出现图片不显示问题请移步</strong> <a href="https://calmcenter.club/2019/PicNotShow.html">图片不显示问题</a></p><h1 id="本文主要记载"><a href="#本文主要记载" class="headerlink" title="本文主要记载"></a>本文主要记载</h1><ul><li><strong>1 如何定义卡顿？</strong></li><li><strong>2 如何排查卡顿？</strong><ul><li>2.1 Linux 命令组合排查</li><li>2.2 使用 top 命令查看进程信息</li></ul></li><li><strong>3 有没有方便的 Android 卡顿排查工具？</strong><ul><li>3.1 TraceView</li><li>3.2 Nanoscope</li><li>3.3 systrace</li><li>3.4 Simpleperf</li><li>3.5 可视化方法(Android Studio Profiler)</li><li>3.6 Android Performance Montitor(BlockCanary)</li><li>3.7 Profilo</li></ul></li><li><strong>4 卡顿现场</strong><ul><li>4.1 获取 java 线程状态</li><li>4.2 获得所有线程堆栈</li><li>4.3 SIGQUIT 信号实现</li><li>4.4 Hook 实现</li></ul></li><li><strong>5 相关 Demo 学习</strong><ul><li>5.1 抓取 CPU 数据</li><li>5.2 PLTHook 监控 Thread 的创建</li><li>5.3 Loop 监控卡顿</li></ul></li><li>总结</li></ul><hr><h1 id="1-如何定义卡顿？"><a href="#1-如何定义卡顿？" class="headerlink" title="1 如何定义卡顿？"></a>1 如何定义卡顿？</h1><p><code>60帧</code> 每秒是目前最合适的图像显示速度，也是绝大部分 <code>Android</code> 设备设置的调试频率，如果在 <code>16ms</code> 内顺利完成界面刷新操作可以展示出流畅的画面，而由于任何原因导致接收到 <code>VSYNC</code> 信号的时候无法完成本次刷新操作，就会产生掉帧的现象，刷新帧率自然也就跟着下降(假定刷新帧率由正常的 <code>60fps</code> 降到 <code>30fps</code> ，用户就会明显感知到卡顿)。</p><p>卡顿的原因可以定义为 <code>UI 复杂度问题</code> ，<code>没有提前或异步初始化问题</code> ， <code>内存泄漏频繁 GC 的问题</code> 等，卡顿的解决思路是集结了 启动优化、内存优化、UI 优化 的所有知识点，所以这篇也是对之前的扩展补充。</p><p>造成卡顿的原因可能有千百种，不过最终都会反映到 CPU 时间上。</p><p>我们可以把 CPU 时间分为两种：</p><ol><li>用户时间：执行用户态应用程序代码所消耗的时间</li><li>系统时间：执行内核态系统调用所消耗的时间，包括 I/O、锁、中断以及其他系统调用的时间。</li></ol><hr><h1 id="2-如何排查卡顿"><a href="#2-如何排查卡顿" class="headerlink" title="2 如何排查卡顿"></a>2 如何排查卡顿</h1><h2 id="2-1-Linux-命令组合排查"><a href="#2-1-Linux-命令组合排查" class="headerlink" title="2.1 Linux 命令组合排查"></a>2.1 Linux 命令组合排查</h2><ol><li><strong>获取 <code>CPU</code> 核心数</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;possible</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>获取某个 <code>CPU</code> 的频率</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpu0&#x2F;cpufreq&#x2F;cpuinfo_max_freq</span><br></pre></td></tr></table></figure><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/20200420172904.png" alt=""></p><p>我们需要根据设备 <code>CPU</code> 性能来 “看菜下饭” ，例如线程池使用线程数根据 <code>CPU</code> 的核心数，一些高级的 <code>AI</code> 功能只在主频比较高或者带有 <code>NPU</code> 的设备开启。</p><ol start="3"><li><strong>查看 <code>CPU</code> 的使用率</strong></li></ol><p><strong>整个系统的 CPU 使用情况</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;proc&#x2F;stat</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;adb shell</span><br><span class="line">cat &#x2F;proc&#x2F;stat</span><br><span class="line">cpu  166492 36473 149538 7550789 34852 0 9110 0 0 0</span><br><span class="line">cpu0 31858 4048 34220 808812 5172 0 4604 0 0 0</span><br><span class="line">cpu1 22897 4439 25504 894380 7874 0 1514 0 0 0</span><br><span class="line">cpu2 29068 6317 27063 908505 7657 0 673 0 0 0</span><br><span class="line">cpu3 25916 6157 23508 931591 6625 0 259 0 0 0</span><br><span class="line">cpu4 28689 5321 22388 971414 2544 0 1030 0 0 0</span><br><span class="line">cpu5 10136 3778 6687 1009482 1551 0 606 0 0 0</span><br><span class="line">cpu6 8074 3398 5163 1014162 1489 0 218 0 0 0</span><br><span class="line">cpu7 9854 3015 5005 1012443 1940 0 206 0 0 0</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>第一行的数据表示的是 <code>CPU</code> 总的使用情况</p><ol><li><p>这些数值的单位都是 <code>jiffies</code>。<code>jiffies</code> 是内核中的一个全局变量，用来记录系统启动以来产生的节拍数，在 <code>Linux</code> 中，一个节拍大致可以理解为操作系统进程调度的最小时间片，不同的 <code>Linux</code> 系统内核这个值可能不同，通常在 <code>1ms</code> 到 <code>10ms</code> 之间。</p></li><li><p>cpu  166492 36473 149538 7550789 34852 0 9110 0 0 0</p><ul><li><code>user</code>(166492) 从系统启动开始累积到当前时刻，处于用户态的运行时间，不包含 nice 值为负的进程。</li><li><code>nice</code>(36473) 从系统启动开始累积到当前时刻，nice 值为负的进程所占用的 CPU 时间。</li><li><code>system</code>(149538) 从系统启动开始累积到当前时刻，处于核心态的运行时间。</li><li><code>idle</code>(7550789) 从系统启动开始累积到当前时刻，除 IO 等待时间以外的其他等待时间。</li><li><code>iowait</code>(34852) 从系统启动开始累积到当前时刻，IO 等待时间。(since 2.5.41)</li><li><code>irq</code>(0) 从系统启动开始累积到当前时刻，硬中断时间。(since 2.6.0-test4)</li><li><code>softirq</code>(9110) 从系统启动开始累积到当前时刻，软中断时间。(since 2.6.0-test4)</li><li><code>stealstolen</code>(0) 这是在虚拟环境中运行时在其他操作系统中花费的时间。(since 2.6.11)</li><li><code>guest</code>(0) 这是运行 Linux 内核控制下的来宾操作系统的虚拟 CPU 所花费的时间。(since 2.6.24)</li><li><code>guest_nice</code>(0) 运行 niced 客户端的时间( Linux 内核控制下的客户操作系统的虚拟CPU)。(since Linux 2.6.33)</li></ul><p>具体使用率计算请查看 <a href="https://time.geekbang.org/column/article/71982" target="_blank" rel="noopener">《Linux环境下进程的CPU占用率》</a> 还是有点麻烦的 ~ </p></li></ol><h2 id="2-2-使用-top-命令查看进程信息"><a href="#2-2-使用-top-命令查看进程信息" class="headerlink" title="2.2 使用 top 命令查看进程信息"></a>2.2 使用 top 命令查看进程信息</h2><ol><li><p>直接输入 <code>top</code> 可查看所有进程的 <code>cpu</code> 使用情况</p><p>几个常用的参数：</p><ul><li><code>-d</code>: 后面接秒数，就是整个进程画面更新的频率。默认是 5 秒。</li><li><code>-b</code>: 以批处理的方式执行 top，还有更多的参数可用。通常会搭配数据流重导向，将批处理的结果输出为文件。</li><li><code>-n</code>: 与 -b 搭配，意义是，需要进行几次 top 的输出结果。</li><li><code>-p</code>: 指定某个 PID 来进行观察监测。</li><li>在 top 执行过程中可以使用的按键命令：</li><li><code>?</code>: 显示在 top 中可以输入的按键命令。</li><li><code>P</code>: 按照 CPU 的使用资源排序显示。</li><li><code>M</code>: 按内存（Memory）的使用资源排序显示。</li><li><code>N</code>: 按 PID 来排序。</li><li><code>T</code>: 按该进程使用的 CPU 时间积累（TIME+）排序。</li><li><code>k</code>: 给某个 PID 一个信号（signal）。</li><li><code>r</code>: 给某个 PID 重新确定一个值。</li><li><code>1</code>: 显示所有 CPU 占用信息。</li></ul></li><li><p>监测进程 13620</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -d 2 -p 13620</span><br></pre></td></tr></table></figure><p>会一直输出进程 13620 的信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">top - 16:27:35 up 4 days, 7:43, 2 users, load average: 0.35, 0.47, 0.44</span><br><span class="line">Tasks: 1 total, 1 running, 0 sleeping, 0 stopped, 0 zombie</span><br><span class="line">Cpu(s): 0.1%us, 3.1%sy, 0.0%ni, 96.5%id, 0.0%wa, 0.0%hi, 0.3%si, 0.0%st</span><br><span class="line">Mem: 16320632k total, 1790796k used, 14529836k free, 233168k buffers</span><br><span class="line">Swap: 8232952k total, 0k used, 8232952k free, 941540k cached</span><br><span class="line"> </span><br><span class="line">PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND</span><br><span class="line">13620 test1370 20 0 11060 944 760 R 53.4 0.0 0:04.78 netperf</span><br></pre></td></tr></table></figure><hr><h1 id="3-有没有方便的-Android-卡顿排查工具？"><a href="#3-有没有方便的-Android-卡顿排查工具？" class="headerlink" title="3 有没有方便的 Android 卡顿排查工具？"></a>3 有没有方便的 Android 卡顿排查工具？</h1><p>日常开发中比较熟悉的工具分为两个流派：</p><ul><li><p>instrument 流派</p><p>获取一段时间内所有函数的调用过程，可以通过分析这段时间内的函数调用流程，再进一步分析待优化的点。</p></li><li><p>sample 流派</p><p>有选择性或者采用抽样的方式观察某些函数调用过程，可以通过这些有限的信息推测出流程中的可疑点，然后再继续细化分析。</p></li></ul><h2 id="3-1-Traceview"><a href="#3-1-Traceview" class="headerlink" title="3.1 Traceview"></a>3.1 Traceview</h2><p>我在 <a href="https://calmcenter.club/2019/start-optimization.html#toc-heading-7">《App 初体验-启动优化 2.2.1 TraceView》</a> 中讲过 <code>TraceView</code>  的基本使用方法。<code>Traceview</code> 属于 <code>instrument</code> 类型，它利用 Android Runtime 函数调用的 event 事件，将函数运行的耗时和调用关系写入 trace 文件中，它可以用来查看整个过程有哪些函数调用。</p><p>工具本身带来的性能开销过大，有时无法反映真实的情况。在 <code>Android 5.0</code> 之后，新增了<code>startMethodTracingSampling</code> 方法，可以使用基于样本的方式进行分析，以减少分析对运行时的性能影响。新增了 sample 类型后，就需要我们在开销和信息丰富度之间做好权衡。</p><h2 id="3-2-Nanoscope"><a href="#3-2-Nanoscope" class="headerlink" title="3.2 Nanoscope"></a>3.2 Nanoscope</h2><p> <a href="https://calmcenter.club/2019/start-optimization.html#toc-heading-10">《App 初体验-启动优化 2.2.4 Nanoscope》</a> 查看原理即项目地址。它是在 <code>instrument</code> 类型的性能分析工具中性能损耗比较小的。</p><h2 id="3-3-systrace"><a href="#3-3-systrace" class="headerlink" title="3.3 systrace"></a>3.3 systrace</h2><p> <a href="https://calmcenter.club/2019/start-optimization.html#toc-heading-8">《App 初体验-启动优化 2.2.2 systrace》</a> 查看具体使用方法。其中还讲到了 <code>systrace + 函数插桩 AOP</code></p><p><code>systrace</code> 工具只能监控特定系统调用的耗时情况，所以它是属于 <code>sample</code> 类型，而且性能开销非常低。但是它不支持应用程序代码的耗时分析，所以在使用时有一些局限性。</p><h2 id="3-4-Simpleperf"><a href="#3-4-Simpleperf" class="headerlink" title="3.4 Simpleperf"></a>3.4 Simpleperf</h2><p>分析 <code>Native</code> 函数时使用的工具，在 <code>Android Studio 3.2</code> 也在 <code>Profiler</code> 中直接支持 <code>Simpleperf</code>。</p><p><code>Simpleperf</code> 属于 <code>sample</code> 类型，它的性能开销非常低，使用火焰图展示分析结果。</p><p><strong>总结：</strong></p><p>选择哪种工具，需要看具体的场景。如果需要分析 <code>Native</code> 代码的耗时，可以选择 <code>Simpleperf</code>；如果想分析系统调用，可以选择 <code>systrace</code>；如果想分析整个程序执行流程的耗时，可以选择 <code>Traceview</code> 或者<code>插桩版本的 systrace</code>。<br><code>systrace</code> 利用了 <code>Linux</code> 的 <a href="http://source.android.com/devices/tech/debug/ftrace" target="_blank" rel="noopener">ftrace</a> 调试工具，相当于在系统各个关键位置都添加了一些性能探针，也就是在代码里加了一些性能监控的埋点。<code>Android</code> 在 <code>ftrace</code> 的基础上封装了<code>atrace</code>，并增加了更多特有的探针，例如 <code>Graphics</code>、<code>Activity Manager</code>、<code>Dalvik VM</code>、<code>System Server</code> 等。</p><h2 id="3-5-可视化方法（Android-Studio-Profiler）"><a href="#3-5-可视化方法（Android-Studio-Profiler）" class="headerlink" title="3.5 可视化方法（Android Studio Profiler）"></a>3.5 可视化方法（Android Studio Profiler）</h2><p>在 <code>Android Studio 3.2</code> 的 <code>CPU Profiler</code> 中直接集成了几种性能分析工具</p><ul><li><strong>Sample Java Methods</strong> 的功能类似于 <code>Traceview</code> 的 <code>sample</code> 类型。</li><li><strong>Trace Java Methods</strong> 的功能类似于 <code>Traceview</code> 的 <code>instrument</code> 类型。</li><li><strong>Trace System Calls</strong> 的功能类似于 <code>systrace</code>。</li><li><strong>SampleNative</strong> (API Level 26+) 的功能类似于 <code>Simpleperf</code>。</li></ul><p>这些分析工具都支持了 <code>Call Chart</code> 和 <code>Flame Chart</code> 两种展示方式。</p><ol><li><p><strong>Call Chart</strong></p><p><code>Call Chart</code> 是 <code>Traceview</code> 和 <code>systrace</code> 默认使用的展示方式。它按照应用程序的函数执行顺序来展示，适合用于分析整个流程的调用。举一个最简单的例子，A 函数调用 B 函数，B 函数调用 C 函数，循环三次，就得到了下面的 <code>Call Chart</code>。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://static001.geekbang.org/resource/image/db/3e/db3612f661d29efe59854df2e6c2383e.jpg" alt="图片来源于 Android开发高手课"></p><p><code>Call Chart</code> 就像给应用程序做一个心电图，我们可以看到在这一段时间内，各个线程的具体工作，比如是否存在线程间的锁、主线程是否存在长时间的 <code>I/O</code> 操作、是否存在空闲等。</p></li><li><p><strong>Flame Chart</strong></p></li></ol><p>Flame Chart 也就是<strong>火焰图</strong>。它跟 Call Chart 不同的是，Flame Chart 以一个全局的视野来看待一段时间的调用分布，它就像给应用程序拍 X 光片，可以很自然地把时间和空间两个维度上的信息融合在一张图上。</p><p>上面函数调用的例子，换成火焰图的展示结果如下。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://static001.geekbang.org/resource/image/6c/01/6ca232173daf9e71f06ac22252d65d01.jpg" alt="图片来源于 Android开发高手课"></p><p>当我们不想知道应用程序的整个调用流程，只想直观看出哪些代码路径花费的 <code>CPU</code> 时间较多时，火焰图就是一个非常好的选择。</p><p>火焰图还可以使用在各种各样的维度，例如内存、I/O 的分析。有些内存可能非常缓慢地泄漏，通过一个内存的火焰图，我们就知道哪些路径申请的内存最多，有了火焰图我们根本不需要分析源代码，也不需要分析整个流程。</p><h2 id="3-6-Android-Performance-Monitor（BlockCanary）"><a href="#3-6-Android-Performance-Monitor（BlockCanary）" class="headerlink" title="3.6 Android Performance Monitor（BlockCanary）"></a>3.6 Android Performance Monitor（BlockCanary）</h2><p><a href="https://github.com/markzhai/AndroidPerformanceMonitor" target="_blank" rel="noopener">AndroidPerformanceMonitor</a> 是一个Android平台的一个非侵入式的性能监控组件，应用只需要实现一个抽象类，提供一些该组件需要的上下文环境，就可以在平时使用应用的时候检测主线程上的各种卡慢问题，并通过组件提供的各种信息分析出原因并进行修复。</p><h2 id="3-7-Profilo"><a href="#3-7-Profilo" class="headerlink" title="3.7 Profilo"></a>3.7 Profilo</h2><p>2018 年 3 月，<code>Facebook</code> 开源了一个叫 <a href="https://github.com/facebookincubator/profilo" target="_blank" rel="noopener">Profilo</a> 的库， 它收集了各大方案的优点。</p><ol><li><p><strong>集成 atrace 功能</strong>。</p><p>这样所有 <code>systrace</code> 的探针我们都可以拿到，例如四大组件生命周期、锁等待时间、类校验、<code>GC</code> 时间等。</p></li><li><p><strong>快速获取 Java 堆栈</strong></p><p>这里有一个误区，大家都觉得在某个线程不断地获取主线程堆栈是不耗时的。但是事实上获取堆栈的代价是巨大的，它要暂停主线程的运行。</p><p>而 <code>profilo</code> 巧妙的解决的这个问题，可以实现线程一边继续跑步，我们还可以帮它做检查，而且耗时基本忽略不计。</p></li></ol><p>不用插桩、性能基本没有影响、捕捉信息还全，那 <code>Profilo</code> 不就是完美的化身吗？当然由于它利用了大量的黑科技，兼容性是需要注意的问题。它内部实现有大量函数的 <code>Hook</code>，<code>unwind</code> 也需要强依赖 <code>Android Runtime</code> 实现。<code>Facebook</code> 已经将 <code>Profilo</code> 投入到线上使用，但由于目前 <code>Profilo</code> 快速获取堆栈功能依然不支持 <code>Android 8.0</code> 和 <code>Android 9.0</code>，鉴于稳定性问题，建议采取抽样部分用户的方式来开启该功能。</p><p><strong>帮助理解</strong></p><ul><li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-ftrace/index.html" target="_blank" rel="noopener">ftrace 简介</a>、<a href="https://www.ibm.com/developerworks/cn/linux/l-cn-ftrace1/index.html" target="_blank" rel="noopener">ftrace 使用（上）</a>、<a href="https://www.ibm.com/developerworks/cn/linux/l-cn-ftrace2/index.html" target="_blank" rel="noopener">frace 使用（下）</a></li><li><a href="http://source.android.com/devices/tech/debug/ftrace" target="_blank" rel="noopener">atrace 介绍</a>、<a href="http://android.googlesource.com/platform/frameworks/native/+/master/cmds/atrace/atrace.cpp" target="_blank" rel="noopener">atrace 实现</a></li></ul><p>每个工具都可以生成不同的展示方式，我们需要根据不同的使用场景选择合适的方式。</p><hr><h1 id="4-卡顿现场"><a href="#4-卡顿现场" class="headerlink" title="4 卡顿现场"></a>4 卡顿现场</h1><h2 id="4-1-获取-java-线程状态"><a href="#4-1-获取-java-线程状态" class="headerlink" title="4.1 获取 java 线程状态"></a>4.1 获取 java 线程状态</h2><p>通过 <code>Thread</code> 的 <code>getState</code> 方法可以获取线程状态，<strong>WAITING</strong>、<strong>TIME_WAITING</strong> 和 <strong>BLOCKED</strong> 都是需要特别注意的状态。</p><p>BLOCKED: 是指线程正在等待获取锁，对应的是下面代码中的情况一；</p><p>WAITING: 是指线程正在等待其他线程的“唤醒动作”，对应的是代码中的情况二。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (object)  &#123;     <span class="comment">// 情况一：在这里卡住 --&gt; BLOCKED</span></span><br><span class="line">    object.wait();           <span class="comment">// 情况二：在这里卡住 --&gt; WAITING</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过当一个线程进入 WAITING 状态时，它不仅会释放 CPU 资源，还会将持有的 object 锁也同时释放。</p><p>更多相关资料 <a href="https://juejin.im/post/5b31b510e51d4558a426f7e9" target="_blank" rel="noopener">《Java 线程 Dump 分析》</a></p><h2 id="4-2-获得所有线程堆栈"><a href="#4-2-获得所有线程堆栈" class="headerlink" title="4.2 获得所有线程堆栈"></a>4.2 获得所有线程堆栈</h2><p>当我们发现有个线程导致主线程 <code>BLOCKED</code> ，需要通过 <code>Thread.getAllStackTraces()</code> 拿所有线程的堆栈，需要注意的是在 <code>Android 7.0</code>，<code>getAllStackTraces</code>是不会返回主线程的堆栈的。</p><h2 id="4-4-SIGQUIT-信号实现"><a href="#4-4-SIGQUIT-信号实现" class="headerlink" title="4.4 SIGQUIT 信号实现"></a>4.4 SIGQUIT 信号实现</h2><p>注：需要 <code>root</code> </p><p><code>Android</code> 应用发生 <code>ANR</code> 时，系统会发出 <code>SIGQUIT</code> 信号给发生 <code>ANR</code> 进程。系统信号捕捉线程触发输出<code>/data/anr/traces.txt</code> 文件，记录问题产生虚拟机、线程堆栈相关信息。这个 <code>trace</code> 文件中包含了线程信息和锁的信息，借助这个 <code>trace</code> 文件可以分析卡死的原因。</p><p>由此，如果利用这个系统原有的机制，自己在线程卡死时候触发traces文件的形成进行上报，便可以把线程卡死的关键进行进行上报。本监控方案便是<strong>利用系统机制进行卡死信息的抓取</strong>：</p><ol><li><p>当监控线程发现被监控线程卡死时，主动向系统发送 <code>SIGQUIT</code> 信号。</p></li><li><p>等待 <code>/data/anr/traces.txt</code> 文件生成。</p></li><li><p>文件生成以后进行上报。</p></li></ol><p>分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程名称; 优先级; 线程id; 线程状态</span></span><br><span class="line"><span class="string">"main"</span> prio=<span class="number">5</span> tid=<span class="number">1</span> Suspended</span><br><span class="line">  <span class="comment">// 线程组;  线程suspend计数; 线程debug suspend计数; </span></span><br><span class="line">  | group=<span class="string">"main"</span> sCount=<span class="number">1</span> dsCount=<span class="number">0</span> obj=<span class="number">0x74746000</span> self=<span class="number">0xf4827400</span></span><br><span class="line">  <span class="comment">// 线程native id; 进程优先级; 调度者优先级;</span></span><br><span class="line">  | sysTid=<span class="number">28661</span> nice=-<span class="number">4</span> cgrp=<span class="keyword">default</span> sched=<span class="number">0</span>/<span class="number">0</span> handle=<span class="number">0xf72cbbec</span></span><br><span class="line">  <span class="comment">// native线程状态; 调度者状态; 用户时间utime; 系统时间stime; 调度的CPU</span></span><br><span class="line">  | state=D schedstat=( <span class="number">3137222937</span> <span class="number">94427228</span> <span class="number">5819</span> ) utm=<span class="number">218</span> stm=<span class="number">95</span> core=<span class="number">2</span> HZ=<span class="number">100</span></span><br><span class="line">  <span class="comment">// stack相关信息</span></span><br><span class="line">  | stack=<span class="number">0xff717000</span>-<span class="number">0xff719000</span> stackSize=<span class="number">8</span>MB</span><br></pre></td></tr></table></figure><p>其中 <code>utm</code> 代表 <code>utime</code>，<code>HZ</code> 代表 <code>CPU</code> 的时钟频率，将 <code>utime</code> 转换为毫秒的公式是 <code>time * 1000/HZ</code>。例子中 <code>utm=218</code>，也就是 <code>218*1000/100=2180</code> 毫秒。</p><h2 id="4-5-Hook-实现"><a href="#4-5-Hook-实现" class="headerlink" title="4.5 Hook 实现"></a>4.5 Hook 实现</h2><p>用 <code>SIGQUIT</code> 信号量获取 <code>ANR</code> 日志，从而拿到所有线程的各种信息，这套方案看起来很美好。但事实上，它存在这几个问题：</p><ol><li><strong>可行性。</strong> 高版本系统已经没有权限读取 <code>/data/anr/traces.txt</code> 文件。需要 <code>root</code> 手机</li><li><strong>性能。</strong>获取所有线程堆栈以及各种信息非常耗时，对于卡顿场景不一定合适，它可能会进一步加剧用户的卡顿。</li></ol><p><a href="https://www.jianshu.com/p/f406d535a8bc" target="_blank" rel="noopener">Android trace文件抓取原理</a>   <a href="https://mp.weixin.qq.com/s/g-WzYF3wWAljok1XjPoo7w?" target="_blank" rel="noopener">Android 平台 Native 代码的崩溃捕获机制及实现</a></p><p><a href="https://blog.csdn.net/oujunli/article/details/9102101" target="_blank" rel="noopener">通过Android trace文件分析死锁ANR</a> </p><p>能力有限，还在研究中。。</p><p><strong>思路：</strong> <code>hook libart.so</code> 。通过<code>hook ThreadList</code> 和 <code>Thread</code> 的函数，获得跟 <code>ANR</code> 一样的堆栈。为了稳定性，我们会在 <code>fork</code> 子进程执行。</p><p>  优点：信息很全，基本跟 <code>ANR</code> 的日志一样，有 <code>native</code> 线程状态，锁信息等等。<br>  缺点：黑科技的兼容性问题，失败时可以用 <code>Thread.getAllStackTraces()</code> 兜底</p><p>获取Java堆栈的方法还可以用在卡顿时，因为使用fork进程，所以可以做到完全不卡主进程。</p><p><code>Breakpad</code> 使用了 <code>fork</code> 子进程甚至孙进程的方式去收集崩溃现场，即便出现二次崩溃，也只是这部分信息丢失。</p><h1 id="5-Demo-相关-Demo-学习"><a href="#5-Demo-相关-Demo-学习" class="headerlink" title="5 Demo 相关 Demo 学习"></a>5 Demo 相关 Demo 学习</h1><h2 id="5-1-抓取-CPU-数据"><a href="#5-1-抓取-CPU-数据" class="headerlink" title="5.1 抓取 CPU 数据"></a>5.1 抓取 CPU 数据</h2><p><a href="https://github.com/AndroidAdvanceWithGeektime/Chapter05" target="_blank" rel="noopener">Chapter05</a> </p><p>模仿 <a href="http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/java/com/android/internal/os/ProcessCpuTracker.java" target="_blank" rel="noopener">ProcessCpuTracker.java</a> 拿到一段时间内各个线程的耗时占比</p><p>示例的日志数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">usage: CPU usage <span class="number">5000</span>ms(from <span class="number">23</span>:<span class="number">23</span>:<span class="number">33.000</span> to <span class="number">23</span>:<span class="number">23</span>:<span class="number">38.000</span>):</span><br><span class="line">System TOTAL: <span class="number">2.1</span>% user + <span class="number">16</span>% kernel + <span class="number">9.2</span>% iowait + <span class="number">0.2</span>% irq + <span class="number">0.1</span>% softirq + <span class="number">72</span>% idle</span><br><span class="line">CPU Core: <span class="number">8</span></span><br><span class="line">Load Average: <span class="number">8.74</span> / <span class="number">7.74</span> / <span class="number">7.36</span></span><br><span class="line"></span><br><span class="line">Process:com.sample.app </span><br><span class="line">  <span class="number">50</span>% <span class="number">23468</span>/com.sample.app(S): <span class="number">11</span>% user + <span class="number">38</span>% kernel faults:<span class="number">4965</span></span><br><span class="line"></span><br><span class="line">Threads:</span><br><span class="line">  <span class="number">43</span>% <span class="number">23493</span>/singleThread(R): <span class="number">6.5</span>% user + <span class="number">36</span>% kernel faults：<span class="number">3094</span></span><br><span class="line">  <span class="number">3.2</span>% <span class="number">23485</span>/RenderThread(S): <span class="number">2.1</span>% user + <span class="number">1</span>% kernel faults：<span class="number">329</span></span><br><span class="line">  <span class="number">0.3</span>% <span class="number">23468</span>/.sample.app(S): <span class="number">0.3</span>% user + <span class="number">0</span>% kernel faults：<span class="number">6</span></span><br><span class="line">  <span class="number">0.3</span>% <span class="number">23479</span>/HeapTaskDaemon(S): <span class="number">0.3</span>% user + <span class="number">0</span>% kernel faults：<span class="number">982</span></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><ol><li>在 <code>System Total</code> 部分 <code>user</code> 占用不多，<code>CPU idle</code> 很高，消耗多在 <code>kernel</code> 和 <code>iowait</code>。</li><li><code>CPU</code> 是 8 核的，<code>Load Average</code> 大约也是 8，表示 <code>CPU</code> 并不处于高负载情况。</li><li>在 <code>Process</code> 里展示了这段时间内 <code>sample app</code> 的 <code>CPU</code> 使用情况：<code>user</code> 低，<code>kernel</code> 高，并且有 <code>4965</code> 次 <code>page faults</code>。<ol><li><code>page faluts</code> 分为三种：<code>minor page fault</code>、<code>major page fault</code> 和 <code>invalid page fault</code></li></ol></li><li>在 <code>Threads</code> 里展示了每个线程的 <code>usage</code> 情况，当前只有 <code>singleThread</code> 处于 <code>R</code> 状态，并且当前线程产生了 3096 次 <code>page faults</code>，其他的线程包括主线程（<code>Sample</code> 日志里可见的）都是处于 <code>S</code>状态。<ol><li><code>R</code>：代表线程处于 <code>Running</code> 或者 <code>Runnable</code> 状态。<code>Running</code> 状态说明线程当前被某个 <code>Core</code> 执行，<code>Runnable</code> 状态说明线程当前正在处于等待队列中等待某个 <code>Core</code> 空闲下来去执行。</li><li><code>S</code>： <code>TASK_INTERRUPTIBLE（可中断）</code>  发生这种状态是线程主动让出了 <code>CPU</code>，如果线程调用了 <code>sleep</code> 或者其他情况导致了自愿式的上下文切换就会处于 <code>S</code> 状态。</li></ol></li></ol><p><code>Demo</code> 中执行 <code>Test</code> 抓取数据如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CPU usage from <span class="number">5137</span>ms to <span class="number">81</span><span class="function">ms <span class="title">ago</span> <span class="params">(<span class="number">2020</span><span class="number">-05</span><span class="number">-13</span> <span class="number">21</span>:<span class="number">57</span>:<span class="number">32.764</span> to <span class="number">2020</span><span class="number">-05</span><span class="number">-13</span> <span class="number">21</span>:<span class="number">57</span>:<span class="number">37.819</span>)</span>:</span></span><br><span class="line"><span class="function">16% 15921/com.sample.<span class="title">processtracker</span><span class="params">(R)</span>: 6.3% user + 9.6% kernel / faults: 3332 minor</span></span><br><span class="line"><span class="function">thread stats:</span></span><br><span class="line"><span class="function">15% 16145/<span class="title">SingleThread</span><span class="params">(S)</span>: 1.9% user + 13% kernel / faults: 3014 minor</span></span><br><span class="line"><span class="function">13% 17088/<span class="title">SingleThread</span><span class="params">(S)</span>: 1.3% user + 12% kernel / faults: 3016 minor</span></span><br><span class="line"><span class="function">1.3% 15921/.<span class="title">processtracker</span><span class="params">(R)</span>: 0.9% user + 0.3% kernel / faults: 40 minor</span></span><br><span class="line"><span class="function">0.5% 16002/<span class="title">RenderThread</span><span class="params">(S)</span>: 0.1% user + 0.3% kernel / faults: 37 minor</span></span><br><span class="line"><span class="function">0.1% 15942/Jit thread <span class="title">pool</span><span class="params">(S)</span>: 0.1% user + 0% kernel / faults: 222 minor</span></span><br><span class="line"><span class="function">0% 15949/<span class="title">HeapTaskDaemon</span><span class="params">(S)</span>: 0% user + 0% kernel</span></span><br><span class="line"><span class="function">...</span></span><br><span class="line"><span class="function">0% <span class="title">TOTAL</span><span class="params">()</span>: 0% user + 0% kernel</span></span><br><span class="line"><span class="function">Load: 0.0 / 0.0 / 0.0</span></span><br></pre></td></tr></table></figure><p>这里不太清楚为什么后面的数据都是 0 ，最后应该输出 <code>iowait</code> 才对。</p><p>极客时间原文例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CPU usage from <span class="number">5187</span>ms to <span class="number">121</span><span class="function">ms <span class="title">ago</span> <span class="params">(<span class="number">2018</span><span class="number">-12</span><span class="number">-28</span> <span class="number">08</span>:<span class="number">28</span>:<span class="number">27.186</span> to <span class="number">2018</span><span class="number">-12</span><span class="number">-28</span> <span class="number">08</span>:<span class="number">28</span>:<span class="number">32.252</span>)</span>:</span></span><br><span class="line"><span class="function">40% 24155/com.sample.<span class="title">processtracker</span><span class="params">(R)</span>: 14% user + 26% kernel / faults: 5286 minor</span></span><br><span class="line"><span class="function">thread stats:</span></span><br><span class="line"><span class="function">35% 24184/<span class="title">SingleThread</span><span class="params">(S)</span>: 11% user + 24% kernel / faults: 3055 minor</span></span><br><span class="line"><span class="function">2.1% 24174/<span class="title">RenderThread</span><span class="params">(S)</span>: 1.3% user + 0.7% kernel / faults: 384 minor</span></span><br><span class="line"><span class="function">1.5% 24155/.<span class="title">processtracker</span><span class="params">(R)</span>: 1.1% user + 0.3% kernel / faults: 95 minor</span></span><br><span class="line"><span class="function">0.1% 24166/<span class="title">HeapTaskDaemon</span><span class="params">(S)</span>: 0.1% user + 0% kernel / faults: 1070 minor</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">100% <span class="title">TOTAL</span><span class="params">()</span>: 3.8% user + 7.8% kernel + 11% iowait + 0.1% irq + 0% softirq + 76% idle</span></span><br><span class="line"><span class="function">Load: 6.31 / 6.52 / 6.66</span></span><br></pre></td></tr></table></figure><p>如果有大佬知道原因，还请告知。</p><p>如果产生大量的 <code>faults</code> 其实是不太正常的，或者 <code>iowait</code> 过高就需要关注是否有很密集的 <code>I/O</code> 操作。</p><p><a href="https://yq.aliyun.com/articles/55820" target="_blank" rel="noopener">《page fault 带来的性能问题》</a> </p><p><a href="http://oenhan.com/iowait-wa-vmstat" target="_blank" rel="noopener">《iowait 的形成原因和内核分析》</a></p><h2 id="5-2-PLTHook-监控-Thread-的创建"><a href="#5-2-PLTHook-监控-Thread-的创建" class="headerlink" title="5.2 PLTHook 监控 Thread 的创建"></a>5.2 PLTHook 监控 Thread 的创建</h2><p><a href="https://github.com/AndroidAdvanceWithGeektime/Chapter06-plus" target="_blank" rel="noopener">Chapter06-plus</a> 这个 <code>Demo</code> 与 <a href="https://www.jianshu.com/p/a26d11502ec8" target="_blank" rel="noopener">Android线程的创建过程</a>  结合，了解 <code>PLTHook</code> 的使用，以及 <code>Thread</code> 状态知识、如何创建的。</p><h2 id="5-3-Loop-监控卡顿"><a href="#5-3-Loop-监控卡顿" class="headerlink" title="5.3 Loop 监控卡顿"></a>5.3 Loop 监控卡顿</h2><p>在 <code>Android UI</code> 线程中有个 <code>Looper</code>，在其 <code>loop</code> 方法中会不断取出 <code>Message</code>，调用其绑定的 <code>Handler</code> 在 <code>UI</code> 线程进行执行。</p><p>部分代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Looper me = myLooper();</span><br><span class="line">    <span class="keyword">final</span> MessageQueue queue = me.mQueue;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Message msg = queue.next(); <span class="comment">// might block</span></span><br><span class="line">        <span class="comment">// This must be in a local variable, in case a UI event sets the logger</span></span><br><span class="line">        <span class="keyword">final</span> Printer logging = me.mLogging;</span><br><span class="line">        <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">            logging.println(<span class="string">"&gt;&gt;&gt;&gt;&gt; Dispatching to "</span> + msg.target + <span class="string">" "</span> +</span><br><span class="line">                            msg.callback + <span class="string">": "</span> + msg.what);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            msg.target.dispatchMessage(msg);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">            logging.println(<span class="string">"&lt;&lt;&lt;&lt;&lt; Finished to "</span> + msg.target + <span class="string">" "</span> + msg.callback);</span><br><span class="line">        &#125;</span><br><span class="line">        msg.recycleUnchecked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在执行此代码前后，如果设置了 <code>logging</code>，会分别打印出 <code>&gt;&gt;&gt;&gt;&gt; Dispatching to</code>和 <code>&lt;&lt;&lt;&lt;&lt; Finished to</code> 这样的<code>log</code> 。</p><p>我们可以通过计算两次 <code>log</code> 之间的时间差值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Looper.getMainLooper().setMessageLogging(<span class="keyword">new</span> Printer() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String START = <span class="string">"&gt;&gt;&gt;&gt;&gt; Dispatching"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String END = <span class="string">"&lt;&lt;&lt;&lt;&lt; Finished"</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(String x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x.startsWith(START)) &#123;</span><br><span class="line">            LogMonitor.getInstance().startMonitor();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x.startsWith(END)) &#123;</span><br><span class="line">            LogMonitor.getInstance().removeMonitor();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>假设我们的阈值是 <code>1000ms</code>，当我在匹配到 <code>&gt;&gt;&gt;&gt;&gt; Dispatching</code> 时，我会在 <code>1000ms</code> 毫秒后执行一个任务（打印出 <code>UI</code> 线程的堆栈信息，会在非 <code>UI</code> 线程中进行）；</p><p>正常情况下，肯定是低于 <code>1000ms</code> 执行完成的，所以当我匹配到 <code>&lt;&lt;&lt;&lt;&lt; Finished</code> ，会移除该任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogMonitor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LogMonitor sInstance = <span class="keyword">new</span> LogMonitor();</span><br><span class="line">    <span class="keyword">private</span> Handler mIoHandler;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> TIME_BLOCK = <span class="number">1000L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LogMonitor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HandlerThread mLogThread = <span class="keyword">new</span> HandlerThread(<span class="string">"log"</span>);</span><br><span class="line">        mLogThread.start();</span><br><span class="line">        mIoHandler = <span class="keyword">new</span> Handler(mLogThread.getLooper());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Runnable mLogRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            StackTraceElement[] stackTrace = Looper.getMainLooper().getThread().getStackTrace();</span><br><span class="line">            <span class="keyword">for</span> (StackTraceElement s : stackTrace) &#123;</span><br><span class="line">                sb.append(s.toString() + <span class="string">"\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Log.e(<span class="string">"TAG"</span>,sb.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LogMonitor <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMonitor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; handlerClass = Class.forName(<span class="string">"android.os.Handler"</span>);</span><br><span class="line">            java.lang.reflect.Method method = handlerClass.getMethod(<span class="string">"hasCallbacks"</span>, Runnable<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            Boolean ret = (Boolean) method.invoke(mIoHandler, mLogRunnable);</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startMonitor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        mIoHandler.postDelayed(mLogRunnable,TIME_BLOCK);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeMonitor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        mIoHandler.removeCallbacks(mLogRunnable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们利用了 <code>HandlerThread</code> 这个类，同样利用了 <code>Looper</code> 机制，只不过在非UI线程中，如果执行耗时达到我们设置的阈值，则会执行 <code>mLogRunnable</code> ，打印出 <code>UI</code> 线程当前的堆栈信息；如果你阈值时间之内完成，则会 <code>remove</code> 掉该 <code>runnable</code>。</p><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fmarkzhai%2FAndroidPerformanceMonitor" target="_blank" rel="noopener">BlockCanary 16 年原理分析</a>   </p><p>代码修改自于 <a href="https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&mid=2650822205&idx=1&sn=6b8e78bc1d71eb79a199667cf132acf7&chksm=80b782a3b7c00bb5c12437556fca68136c75409855e9252e395b545621319edf23959942b67c&scene=21#wechat_redirect" target="_blank" rel="noopener">Android UI性能优化 检测应用中的UI卡顿</a> 修改了 <code>hasCallbacks</code> 调用方式</p><p><strong>这个方法的缺点：</strong> 大量字符串拼接导致性能损耗严重，快速滑动时会降低帧数。</p><ul><li><strong>消息队列</strong></li></ul><p>可以通过一个监控线程，每隔 1 秒向主线程消息队列的头部插入一条空消息。假设 1 秒后这个消息并没有被主线程消费掉，说明阻塞消息运行的时间在 0～1 秒之间。换句话说，如果我们需要监控 3 秒卡顿，那在第 4 次轮询中头部消息依然没有被消费的话，就可以确定主线程出现了一次 3 秒以上的卡顿。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://static001.geekbang.org/resource/image/b0/56/b06d5aa439e8bb75885a338df9a25f56.png" alt="图片来源于 Android开发高手课"></p><p>这个方案也存在一定的误差，那就是发送空消息的间隔时间。但这个间隔时间也不能太小，因为监控线程和主线程处理空消息都会带来一些性能损耗，但基本影响不大。</p><p><strong>这个方法的缺点：</strong> 基于消息队列的卡顿监控并不准确，正在运行的函数有可能并不是真正耗时的函数。</p><ul><li><strong>插桩</strong></li></ul><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FTencent%2Fmatrix" target="_blank" rel="noopener">参考 微信 开源库 matrix</a></p><p><strong>避免方法数暴增。</strong>在函数的入口和出口应该插入相同的函数，在编译时提前给代码中每个方法分配一个独立的 <code>ID</code> 作为参数。</p><p><strong>过滤简单的函数。</strong>过滤一些类似直接 <code>return</code>、<code>i++</code> 这样的简单函数，并且支持黑名单配置。对一些调用非常频繁的函数，需要添加到黑名单中来降低整个方案对性能的损耗。</p><p>基于性能的考虑，线上只会监控主线程的耗时。最终安装包体积只增大 1～2%，平均帧率下降也在 2 帧以内。</p><p>插桩方案看起来美好，它也有自己的短板，那就是只能监控应用内自身的函数耗时，无法监控系统的函数调用，整个堆栈看起来好像 “缺失了” 一部分。</p><h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h1><blockquote><p><a href="https://time.geekbang.org/column/article/74044" target="_blank" rel="noopener">极客时间 Android开发高手课</a>  </p><p><a href="https://time.geekbang.org/column/article/71982" target="_blank" rel="noopener">《Linux环境下进程的CPU占用率》</a></p><p><a href="http://man7.org/linux/man-pages/man5/proc.5.html" target="_blank" rel="noopener">《Linux 文档》</a></p><p><a href="https://juejin.im/post/5b31b510e51d4558a426f7e9" target="_blank" rel="noopener">《Java线程Dump分析》</a></p><p><a href="https://cloud.tencent.com/developer/article/1064396" target="_blank" rel="noopener">《手Q Android线程死锁监控与自动化分析实践》</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&mid=2650822205&idx=1&sn=6b8e78bc1d71eb79a199667cf132acf7&chksm=80b782a3b7c00bb5c12437556fca68136c75409855e9252e395b545621319edf23959942b67c&scene=21#wechat_redirect" target="_blank" rel="noopener">Android UI性能优化 检测应用中的UI卡顿</a></p><p>以及上文中的链接</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>App UI优化💦</title>
      <link href="/2020/ui-optimization.html"/>
      <url>/2020/ui-optimization.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>每个做 UI 的 Android 开发，上辈子都是折翼的天使。</p></blockquote><h1 id="本文主要记载"><a href="#本文主要记载" class="headerlink" title="本文主要记载"></a>本文主要记载</h1><ul><li><strong>1 UI 优化究竟指的是什么呢？</strong></li><li><strong>2 屏幕适配？？？</strong></li><li><strong>3 如何测量、监控 UI 需要优化？</strong><ul><li>3.1 过度绘制</li><li>3.2 Profile GPU Rendering</li><li>3.3 测量 setContentView 具体耗时<ul><li>3.3.1 AOP</li><li>3.3.2 Factory2</li></ul></li><li>3.4 问题定位 systrace</li></ul></li><li><strong>4 UI 优化常用手段</strong><ul><li>4.1 尽量使用硬件加速</li><li>4.2 Create View 优化<ul><li>4.2.1 使用代码创建</li><li>4.2.2 异步创建</li></ul></li><li>4.3. measure/layout 优化</li><li>4.4 其他<ul><li>4.4.1 Litho：异步布局</li><li>4.4.2 Flutter：自己的布局 + 渲染引擎</li><li>4.4.3 RenderThread 与 RenderScript</li></ul></li></ul></li><li><strong>5 总结</strong></li></ul><hr><h1 id="1-UI-优化究竟指的是什么呢？"><a href="#1-UI-优化究竟指的是什么呢？" class="headerlink" title="1 UI 优化究竟指的是什么呢？"></a>1 UI 优化究竟指的是什么呢？</h1><p>我认为所谓的 <code>UI</code> 优化，应该包含两个方面</p><ol><li>一个是效率的提升，我们可以非常高效地把 <code>UI</code> 的设计图转化成应用界面，并且保证 <code>UI</code> 界面在不同尺寸和分辨率的手机上都是一致的</li><li>另一个是性能的提升，在正确实现复杂、炫酷的 <code>UI</code> 设计的同时，需要保证用户有流畅的体验。</li></ol><hr><h1 id="2-屏幕适配？？？"><a href="#2-屏幕适配？？？" class="headerlink" title="2 屏幕适配？？？"></a>2 屏幕适配？？？</h1><p><code>Android</code> 的碎片化问题令人痛心疾首，屏幕的差异正是碎片化问题的 “中心” ，多年来，有那么一群苦逼的 <code>Android</code> 开发，他们饱受碎片化之苦，面对着各式各样的手机屏幕尺寸和分辨率，还要与“凶残”的产品和 <code>UI</code> 设计师过招，日复一日、年复一年的做着 <code>UI</code> 适配和优化工作，蹉跎着青春的岁月。更加不幸的是，最近两年这个趋势似乎还愈演愈烈：刘海屏、全面屏，还有即将推出的柔性折叠屏，<code>UI</code> 适配将变得越来越复杂。</p><p>对于屏幕碎片化的问题，<code>Android</code> 推荐使用 <code>dp</code> 作为尺寸单位来适配 <code>UI</code>，因此每个 <code>Android</code> 开发都应该很清楚 <code>px</code>、<code>dp</code>、<code>dpi</code>、<code>ppi</code>、<code>density</code> 这些概念。<br><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/20200416135354.png" alt=""></p><p>通过 <code>dp</code> 加上自适应布局可以基本解决屏幕碎片化的问题。</p><ul><li>不一致性。因为 dpi 与实际 ppi 的差异性，导致在相同分辨率的手机上，控件的实际大小会有所不同。</li><li>效率。设计师的设计稿都是以 px 为单位的，开发人员为了 UI 适配，需要手动通过百分比估算出 dp 值。</li></ul><p>除了直接 dp 适配之外，目前业界比较常用的 UI 适配方法主要有下面几种：</p><p>限制符适配方案。主要有宽高限定符与 smallestWidth 限定符适配方案，具体可以参考<a href="https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&mid=2650826034&idx=1&sn=5e86768d7abc1850b057941cdd003927&chksm=80b7b1acb7c038ba8912b9a09f7e0d41eef13ec0cea19462e47c4e4fe6a08ab760fec864c777&scene=21#wechat_redirect" target="_blank" rel="noopener">《Android 目前稳定高效的 UI 适配方案》</a><a href="https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&mid=2650826381&idx=1&sn=5b71b7f1654b04a55fca25b0e90a4433&chksm=80b7b213b7c03b0598f6014bfa2f7de12e1f32ca9f7b7fc49a2cf0f96440e4a7897d45c788fb&scene=21#wechat_redirect" target="_blank" rel="noopener">《smallestWidth 限定符适配方案》</a>。今日头条适配方案。通过反射修正系统的 density 值，具体可以参考<a href="https://mp.weixin.qq.com/s?__biz=MzI1MzYzMjE0MQ==&mid=2247484502&idx=2&sn=a60ea223de4171dd2022bc2c71e09351&scene=21#wechat_redirect" target="_blank" rel="noopener">《一种极低成本的 Android 屏幕适配方式》</a><a href="https://mp.weixin.qq.com/s/oSBUA7QKMWZURm1AHMyubA" target="_blank" rel="noopener">《今日头条适配方案》</a>。</p><hr><h1 id="3-如何测量、监控-UI-需要优化？"><a href="#3-如何测量、监控-UI-需要优化？" class="headerlink" title="3 如何测量、监控 UI 需要优化？"></a>3 如何测量、监控 UI 需要优化？</h1><h2 id="3-1-过度绘制"><a href="#3-1-过度绘制" class="headerlink" title="3.1 过度绘制"></a>3.1 过度绘制</h2><blockquote><p><strong>理论上一个像素每次只绘制一次是最优的，但是由于重叠的布局导致一些像素会被多次绘制，Overdraw由此产生。</strong></p></blockquote><p>我们可以通过调试工具来检测 <code>Overdraw</code> ：<code>设置——&gt;开发者选项——&gt;调试 GPU 过度绘制——&gt;显示过度绘制区域</code>。<br><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/20200416164642.png" alt=""></p><blockquote><p>原色 – 没有过度绘制 – 这部分的像素点只在屏幕上绘制了一次。<br>蓝色 – 1次过度绘制   – 这部分的像素点只在屏幕上绘制了两次。<br>绿色 – 2次过度绘制   – 这部分的像素点只在屏幕上绘制了三次。<br>粉色 – 3次过度绘制   – 这部分的像素点只在屏幕上绘制了四次。<br>红色 – 4次过度绘制   – 这部分的像素点只在屏幕上绘制了五次。</p></blockquote><p><strong>在实际项目中，一般认为蓝色即是可以接受的颜色。</strong></p><p><strong>具体优化点：</strong></p><ol><li>各种控件背景颜色</li><li><code>Activity</code> 的 <code>Theme</code> 中的背景颜色</li></ol><p><strong>备注：有些过度绘制都是不可避免的，需要结合具体的布局场景具体分析。</strong></p><h2 id="3-2-Profile-GPU-Rendering"><a href="#3-2-Profile-GPU-Rendering" class="headerlink" title="3.2 Profile GPU Rendering"></a>3.2 Profile GPU Rendering</h2><p><code>设置——&gt;开发者选项——&gt;GPU 呈现模式分析——&gt;条形图</code><br><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/20200416171116.png" alt=""></p><p>如果我们把上面的步骤转化线程模型，可以得到下面的流水线模型。<code>CPU</code> 将数据同步（<code>sync</code>）给 <code>GPU</code> 之后，一般不会阻塞等待<code>GPU</code> 渲染完毕，而是通知结束后就返回。而 <code>RenderThread</code> 承担了比较多的绘制工作，分担了主线程很多压力，提高了 <code>UI</code> 线程的响应速度。<br><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/20200416173431.png" alt=""></p><h2 id="3-3-测量-setContentView-具体耗时"><a href="#3-3-测量-setContentView-具体耗时" class="headerlink" title="3.3 测量 setContentView 具体耗时"></a>3.3 测量 <code>setContentView</code> 具体耗时</h2><h3 id="3-3-1-AOP"><a href="#3-3-1-AOP" class="headerlink" title="3.3.1 AOP"></a>3.3.1 AOP</h3><p>我们可以通过 <code>AOP</code> 将代码切入到 <code>android.app.Activity.setContentView(..)</code> 中。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around</span>(<span class="string">"execution(* android.app.Activity.setContentView(..))"</span>) <span class="comment">//方法切入点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodAnnotated</span><span class="params">(ProceedingJoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">Signature signature = joinPoint.getSignature();</span><br><span class="line">String name = signature.toShortString();</span><br><span class="line"><span class="keyword">long</span> time = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">joinPoint.proceed();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">throwable.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">LogUtils.i(name + <span class="string">" cost "</span> + (System.currentTimeMillis() - time));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-2-Factory2"><a href="#3-3-2-Factory2" class="headerlink" title="3.3.2 Factory2"></a>3.3.2 Factory2</h3><p><code>View</code> 的绘制源码中，在生成我们 <code>xml</code> 所对应的 <code>View</code> 的时候有一个 <code>mFactory2</code> 的判断，我们可以在创建的时候做一些事情。<br><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/20200416180108.png" alt=""></p><p>作用：</p><ol><li>定制生成控件的过程，全局替换，比如将 <code>TextView</code> 替换为 <code>CustomTextView</code>。</li><li>监控控件的生成时间，自己调用系统创建方法并且在方法前后记录时间。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">LayoutInflaterCompat.setFactory2(getLayoutInflater(), <span class="keyword">new</span> LayoutInflater.Factory2() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(View parent, String name, Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (name.equals(<span class="string">"TextView"</span>)) &#123;</span><br><span class="line">            <span class="comment">//创建 CustomTextView</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        View view = getDelegate().createView(parent,name,context,attrs);</span><br><span class="line">        LogUtils.i(name + <span class="string">" cost "</span> + (System.currentTimeMillis() - startTime));</span><br><span class="line">        <span class="keyword">return</span> view;<span class="comment">//返回生成后的 View</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(String name, Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="3-4-问题定位-systrace"><a href="#3-4-问题定位-systrace" class="headerlink" title="3.4 问题定位 systrace"></a>3.4 问题定位 systrace</h2><p>在 <code>Android 4.1</code>，新增了 <code>Systrace</code> 性能数据采样和分析工具。在启动优化中，已经用过 Systrace 了，这里也可以用它来检测每一帧的渲染情况。</p><p>结合 Android 内核的数据，生成 HTML 报告，<code>API 18</code> 以上，推荐 <code>TraceCompat</code></p><ul><li><strong>首先清空后台💦</strong></li></ul><p>杀掉所有应用，防止出现莫名莫名方法。</p><ul><li><strong>在需要检测的地方写入代码(可以不写，但是会少一些 tag 提示)💦</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TraceCompat.beginSection(<span class="string">"AppOnCreate"</span>);</span><br><span class="line">...</span><br><span class="line">TraceCompat.endSection();</span><br></pre></td></tr></table></figure><ul><li><strong>执行检测💦</strong></li></ul><p>首先进入 <code>SDK</code> 目录，<code>Sdk\platform-tools\systrace\</code> 目录下有一个 <code>systrace.py</code> 文件，打开 <code>cmd</code> 输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python systrace.py -b 32768 -t 5 -a &lt;packagename&gt; -o test.log.html sched gfx view wm am</span><br></pre></td></tr></table></figure><p>这种方式是 <code>5</code> 秒后自动输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python systrace.py gfx view wm am pm ss dalvik sched -b 32768 -a &lt;packagename&gt; -o test.log.html</span><br></pre></td></tr></table></figure><p>这种方式可以在自己收集完后，点击 <code>Enter</code> 键停止收集</p><p>两种内容是不太一样的， <code>-t</code> 表示时间，<code>-a</code> 表示包名，<code>-o</code> 输出文件名，最终在当前目录打开文件即可看到，文件只能使用 <code>Chrome</code> 来打开，如果打开 <code>HTML</code> 出现 </p><p><code>Unable to select a master clock domain because no path can be found from &quot;SYSTRACE&quot; to &quot;LINUX_FTRACE_GLOBAL&quot;.</code></p><p>那就是命令出错了，命令我也是收集了好久，最终找到可用的，想了解更多的请查看 <a href="http://gityuan.com/2016/01/17/systrace/" target="_blank" rel="noopener">Gityuan</a> 或 <a href="https://source.android.com/devices/tech/debug/systrace" target="_blank" rel="noopener">官方文档</a> </p><ul><li><p><strong>分析文件</strong></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/20200416163431.png" alt=""></p></li></ul><p>在每个 <code>app</code> 进程，都有一个 <code>Frames</code> 行，正常情况以绿色的圆点表示。当圆点颜色为黄色或者红色时，意味着这一帧超过 <code>16.6ms</code> （即发现丢帧），这时需要通过放大那一帧进一步分析问题。对于 <code>Android 5.0(API level 21)</code> 或者更高的设备，该问题主要聚焦在 <code>UI Thread</code> 和 <code>Render Thread</code> 这两个线程当中。对于更早的版本，则所有工作在 <code>UI Thread</code> 。</p><p>想要了解更多，全力推荐 <a href="https://www.androidperformance.com/2019/05/28/Android-Systrace-About/" target="_blank" rel="noopener">Android Systrace</a> </p><ul><li><strong>Alerts</strong></li></ul><p><code>Systrace</code> 能自动分析 <code>trace</code> 中的事件，并能自动高亮性能问题作为一个 <code>Alerts</code> ，建议调试人员下一步该怎么做。</p><p>比如对于丢帧是，点击黄色或红色的 <code>Frames</code> 圆点便会在下方有相关的提示信息；另外，在 <code>systrace</code> 的最右上方，有一个 <code>Alerts tab</code> 可以展开，这里记录着所有的的警告提示信息。</p><p>总的来说，UI 渲染的优化必然会朝着两个方向。一个是进一步压榨硬件的性能，让 UI 可以更加流畅。一个是改进或者增加更多的分析工具，帮助我们更容易地发现以及定位问题。</p><hr><h1 id="4-UI-优化常用手段"><a href="#4-UI-优化常用手段" class="headerlink" title="4 UI 优化常用手段"></a>4 UI 优化常用手段</h1><h2 id="4-1-尽量使用硬件加速"><a href="#4-1-尽量使用硬件加速" class="headerlink" title="4.1 尽量使用硬件加速"></a>4.1 尽量使用硬件加速</h2><p>硬件加速绘制的性能是远远高于软件绘制的。所以说 <code>UI</code> 优化的第一个手段就是保证渲染尽量使用硬件加速。</p><p>有哪些情况我们不能使用硬件加速呢？之所以不能使用硬件加速，是因为硬件加速不能支持所有的 <code>Canvas API</code>。如果使用了不支持的 <code>API</code>，系统就需要通过 <code>CPU</code> 软件模拟绘制，这也是渐变、磨砂、圆角等效果渲染性能比较低的原因。</p><p><code>SVG</code> 也是一个非常典型的例子，<code>SVG</code> 有很多指令硬件加速都不支持。但我们可以用一个取巧的方法，提前将这些 <code>SVG</code> 转换成 <code>Bitmap</code> 缓存起来，这样系统就可以更好地使用硬件加速绘制。</p><h2 id="4-2-Create-View-优化"><a href="#4-2-Create-View-优化" class="headerlink" title="4.2 Create View 优化"></a>4.2 Create View 优化</h2><p><code>View</code> 的创建是在 <code>UI</code> 线程里，对于一些非常复杂的界面，这部分的耗时不容忽视。</p><h3 id="4-2-1-使用代码创建"><a href="#4-2-1-使用代码创建" class="headerlink" title="4.2.1 使用代码创建"></a>4.2.1 使用代码创建</h3><p>使用 <code>XML</code> 进行 <code>UI</code> 编写可以说是十分方便，可以在 <code>Android Studio</code> 中实时预览到界面。如果我们要对一个界面进行极致优化，就可以使用代码进行编写界面。</p><p>但是这种方式对开发效率来说简直是灾难，因此我们可以使用一些开源的 <code>XML</code> 转换为 <code>Java</code> 代码的工具，例如 <a href="https://github.com/iReaderAndroid/X2C" target="_blank" rel="noopener">X2C</a> 。但坦白说，还是有不少情况是不支持直接转换的，有时候需要修改源码。</p><p>所以我们需要兼容性能与开发效率，我建议只在对性能要求非常高，但修改又不非常频繁的场景才使用这个方式。</p><h3 id="4-2-2-异步创建"><a href="#4-2-2-异步创建" class="headerlink" title="4.2.2 异步创建"></a>4.2.2 异步创建</h3><p>之前在 <a href="http://localhost:4000/2019/start-optimization.html" target="_blank" rel="noopener">启动优化</a> 中提到的参考文章 <a href="https://juejin.im/post/5d63cdf7f265da03ed195f68?utm_source=gold_browser_extension#comment" target="_blank" rel="noopener">Android - 一种新奇的冷启动速度优化思路(Fragment极度懒加载 + Layout子线程预加载)</a> </p><p>遇到个点，如果 <code>xml</code> 中是 <code>com.google.android.material.appbar.AppBarLayout</code> 等 <code>google</code> 包里的，需要加上一条属性</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:theme="@style/Theme.AppCompat.Light.DarkActionBar"</span><br></pre></td></tr></table></figure><p>这个属性与自己 <code>Activity</code> 的 <code>theme</code> 相对应。</p><p>即刻时间中还提到一个错误 ：<code>java.lang.RuntimeException: Can&#39;t create handler inside thread that has not called Looper.prepare() at android.os.Handler.(Handler.java:121)</code> </p><p>这个问题在异步初始化 <code>WebView</code> 是有出现过。</p><p>解决办法：通过又一个非常取巧的方式来实现。在使用线程创建 UI 的时候，先把线程的 Looper 的 MessageQueue 替换成 UI 线程 Looper 的 Queue。<br><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/20200417114544.png" alt=""></p><p>不过需要注意的是，在创建完 View 后我们需要把线程的 Looper 恢复成原来的。</p><blockquote><p>x5WebView 中异步调用会报错，还在研究中。。。</p></blockquote><h2 id="4-3-measure-layout-优化"><a href="#4-3-measure-layout-优化" class="headerlink" title="4.3. measure/layout 优化"></a>4.3. measure/layout 优化</h2><p>渲染流程中 <code>measure</code> 和 <code>layout</code> 也是需要 <code>CPU</code> 在主线程执行的，对于这块内容网上有很多优化的文章，一般的常规方法有：</p><ul><li><strong>减少 UI 布局层次</strong>。例如尽量扁平化，使用 等优化。</li><li><strong>优化 layout 的开销</strong>。尽量不使用 <code>RelativeLayout</code> 或者基于 <code>weighted LinearLayout</code>，它们 layout 的开销非常巨大。这里我推荐使用 <code>ConstraintLayout</code> 替代 <code>RelativeLayout</code> 或者 <code>weighted LinearLayout</code>。</li><li><strong>背景优化</strong>。尽量不要重复去设置背景，这里需要注意的是主题背景（<code>theme</code>)， <code>theme</code> 默认会是一个纯色背景，如果我们自定义了界面的背景，那么主题的背景我们来说是无用的。但是由于主题背景是设置在 <code>DecorView</code> 中，所以这里会带来重复绘制，也会带来绘制性能损耗。</li></ul><p>对于 <code>measure</code> 和 <code>layout</code>，我们可以像 <code>Create View</code> 一样实现异步创建，这样可以大大地提升首次显示的性能。</p><p><code>Textview</code> 是系统控件中非常强大也非常重要的一个控件，强大的背后就代表着需要做很多计算。在 <code>2018</code> 年的 <code>Google I/O</code> 大会，发布了 <code>PrecomputedText</code> 并已经集成在 <code>Jetpack</code> 中，它给我们提供了接口，可以异步进行 <code>measure</code> 和 <code>layout</code>，不必在主线程中执行。</p><p><strong>PrecomputedText</strong></p><p>在 <code>xml</code> 布局中使用 <code>AppCompatTextView</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">androidx.appcompat.widget.AppCompatTextView</span></span></span><br></pre></td></tr></table></figure><p>赋值的时候</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;PrecomputedTextCompat&gt; future = PrecomputedTextCompat.getTextFuture(</span><br><span class="line">                <span class="string">"content xxx"</span>, mTextView.getTextMetricsParamsCompat(), <span class="keyword">null</span>);</span><br><span class="line"> </span><br><span class="line">mTextView.setTextFuture(future);</span><br></pre></td></tr></table></figure><p>如果使用 <code>kotlin</code> ，那么利用拓展方法会更加酸爽。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> AppCompatTextView.<span class="title">setTextFuture</span><span class="params">(charSequence: <span class="type">CharSequence</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.setTextFuture(PrecomputedTextCompat.getTextFuture(</span><br><span class="line">            charSequence,</span><br><span class="line">            TextViewCompat.getTextMetricsParams(<span class="keyword">this</span>),</span><br><span class="line">            <span class="literal">null</span></span><br><span class="line">    ))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">textView.setTextFuture(“text”)</span><br></pre></td></tr></table></figure><h2 id="4-4-其他"><a href="#4-4-其他" class="headerlink" title="4.4 其他"></a>4.4 其他</h2><h3 id="4-4-1-Litho：异步布局"><a href="#4-4-1-Litho：异步布局" class="headerlink" title="4.4.1 Litho：异步布局"></a>4.4.1 Litho：异步布局</h3><p><a href="https://github.com/facebook/litho" target="_blank" rel="noopener">Litho</a> 是 <code>Facebook</code> 开源的声明式 <code>Android UI</code> 渲染框架，它是基于另外一个 <code>Facebook</code> 开源的布局引擎 <a href="https://github.com/facebook/yoga" target="_blank" rel="noopener">Yoga</a> 开发的。</p><p><code>Litho 如何优化的</code></p><ol><li><p><strong>异步布局</strong></p><p>一般来说的 Android 所有的控件绘制都要遵守 measure -&gt; layout -&gt; draw 的流水线，并且这些都发生在主线程中。<br><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/20200417165148.png" alt=""></p></li></ol><p>   <code>Litho</code> 如我前面提到的 <code>PrecomputedText</code> 一样，把 <code>measure</code> 和 <code>layout</code> 都放到了后台线程，只留下了必须要在主线程完成的 <code>draw</code>，这大大降低了 <code>UI</code> 线程的负载。它的渲染流水线如下：<br>   <img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/20200417165357.png" alt=""></p><ol start="2"><li><p><strong>界面扁平化</strong></p><p>前面也提到过，降低 <code>UI</code> 的层级是一个非常通用的优化方法。<code>Litho</code> 就给了我们一种方案，由于 <code>Litho</code> 使用了自有的布局引擎（<code>Yoga</code>)，在布局阶段就可以检测不必要的层级、减少 <code>ViewGroups</code>，来实现 <code>UI</code> 扁平化。</p></li><li><p><strong>优化 RecyclerView</strong></p><p><code>Litho</code> 还优化了 <code>RecyclerView</code> 中 <code>UI</code>组件的缓存和回收方法。原生的 <code>RecyclerView</code> 或者 <code>ListView</code> 是按照 <code>viewType</code> 来进行缓存和回收，但如果一个<code>RecyclerView/ListView</code> 中出现 <code>viewType</code> 过多，会使缓存形同虚设。但 <code>Litho</code> 是按照 <code>text</code>、<code>image</code> 和 <code>video</code> 独立回收的，这可以提高缓存命中率、降低内存使用率、提高滚动帧率。</p><p><code>Litho</code> 虽然强大，但也有自己的缺点。它为了实现 <code>measure/layout</code> 异步化，使用了类似 <code>react</code> 单向数据流设计，这一定程度上加大了 <code>UI</code> 开发的复杂性。并且 <code>Litho</code> 的 <code>UI</code>代码是使用 <code>Java/Kotlin</code> 来进行编写，无法做到在 <code>AS</code> 中预览。如果你没有计划完全迁移到 <code>Litho</code>，我建议可以优先使用 <code>Litho</code> 中的 <code>RecyclerCollectionComponent</code> 和 <code>Sections</code> 来优化自己的 <code>RecyelerView</code> 的性能。</p></li></ol><h3 id="4-4-2-Flutter：自己的布局-渲染引擎"><a href="#4-4-2-Flutter：自己的布局-渲染引擎" class="headerlink" title="4.4.2 Flutter：自己的布局 + 渲染引擎"></a>4.4.2 <strong>Flutter：自己的布局 + 渲染引擎</strong></h3><p>如下图所示，<code>Litho</code> 虽然通过使用自己的布局引擎 <code>Yoga</code>，一定程度上突破了系统的一些限制，但是在 <code>draw</code> 之后依然走的系统的渲染机制。</p><p><a href="https://github.com/flutter/flutter" target="_blank" rel="noopener">Flutter</a> 把 <code>Skia</code> 引擎直接集成进了 <code>App</code> 中，这使得 <code>Flutter App</code> 就像一个游戏 <code>App</code>。并且直接使用了 <code>Dart</code> 虚拟机，可以说是一套跳脱出 <code>Android</code> 的方案，所以 <code>Flutter</code> 也可以很容易实现跨平台。</p><p><a href="https://tech.meituan.com/2018/08/09/waimai-flutter-practice.html" target="_blank" rel="noopener">《Flutter 原理与实践》</a></p><h3 id="4-4-3-RenderThread-与-RenderScript"><a href="#4-4-3-RenderThread-与-RenderScript" class="headerlink" title="4.4.3 RenderThread 与 RenderScript"></a>4.4.3 RenderThread 与 RenderScript</h3><p>在 <code>Android 5.0</code>，系统增加了 <code>RenderThread</code>，对于 <code>ViewPropertyAnimator</code> 和 <code>CircularReveal</code> 动画，我们可以使用 <a href="https://mp.weixin.qq.com/s?__biz=MzUyMDAxMjQ3Ng==&mid=2247489230&idx=1&sn=adc193e35903ab90a4c966059933a35a&source=41#wechat_redirect" target="_blank" rel="noopener">RenderThead 实现动画的异步渲染</a>。当主线程阻塞的时候，普通动画会出现明显的丢帧卡顿，而使用 <code>RenderThread</code> 渲染的动画即使阻塞了主线程仍不受影响。</p><p>我们可以通过 <code>RenderScript</code>，它是 <code>Android</code> 操作系统上的一套 <code>API</code>。它基于异构计算思想，专门用于密集型计算。<code>RenderScript</code> 提供了三个基本工具：一个硬件无关的通用计算 <code>API</code>；一个类似于 <code>CUDA</code>、<code>OpenCL</code> 和 <code>GLSL</code> 的计算 <code>API</code>；一个类 <code>C99</code> 的脚本语言。允许开发者以较少的代码实现功能复杂且性能优越的应用程序。</p><ul><li><a href="https://www.jianshu.com/p/b72da42e1463" target="_blank" rel="noopener">RenderScript 渲染利器</a></li><li><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2016/0504/4205.html?utm_source=itdadao&utm_medium=referral" target="_blank" rel="noopener">RenderScript : 简单而快速的图像处理</a></li><li>…</li></ul><hr><h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h1><ol><li><strong>在系统的框架下优化。</strong>布局优化、使用代码创建、<code>View</code> 缓存等都是这个思路，我们希望减少甚至省下渲染流水线里某个阶段的耗时。</li><li><strong>利用系统新的特性。</strong>使用硬件加速、<code>RenderThread</code>、<code>RenderScript</code> 都是这个思路，通过系统一些新的特性，最大限度压榨出性能。</li><li><strong>突破系统的限制。</strong>由于 <code>Android</code> 系统碎片化非常严重，很多好的特性可能低版本系统并不支持。而且系统需要支持所有的场景，在一些特定场景下它无法实现最优解。这个时候，我们希望可以突破系统的条条框框，例如 <code>Litho</code> 突破了布局，<code>Flutter</code> 则更进一步，把渲染也接管过来了。</li></ol><p>对于 <code>UI</code> 优化的另一个思考是效率，目前 <code>Android Studio</code> 对设计并不友好，例如不支持 <code>Sketch</code> 插件和 <code>AE</code> 插件。<a href="https://github.com/airbnb/lottie-android" target="_blank" rel="noopener">Lottie</a> 是一个非常好的案例，它很大提升了开发人员写动画的效率。</p><blockquote><p>“设计师和产品，你们长大了，要学会自己写 UI 了”。在未来，我们希望 UI 界面与适配可以实现自动化，或者干脆把它交还给设计师和产品。</p></blockquote><h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a><strong>感谢</strong></h1><blockquote><p><a href="https://time.geekbang.org/column/article/74044" target="_blank" rel="noopener">极客时间 Android开发高手课</a>  </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>App 内存检测优化💦</title>
      <link href="/2020/memory-optimization2.html"/>
      <url>/2020/memory-optimization2.html</url>
      
        <content type="html"><![CDATA[<p>🌞一个好的架构可以减少甚至避免我们犯错，而一个好的监控可以帮助我们及时发现问题🌞内存优化的重点在于监控，和平时代码规范。这篇文章带你了解监控工具 Memory Profiler、MAT、LeakCanary 的使用以及分析。</p><h1 id="本文主要记载"><a href="#本文主要记载" class="headerlink" title="本文主要记载"></a>本文主要记载</h1><ul><li><strong>1 什么是 Memory Profiler？</strong><ul><li>1.1 使用介绍<ul><li>1.1.1 启用高级分析</li><li>1.1.2 计算内存(每个内存类别当前使用多少内存)</li><li>1.1.3 查看内存分配(分配的对象数)</li><li>1.1.4 在分析时提高应用性能</li><li>1.1.5 捕获堆转储</li><li>1.1.6 将堆转储另存为 HPROF 文件</li></ul></li></ul></li><li><strong>2 什么是 MAT？</strong><ul><li>2.1 使用前提</li><li>2.2 使用介绍</li></ul></li><li><strong>3 什么是 LeakCanary？</strong><ul><li>3.1 LeakCanary 原理</li><li>3.2 LeakCanary 使用</li></ul></li><li><strong>4 自定义实现 Demo</strong><ul><li>4.1 自动化监测 Demo</li><li>4.2 重复图片监测 Demo</li></ul></li><li><strong>5 优化思路</strong><ul><li>5.1 设备分级</li><li>5.2 Bitmap 优化</li></ul></li><li><strong>6 更多</strong></li></ul><hr><blockquote><p>一个好的架构可以减少甚至避免我们犯错，而一个好的监控可以帮助我们及时发现问题。</p></blockquote><p>检测工具常见的有 <code>Memory Profiler</code> <code>MAT</code> <code>LeakCanary</code></p><h1 id="1-什么是-Memory-Profiler"><a href="#1-什么是-Memory-Profiler" class="headerlink" title="1  什么是 Memory Profiler?"></a>1  什么是 Memory Profiler?</h1><p><code>Profiler</code> 是 <code>Android Studio</code> 为我们提供的性能分析工具，它包含了 <code>CPU</code>、<code>内存</code>、<code>网络</code>以及 <code>电量</code> 的分析信息，而 <code>Memory Profiler</code> 则是 <code>Profiler</code> 中的其中一个版块。</p><p>打开 <code>Profiler</code>  方式</p><ol><li>View &gt; Tool Windows &gt; Android Profiler</li><li>下方的 Profiler 标签</li><li>双击 shift 搜索 profiler</li></ol><h2 id="1-1-使用介绍"><a href="#1-1-使用介绍" class="headerlink" title="1.1 使用介绍"></a>1.1 使用介绍</h2><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/20200413144637.png" alt=""></p><ol><li><p>用于强制执行垃圾回收事件的按钮（强制 <code>GC</code> ）。</p></li><li><p>用于 <code>1.1.5 捕获堆转储</code> 的按钮。</p><p><strong>注意</strong>：只有在连接到搭载 <code>Android 7.1</code>（<code>API</code> 级别 25）或更低版本的设备时，才会在堆转储按钮右侧显示用于 <code>记录内存分配</code> 的按钮。</p></li><li><p>用于指定分析器多久捕获一次内存分配的下拉菜单。选择适当的选项可 <code>1.1.4 在分析时提高应用性能</code>。</p></li><li><p>用于缩放时间轴的按钮。</p></li><li><p>用于跳转到实时内存数据的按钮。</p></li><li><p>事件时间轴，显示活动状态、用户输入事件和屏幕旋转事件。</p></li><li><p>内存使用量时间轴，它会显示以下内容：</p><ul><li>一个堆叠图表，显示 <code>1.1.2 每个内存类别当前使用多少内存</code> ，如左侧的 y 轴以及顶部的彩色键所示。</li><li>一条虚线，表示 <code>1.1.3 分配的对象数</code>，如右侧的 y 轴所示。</li><li>每个垃圾回收事件的图标。</li></ul></li></ol><p>如果使用的是搭载 Android 7.1 或更低版本的设备，则并非所有分析数据在默认情况下都可见。如果看到一条消息，显示“Advanced profiling is unavailable for the selected process”，需要 <code>1.1.1 启用高级分析</code> 才能看到以下内容：</p><ul><li>事件时间轴</li><li>分配的对象数</li><li>垃圾回收事件</li></ul><p>在 Android 8.0 及更高版本上，始终为可调试应用启用高级分析。</p><h3 id="1-1-1-启用高级分析"><a href="#1-1-1-启用高级分析" class="headerlink" title="1.1.1  启用高级分析"></a>1.1.1  启用高级分析</h3><ol><li>依次选择 <strong>Run &gt; Edit Configurations</strong>。</li><li>在左侧窗格中选择本应用模块。</li><li>点击 <strong>Profiling</strong> 标签，然后勾选 <strong>Enable advanced profiling</strong>。</li><li>重新编译并运行应用。</li></ol><h3 id="1-1-2-计算内存-每个内存类别当前使用多少内存"><a href="#1-1-2-计算内存-每个内存类别当前使用多少内存" class="headerlink" title="1.1.2 计算内存(每个内存类别当前使用多少内存)"></a>1.1.2 计算内存(每个内存类别当前使用多少内存)</h3><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/20200414112438.png" alt=""></p><p>内存计数中的类别如下：</p><ul><li><p><strong>Java</strong>：从 <code>Java</code> 或 <code>Kotlin</code> 代码分配的对象的内存。</p></li><li><p><strong>Native</strong>：从 <code>C</code> 或 <code>C++</code> 代码分配的对象的内存。</p><p>即使应用中不使用 <code>C++</code>，也可能会看到此处使用的一些原生内存，因为 <code>Android</code> 框架使用原生内存处理各种任务，如处理图像资源和其他图形时。</p></li><li><p><strong>Graphics</strong>：图形缓冲区队列向屏幕显示像素（包括 <code>GL</code> 表面、<code>GL</code> 纹理等等）所使用的内存。（请注意，这是与 <code>CPU</code> 共享的内存，不是 <code>GPU</code> 专用内存。）</p></li><li><p><strong>Stack</strong>：应用中的原生堆栈和 <code>Java</code> 堆栈使用的内存。这通常与应用运行多少线程有关。</p></li><li><p><strong>Code</strong>：应用用于处理代码和资源（如 <code>dex</code> 字节码、经过优化或编译的 <code>dex</code> 代码、<code>.so</code> 库和字体）的内存。</p></li><li><p><strong>Others</strong>：应用使用的系统不确定如何分类的内存。</p></li><li><p><strong>Allocated</strong>：应用分配的 <code>Java/Kotlin</code> 对象数。此数字没有计入 C 或 C++ 中分配的对象。</p><p>如果连接到搭载 <code>Android 7.1</code> 及更低版本的设备，只有在 <code>Memory Profiler</code> 连接到运行的应用时，才开始此分配计数。因此，开始分析之前分配的任何对象都不会被计入。不过，<code>Android 8.0</code> 及更高版本附带一个设备内置分析工具，该工具可跟踪所有分配，因此，在 <code>Android 8.0</code> 及更高版本上，此数字始终表示应用中待处理的 Java 对象总数。</p></li></ul><p><strong>注意：</strong>高级分析配置会使编译过程变慢，所以仅在想要开始分析应用时，才应启用该配置。</p><h3 id="1-1-3-查看内存分配-分配的对象数"><a href="#1-1-3-查看内存分配-分配的对象数" class="headerlink" title="1.1.3 查看内存分配(分配的对象数)"></a>1.1.3 查看内存分配(分配的对象数)</h3><p>对于 <code>Android 8.0</code> 及更高版本，选择一个现有时间轴区域以查看对象分配</p><p>对于 <code>Android 7.1</code> 及更低版本，必须明确记录内存分配，点击 <code>Memory Profiler</code> 工具栏中的 <code>Record memory allocations</code> 图标或者 一个 <code>Record</code> 的按钮。记录时，<code>Memory Profiler</code> 会跟踪应用中发生的所有分配。完成后，请点击 <code>Stop recording</code> 图标或者一个 <code>Stop</code> 的按钮，查看分配。</p><p><strong>注意</strong>：在 <code>Android 7.1</code> 及更低版本上，最多可以记录 <code>65535</code> 个分配。 如果记录会话超出此限制，则记录中仅保存最新的 <code>65535</code> 个分配。（在 <code>Android 8.0</code> 及更高版本上，则没有实际的限制。）<br><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/20200414135710.png" alt=""></p><ol><li>浏览列表以查找堆计数异常大且可能存在泄露的对象。为帮助查找已知类，点击 <code>Class Name</code> 列标题以按字母顺序排序。然后，点击一个类名称。此时右侧将出现 <code>Instance View</code> 窗格，显示该类的每个实例。</li><li>在 <code>Instance View</code> 窗格中，点击一个实例。此时下方将出现 <code>Call Stack</code> 标签页，显示该实例被分配到何处以及在哪个线程中。</li><li>在 <code>Call Stack</code> 标签页中，右键点击任意行并选择 <code>Jump to Source</code>，以在编辑器中打开该代码。</li></ol><p><code>Live Allocation</code> 第一个选择框是选择要检查的堆：</p><ul><li><strong>default heap</strong>：当系统未指定堆时。</li><li><strong>image heap</strong>：系统启动映像，包含启动期间预加载的类。此处的分配保证绝不会移动或消失。</li><li><strong>zygote heap</strong>：写时复制堆，其中的应用进程是从 <code>Android</code> 系统中派生的。</li><li><strong>app heap</strong>：您的应用在其中分配内存的主堆。</li><li><strong>JNI heap</strong>：显示 Java 原生接口 (<code>JNI</code>) 引用被分配和释放到什么位置的堆。</li></ul><p>第二个选择框选择如何安排分配：</p><ul><li><strong>Arrange by class</strong>：根据类名称对所有分配进行分组。这是默认选项。</li><li><strong>Arrange by package</strong>：根据软件包名称对所有分配进行分组。</li><li><strong>Arrange by callstack</strong>：将所有分配分组到其对应的调用堆栈。只有在记录分配期间 <code>捕获堆转储</code> 时，此选项才有效。即便如此，堆中也很可能有在开始记录之前分配的对象，所以会先显示这些分配，直接按类名称列出它们。</li></ul><h3 id="1-1-4-在分析时提高应用性能"><a href="#1-1-4-在分析时提高应用性能" class="headerlink" title="1.1.4 在分析时提高应用性能"></a>1.1.4 在分析时提高应用性能</h3><p>为了在分析时提高应用性能，<code>Memory Profiler</code> 在默认情况下会定期对内存分配进行采样。在运行 <code>API</code> 级别 <code>26</code> 或更高级别的设备上进行测试时，可以使用 <code>Allocation Tracking</code> 下拉菜单来更改此行为。可用选项如下：</p><ul><li><strong>Full</strong>：捕获内存中的所有对象分配。这是 <code>Android Studio 3.2</code> 及更低版本中的默认行为。如果您有一个分配了大量对象的应用，则可能会在分析时观察到应用的运行速度明显减慢。</li><li><strong>Sampled</strong>：定期对内存中的对象分配进行采样。这是默认选项，在分析时对应用性能的影响较小。在短时间内分配大量对象的应用仍可能会表现出明显的速度减慢。</li><li><strong>Off</strong>：停止跟踪应用的内存分配。</li></ul><h3 id="1-1-5-捕获堆转储"><a href="#1-1-5-捕获堆转储" class="headerlink" title="1.1.5 捕获堆转储"></a>1.1.5 捕获堆转储</h3><p>堆转储显示在捕获堆转储时应用中哪些对象正在使用内存。特别是在长时间的用户会话后，堆转储会显示认为不应再位于内存中却仍在内存中的对象，从而帮助识别内存泄露。<br><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/20200414161957.png" alt=""></p><p>要捕获堆转储，请点击 Memory Profiler 工具栏中的 <strong>Dump Java heap</strong> 图标 <img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://developer.android.google.cn/studio/images/buttons/profiler-heap-dump.png" style="zoom:70%">  在转储堆期间，Java 内存量可能会暂时增加。 这很正常，因为堆转储与您的应用发生在同一进程中，并需要一些内存来收集数据。</p><ul><li><p><strong>Allocations</strong>：堆中的分配数。</p></li><li><p><strong>Native Size</strong>：此对象类型使用的原生内存总量（以字节为单位）。只有在使用 <code>Android 7.0</code> 及更高版本时，才会看到此列。</p><p>您会在此处看到采用 <code>Java</code> 分配的某些对象的内存，因为 <code>Android</code> 对某些框架类（如 <code>Bitmap</code>）使用原生内存。</p></li><li><p><strong>Shallow Size</strong>：此对象类型使用的 Java 内存总量（以字节为单位）。</p></li><li><p><strong>Retained Size</strong>：为此类的所有实例而保留的内存总大小（以字节为单位）。</p></li></ul><p>点击一个类名称可在右侧打开 <strong>Instance View</strong> 窗口。</p><ul><li><strong>Depth</strong>：从任意 <code>GC</code> 根到选定实例的最短跳数。</li><li><strong>Native Size</strong>：原生内存中此实例的大小。 只有在使用 Android 7.0 及更高版本时，才会看到此列。</li><li><strong>Shallow Size</strong>：<code>Java</code> 内存中此实例的大小。</li><li><strong>Retained Size</strong>：此实例所支配内存的大小。</li></ul><p>如果你 <code>ClassName</code> 选中的是 <code>Bitmap</code> ,在 <code>7.1</code> 及以下版本的设备中 <code>Call Sack</code>位置会出现 <code>Bitmap Preview</code> 功能，来预览是哪张图片</p><p><code>References</code> 标签页，显示对该对象的每个引用，如果发现某个引用可能在泄露内存，右键点击它并选择 <code>Go to Instance</code>。这样会从堆转储中选择相应的实例，从而显示它自己的实例数据。</p><h3 id="1-1-6-将堆转储另存为-HPROF-文件"><a href="#1-1-6-将堆转储另存为-HPROF-文件" class="headerlink" title="1.1.6 将堆转储另存为 HPROF 文件"></a>1.1.6 将堆转储另存为 HPROF 文件</h3><p>在 Android Studio 3.1 及更低版本中，<code>Export capture to file</code> 按钮 <img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://developer.android.google.cn/studio/images/buttons/profiler-export-hprof.png" alt="img"> 位于时间轴下方工具栏的左侧</p><p>在 Android Studio 3.2 及更高版本中，<code>Sessions</code> 窗格中每个 <code>Heap Dump</code>条目的右侧都有一个 <code>Export Heap Dump</code> 按钮。在随即显示的 <code>Export As</code> 对话框中，使用 <code>.hprof</code>  文件扩展名保存文件。</p><hr><h1 id="2-什么是-MAT"><a href="#2-什么是-MAT" class="headerlink" title="2 什么是 MAT?"></a>2 什么是 MAT?</h1><p>对于内存泄漏问题，Memory Profiler 只能给我们提供一个简单的分析，不能够帮我们确认具体发生问题的地方。</p><p>而 MAT 就可以帮我们做到这一点，MAT 的全称是 Memory Analyzer Tool，它是一款功能强大的 Java 堆内存分析工具，可以用于查找内存泄漏以及查看内存消耗情况。</p><h2 id="2-1-使用前提"><a href="#2-1-使用前提" class="headerlink" title="2.1 使用前提"></a>2.1 使用前提</h2><ol><li><p>到 MAT 的官网 <a href="https://www.eclipse.org/mat/downloads.php" target="_blank" rel="noopener">下载 MAT</a>。</p></li><li><p>使用 <code>Memory Profiler</code> 的堆转储功能，导出 <code>hprof（Heap Profile）</code>文件。</p></li><li><p>配置 <code>platform-tools</code> 环境变量</p></li><li><p>使用命令将 <code>Memory Profiler</code> 中导出来的 <code>hprof</code> 文件转换为 MAT 可以解析的 hprof 文件，命令如下</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hprof-conv ..&#x2F;原始文件.hprof ..&#x2F;输出文件.hprof</span><br></pre></td></tr></table></figure><ol start="5"><li>打开 MAT</li></ol><p><code>File &gt; open Heap dump</code> ，选择我们转换后的文件</p><h2 id="2-2-使用介绍"><a href="#2-2-使用介绍" class="headerlink" title="2.2 使用介绍"></a>2.2 使用介绍</h2><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/20200414173426.png" alt=""></p><ul><li><p><strong>Overview</strong>：概览信息</p><ul><li><strong>Unreachable Objects Histogram</strong>：可被回收的对象，但是仍在内存当中</li></ul></li><li><p><strong>Histogram</strong>：直方图，基于类来分析，会显示该类有多少个实例</p><p>第一行输入可以搜索，<code>Tool Bar</code> 中会多出一个 <code>Group by...</code>  选择 <code>package</code> 会变成已报名的形式来进行分类。</p><ul><li><strong>Object</strong>：有多少实例</li><li><strong>Shallow Heap</strong>：自己占了多少内存</li><li><strong>Retained Heap</strong>：应用链总共占了多少内存</li><li>选择一个类条目右键会出现 <code>List objects</code><ul><li><strong>with outgoing references</strong>：引用了些什么</li><li><strong>with incoming references</strong>：被谁引用着</li></ul></li></ul></li><li><p><strong>dominator_tree</strong>：基于实例来分析，会显示具体的实例是哪个</p><p>第一行输入可以搜索，<code>Tool Bar</code> 中会多出一个 <code>Group by...</code>  选择 <code>package</code> 会变成已报名的形式来进行分类。</p><ul><li><strong>Percentage</strong>：当前所有对象中，此对象内存占用百分比，可以发现那些内存占用过大的对象</li><li>右键点击会出现 <code>List objects</code> ，会显示出具体事例</li></ul></li><li><p><strong>OQL</strong>：对象查询语言</p><ul><li>例如 <code>slect * from com.package.Activity</code> ，会查询出该类所有的实例</li></ul></li><li><p><strong>thread_overview</strong>：<code>dump</code> 内存这个时刻的所有线程</p></li><li><p><strong>top_consumers</strong>：用图形列出占用内存比较大的实例</p><ul><li><strong>Biggest Objects</strong>：详细信息，点击出现 <code>List objects</code></li></ul></li><li><p><strong>Leak Suspects</strong>：更详细的分析，可以从这里找到可以的泄漏点</p><ul><li><strong>Probleam Suspect (x)</strong> ：点击 <code>Details</code> 会出现可疑的 引用链，找到泄漏点</li></ul></li></ul><hr><h1 id="3-什么是-LeakCanary？"><a href="#3-什么是-LeakCanary？" class="headerlink" title="3 什么是 LeakCanary？"></a>3 什么是 LeakCanary？</h1><p>如果使用 MAT 来分析内存问题，会有一些难度，而且效率也不是很高。</p><p>为了能迅速发现内存泄漏，Square 公司基于 MAT 开源了 <a href="https://square.github.io/leakcanary" target="_blank" rel="noopener">LeakCanary</a>。</p><p><code>LeakCanary</code> 是一个内存泄漏检测框架。</p><h2 id="3-1-LeakCanary-原理"><a href="#3-1-LeakCanary-原理" class="headerlink" title="3.1 LeakCanary 原理"></a>3.1 LeakCanary 原理</h2><ol><li><p><strong>检测保留的实例</strong></p><p><code>LeakCanary</code> 是基于 <code>LeakSentry</code> 开发的，<code>LeakSentry</code> 会 <code>hook Android</code> 生命周期，自动检测当 <code>Activity</code> 或 <code>Fragment</code> 被销毁时，它们的实例是否被回收了。</p><p>销毁的实例会传给 <code>RefWatcher</code>，<code>RefWatcher</code> 会持有它们的弱引用。</p><p>你也可以观察所有不再需要的实例，比如一个不再使用的 <code>View</code>，不再使用的 <code>Presenter</code> 等。</p><p>如果等待了 5 秒，并且 <code>GC</code> 触发了之后，弱引用还没有被清理，那么 <code>RefWatcher</code> 观察的实例就可能处于内存泄漏状态了。</p></li><li><p><strong>堆转储</strong></p><p>当保留对象的数量达到阈值时，<code>LeakCanary</code> 将 <code>Java</code> 堆转储到<code>.hprof</code> 存储在 <code>Android</code> 文件系统中的文件中。</p><p>当应用程序可见时，默认的阈值是5个被保留的对象，当应用程序不可见时，默认的阈值是 1 个被保留的对象。如果您看到保留的对象通知，然后将应用程序放在后台(例如通过按Home按钮)，那么阈值将从 5 更改为 1 ，<code>LeakCanary</code> 将在 5 秒内转储堆。点击通知将迫使<code>LeakCanary</code> 立即转储堆。</p></li><li><p><strong>分析堆</strong></p><p><code>LeakCanary</code>  <code>.hprof</code>使用 <a href="https://square.github.io/leakcanary/shark/" target="_blank" rel="noopener">Shark</a> 解析文件，并在该堆转储中找到保留的对象。</p><p>对于每个保留的对象，<code>LeakCanary</code> 会找到引用的路径，以防止对该保留的对象进行垃圾回收：其<strong>泄漏跟踪</strong>。泄漏跟踪是<em>从垃圾回收根到保留对象</em>的<em>最佳强引用路径的</em>另一个名称。</p></li><li><p><strong>泄漏分组</strong></p><p>当有两个泄漏分析结果相同时，<code>LeakCanary</code> <strong>为每个泄漏跟踪</strong>创建一个<strong>签名</strong>，并将具有相同签名的泄漏（即，由同一 <code>bug</code> 引起的泄漏）组合在一起，以免重复显示同样的泄漏信息。</p></li></ol><h2 id="3-2-LeakCanary-使用"><a href="#3-2-LeakCanary-使用" class="headerlink" title="3.2 LeakCanary 使用"></a>3.2 LeakCanary 使用</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  debugImplementation <span class="string">'com.squareup.leakcanary:leakcanary-android:2.2'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>2.2</code> 不需要初始化，如果你添加了</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">'android-aspectjx'</span></span><br></pre></td></tr></table></figure><p>需要在文章添加</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">aspectjx &#123; </span><br><span class="line">    exclude <span class="string">'com.squareup'</span> </span><br><span class="line">    exclude <span class="string">'leakcanary'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>否则会报 <code>Unable to get provider leakcanary.internal.LeakCanaryFileProvider: java.lang.ClassNotFoundException: Didn&#39;t find class &quot;leakcanary.internal.LeakCanaryFileProvider&quot;</code></p><h1 id="4-自定义实现-Demo"><a href="#4-自定义实现-Demo" class="headerlink" title="4 自定义实现 Demo"></a>4 自定义实现 Demo</h1><p><code>Profiler</code> 中使用了 <code>Allocation Tracker</code> 技术，<a href="https://mp.weixin.qq.com/s/b_lFfL1mDrNVKj_VAcA2ZA?" target="_blank" rel="noopener">Android内存申请分析</a> 这篇文章讲述了 <code>Allocation Tracker</code> 的使用方式，并且讲解了 <code>Android Studio</code> 是如何使用 <code>Allocation Tracker</code> 的。可以让我们更加熟悉 <code>Android Studio</code> 中 <code>Profiler</code> 各种工具的实现原理后。</p><p>文中提到了 <code>Allocation Tracker</code> 的三个缺点。</p><ul><li>获取的信息过于分散，中间夹杂着不少其他的信息，很多信息不是应用申请的，可能需要进行不少查找才能定位到具体的问题。</li><li>跟 <code>Traceview</code> 一样，无法做到自动化分析，每次都需要开发者手工开始 / 结束，这对于某些问题的分析可能会造成不便，而且对于批量分析来说也比较困难。</li><li>虽然在 <code>Allocation Tracking</code> 的时候，不会对手机本身的运行造成过多的性能影响，但是在停止的时候，直到把数据 <code>dump</code> 出来之前，经常会把手机完全卡死，如果时间过长甚至会直接 <code>ANR</code>。</li></ul><p>因此我们希望可以做到脱离 <code>Android Studio</code>，实现一个自定义的 <code>Allocation Tracker</code>，实现对象内存的自动化分析。通过这个工具可以获取所有对象的申请信息（大小、类型、堆栈等），可以找到一段时间内哪些对象占用了大量的内存。</p><p>我们可以用自定义的 <code>Allocation Tracker</code> 来监控 Java 内存的监控，也可以拓展成实时监控 <code>Java</code> 内存泄漏。不过任何一个工具如果只需要做到线下自动化测试，实现起来会相对简单，但想要移植到线上使用，那就要更加关注兼容性、稳定性和性能。</p><h2 id="4-1-自动化检测Demo"><a href="#4-1-自动化检测Demo" class="headerlink" title="4.1 自动化检测Demo"></a>4.1 自动化检测Demo</h2><p>这是一个自定义 <code>Allocation Tracker</code> 的 <code>Demo</code> <a href="https://github.com/AndroidAdvanceWithGeektime/Chapter03" target="_blank" rel="noopener">极客时间 Android 高手课 Chapter03</a></p><blockquote><p>项目使用了 inline hook 来拦截内存对象分配时候的 RecordAllocation 函数，通过拦截该接口可以快速获取到当时分配对象的类名和分配的内存大小。<br>在初始化的时候我们设置了一个分配对象数量的最大值，如果从 start 开始对象分配数量超过最大值就会触发内存 dump，然后清空 alloc 对象列表，重新计算。该功能和 Android Studio 里的 Allocation Tracker 类似，只不过可以在代码级别更细粒度的进行控制。可以精确到方法级别。</p></blockquote><ul><li><code>ndk_dlopen</code> 用来获取动态链接库</li><li><code>ndk_dlsym</code> 通过动态链接库和函数签名拿到函数地址</li><li><code>Substrate</code> <a href="http://www.cydiasubstrate.com/api/c/MSHookFunction/" target="_blank" rel="noopener">MSHookFunction</a>  一款经典的 <code>hook</code> 框架，支持 <code>hook C/C++</code> 代码 </li><li><a href="https://github.com/facebookincubator/profilo/tree/master/deps/fbjni" target="_blank" rel="noopener">fbjni</a> 是从 <code>Facebook</code> 开源的一款jni工具类库，主要提供了工具类，ref utils ，Global JniEnv。</li><li><code>native-lib</code> 中 <code>JNI_OnLoad</code>  在 <code>System.loadLibrary(&quot;xxx&quot;);</code> 时执行</li></ul><p>代码运行流程：</p><ol><li><p>在 <code>MainActivity</code> 中调用 <code>AllocTracker.initForArt</code> 去初始化，然后通过 <code>ndk_dlopen</code> 和<code>ndk_dlsym</code> 拿到所有需要的函数，只是拿到函数并没有调用</p></li><li><p><code>JNI_OnLoad</code> 调用 <code>hookFunc();</code>这个方法就是真正的把系统的 <code>tracking</code> 函数 <code>hook</code> 住的地方</p><ol><li>通过 <code>ndk_dlsym</code> 拿到函数地址。</li><li>通过 <code>MSHookFunction</code> 把 <code>newArtRecordAllocation26</code> <code>hook</code> 进原函数地址里，同时拿到旧函数的实现并导向 <code>oldArtRecordAllocation26</code> 。这样做可以保留旧函数。</li><li>在新函数中有一句 <code>allocObjectCount &gt; setAllocRecordMax</code> ，当分配对象数量大于初始化时设置的最大值，就把数据保存在 <code>log</code> 文件中。</li></ol></li></ol><p><code>C/C++</code> 的 <code>hook</code> 和 <code>java</code> 反射一样，如果系统在新版本把函数名，或者函数签名改了那就无法使用了，所以在文件中出现了很多版本适配的地方。</p><p><code>Logcat</code> 中 <code>saveARTAllocationData write file to XXXX</code> 能找到对应的日志文件路径</p><p>看不到日志的输出情况，每个人设备内存情况不一样，<code>GC</code> 回收的频率也不一致，在你不停生产对象的时候，<code>GC</code> 不断的跟随回收，导致无法达到设置的最大的数据量，所以一直没有日志的写入。</p><p><strong>总结：</strong></p><p>这个 <code>Demo</code>  主要学习了 <code>Substrate</code> <a href="https://github.com/facebookincubator/profilo/tree/master/deps/fbjni" target="_blank" rel="noopener">fbjni</a> <code>ndk_dlopen</code> 这几个库的简单使用，<code>CmakeList</code>  的很多写法，以及 <code>native</code> 函数简写</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JNI_METHOD_DECL(ret_type, method_name) \</span></span><br><span class="line">     <span class="keyword">extern</span> <span class="string">"C"</span> JNIEXPORT ret_type JNICALL Java_##com_dodola_alloctrack##_##AllocTracker##_##method_name</span><br></pre></td></tr></table></figure><p>还了解了一些 <code>hook</code> 点以及 <code>hook</code> 方法。</p><h2 id="4-2-重复图片检测Demo"><a href="#4-2-重复图片检测Demo" class="headerlink" title="4.2 重复图片检测Demo"></a>4.2 重复图片检测Demo</h2><p><a href="https://github.com/simplezhli/Chapter04" target="_blank" rel="noopener">极客时间 Android 高手课 Chapter04</a> 已完成的 <code>Demo</code> </p><blockquote><p>通过分析内存文件 hprof 快速判断内存中是否存在重复的图片，并且将这些重复图片的 PNG 、堆栈等信息输出。</p><p><strong>需要注意的是需要使用8.0以下的机器，因为8.0以后Bitmap中的buffer已经放到native内存中了</strong></p></blockquote><p>代码在开始加载了两张相同的图片。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Bitmap bitmap1 = BitmapFactory.decodeResource(getResources(), R.mipmap.test); </span><br><span class="line">Bitmap bitmap2 = BitmapFactory.decodeResource(getResources(), R.mipmap.test);</span><br><span class="line">imageView1.setImageBitmap(bitmap1); </span><br><span class="line">imageView2.setImageBitmap(bitmap2);</span><br></pre></td></tr></table></figure><p>然后手动 <code>GC</code> 生成 <code>hprof</code> 文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手动触发GC</span></span><br><span class="line">Runtime.getRuntime().gc();</span><br><span class="line">System.runFinalization();</span><br><span class="line"><span class="comment">// 生成Hprof文件</span></span><br><span class="line">Debug.dumpHprofData(file.getAbsolutePath());</span><br></pre></td></tr></table></figure><p>接下来在<code>DuplicatedBitmapAnalyzer</code> 的一个 <code>java</code> 项目里，利用 <a href="https://github.com/square/haha" target="_blank" rel="noopener">HAHA</a> 库进行文件分析，并输入重复图片。</p><p>作者已经将代码打成 <code>JAR</code> 包，可以直接调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar tools&#x2F;DuplicatedBitmapAnalyzer-1.0.jar hprof文件路径</span><br></pre></td></tr></table></figure><p>对于更多的信息，可以参看 <a href="https://github.com/square/leakcanary" target="_blank" rel="noopener">LeakCanary</a> 源码</p><p><strong>总结：</strong></p><p>这个 <code>Demo</code> 主要学到了如何主动生成 <code>hprof</code> 文件，以及如何用 <a href="https://github.com/square/haha" target="_blank" rel="noopener">HAHA</a> 这个库解析 <code>hprof</code> 文件。</p><p>联想：可以在特定场合去 <code>dump</code> 文件，比如内存大于最大内存 80%，因为 <code>hprof</code> 文件可能会很大，所以在用户 <code>wifi</code> 情况下回传。</p><p><a href="https://github.com/Tencent/matrix#matrix_android_cn" target="_blank" rel="noopener">Tencent/matrix</a> 这个框架拥有更丰富的检测方式。</p><hr><h1 id="5-优化思路"><a href="#5-优化思路" class="headerlink" title="5 优化思路"></a>5 优化思路</h1><h2 id="5-1-设备分级"><a href="#5-1-设备分级" class="headerlink" title="5.1 设备分级"></a>5.1 设备分级</h2><p>内存优化首先需要根据设备环境来综合考虑</p><ul><li><strong>设备分级</strong>。使用类似 <a href="http://github.com/facebook/device-year-class" target="_blank" rel="noopener">device-year-class</a> 的策略对设备分级，对于低端机用户可以关闭复杂的动画，或者是某些功能；使用 565 格式的图片，使用更小的缓存内存等。<ul><li><code>device-year-class</code> 会根据手机的内存、CPU 核心数和频率等信息决定设备属于哪一个年份，这个示例表示对于 2013 年之后的设备可以使用复杂的动画，对于 2010 年之前的低端设备则不添加任何动画。</li><li>565 格式图片：一张图片中每一个像素的大小取决于它的解码选项，而 Android 中能够选择的 Bitmap 解码选项有四种。<ul><li>ARGB_8888 ：ARGB 四个通道的值都是 8 位，加起来 32 位，也就是每个像素占 4 个字节</li><li>ARGB_4444： ARGB 四个通道的值都是 4 位，加起来 16 位，也就是每个像素占 2 个字节</li><li>RGB_565： RGB 三个通道分别是 5 位、6 位、5 位，加起来 16 位，也就是每个像素占 2 个字节</li><li>ALPHA_8：只有 A 通道，占 8 位，也就是每个像素占 1 个字节</li></ul></li></ul></li><li><strong>缓存管理</strong>。我们需要有一套统一的缓存管理机制，可以适当地使用内存；当“系统有难”时，也要义不容辞地归还。我们可以使用 <code>OnTrimMemory(本文 4.1.1 会讲到)</code> 回调，根据不同的状态决定释放多少内存。</li><li><strong>进程模型</strong>。一个空的进程也会占用 10MB 的内存，而有些应用启动就有十几个进程，甚至有些应用已经从双进程保活升级到四进程保活，所以减少应用启动的进程数、减少常驻进程、有节操的保活，对低端机内存优化非常重要。</li><li><strong>安装包大小</strong>。安装包中的代码、资源、图片以及 so 库的体积，跟它们占用的内存有很大的关系。一个 80MB 的应用很难在 512MB 内存的手机上流畅运行。这种情况我们需要考虑针对低端机用户推出 4MB 的轻量版本，例如 <code>Facebook Lite</code>、今日头条极速版都是这个思路。</li></ul><h2 id="5-2-Bitmap-优化"><a href="#5-2-Bitmap-优化" class="headerlink" title="5.2 Bitmap 优化"></a>5.2 Bitmap 优化</h2><p><code>Bitmap</code> 内存一般占应用总内存很大一部分，所以做内存优化永远无法避开图片内存这个“永恒主题”。</p><ol><li><p>统一图片库</p><p>图片内存优化的前提是收拢图片的调用，这样我们可以做整体的控制策略。就如设备分级中说的，低端设备策略等。</p></li><li><p>统一监控</p><ol><li><strong>大图片监控</strong>。我们需要注意某张图片内存占用是否过大，例如长宽远远大于 View 甚至是屏幕的长宽。在开发过程中，如果检测到不合规的图片使用，应该立即弹出对话框提示图片所在的 Activity 和堆栈，让开发同学更快发现并解决问题。<code>Glide</code> 可以有效的解决此类问题，因为 <code>Glide</code> 会根据 <code>ImageView</code> 的大小把图片大小调整成<code>ImageView</code> 的大小加载图片，并且 <code>Glide</code> 有三级缓存，在内存缓存中，<code>Glide</code> 会根据屏幕大小选择合适的大小作为图片内存缓存区的大小。</li><li><strong>重复图片监控</strong>。重复图片指的是 <code>Bitmap</code> 的像素数据完全一致，但是有多个不同的对象存在。这个监控不需要太多的样本量，一般只在内部使用。在检测模块中实现过一个内存 <code>Hprof</code> 的分析工具，它可以自动将重复 <code>Bitmap</code> 的图片和引用链输出。<ol><li><strong>图片总内存</strong>。通过收拢图片使用，我们还可以统计应用所有图片占用的内存，这样在线上就可以按不同的系统、屏幕分辨率等维度去分析图片内存的占用情况。在 <code>OOM</code> 崩溃的时候，也可以把图片占用的总内存、Top N 图片的内存都写到崩溃日志中，帮助我们排查问题。</li></ol></li></ol></li></ol><hr><h1 id="6-更多"><a href="#6-更多" class="headerlink" title="6 更多"></a>6 更多</h1><h2 id="6-1-监听系统内存状态"><a href="#6-1-监听系统内存状态" class="headerlink" title="6.1 监听系统内存状态"></a>6.1 监听系统内存状态</h2><p>Android 提供了两种方式让我们可以监听系统内存状态</p><h3 id="6-1-1-ComponentCallback2"><a href="#6-1-1-ComponentCallback2" class="headerlink" title="6.1.1 ComponentCallback2"></a>6.1.1 ComponentCallback2</h3><p>在 <code>Android 4.0</code> 后，<code>Android</code> 应用可以通过在 <code>Activity</code> 中实现 <code>ComponentCallback2</code> 接口获取系统内存的相关事件，这样就能在系统内存不足时提前知道这件事，提前做出释放内存的操作，避免我们自己的应用被系统干掉。</p><p><code>ComponentCallnback2</code> 提供了 <code>onTrimMemory(level)</code> 回调方法，在这个方法里我们可以针对不同的警告等级做出不同的释放内存操作。</p><p>原文是 <code>kotlin</code> 版，这里给出一个 <code>java</code> 版</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity2</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title">ComponentCallbacks2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTrimMemory</span><span class="params">(<span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onTrimMemory(level);</span><br><span class="line">        <span class="keyword">switch</span> (level) &#123;</span><br><span class="line">            <span class="keyword">case</span> ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN:</span><br><span class="line">                <span class="comment">// 应用界面处于后台</span></span><br><span class="line">                <span class="comment">// 可以在这里释放 UI 对象</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ComponentCallbacks2.TRIM_MEMORY_RUNNING_MODERATE:</span><br><span class="line">                <span class="comment">// 应用正常运行中，不会被杀掉，但是系统内存已经有点低了</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ComponentCallbacks2.TRIM_MEMORY_RUNNING_LOW:</span><br><span class="line">                <span class="comment">// 应用正常运行中，不会被杀掉，但是系统内存已经非常低了，</span></span><br><span class="line">                <span class="comment">// 这时候应该释放一些不必要的资源以提升系统性能</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL:</span><br><span class="line">                <span class="comment">// 应用正常运行，但是系统内存非常紧张，</span></span><br><span class="line">                <span class="comment">// 系统已经开始根据 LRU 缓存杀掉了大部分缓存的进程</span></span><br><span class="line">                <span class="comment">// 这时候我们要释放所有不必要的资源，不然系统可能会继续杀掉所有缓存中的进程</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ComponentCallbacks2.TRIM_MEMORY_BACKGROUND:</span><br><span class="line">                <span class="comment">// 系统内存很低，系统准备开始根据 LRU 缓存清理进程，</span></span><br><span class="line">                <span class="comment">// 这时我们的程序在 LRU 缓存列表的最近位置，不太可能被清理掉，</span></span><br><span class="line">                <span class="comment">// 但是也要去释放一些比较容易恢复的资源，让系统内存变得充足</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ComponentCallbacks2.TRIM_MEMORY_MODERATE:</span><br><span class="line">                <span class="comment">// 系统内存很低，并且我们的应用处于 LRU 列表的中间位置，</span></span><br><span class="line">                <span class="comment">// 这时候如果还不释放一些不必要资源，那么我们的应用可能会被系统干掉</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ComponentCallbacks2.TRIM_MEMORY_COMPLETE:</span><br><span class="line">                <span class="comment">// 系统内存非常低，并且我们的应用处于 LRU 列表的最边缘位置，</span></span><br><span class="line">                <span class="comment">// 系统会有限考虑干掉我们的应用，如果想活下来，就要把所有能释放的资源都释放了</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="comment">// 应用从系统接收到一个无法识别的内存等级值，</span></span><br><span class="line">                <span class="comment">// 跟一般的低内存消息提醒一样对待这个事件</span></span><br><span class="line">                <span class="comment">// 释放所有不重要的数据结构。</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-1-2-ActivityManager-getMemoryInfo"><a href="#6-1-2-ActivityManager-getMemoryInfo" class="headerlink" title="6.1.2 ActivityManager.getMemoryInfo()"></a>6.1.2 ActivityManager.getMemoryInfo()</h3><p>Android 提供了一个 <code>ActivityManager.getMemoryInfo()</code> 方法给我们查询内存信息，这个方法会返回一个 <code>ActivityManager.MemoryInfo</code> 对象，这个对象包含了系统当前内存状态，这些状态信息包括可用内存、总内存以及低杀内存阈值。</p><p><code>MemoryInfo</code> 中包含了一个 <code>lowMemory</code> 布尔值，这个布尔值用于表明系统是否处于低内存状态。</p><p>原文是 <code>kotlin</code> 版，这里给出一个 <code>java</code> 版</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomethingMemoryIntensive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在做一些需要很多内存的任务前，</span></span><br><span class="line">        <span class="comment">// 检查设备是否处于低内存状态、</span></span><br><span class="line">        <span class="keyword">if</span> (!getAvailableMemory().lowMemory) &#123;</span><br><span class="line">            <span class="comment">// 做需要很多内存的任务</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ActivityManager.<span class="function">MemoryInfo <span class="title">getAvailableMemory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ActivityManager activityManager = (ActivityManager) getSystemService(Context.ACTIVITY_SERVICE);</span><br><span class="line">        ActivityManager.MemoryInfo MemoryInfo = <span class="keyword">new</span> ActivityManager.MemoryInfo();</span><br><span class="line">        activityManager.getMemoryInfo(MemoryInfo);</span><br><span class="line">        <span class="keyword">return</span> MemoryInfo;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="6-2-内存优化技巧"><a href="#6-2-内存优化技巧" class="headerlink" title="6.2 内存优化技巧"></a>6.2 内存优化技巧</h2><h3 id="6-2-1-谨慎使用-Service"><a href="#6-2-1-谨慎使用-Service" class="headerlink" title="6.2.1 谨慎使用 Service"></a>6.2.1 谨慎使用 Service</h3><p>让一个没用的 <code>Service</code> 在后台运行对于一个应用的内存管理来说是一件最糟糕的事情。</p><p>要在 <code>Service</code> 的任务完成后停止它，不然 <code>Service</code> 占用的这块内存会泄漏。</p><p>当你的应用中运行着一个 <code>Service</code>，除非系统内存不足，否则它不会被干掉。</p><p>这就导致对于系统来说 <code>Service</code> 的运行成本很高，因为 <code>Service</code> 占用的内存其他的进程是不能使用的。</p><p><code>Android</code> 有一个缓存进程列表，当可用内存减少时，这个列表也会随之缩小，这就会导致应用间的切换变得很慢。</p><p>如果我们是用 <code>Service</code> 监听一些系统广播，希望在特定情况下再启动事务，可以考虑使用 <code>JobScheduler</code>。</p><p>如果你真的要用 <code>Service</code>，可以考虑使用 <code>IntentService</code>，<code>IntentService</code> 是 <code>Service</code> 的一个子类，在它的内部有一个工作线程来处理耗时任务，当任务执行完后，<code>IntentService</code> 就会自动停止。</p><h3 id="6-2-2-选择优化后的数据容器"><a href="#6-2-2-选择优化后的数据容器" class="headerlink" title="6.2.2 选择优化后的数据容器"></a>6.2.2 选择优化后的数据容器</h3><p><code>Java</code> 提供的部分数据容器并不适合 <code>Android</code>，比如 <code>HashMap</code>，<code>HashMap</code> 需要中存储每一个键值对都需要一个额外的 <code>Entry</code> 对象。</p><p>Android 提供了几个优化后的数据容器，包括 <code>SparseArray</code>、<code>SparseBooleanArray</code> 以及 <code>LongSparseArray</code>。</p><p><code>SparseArray</code>和<code>ArrayMap</code>是Android专门针对内存优化而设计的取代 <code>Java API</code> 中的<code>HashMap</code>的数据结构。对于 <code>key</code> 是 <code>int</code> 类型则使用<code>SparseArray</code>，可避免自动装箱过程；对于 <code>key</code> 为其他类型则使用<code>ArrayMap</code>。<code>HashMap</code>的查找和插入时间复杂度为 <code>O(1)</code> 的代价是牺牲大量的内存来实现的，而<code>SparseArray</code>和<code>ArrayMap</code>性能略逊于<code>HashMap</code>，但更节省内存。</p><h3 id="6-2-3-小心代码抽象"><a href="#6-2-3-小心代码抽象" class="headerlink" title="6.2.3 小心代码抽象"></a>6.2.3 小心代码抽象</h3><p>抽象可以优化代码的灵活性和可维护性，但是抽象也会带来其他成本。</p><p>抽象会导致更多的代码需要被执行，也就是需要更多的时间和把更多的代码映射到内存中。</p><p>如果某段抽象代码带来的好处不大，比如一个地方可以直接实现而不需要用到接口的，那就不用接口。</p><h3 id="6-2-4-使用-protobuf-作为序列化数据"><a href="#6-2-4-使用-protobuf-作为序列化数据" class="headerlink" title="6.2.4 使用 protobuf 作为序列化数据"></a>6.2.4 使用 protobuf 作为序列化数据</h3><p><code>Protocol buffers</code> 是 <code>Google</code> 设计的，它可以对结构化的数据序列化，与<code>XML</code> 类似，不过比<code>XML</code> 更小，更快，而且更简单。</p><p>如果你决定使用 <code>protobuf</code> 作为序列化数据格式，那在客户端代码中应该使用轻量级的 <code>protobuf</code>。</p><p>因为一般的 <code>protobuf</code> 会生成冗长的代码，这样会导致内存增加、<code>APK</code> 大小增加，执行速度变慢等问题。</p><p>更多关于 <code>protobuf</code> 的信息可以查看 <a href="https://android.googlesource.com/platform/external/protobuf/+/master/java/README.md#installation-lite-version-with-maven" target="_blank" rel="noopener">protobuf readme</a> 中的 “轻量级版本”  。</p><h3 id="6-2-5-Apk-瘦身"><a href="#6-2-5-Apk-瘦身" class="headerlink" title="6.2.5 Apk 瘦身"></a>6.2.5 Apk 瘦身</h3><p>有些资源和第三方库会在我们不知情的情况下大量消耗内存。</p><p><code>Bitmap</code> 大小、资源、动画以及第三方库会影响到 <code>APK</code> 的大小，<code>Android Studio</code> 提供了 <code>R8</code> 和 <code>ProGuard</code> 帮助我们缩小 <code>Apk</code>，去掉不必要的资源。</p><p>如果你使用的 <code>Android Studio</code> 版本是 3.3 以下的，可以使用 <code>ProGuard</code>，3.3 及以上版本的可以使用 <code>R8</code>。</p><h3 id="6-2-6-使用-Dagger2-进行依赖注入"><a href="#6-2-6-使用-Dagger2-进行依赖注入" class="headerlink" title="6.2.6 使用 Dagger2 进行依赖注入"></a>6.2.6 使用 Dagger2 进行依赖注入</h3><p>依赖注入框架不仅可以简化我们的代码，而且能让我们在测试代码的时候更方便。</p><p>如果我们想在应用中使用依赖注入，可以考虑使用 <code>Dagger2</code>。</p><p><code>Dagger2</code> 是在编译期生成代码，而不是用反射实现的，这样就避免了反射带来的内存开销，而是在编译期生成代码，</p><h3 id="6-2-7-谨慎使用第三方库"><a href="#6-2-7-谨慎使用第三方库" class="headerlink" title="6.2.7 谨慎使用第三方库"></a>6.2.7 谨慎使用第三方库</h3><p>当你决定使用一个不是为移动平台设计的第三方库时，你需要对它进行优化，让它能更好地在移动设备上运行。</p><p>这些第三方库包括日志、分析、图片加载、缓存以及其他框架，都有可能带来性能问题。</p><h3 id="6-2-8-使用-IntDef-和-StringDef-替代枚举类型"><a href="#6-2-8-使用-IntDef-和-StringDef-替代枚举类型" class="headerlink" title="6.2.8 使用  IntDef 和 StringDef 替代枚举类型"></a>6.2.8 使用  IntDef 和 StringDef 替代枚举类型</h3><p>使用枚举类型的 <code>dex size</code> 是普通常量定义的 <code>dex size</code> 的 13 倍以上，同时，运行时的内存分配，一个 <code>enum</code> 值的声明会消耗至少 <code>20 bytes</code> 。</p><p>枚举最大的优点是类型安全，但在Android平台上，枚举的内存开销是直接定义常量的三倍以上。所以Android提供了注解的方式检查类型安全。目前提供了int型和String型两种注解方式：<code>IntDef</code> 和 <code>StringDef</code> ，用来提供编译期的类型检查。</p><p>使用 <code>IntDef</code>和 <code>StringDef</code> 需要在 <code>Gradle</code> 配置中引入相应的依赖包：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile <span class="string">'com.android.support:support-annotations:22.0.0'</span></span><br></pre></td></tr></table></figure><hr><h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a><strong>感谢</strong></h1><blockquote><p><a href="https://time.geekbang.org/column/article/74044" target="_blank" rel="noopener">极客时间 Android开发高手课</a>  </p><p><a href="https://coding.imooc.com/learn/list/308.html" target="_blank" rel="noopener">慕课 Top团队大牛带你玩转Android性能分析与优化</a></p><p><a href="https://juejin.im/post/5d3ada056fb9a07eb94fd1bc" target="_blank" rel="noopener">探索 Android 内存优化方法</a></p><p><a href="https://juejin.im/post/58b80c3b61ff4b006cd8c33d" target="_blank" rel="noopener">Android 性能优化（四）之内存优化实战</a></p><p><a href="https://square.github.io/leakcanary" target="_blank" rel="noopener">LeakCanary</a></p><p><a href="https://developer.android.google.cn/studio/profile/memory-profiler" target="_blank" rel="noopener">AndroidDeveloper</a> </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>App 内存知识介绍💦</title>
      <link href="/2020/memory-optimization.html"/>
      <url>/2020/memory-optimization.html</url>
      
        <content type="html"><![CDATA[<p>Android 性能优化第二篇， 内存优化是减少崩溃率工作中非常关键的一部分，由于Android有垃圾自动回收机制不需要手动干预，但也因此，经常出现内存问题如内存泄漏、内存泄漏引发 <code>GC</code> 频繁导致页面卡顿和内存溢出等问题，如果不了解内存是如何管理的以及如何优化，会难以排查问题。</p><p>这篇文章集结了很多文章精华部分(个人认为)，在这里整理分享出更多更完整内存知识，所以这篇文章会很长，目录我会分的很细，方便查找，文末会贴出参考文章。</p><p><strong>注意：如果出现图片不显示问题请移步</strong> <a href="https://calmcenter.club/2019/PicNotShow.html">图片不显示问题</a></p><h1 id="本文主要记载"><a href="#本文主要记载" class="headerlink" title="本文主要记载"></a>本文主要记载</h1><ul><li><strong>1 什么是内存？</strong></li><li><strong>2 JVM 如何分配内存？</strong><ul><li>2.1 所有线程共享的数据区域</li><li>2.2 线程私有的数据区域</li></ul></li><li><strong>3 JVM 如何管理内存？</strong><ul><li>3.1 引用计数算法</li><li>3.2 可达性算法</li><li>3.3 引用介绍</li><li>3.4 垃圾回收器<ul><li>3.4.1 标记-清除算法（Mark-Sweep）</li><li>3.4.2 复制算法（Copying）</li><li>3.4.3 标记-整理算法（Mark-Compact）</li><li>3.4.4 分代收集算法（Generational Collection）</li></ul></li></ul></li><li><strong>4 什么是 Dalvik?</strong><ul><li>4.1 Dalvik 与 JVM 的区别</li><li>4.2 Dalvik 堆大小</li></ul></li><li><strong>5 什么是 ART?</strong><ul><li>5.1 ART 与 Dalvik 的区别</li></ul></li><li><strong>6 内存引发的问题</strong><ul><li>6.1 内存泄漏<ul><li>6.1.1 常见的内存泄漏</li></ul></li><li>6.2 低杀</li><li>6.3 内存抖动</li></ul></li><li><strong>7 Android Bitmap 内存分配的变化</strong></li><li><strong>8 内存优化的两个误区</strong><ul><li>8.1 内存占用越少越好</li><li>8.2 Native 内存不用管</li></ul></li></ul><hr><h1 id="1-什么是内存？"><a href="#1-什么是内存？" class="headerlink" title="1 什么是内存？"></a>1 什么是内存？</h1><p>内存是计算机中重要的部件之一，是与 CPU 进行沟通的桥梁，是 CPU 能直接寻址的存储空间，由半导体器件制成。</p><blockquote><p>如果说数据是商品，那硬盘就是商店的仓库，内存就是商店的货架，仓库里的商品你是不能直接买的，你只能买货架上的商品。</p><p>每一个程序中使用的内存区域相当于是不同的货架，当一个货架上需要摆放的商品超过这个货架所能容纳的最大值，就会出现放不下的情况，也就是内存溢出。</p></blockquote><hr><h1 id="2-JVM-如何分配内存？"><a href="#2-JVM-如何分配内存？" class="headerlink" title="2 JVM 如何分配内存？"></a>2 JVM 如何分配内存？</h1><h2 id="2-1-所有线程共享的数据区域"><a href="#2-1-所有线程共享的数据区域" class="headerlink" title="2.1 所有线程共享的数据区域"></a>2.1 <strong>所有线程共享的数据区域</strong></h2><ul><li><strong>堆</strong>（Java Heap）<ul><li><code>Java</code> 堆是 <code>JVM</code> 管理的内存中最大的一块内存区域。</li><li>几乎所有的对象实例都是在堆中分配内存。</li><li>此区域也是垃圾回收器（<code>Garbage Collection</code>）主要的作用区域，内存泄漏就发生在这个区域。</li></ul></li><li><strong>方法区</strong>（Method Area）<ul><li>方法区存放的是 <strong>类信息、常量、静态变量</strong></li><li>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机会抛出内存溢出异常 <code>OutOfMemoryError</code>。</li></ul></li></ul><h2 id="2-2-线程私有的数据区域"><a href="#2-2-线程私有的数据区域" class="headerlink" title="2.2 线程私有的数据区域"></a>2.2 <strong>线程私有的数据区域</strong></h2><ul><li><p><strong>程序计数器</strong>（Program Counter Register）</p><ul><li><p>一块较小的内存空间，可看做是当前线程所执行的字节码的行号指示器。</p></li><li><p>为了线程切换后能恢复到正确的执行位置，每条线程都有一个私有的程序计数器。</p></li><li><p>如果线程在执行 <code>Java</code> 方法，这个计数器记录的是正在执行的虚拟机字节码指令地址；</p></li><li><p>如果执行的是 <code>Native</code> 方法，这个计数器的值为空（Undefined）。</p></li><li><p>程序计数器是唯一一个在 Java 虚拟机规范中没有规定任何 <code>OOM</code> 情况的区域。</p></li></ul></li><li><p><strong>本地方法栈</strong>（Native Method Stack）</p><ul><li>本地方法栈与虚拟机栈的区别是虚拟机栈为 <code>Java</code> 方法服务，而本地方法栈为 <code>Native</code> 方法服务。</li><li>与虚拟机栈一样，本地方法栈也会抛出 <code>StackOverflowError</code> 和 <code>OutOfMemoryError</code> 异常。</li></ul></li><li><p><strong>虚拟机栈</strong>（Virtual Machine Stack ）</p><ul><li>每个方法在执行的同时都会创建一个<strong>栈帧（Stack Frame）</strong>用于存储局部变量表、操作数栈、动态链接、方法出口等信息。</li><li>虚拟机栈生命周期与线程相同。</li><li>当执行 Java 方法时会进行压栈的操作，在栈中会保存局部变量、操作数栈和方法出口等信息。<code>JVM</code> 规定了栈的最大深度，如果线程请求执行方法时栈的深度大于规定的深度，就会抛出栈溢出异常 <code>StackOverflowError</code>。</li><li>如果虚拟机在扩展时无法申请到足够的内存，就会抛出内存溢出异常 <code>OutOfMemoryError</code>。</li></ul><div class="note default no-icon">            <p><strong>栈帧（Stack Frame）</strong></p><p>当 <code>Java</code> 程序出现异常时，程序会打印出对应的异常堆栈，通过这个堆栈我们可以知道方法的调用链路，而这个调用链路就是由一个个 Java 方法栈帧组成的。</p><ol><li><p><strong>局部变量表</strong>（Local Variable Table）：里面的变量只在当前函数调用中有效，当函数调用结束后，随着函数栈帧的销毁，局部变量表也会随之销毁。</p><p>局部变量表中存放的<strong>编译期</strong>可知的各种数据有：</p><ul><li><p>基本数据类型：如 boolean、char、int 等。</p></li><li><p>对象引用：reference 类型，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置。</p></li><li><p><code>returnAddress</code>类型：指向一条虚拟机指令的操作码。与前面介绍的那些数值类的原生类型不同，<code>returnAddress</code> 类型在 <code>Java</code> 语言之中并不存在相应的类型，也无法在程序运行期间更改 <code>returnAddress</code> 类型的值。</p></li></ul></li><li><p><strong>操作数栈</strong>（Operand Stack）：操作数栈（Operand Stack）也叫操作栈，它主要用于保存计算过程的中间结果，同时作为计算过程中临时变量的存储空间。</p></li><li><p><strong>动态连接</strong>（Dynamic Linking）：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接</p></li><li><p><strong>方法返回地址</strong>：当一个方法开始执行后，只有两种方式可以退出这个方法，一种是正常完成出口，另一种是异常完成出口。</p><ul><li>正常完成出口（Normal Method Invocation Completion）：执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者。是否有返回值和返回值的类型将根据遇到哪种方法返回指令来决定，这种退出方法的方式称为正常完成出口。</li><li>异常完成出口（Abrupt Method Invocation Completion）：在方法执行过程中遇到异常，并且这个异常没有在方法体内得到处理，就会导致方法退出，这种退出方式称为异常完成出口。一个方法使用异常完成出口的方式退出，任何值都不会返回给它的调用者。</li></ul><p>无论采用哪种退出方式，在方法退出后，都需要返回到方法被调用的位置，程序才能继续执行。</p></li></ol>          </div></li></ul><hr><h1 id="3-JVM-如何管理内存？"><a href="#3-JVM-如何管理内存？" class="headerlink" title="3 JVM 如何管理内存？"></a>3 JVM 如何管理内存？</h1><p>JVM 的管理主要有 <strong>引用计数算法</strong>、<strong>可达性算法</strong>、<strong>Java 引用</strong> 以及 <strong>垃圾回收器</strong> 知识点。</p><h2 id="3-1-引用计数算法"><a href="#3-1-引用计数算法" class="headerlink" title="3.1 引用计数算法"></a>3.1 引用计数算法</h2><p>给对象中添加一个引用计数器，每当有一个地方引用该对象时，计数器值加1；引用失效时，计数器值减1；任意时刻计数器为0的对象就是不可能再被使用的，表示该对象不存在引用关系。</p><p>优点：实现简单，判定效率也很高；<br>缺点：难以解决对象之间相互循环引用导致计数器值不等于0的问题。</p><h2 id="3-2-可达性算法"><a href="#3-2-可达性算法" class="headerlink" title="3.2 可达性算法"></a>3.2 可达性算法</h2><p>判定对象是否是存活的</p><p>这个算法的基本思路就是通过一系列 <code>GC Roots</code> 对象作为起始点，从这些节点开始向下搜索，搜索走过的路径就叫引用链。<br>当一个对象到 <code>GC Roots</code> 没有任何引用链相连时（<code>GC Roots</code> 到这个对象不可达），则证明此对象是不可用的。</p><p>比如下图中的 <code>object5、object6、object7</code>，虽然它们互有关联，但是它们到 <code>GC Roots</code> 是不可达的，所以它们会被判定为可回收对象。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/20200330171812.png" alt=""></p><p>那么那些点可以作为 <code>GC Roots</code> 呢？一般来说，如下情况的对象可以作为 <code>GC Roots</code> ：</p><ol><li><p>虚拟机栈</p><p>虚拟机栈的栈帧中的局部变量表中引用的对象，比如某个方法正在使用的类字段。</p></li><li><p>方法区</p><ul><li><p>类静态属性引用的对象</p></li><li><p>常量引用的对象</p></li></ul></li><li><p>本地方法栈</p><p>本地方法栈中 <code>Native</code> 方法引用的对象。</p></li></ol><h2 id="3-3-引用介绍"><a href="#3-3-引用介绍" class="headerlink" title="3.3 引用介绍"></a>3.3 引用介绍</h2><p>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判定对象是否存活都与引用有关。</p><p>在 <code>JDK 1.2</code> 之后，<code>Java</code> 对引用的概念进行了扩充，将引用分为<strong>强引用</strong>、<strong>软引用</strong>、<strong>弱引用</strong>和<strong>虚引用</strong>四种，这四种引用强度按顺序依次减弱。如果没有指定对象引用类型，默认是<strong>强引用</strong>。</p><ol><li><strong>强引用</strong>：<ul><li>强引用是指代码中普遍存在的，比如 <code>Object obj = new Object()</code> 这类引用。</li><li>强引用可以直接访问目标对象。</li><li>强引用指向的对象在任何时候都不会被系统回收，虚拟机即使抛出 <code>OOM</code> 异常，也不会回收强引用指向的对象。<br>使用 <code>obj = null</code> 不会触发 <code>GC</code>，但是在下次 <code>GC</code> 的时候这个强引用对象就可以被回收了。</li><li>强引用可能导致内存泄漏。</li></ul></li><li><strong>软引用</strong>：<ul><li>软引用用于描述一些还有用但非必需的对象。</li><li>对于软引用关联的对象，在系统即将发生内存溢出前，会把这些对象列入回收范围中进行二次回收。</li><li>如果二次回收后还没有足够的内存，就会抛出内存溢出异常。</li><li>在 <code>JDK 1.2</code> 后，<code>Java</code> 提供了 <code>SoftReference</code> 类来实现软引用。</li></ul></li><li><strong>弱引用</strong>：<ul><li>弱引用的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次 <code>GC</code> 前。</li><li>在 <code>GC</code> 时，只要发现弱引用，不管系统堆空间使用情况如何，都会将对象进行回收。</li><li>软引用、弱引用适合保存可有可无的缓存数据。</li><li><code>JDK 1.2</code> 后，提供了 <code>WeakReference</code> 类来实现弱引用。</li></ul></li><li><strong>虚引用</strong>：<ul><li>一个对象是否有虚引用的存在，都不会对其生存时间构成影响，也无法通过虚引用取得一个对象实例。</li><li>为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</li><li>在 <code>JDK 1.2</code> 后，提供了 <code>PhantomReference</code> 类来实现虚引用。</li></ul></li></ol><h2 id="3-4-垃圾回收器"><a href="#3-4-垃圾回收器" class="headerlink" title="3.4 垃圾回收器"></a>3.4 垃圾回收器</h2><p>垃圾回收器就是我们经常说到的 <code>GC（Garbage Collector）</code>，当我们操作不当导致某块内存泄漏时，<code>GC</code> 就不能对这块内存进行回收。</p><p>拿 <code>Android</code> 来说，进行 <code>GC</code> 时，所有线程都要暂停，包括主线程，<code>16ms</code> 是 <code>Android</code> 要求的每帧绘制时间，而当 <code>GC</code> 的时间超过 <code>16ms</code>，就会造成丢帧的情况，也就是界面卡顿。</p><p>垃圾回收器回收资源的方式就是垃圾回收算法</p><h3 id="3-4-1-标记-清除算法（Mark-Sweep）"><a href="#3-4-1-标记-清除算法（Mark-Sweep）" class="headerlink" title="3.4.1 标记-清除算法（Mark-Sweep）"></a>3.4.1 标记-清除算法（Mark-Sweep）</h3><p>最基础的收集算法：分为 <strong>标记</strong> 和 <strong>清除</strong> 两个阶段，首先，标记出所有需要回收的对象，然后统一回收所有被标记的对象。<br>这种方法有两个不足点：</p><ol><li>标记和清除的效率都不高</li><li>标记清除后会产生大量不连续的内存碎片，内存碎片太多会导致当程序需要分配较大的对象时，无法找到足够的连续内存而不得不提前触发 ·<code>GC</code></li></ol><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/20200330181053.png" alt=""></p><h3 id="3-4-2-复制算法（Copying）"><a href="#3-4-2-复制算法（Copying）" class="headerlink" title="3.4.2 复制算法（Copying）"></a>3.4.2 复制算法（Copying）</h3><p>为了解决 <strong>标记-清除算法</strong> 效率问题，<strong>复制收集算法</strong> 出现了。</p><p>将内存按容量划分为大小相等的两块，每次只使用其中的一块，当这一块内存将用完了，就将还存活着的对象复制到另一块内存上面，然后再把已使用过的内存空间一次清理掉。</p><ul><li>优点：实现简单，运行高效；每次都是对整个半区进行内存回收，内存分配时也不需要考虑内存碎片等情况，只要移动堆顶指针，按顺序分配内存即可；</li><li>缺点：粗暴的将内存一分为二，代价有点高。在对象存活率高时，要进行较多的复制操作，这时效率就变低了</li></ul><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/20200330181822.png" alt=""></p><h3 id="3-4-3-标记-整理算法（Mark-Compact）"><a href="#3-4-3-标记-整理算法（Mark-Compact）" class="headerlink" title="3.4.3 标记-整理算法（Mark-Compact）"></a>3.4.3 标记-整理算法（Mark-Compact）</h3><p><strong>标记-整理算法</strong> 的标记过程与 <strong>标记-清除算法</strong> 一样，但后续步骤是让所有存活的对象向一端移动，然后直接清理掉边界外的内存。</p><ul><li>避免了 <strong>标记-清除算法</strong> 内存碎片；</li><li>避免了 <strong>复制算法</strong> 50%的空间浪费；</li><li>主要针对对象存活率高的老年代。<br><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/20200403112950.png" alt=""></li></ul><h3 id="3-4-4-分代收集算法（Generational-Collection）"><a href="#3-4-4-分代收集算法（Generational-Collection）" class="headerlink" title="3.4.4 分代收集算法（Generational Collection）"></a>3.4.4 分代收集算法（Generational Collection）</h3><p>现代商业虚拟机的垃圾回收都采用 <strong>分代收集算法</strong> ，这种算法会根据对象存活周期的不同将内存划分为几块，这样就可以根据各个区域的特点采用最适当的收集算法。</p><p>堆内存可分为 <strong>新生区</strong> 、<strong>养老区</strong> 和 <strong>永久存</strong> 储区三个区域。</p><ul><li><p><strong>新生区（Young Generation Space）</strong></p><p>由 <strong>一个伊甸区（Eden space）</strong> 和 <strong>两个幸存者区（Survivor space）区</strong> 组成。<br>每次垃圾收集都有大批对象死去，只有少量存活，所以可以用复制算法。</p><ul><li><strong>伊甸区</strong></li></ul><p>大多数情况下，对象都是在伊甸区中分配的，当伊甸区没有足够的空间进行分配时，虚拟机将发起一次 <code>Minor GC</code>。<br><code>Minor GC</code> 是指发生在新生区的垃圾收集动作，<code>Minor GC</code> 非常频繁，回收速度也比较快。<br>当伊甸区的空间用完时，<code>GC</code> 会对伊甸区进行垃圾回收，然后把伊甸区剩下的对象移动到幸存 0 区。</p><ul><li><strong>幸存 0 区</strong></li></ul><p>如果幸存 0 区满了，<code>GC</code> 会对该区域进行垃圾回收，然后再把该区剩下的对象移动到幸存 1 区。</p><ul><li><strong>幸存 1 区</strong></li></ul><p>如果幸存 1 区满了，<code>GC</code> 会对该区域进行垃圾回收，然后把幸存 1 区中的对象移动到养老区。</p></li><li><p><strong>养老区（Tenure Generation Space）</strong></p></li></ul><p>对象存活率高、没有额外空间对它进行担保，就必须使用 <strong>标记-清理</strong> 或 <strong>标记-整理算法</strong> 进行回收。</p><p>用于保存从新生区筛选出来的 <code>Java</code> 对象。<br>当幸存 1 区移动尝试对象到养老区，但是发现空间不足时，虚拟机会发起一次 <code>Major GC</code>。<br><code>Major GC</code> 的速度一般比 <code>Minor GC</code> 慢 10 倍以上。<br>大对象会直接进入养老区，比如很大的数字和很长的字符串。</p><ul><li><strong>永久存储区（Permanent Space）</strong></li></ul><p>一个常驻内存区域，用于存放 <code>JDK</code> 自身携带的 <code>Class Interface</code> 元数据。<br>永久存储区存储的是运行环境必需的类信息，被装载进该区域的数据是不会被垃圾回收器回收掉的，只有 <code>JVM</code> 关闭时才会释放此区域的内存。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/20200403114531.png" alt=""></p><hr><h1 id="4-什么是-Dalvik"><a href="#4-什么是-Dalvik" class="headerlink" title="4 什么是 Dalvik?"></a>4 什么是 Dalvik?</h1><p><code>Dalvik</code> 是 <code>Dalvik Virtual Machine</code>（<code>Dalvik</code> 虚拟机）的简称，是 <code>Android</code> 平台的核心组成部分之一。<code>Android 4.4</code> 之前都是使用 <code>Dalvik</code>。</p><p>在 <code>Androd</code> 中，每一个应用都运行在一个 <code>Dalvik VM</code> 实例中，每一个 <code>Dalvik VM</code> 都运行在一个独立的进程空间，这种机制使得 <code>Dalvik</code> 运行在有限的内存中同时运行多个进程。</p><h2 id="4-1-Dalvik-与-JVM-的区别"><a href="#4-1-Dalvik-与-JVM-的区别" class="headerlink" title="4.1 Dalvik 与 JVM 的区别"></a>4.1 Dalvik 与 JVM 的区别</h2><p><code>Dalvik</code> 不是 <code>Java</code> 虚拟机，它并不是按照 Java 虚拟机规范实现的，两者之间并不兼容。</p><ol><li><p>架构</p><ul><li><p><code>JVM</code> 是基于栈的，需要在栈中读取数据，所需的指令会更多，这样会导致速度慢，不适合性能优先的移动设备。</p></li><li><p><code>Dalvik</code> 是基于寄存器的，指令更紧凑和简洁。</p></li></ul><p>由于显式指定了操作数，所以基于寄存器的指令会比基于栈的指令要大，但是由于指令数的减少，总的代码数不会增加多少。</p></li><li><p>执行代码不同</p><ul><li><p>在 <code>Java SE</code> 程序中，<code>Java</code> 类会被编译成一个或多个 <code>.class</code> 文件，然后打包成 <code>jar</code> 文件，<code>JVM</code> 会通过对应的 <code>.class</code> 文件和 <code>jar</code> 文件获取对应的字节码。</p></li><li><p>而 <code>Dalvik</code> 会用 <code>dx</code> 工具将所有的 .class 文件转换为一个 <code>.dex</code> 文件，然后会从该 <code>.dex</code> 文件读取指令和数据。</p></li></ul></li><li><p>共享机制</p><ul><li><p><code>Dalvik</code> 拥有预加载—共享机制，不同应用之间在运行时可以共享相同的类，拥有更高的效率。</p></li><li><p>而 <code>JVM</code> 不存在这种共享机制，不同的程序，打包后的程序都是彼此独立的，即使包中使用了同样的类，运行时也是单独加载和运行的，无法进行共享。</p></li></ul></li></ol><h2 id="4-2-Dalvik-堆大小"><a href="#4-2-Dalvik-堆大小" class="headerlink" title="4.2 Dalvik 堆大小"></a>4.2 Dalvik 堆大小</h2><p>每一个手机厂商都可以设定设备中每一个进程能够使用的堆大小，有关进程堆大小的值有下面三个。</p><p>如果我们想看堆内存大小应该怎么办呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell getprop dalvik.vm.heapsize</span><br></pre></td></tr></table></figure><ul><li><p>dalvik.vm.heapstartsize</p><p>堆分配的初始值大小，这个值越小，系统内存消耗越慢，但是当应用扩展这个堆，导致 <code>GC</code> 和堆调整时，应用会变慢。</p><p>这个值越大，应用越流畅，但是可运行的应用也会相对减少。</p></li><li><p>dalvik.vm.heapgrowthlimit</p><p>如果在清单文件中声明 <code>largeHeap</code> 为 <code>true</code>，则 <code>App</code> 使用的内存到 <code>heapsize</code> 才会 <code>OOM</code>，否则达到 <code>heapgrowthlimit</code> 就会 <code>OOM</code>。</p></li><li><p>dalvik.vm.heapsize</p><p>进程可用的堆内存最大值，一旦应用申请的内存超过这个值，就会 <code>OOM</code>。</p></li></ul><hr><h1 id="5-什么是-ART"><a href="#5-什么是-ART" class="headerlink" title="5 什么是 ART?"></a>5 什么是 ART?</h1><p><code>ART</code> 的全称是 <code>Android Runtime</code>，是从 <code>Android 4.4</code> 开始新增的 <strong>应用运行时环境</strong>，用于替代 <code>Dalvik</code> 虚拟机。</p><p><code>Dalvik VM</code> 和 <code>ART</code> 都可以支持已转换为 <code>.dex（Dalvik Executable）</code>格式的 <code>Java</code> 应用程序的运行。</p><p><code>Dalvik</code> 是为 32 位 <code>CPU</code> 设计的，而 <code>ART</code> 支持 64 位并兼容 32 位 <code>CPU</code>，这也是 <code>Dalvik</code> 被淘汰的主要原因。</p><h2 id="5-1-ART-与-Dalvik-的区别"><a href="#5-1-ART-与-Dalvik-的区别" class="headerlink" title="5.1 ART 与 Dalvik 的区别"></a>5.1 ART 与 Dalvik 的区别</h2><ol><li><p>预编译</p><ul><li><p><code>Dalvik</code> 中的应用每次运行时，字节码都需要通过即时编译器 JIT 转换为机器码，这会使得应用的运行效率降低。</p></li><li><p>在 <code>ART</code> 中，系统在安装应用时会进行一次预编译，将字节码预先编译成机器码并存储在本地，这样应用就不用在每次运行时执行编译了，运行效率也大大提高。</p></li></ul></li><li><p>GC</p><ul><li><p>在 <code>Dalvik</code> 采用的垃圾回收算法是标记-清除算法，启动垃圾回收机制会造成两次暂停（一次在遍历阶段，另一次在标记阶段）。</p></li><li><p>而在 <code>ART</code> 下，<code>GC</code> 速度比 <code>Dalvik</code> 要快，这是因为应用本身做了垃圾回收的一些工作，启动 <code>GC</code> 后，不再是两次暂停，而是一次暂停。</p><p>而且 <code>ART</code> 使用了一种新技术（<code>packard pre-cleaning</code>），在暂停前做了许多事情，减轻了暂停时的工作量。</p></li></ul></li></ol><hr><h1 id="6-内存引发的问题"><a href="#6-内存引发的问题" class="headerlink" title="6 内存引发的问题"></a>6 内存引发的问题</h1><ol><li>内存造成的第一个问题是<strong>异常</strong>。异常包括 <code>OOM</code>、内存分配失败这些崩溃，也包括因为整体内存不足导致应用被杀死、设备重启等问题。</li><li>内存造成的第二个问题是卡顿。<strong>内存泄漏</strong> 导致 <code>Java</code> 内存不足会频繁 <code>GC</code>，常见现象是 <strong>内存抖动</strong>，这个问题在 <code>Dalvik</code> 虚拟机会更加明显。而 ART 虚拟机在内存管理跟回收策略上都做大量优化</li><li>除了频繁 <code>GC</code> 造成卡顿之外，物理内存不足时系统会触发 <strong>low memory killer</strong> 机制，系统负载过高是造成卡顿的另外一个原因。</li></ol><h2 id="6-1-内存泄漏"><a href="#6-1-内存泄漏" class="headerlink" title="6.1 内存泄漏"></a>6.1 内存泄漏</h2><p>内存泄漏指的是，当一块内存没有被使用，但无法被 GC 时的情况。</p><p>内存泄漏的表现就是可用内存逐渐减少，无法被回收的内存逐渐累积，直到无更多可用内存可申请时，就会导致 <code>OOM</code>。</p><h3 id="6-1-1-常见的内存泄漏"><a href="#6-1-1-常见的内存泄漏" class="headerlink" title="6.1.1 常见的内存泄漏"></a>6.1.1 常见的内存泄漏</h3><ol><li><p><strong>非静态内部类</strong></p><ul><li><p><strong>泄漏场景</strong> </p><p>非静态内部类会持有外部类的实例，比如匿名内部类。</p><p>匿名内部类指的是一个对象名称的类，但是在字节码中，它还是会有构造函数的，而它的构造函数中会包含外部类的实例。</p><p>比如在 <code>Activity</code> 中以匿名内部类的方式声明 <code>Handler</code> 或 <code>AsyncTask</code>，当 <code>Activity</code> 关闭时，由于 <code>Handler</code> 持有 <code>Activity</code> 的强引用，导致 <code>GC</code> 无法对 <code>Activity</code> 进行回收。</p><p>当我们通过 <code>Handler</code> 发送消息时，消息会加入到 <code>MessageQueue</code> 队列中交给 <code>Looper</code> 处理，当有消息还没发送完毕时，<code>Looper</code> 会一直运行，在这个过程中会一直持有 <code>Handler</code>，而 <code>Handler</code> 又持有外部类 <code>Activity</code> 的实例，这就导致了 Activity 无法被释放。</p></li><li><p><strong>解决</strong></p><p>把 <code>Handler</code> 或 <code>AsyncTask</code> 声明为静态内部类，并且使用 <code>WeakReference</code> 包住 <code>Activity</code>，这样 <code>Handler</code> 拿到的就是一个 <code>Activity</code> 的弱引用，<code>GC</code> 就可以回收 <code>Activity</code>。这种方式适用于所有匿名内部类导致的内存泄漏问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    Activity activity;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyHandler</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">        activity = <span class="keyword">new</span> WeakReference&lt;&gt;(activity).get();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>静态变量</strong></p><ul><li><p><strong>泄漏场景</strong></p><p>静态变量导致内存泄漏的原因是因为 <strong>长生命周期对象</strong> 持有了 <strong>短生命周期对象</strong> 的引用，导致短生命周期对象无法被释放。</p><p>比如一个单例持有了 <code>Activity</code> 的引用，而 <code>Activity</code> 的生命周期可能很短，用户一打开就关闭了，但是单例的生命周期往往是与应用的生命周期相同的。</p></li><li><p><strong>解决</strong></p><p>如果单例需要 <code>Context</code>， 可以考虑使用 <code>ApplicationContext</code>，这样单例持有的 <code>Context</code> 引用就是与应用的生命周期相同的了。</p></li></ul></li><li><p><strong>资源未释放</strong></p><ul><li><p><strong>泄漏场景</strong></p><p>忘了注销 <code>BroadcastReceiver</code></p><p>打开了数据库游标（<code>Cursor</code>）忘了关闭</p><p>打开流忘了关闭</p><p>创建了 <code>Bitmap</code> 但是调用 <code>recycle</code> 方法回收 <code>Bitmap</code> 使用的内存</p><p>使用 <code>RxJava</code> 忘了在 <code>Activity</code> 退出时取消任务</p><p>使用协程忘了在 <code>Activity</code> 退出时取消任务</p></li></ul></li><li><p><strong>Webview</strong></p><ul><li><p><strong>泄漏场景</strong></p><p>不同的 <code>Android</code> 版本的 <code>Webview</code> 会有差异，加上不同厂商定制 <code>ROM</code> 的 <code>Webview</code> 的差异，导致 <code>Webview</code> 存在很大的兼容问题。</p><p>一般情况下，在应用中只要使用一次 <code>Webview</code>，它占用的内存就不会被释放。</p></li><li><p><strong>解决</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( mWebView!=<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果先调用destroy()方法，则会命中if (isDestroyed()) return;这一行代码，需要先onDetachedFromWindow()，再</span></span><br><span class="line">        <span class="comment">// destory()</span></span><br><span class="line">        ViewParent parent = mWebView.getParent();</span><br><span class="line">        <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ((ViewGroup) parent).removeView(mWebView);</span><br><span class="line">        &#125;</span><br><span class="line">        mWebView.stopLoading();</span><br><span class="line">        <span class="comment">// 退出时调用此方法，移除绑定的服务，否则某些特定系统会报错</span></span><br><span class="line">        mWebView.getSettings().setJavaScriptEnabled(<span class="keyword">false</span>);</span><br><span class="line">        mWebView.clearHistory();</span><br><span class="line">        mWebView.clearView();</span><br><span class="line">        mWebView.removeAllViews();</span><br><span class="line">        mWebView.destroy();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">super</span>.<span class="function">on <span class="title">Destroy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="6-2-低杀"><a href="#6-2-低杀" class="headerlink" title="6.2 低杀"></a>6.2 低杀</h2><p>在内存不足时，这种机制就会针对于所有进程进行回收(优先级由高到低，优先回收低优先级)</p><p>进程优先级：</p><ol><li><p><strong>前台进程</strong>：优先级最高的进程，是正在于用户交互的进程</p><ul><li>进程持有一个与用户交互的 Activity（该 Activity 的 onResume 方法被调用）</li><li>进程持有一个 Service，<code>[Service 与用户正在交互的 Activity 绑定]</code>  <code>[Service 调用了 startForeground() 方法(前台服务)]</code>  <code>[Service 正在执行以下生命周期函数（onCreate、onStart、onDestroy ）]</code></li><li>进程持有一个 <code>BroadcastReceiver</code>，这个 <code>BroadcastReceiver</code> 正在执行它的 <code>onReceive()</code> 方法</li></ul></li><li><p><strong>可见进程</strong>：不含有任何前台组件，但用户还能再屏幕上看见它</p><ul><li>进程持有一个 <code>Activity</code>，这个 <code>Activity</code> 处于 <code>pause</code> 状态</li><li>进程持有一个 <code>Service</code> 这个 <code>Service</code> 和一个可见的 <code>Activity</code> 绑定。</li><li>可见进程是非常重要的进程，除非前台进程已经把系统的可用内存耗光，否则系统不会终止可见进程。</li></ul></li><li><p><strong>服务进程</strong>：可能在播放音乐或在后台下载文件，除非系统内存不足，否则系统会尽量维持服务进程的运行。</p><ul><li>如果一个进程中运行着一个 <code>Service</code>，并且这个 <code>service</code> 是通过 <code>startService</code> 开启的，那这个进程就是一个服务进程。</li></ul></li><li><p><strong>后台进程</strong></p><p>系统会把后台进程（<code>Background Process</code>）保存在一个 <code>LruCache</code> 列表中，因为终止后台进程对用户体验影响不大，所以系统会酌情清理部分后台进程。</p><p>你可以在 <code>Activity</code> 的 <code>onSaveInstanceState()</code> 方法中保存一些数据，以免在应用在后台被系统清理掉后，用户已输入的信息被清空，导致要重新输入。</p><ul><li>当进程持有一个用户不可见的 <code>Activity</code>（<code>Activity</code> 的 <code>onStop()</code> 方法被调用），但是 <code>onDestroy</code> 方法没有被调用，这个进程就会被系统认定为后台进程。</li></ul></li><li><p><strong>空进程</strong>：当一个进程不包含任何活跃的应用组件，则被系统认定为是空进程。</p><p>系统保留空进程的目的是为了加快下次启动进程的速度。</p></li></ol><h2 id="6-3-内存抖动"><a href="#6-3-内存抖动" class="headerlink" title="6.3 内存抖动"></a>6.3 内存抖动</h2><p>当我们在短时间内频繁创建大量临时对象时，就会引起内存抖动，比如在一个 <code>for</code> 循环中创建临时对象实例。</p><p>内存检测表现如下<br><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/20200412160136.png" alt=""></p><p><strong>预防的方法</strong></p><ol><li>尽量避免在循环体中创建对象</li><li>尽量不要在自定义 <code>View</code> 的 <code>onDraw()</code> 方法中创建对象，因为这个方法会被频繁调用</li><li>对于能够复用的对象，可以考虑使用对象池把它们缓存起来</li></ol><hr><h1 id="7-Android-Bitmap-内存分配的变化"><a href="#7-Android-Bitmap-内存分配的变化" class="headerlink" title="7 Android Bitmap 内存分配的变化"></a>7 <strong>Android Bitmap 内存分配的变化</strong></h1><ul><li>在 <code>Android 3.0</code> 之前，<code>Bitmap</code> 对象放在 <code>Java</code> 堆，而像素数据是放在 <code>Native</code> 内存中。如果不手动调用 <code>recycle</code>，<code>Bitmap Native</code> 内存的回收完全依赖 <code>finalize</code> 函数回调，这个时机不太可控。</li><li><code>Android 3.0～Android 7.0</code> 将 <code>Bitmap</code> 对象和像素数据统一放到 <code>Java</code> 堆中，这样就算我们不调用 <code>recycle</code>，<code>Bitmap</code> 内存也会随着对象一起被回收。不过 <code>Bitmap</code> 是内存消耗的大户，把它的内存放到 <code>Java</code> 堆中似乎不是那么美妙。即使是华为 <code>Mate 20</code>，最大的 <code>Java</code> 堆限制也才到 512MB，可能我的物理内存还有 5GB，但是应用还是会因为<code>Java</code> 堆内存不足导致 <code>OOM</code>。<code>Bitmap</code> 放到 <code>Java</code> 堆的另外一个问题会引起大量的 <code>GC</code>，对系统内存也没有完全利用起来。</li><li>有没有一种实现，可以将 <code>Bitmap</code> 内存放到 <code>Nativ</code>e 中，也可以做到和对象一起快速释放，同时 <code>GC</code> 的时候也能考虑这些内存防止被滥用？<code>NativeAllocationRegistry</code> 可以一次满足你这三个要求，<code>Android 8.0</code> 正是使用这个辅助回收 <code>Native</code> 内存的机制，来实现像素数据放到 <code>Native</code> 内存中。<code>Android 8.0</code> 还新增了硬件位图 <code>Hardware Bitmap</code>，它可以减少图片内存并提升绘制效率。</li></ul><hr><h1 id="8-内存优化的两个误区"><a href="#8-内存优化的两个误区" class="headerlink" title="8 内存优化的两个误区"></a>8 内存优化的两个误区</h1><h2 id="8-1-内存占用越少越好。"><a href="#8-1-内存占用越少越好。" class="headerlink" title="8.1 内存占用越少越好。"></a>8.1 内存占用越少越好。</h2><ol><li>有些人认为内存是洪水猛兽，占用越少应用的性能越好，这种认识在具体的优化过程中很容易“用力过猛”。</li><li>应用是否占用了过多的内存，跟设备、系统和当时情况有关，而不是 <code>300MB</code>、<code>400MB</code> 这样一个绝对的数值。当系统内存充足的时候，我们可以多用一些获得更好的性能。当系统内存不足的时候，希望可以做到“用时分配，及时释放”</li></ol><h2 id="8-2-Native-内存不用管"><a href="#8-2-Native-内存不用管" class="headerlink" title="8.2 Native 内存不用管"></a>8.2 <code>Native</code> 内存不用管</h2><ol><li>虽然 <code>Android 8.0</code> 重新将 <code>Bitmap</code> 内存放回到 <code>Native</code> 中，那么我们是不是就可以随心所欲地使用图片呢？</li><li>答案当然是否定的。正如前面所说当系统物理内存不足时，<code>lmk</code> 开始杀进程，从后台、桌面、服务、前台，直到手机重启。</li></ol><hr><h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a><strong>感谢</strong></h1><blockquote><p><a href="https://time.geekbang.org/column/article/74044" target="_blank" rel="noopener">极客时间 Android开发高手课</a>  </p><p><a href="https://coding.imooc.com/learn/list/308.html" target="_blank" rel="noopener">慕课 Top团队大牛带你玩转Android性能分析与优化</a></p><p><a href="https://juejin.im/post/5d3ada056fb9a07eb94fd1bc#heading-3" target="_blank" rel="noopener">探索 Android 内存优化方法</a></p><p><a href="https://juejin.im/post/5d3a870df265da1b855c9d41#heading-15" target="_blank" rel="noopener">探索 Java 内存管理机制</a></p><p><a href="https://juejin.im/post/58b18e442f301e0068028a90" target="_blank" rel="noopener">Android性能优化（三）之内存管理</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生财有术日历</title>
      <link href="/2020/sheng-cai-you-zhu-ri-li.html"/>
      <url>/2020/sheng-cai-you-zhu-ri-li.html</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>日期</th><th align="left">内容</th><th>完整原文链接<br/>(有可能需要付费加入才能观看)</th></tr></thead><tbody><tr><td>1.1</td><td align="left">有钱赚的时候，要集中所有的资源和精力，All in，不要小富即安。<br/>过几年你会拍大腿，那么好的捡钱的机会，为什么错过了。<br/>居安思危才能活得足够长久，富一次的人很多，富一辈子的人很少。</td><td><a href="https://t.zsxq.com/3rrRbMR" target="_blank" rel="noopener">https://t.zsxq.com/3rrRbMR</a></td></tr><tr><td>1.2</td><td align="left">引流也好、裂变也罢，核心仍然是提供价值。<br/>总会有认同价值的，也总会有怀疑价值的，我们不能因为50%的怀疑价值的人，而放弃为剩下的50%的人提供价值的机会。<br/>引流、裂变、发售、势能都是术而已，掌握术容易，术也能带来更快的收益，但不变的是道：核心价值。</td><td><a href="https://t.zsxq.com/2zNrNNr" target="_blank" rel="noopener">https://t.zsxq.com/2zNrNNr</a></td></tr><tr><td>1.3</td><td align="left">我现在创业，期待越轻越好，越产品化越好，最好把内容环节都省掉才觉得好，把增长模块都做到产品中去，只要第一波倒入流量，后面就可以自发增长和变现了。</td><td><a href="https://t.zsxq.com/rVzvzVb" target="_blank" rel="noopener">https://t.zsxq.com/rVzvzVb</a></td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>App 初体验-启动优化💦</title>
      <link href="/2019/start-optimization.html"/>
      <url>/2019/start-optimization.html</url>
      
        <content type="html"><![CDATA[<p>Android 性能第一篇，随着项目功能的迭（zeng）代（jia），启动速度也会受到影响，性能优化之路的第一步，也就是启动优化，个人认为非常重要，它可以直接影响 <code>APP</code> 的留存率，没有人希望自己应用半天打不开。这篇文章就带你解决🌞用户初体验-启动优化🌞。</p><p><strong>注意：如果出现图片不显示问题请移步</strong> <a href="https://calmcenter.club/2019/PicNotShow.html">图片不显示问题</a></p><h1 id="本文主要记载"><a href="#本文主要记载" class="headerlink" title="本文主要记载"></a>本文主要记载</h1><ul><li><strong>1 启动</strong></li><li><strong>2 检测启动消耗<code>(敲黑板)</code></strong><ul><li>2.1 启动时间测量方式<ul><li>2.1.1 adb 命令启动时间测量方式</li><li>2.1.2 手动打点</li></ul></li><li>2.2 启动耗时检测方式<ul><li>2.2.1 TraceView</li><li>2.2.2 systrace</li><li>2.2.3 systrace + 函数插桩 AOP</li></ul></li></ul></li><li><strong>3 启动优化<code>(干货)</code></strong><ul><li>3.1 闪屏页展示</li><li>3.2 异步启动实践</li><li>3.3 数据重排</li><li>3.4 类的加载</li><li>3.5 延迟加载方案 IdleHandler</li><li>3.6 其他优化思路</li></ul></li></ul><hr><h1 id="1-启动"><a href="#1-启动" class="headerlink" title="1 启动"></a>1 启动</h1><p>Google官方文档 <a href="https://developer.android.com/topic/performance/launch-time.html" target="_blank" rel="noopener">《Launch-Time Performance》</a> 对应用启动优化的概述</p><p>应用的启动分为冷启动、热启动、温启动，而启动最慢、挑战最大的就是冷启动：系统和App本身都有更多的工作要从头开始！我们只要知道我们处理的是冷启动的情况。</p><hr><h1 id="2-检测启动消耗-敲黑板"><a href="#2-检测启动消耗-敲黑板" class="headerlink" title="2 检测启动消耗(敲黑板)"></a>2 检测启动消耗<code>(敲黑板)</code></h1><p>“工欲善其事必先利其器”，我们需要先找到一款适合做启动优化分析的工具。</p><h2 id="2-1-启动时间测量方式"><a href="#2-1-启动时间测量方式" class="headerlink" title="2.1 启动时间测量方式"></a>2.1 启动时间测量方式</h2><h3 id="2-1-1-adb-命令启动时间测量方式"><a href="#2-1-1-adb-命令启动时间测量方式" class="headerlink" title="2.1.1 adb 命令启动时间测量方式"></a>2.1.1 adb 命令启动时间测量方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am start -W packagename&#x2F;packagename.Activity</span><br></pre></td></tr></table></figure><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/20190829115742.png" alt=""></p><p>划掉的红色部分都是包名</p><table><thead><tr><th>字段</th><th>功能</th></tr></thead><tbody><tr><td>ThisTime</td><td>最后一个 Activity 启动耗时</td></tr><tr><td>TotalTIme</td><td>所有 Activity 启动耗时，比如添加启动页</td></tr><tr><td>WaitTime</td><td>AMS 启动 Activity 的总耗时</td></tr><tr><td>ThisTime ≤ TotalToime &lt; WaitTime</td><td></td></tr></tbody></table><p>线下方便使用、可以测量竞品、不能带到线上</p><h3 id="2-1-2-手动打点"><a href="#2-1-2-手动打点" class="headerlink" title="2.1.2 手动打点"></a>2.1.2 手动打点</h3><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LaunchTimer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> sTime;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startRecord</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sTime = System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">endRecord</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        endRecord(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">endRecord</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> cost = System.currentTimeMillis() - sTime;</span><br><span class="line">        LogUtils.e(<span class="string">"LaunchTimer"</span>, msg + <span class="string">" cost "</span> + cost);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在应用启动中，我们所能接收到最早的回调是 <code>Application</code> 中 <code>attachBaseContext(Context context)</code> ，所以只能将 <code>startRecord()</code> 写到这个回调中</p><p>应用启动的结束时间，是用户可操作的时间，先了解两个误区</p><p><code>onAttachedToWindow()</code> 这个方法是在 <code>onResume</code> 之后，只调用一次</p><p><code>onWindowFocusChanged(boolean hasFocus)</code> 这个方法是在获取焦点和失去焦点是调用，在 <code>onAttachedToWindow()</code> 之后调用</p><p>这两个方法，回调时，用户并不可以操作，计算启动耗时的最好的时机应该是某个数据被加载出来后，当然会掺杂一些网络因素，但这里不是为了数据，只是为了用户体验，可以使用一些监听方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mView.getViewTreeObserver().addOnPreDrawListener(<span class="keyword">new</span> ViewTreeObserver.OnPreDrawListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onPreDraw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mView.getViewTreeObserver().removeOnPreDrawListener(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">mView.getViewTreeObserver().addOnDrawListener(<span class="keyword">new</span> ViewTreeObserver.OnDrawListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mView.getViewTreeObserver().removeOnDrawListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在 View 将要绘制的时候去进行耗时的统计，<code>addOnDrawListener()</code> 需要 <code>API 16</code></p><h2 id="2-2-启动耗时检测方式"><a href="#2-2-启动耗时检测方式" class="headerlink" title="2.2 启动耗时检测方式"></a>2.2 启动耗时检测方式</h2><h3 id="2-2-1-TraceView"><a href="#2-2-1-TraceView" class="headerlink" title="2.2.1 TraceView"></a>2.2.1 TraceView</h3><p>图形化界面的形式展示出执行时间、调用栈，包含所有线程，信息全面</p><p>但是加入 <code>TraceView</code> 的代码后，运行时开销严重，整体都会变慢，可能会带骗优化方向</p><ul><li>通过代码跟踪💦</li></ul><p>只能用于某一个方法的检测</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Debug.startMethodTracing(&quot;xxx&quot;);</span><br><span class="line">...</span><br><span class="line">Debug.stopMethodTracing();</span><br></pre></td></tr></table></figure><p>默认生成文件在 <code>mnt/sdcard/Android/data/packagename/fils</code>  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb pull &#x2F;sdcard&#x2F;Android&#x2F;data&#x2F;packagename&#x2F;fils&#x2F;my.trace</span><br></pre></td></tr></table></figure><p>这样可以将 <code>trace</code> 文件拷贝到项目根目录</p><p>也可以通过 <code>Device File Explorer</code>(AS 右下角) 找到文件，右键点击 <code>Sava as…</code></p><ul><li>通过命令跟踪💦</li></ul><p>可用于整个开始结束的过程(内容会比较多~)</p><p>开始跟踪</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am start -n packagename&#x2F;packagename.Activity --start-profiler &#x2F;data&#x2F;local&#x2F;tmp&#x2F;my.trace --sampling 1000</span><br></pre></td></tr></table></figure><p>终止跟踪</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am profile stop</span><br></pre></td></tr></table></figure><p>拉取文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb pull &#x2F;data&#x2F;local&#x2F;tmp&#x2F;my.trace</span><br></pre></td></tr></table></figure><p>这种方法可以检测启动到调用终止期间的全部内容，但是有些手机出来的 <code>trace</code> 文件时 <code>0B</code>，这就需要在需要停止的地方写上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Debug.stopMethodTracing();</span><br></pre></td></tr></table></figure><p>然后调用开始追踪，会自动停止。文件会放在 <code>data/local/tmp</code> 下。</p><ul><li>查看 Trace 文件💦<br><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/20191126115732.png" alt=""></li></ul><p>这就是用 <code>AndroidStudio</code> 查看生成的 <code>TraceView</code> 文件</p><ol><li><p>范围选择</p><p>标有 <code>Cpu usage details unavailable</code> 的地方可以选择时间范围；标有 ·THREADS· 的地方可以选择某条线程，括号中的 <code>67</code> 表示检测全称有 <code>67</code> 条线程。选择时间或线程底部的 <code>Call Chart</code> 都会有相应的变化。</p></li><li><p>执行选择</p><p>在线程选择下有一个 <code>Wall Clock Time</code> 这个表示真正执行的时间，可以切换为 <code>Thread Time</code> 表示 <code>CPU</code> 执行的时间，<code>Thread Time</code> 始终小于 <code>Wall Clock Time</code>。</p></li><li><p>CallChart</p><p>从上到下，调用者在上方，被调用者在下方；<code>系统 API</code> 是橙色、<code>应用自身调用</code> 是绿色、<code>第三方 API</code> 是蓝色，看绿色的部分很直观的可以看出我们自己代码在哪里耗时了~</p></li><li><p>TopDown</p></li></ol><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/20191126121637.png" alt=""></p><table><thead><tr><th>标题</th><th>作用</th></tr></thead><tbody><tr><td><strong>Total</strong></td><td>整个函数执行时间</td></tr><tr><td><strong>Self</strong></td><td>函数代码内执行时间</td></tr><tr><td><strong>Children</strong></td><td>子函数耗时</td></tr></tbody></table><p>🌞举个栗子🌞：调用 <code>A</code> 函数整体时间是 <code>Total</code> ，在函数中执行了一行代码耗时 <code>Self</code> ，然后调用 <code>B</code> 函数耗时 <code>Children</code></p><p>这两个方式是比较常用的方式，如果是应用自身方法都可以点击右键进入源码所在位置。</p><ul><li>总结💦</li></ul><ol><li>运行时开销严重，整体都会变慢(因为 <code>TraceView</code> 要抓取所有线程的所有执行函数以及顺序)</li><li>可能会带偏优化方向(本来不好时间的函数可能加入 <code>TraceView</code> 后，变的非常耗时)</li></ol><h3 id="2-2-2-systrace"><a href="#2-2-2-systrace" class="headerlink" title="2.2.2 systrace"></a>2.2.2 systrace</h3><p>结合 Android 内核的数据，生成 HTML 报告，<code>API 18</code> 以上，推荐 <code>TraceCompat</code></p><ul><li>首先清空后台💦</li></ul><p>杀掉所有应用，防止出现莫名莫名方法。</p><ul><li>在需要检测的地方写入代码(可以不写，但是会少一些 tag 提示)💦</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TraceCompat.beginSection(&quot;AppOnCreate&quot;);</span><br><span class="line">...</span><br><span class="line">TraceCompat.endSection();</span><br></pre></td></tr></table></figure><ul><li>执行检测💦</li></ul><p>首先进入 <code>SDK</code> 目录，<code>Sdk\platform-tools\systrace\</code> 目录下有一个 <code>systrace.py</code> 文件，打开 <code>cmd</code> 输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python systrace.py -b 32768 -t 5 -a &lt;packagename&gt; -o test.log.html sched gfx view wm am</span><br></pre></td></tr></table></figure><p>这种方式是 <code>5</code> 秒后自动输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python systrace.py gfx view wm am pm ss dalvik sched -b 32768 -a &lt;packagename&gt; -o test.log.html</span><br></pre></td></tr></table></figure><p>这种方式可以在自己收集完后，点击 <code>Enter</code> 键停止收集</p><p>两种内容是不太一样的， <code>-t</code> 表示时间，<code>-a</code> 表示包名，<code>-o</code> 输出文件名，最终在当前目录打开文件即可看到，文件只能使用 <code>Chrome</code> 来打开，如果打开 <code>HTML</code> 出现 </p><p><code>Unable to select a master clock domain because no path can be found from &quot;SYSTRACE&quot; to &quot;LINUX_FTRACE_GLOBAL&quot;.</code></p><p>那就是命令出错了，命令我也是收集了好久，一定要注意必须是 <code>python 2.x</code>，而不是能 <code>3.x</code>，否则可能会出现问题。另外，<code>buffer</code> 大小不可过大，否则会出现 <code>oom</code> 异常。最终找到可用的，想了解更多的请查看 <a href="http://gityuan.com/2016/01/17/systrace/" target="_blank" rel="noopener">Gityuan</a> 或 <a href="https://source.android.com/devices/tech/debug/systrace" target="_blank" rel="noopener">官方文档</a> </p><ul><li>分析文件</li></ul><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/20191212120416.png" alt=""></p><p>这里可以看到 <code>CPU</code> 核心数以及运行状态，还有各个线程。</p><p>在 <code>UI Thread</code> 中的 <code>AppOnCreate</code> 正是我们在之前的代码埋 <code>tag</code> 点，点击条目并按 <code>M</code> 键可以查看具体信息。右上角是可以搜索 <code>tag</code> 的。</p><p>具体信息中有 <code>Wall Duration</code> （代码执行时间） <code>CPU Duration</code> （代码消耗 CPU 的时间）两者出现差值的原因是同步锁冲突。 </p><p>这种方式不仅可以帮助监控启动过程中性能问题，卡顿优化的时候也可以用这种方式。因为它会把 <code>UI</code> 的渲染也检测到。</p><ul><li>总结💦</li></ul><ol><li>轻量级，开销小</li><li>直观的反应 CPU 利用率</li></ol><p>想要了解更多，全力推荐 <a href="https://www.androidperformance.com/2019/05/28/Android-Systrace-About/" target="_blank" rel="noopener">Android Systrace</a> </p><h3 id="2-2-3-systrace-函数插桩-AOP-Aspect-Oriented-Programming"><a href="#2-2-3-systrace-函数插桩-AOP-Aspect-Oriented-Programming" class="headerlink" title="2.2.3 systrace + 函数插桩 AOP(Aspect Oriented Programming)"></a>2.2.3 systrace + 函数插桩 AOP(Aspect Oriented Programming)</h3><hr><p> 面向切面编程，针对同一类问题的统一处理，无侵入添加代码。</p><p>在根目录的 <code>build.gradle</code> 下，最新版本请查看 <a href="https://github.com/HujiangTechnology/gradle_plugin_android_aspectjx" target="_blank" rel="noopener">AspectJX 开源地址</a></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classpath <span class="string">'com.hujiang.aspectjx:gradle-android-plugin-aspectjx:2.0.8'</span></span><br></pre></td></tr></table></figure><p>在 <code>app</code> 模块下添加如下，通过我的测试这些引用只能添加在 <code>app</code> 模块下，添加在其他子模块下不生效。最新版本请查看 <a href="http://www.eclipse.org/aspectj/downloads.php#stable_release" target="_blank" rel="noopener">AspectJ官网</a></p><p>顶部</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">'android-aspectjx'</span></span><br></pre></td></tr></table></figure><p><code>dependencies</code> 内</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">api <span class="string">'org.aspectj:aspectjrt:1.9.5'</span></span><br></pre></td></tr></table></figure><p>下面是通过注解的方式结合 <code>Systrace</code> 进行埋点。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AnnotationRetention.SOURCE：不存储在编译后的 Class 文件。</span></span><br><span class="line"><span class="comment"> * AnnotationRetention.BINARY：存储在编译后的 Class 文件，但是反射不可见。</span></span><br><span class="line"><span class="comment"> * AnnotationRetention.RUNTIME：存储在编译后的 Class 文件，反射可见。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Retention(AnnotationRetention.RUNTIME)</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AnnotationTarget.CLASS：类，接口或对象，注解类也包括在内。</span></span><br><span class="line"><span class="comment"> * AnnotationTarget.ANNOTATION_CLASS：只有注解类。</span></span><br><span class="line"><span class="comment"> * AnnotationTarget.TYPE_PARAMETER：Generic type parameter (unsupported yet)通用类型参数（还不支持）。</span></span><br><span class="line"><span class="comment"> * AnnotationTarget.PROPERTY：属性。</span></span><br><span class="line"><span class="comment"> * AnnotationTarget.FIELD：字段，包括属性的支持字段。</span></span><br><span class="line"><span class="comment"> * AnnotationTarget.LOCAL_VARIABLE：局部变量。</span></span><br><span class="line"><span class="comment"> * AnnotationTarget.VALUE_PARAMETER：函数或构造函数的值参数。</span></span><br><span class="line"><span class="comment"> * AnnotationTarget.CONSTRUCTOR：仅构造函数（主函数或者第二函数）。</span></span><br><span class="line"><span class="comment"> * AnnotationTarget.FUNCTION：方法（不包括构造函数）。</span></span><br><span class="line"><span class="comment"> * AnnotationTarget.PROPERTY_GETTER：只有属性的 getter。</span></span><br><span class="line"><span class="comment"> * AnnotationTarget.PROPERTY_SETTER：只有属性的 setter。</span></span><br><span class="line"><span class="comment"> * AnnotationTarget.TYPE：类型使用。</span></span><br><span class="line"><span class="comment"> * AnnotationTarget.EXPRESSION：任何表达式。</span></span><br><span class="line"><span class="comment"> * AnnotationTarget.FILE：文件。</span></span><br><span class="line"><span class="comment"> * AnnotationTarget.TYPEALIAS：<span class="doctag">@SinceKotlin</span>("1.1") 类型别名，Kotlin1.1已可用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(AnnotationTarget.FUNCTION)</span></span><br><span class="line"><span class="keyword">annotation</span> <span class="class"><span class="keyword">class</span> <span class="title">TraceCompat</span></span></span><br></pre></td></tr></table></figure><p>具体的切入代码，需要将 <code>packagename</code> 换成自己的路径名字</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TraceCompatAspect</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Pointcut(<span class="meta-string">"execution(@packagename.TraceCompat * *(..))"</span>)</span> <span class="comment">//方法切入点</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">methodAnnotated</span><span class="params">()</span></span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(<span class="meta-string">"methodAnnotated()"</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">aroundJoinPoint</span><span class="params">(joinPoint: <span class="type">ProceedingJoinPoint</span>)</span></span> &#123;</span><br><span class="line">        TraceCompat.beginSection(<span class="string">"TraceCompat"</span>)</span><br><span class="line">        <span class="comment">//执行原方法</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            joinPoint.proceed()</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            TraceCompat.endSection()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在需要埋点的加入注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TraceCompat</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就完成了 <code>AOP</code> 埋点辅助<code>systrace</code> 监控的方式。<code>AOP</code> 还有很多更强大更方便的用法，这里只是一种注解切入的方式。更多用法请查看其它文章。</p><p>由于我现在使用 <code>AOP</code> 还存在很多问题，还在研究中。。。(上面的例子是可以使用的)</p><h3 id="2-2-4-Nanoscope"><a href="#2-2-4-Nanoscope" class="headerlink" title="2.2.4 Nanoscope"></a>2.2.4 Nanoscope</h3><p>还未使用过 ~ </p><p>在<a href="https://time.geekbang.org/column/article/74044" target="_blank" rel="noopener">极客时间 《Android开发高手课》</a>   中提到了 <a href="https://github.com/uber/nanoscope" target="_blank" rel="noopener">Nanoscope</a> ，它是在 <code>instrument</code> 类型的性能分析工具中性能损耗比较小的。</p><p>它的实现原理是直接修改 <code>Android</code> 虚拟机源码，在 <code>ArtMethod</code> 执行入口和执行结束位置增加埋点代码，将所有的信息先写到内存，等到 <code>trace</code> 结束后才统一生成结果文件。在使用过程可以明显感觉到应用不会因为开启 <code>Nanoscope</code> 而感到卡顿，但是 <code>trace</code> 结束生成结果文件这一步需要的时间比较长。<strong>另一方面它可以支持分析任意一个应用，可用于做竞品分析。</strong></p><p>但是它也有不少限制：</p><ul><li>需要自己刷 <code>ROM</code>，并且当前只支持 <code>Nexus 6P</code>，或者采用其提供的 <code>x86</code> 架构的模拟器。</li><li>默认只支持主线程采集，其他线程需要 <a href="https://github.com/uber/nanoscope/wiki/Architecture%3A-Nanoscope-ROM#java-api" target="_blank" rel="noopener">代码手动设置</a> 。考虑到内存大小的限制，每个线程的内存数组只能支持大约 <code>20</code> 秒左右的时间段。</li></ul><p><code>Uber</code> 写了一系列自动化脚本协助整个流程，使用起来还算简单。<code>Nanoscope</code> 作为基本没有性能损耗的 <code>instrument</code> 工具，它非常适合做启动耗时的自动化分析。</p><p><code>Nanoscope</code> 生成的是符合 <code>Chrome tracing</code> 规范的 <code>HTML</code> 文件。我们可以通过脚本来实现两个功能：</p><p>第一个是反混淆。通过 <code>mapping</code> 自动反混淆结果文件。</p><p>第二个是自动化分析。传入相同的起点和终点，实现两个结果文件的<code>diff</code>，自动分析差异点。</p><p>这样我们可以每天定期去跑自动化启动测试，查看是否存在新增的耗时点。</p><hr><h1 id="3-启动优化-干货"><a href="#3-启动优化-干货" class="headerlink" title="3 启动优化(干货)"></a>3 启动优化<code>(干货)</code></h1><h2 id="3-1-闪屏页展示"><a href="#3-1-闪屏页展示" class="headerlink" title="3.1 闪屏页展示"></a>3.1 闪屏页展示</h2><p>闪屏页是优化启动速度的一个小技巧，虽然对实际的启动速度没有任何帮助，但是能让用户感觉应用到应用在第一时间已经被打开。</p><p>合并闪屏和主页面的 Activity，减少一个 Activity 会给线上带来 100 毫秒左右的优化。但是如果这样做的话，管理时会非常复杂。</p><p>闪屏如果存在网络请求，一般都是提前准备好闪屏页的，在下一次生效。</p><p>具体操作文末参考中会有 ~ 这里不再说明。</p><h2 id="3-2-异步启动实践"><a href="#3-2-异步启动实践" class="headerlink" title="3.2 异步启动实践"></a>3.2 异步启动实践</h2><h3 id="3-2-1-启动器"><a href="#3-2-1-启动器" class="headerlink" title="3.2.1 启动器"></a>3.2.1 启动器</h3><p>微信内部使用的 <a href="https://mp.weixin.qq.com/s/6Q818XA5FaHd7jJMFBG60w?" target="_blank" rel="noopener">mmkernel</a></p><p>阿里最近开源的 <a href="https://github.com/alibaba/alpha" target="_blank" rel="noopener">Alpha</a> 启动框架</p><p><a href="https://yq.aliyun.com/articles/710466" target="_blank" rel="noopener">历时1年，上百万行代码！首次揭秘手淘全链路性能优化（上）</a> </p><p>慕课网中学习到的 启动器 <code>Task</code> </p><p>它们为各个任务建立依赖关系，最终构成一个有向无环图。对于可以并发的任务，会通过线程池最大程度提升启动速度。</p><h3 id="3-2-1-异步Layout子线程预加载"><a href="#3-2-1-异步Layout子线程预加载" class="headerlink" title="3.2.1 异步Layout子线程预加载"></a>3.2.1 异步Layout子线程预加载</h3><p>参考文章 <a href="https://juejin.im/post/5d63cdf7f265da03ed195f68?utm_source=gold_browser_extension#comment" target="_blank" rel="noopener">Android - 一种新奇的冷启动速度优化思路(Fragment极度懒加载 + Layout子线程预加载)</a> </p><p>遇到个点，如果 <code>xml</code> 中是 <code>com.google.android.material.appbar.AppBarLayout</code> 等 <code>google</code> 包里的，需要加上一条属性</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:theme="@style/Theme.AppCompat.Light.DarkActionBar"</span><br></pre></td></tr></table></figure><p>这个属性与自己 <code>Activity</code> 的 <code>theme</code> 相对应。</p><p> <a href="https://github.com/luckybilly/PreLoader" target="_blank" rel="noopener">预加载：页面启动速度优化利器 PreLoader</a></p><h2 id="3-3-数据重排"><a href="#3-3-数据重排" class="headerlink" title="3.3 数据重排"></a>3.3 数据重排</h2><p>支付宝 <a href="https://mp.weixin.qq.com/s/79tAFx6zi3JRG-ewoapIVQ" target="_blank" rel="noopener">《通过安装包重排布优化 Android 端启动性能》</a></p><h2 id="3-4-类重排"><a href="#3-4-类重排" class="headerlink" title="3.4 类重排"></a>3.4 类重排</h2><p>本人费劲心血自己自己实现了一次~ <a href="https://calmcenter.club/2020/package-optimization.html#Redex-Ubuntu-具体实践">Redex Ubuntu 实现</a> </p><p>更多资料：</p><p><code>Facebook</code> 开源的 Dex 优化工具 <a href="https://github.com/facebook/redex/blob/master/docs/Interdex.md" target="_blank" rel="noopener">ReDex</a> </p><p><a href="https://mp.weixin.qq.com/s/Bf41Kez_OLZTyty4EondHA?" target="_blank" rel="noopener">Redex 初探与 Interdex：Andorid 冷启动优化</a></p><p><a href="https://mp.weixin.qq.com/s/Hquq8iJvZuN-gynVFxCCNA" target="_blank" rel="noopener">都9102年了，Android 冷启动优化除了老三样还有哪些新招？</a></p><h2 id="3-5-延迟加载方案-IdleHandler"><a href="#3-5-延迟加载方案-IdleHandler" class="headerlink" title="3.5 延迟加载方案 IdleHandler"></a>3.5 延迟加载方案 IdleHandler</h2><p>利用 <code>IdleHandler</code> 特性，空闲时执行初始化。</p><p><strong><code>IdleHandler</code> 可以用来提升性能，主要用在我们希望能够在当前线程消息队列空闲时做些事情</strong> （譬如 <code>UI</code> 线程在显示完成后，如果线程空闲我们就可以提前准备其他内容）的情况下，不过最好不要做耗时操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Looper.myQueue().addIdleHandler(new IdleHandler() &#123;  </span><br><span class="line">    @Override  </span><br><span class="line">    public boolean queueIdle() &#123;  </span><br><span class="line">        &#x2F;&#x2F;你要处理的事情</span><br><span class="line">        return false;    </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果返回 <code>true</code>, 则会一直执行，如果返回 <code>false</code>，执行完一次后就会被移除消息队列。我们可以将从服务器获取推送 <code>Token</code> 的任务放在延迟 <code>IdleHandler</code>中执行，或者把一些不重要的 <code>View</code> 的加载放到 <code>IdleHandler</code> 中执行</p><h2 id="3-6-其他优化思路"><a href="#3-6-其他优化思路" class="headerlink" title="3.6 其他优化思路"></a>3.6 其他优化思路</h2><h3 id="AndroidX-App-Startup"><a href="#AndroidX-App-Startup" class="headerlink" title="AndroidX App Startup"></a>AndroidX App Startup</h3><p><code>App</code> 启动运行时会初始化一些逻辑，它们为了方便开发者使用，避免开发者手动调用，使用 <code>ContentProvider</code> 进行初始化</p><ul><li>多个 <code>ContentProvider</code> 会增加了 <code>App</code> 启动运行的时间。</li><li><code>ContentProvider</code> 的 <code>onCreate</code> 方法会先于 <code>Application</code> 的 <code>OnCreate</code> 方法执行，这是在冷启动阶段自动运行初始化的，</li></ul><p>这样只会增加 <code>App</code> 的加载时间，用户希望 <code>App</code> 加载得快，启动慢会带来糟糕的用户体验，<code>AndroidX App Startup</code> 正是为了解决这个问题而出现的。</p><p><a href="https://developer.android.com/topic/libraries/app-startup" target="_blank" rel="noopener">App Startup</a>   <a href="https://juejin.im/post/5ee4bbe4f265da76b559bdfe?utm_source=gold_browser_extension#comment" target="_blank" rel="noopener">Jetpack 最新成员 AndroidX App Startup 实践以及原理分析</a> </p><h3 id="5-0-以下机型-MultiDex-优化"><a href="#5-0-以下机型-MultiDex-优化" class="headerlink" title="5.0 以下机型 MultiDex 优化"></a><code>5.0</code> 以下机型 <code>MultiDex</code> 优化</h3><p><a href="https://juejin.im/post/5d95f4a4f265da5b8f10714b?utm_source=gold_browser_extension#comment" target="_blank" rel="noopener">面试官：今日头条启动很快，你觉得可能是做了哪些优化？</a></p><h3 id="GC-优化"><a href="#GC-优化" class="headerlink" title="GC 优化"></a>GC 优化</h3><p>支付宝提出一种 <a href="https://mp.weixin.qq.com/s/ePjxcyF3N1vLYvD5dPIjUw" target="_blank" rel="noopener">GC 抑制</a> 的方案</p><p>在启动过程，要尽量减少 <code>GC</code> 的次数，避免造成主线程长时间的卡顿。</p><p>特别是对 <code>Dalvik</code> 来说，我们可以通过 <code>systrace</code> 单独查看整个启动过程 <code>GC</code> 的时间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python systrace.py dalvik -b 90960 -a com.sample.gc</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GC使用的总耗时，单位是毫秒</span></span><br><span class="line">Debug.getRuntimeStat(<span class="string">"art.gc.gc-time"</span>);</span><br><span class="line"><span class="comment">// 阻塞式GC的总耗时</span></span><br><span class="line">Debug.getRuntimeStat(<span class="string">"art.gc.blocking-gc-time"</span>);</span><br></pre></td></tr></table></figure><ul><li>避免进行大量的字符串操作，特别是序列化和反序列化</li><li>频繁创建的对象需要考虑复用</li><li>转移到 Native 实现</li></ul><p>参考 <a href="https://juejin.im/post/5be1077d518825171140dbfa" target="_blank" rel="noopener">支付宝客户端架构解析：Android 客户端启动速度优化之「垃圾回收」</a></p><h3 id="系统调用优化"><a href="#系统调用优化" class="headerlink" title="系统调用优化"></a>系统调用优化</h3><p>通过 <code>systrace</code> 的 System Service 类型，我们可以看到启动过程 <code>System Server</code> 的 CPU 工作情况。在启动过程，我们尽量不要做系统调用，例如 </p><ul><li><strong>启动过程中减少系统调用</strong>，避免与 <code>AMS</code>、<code>WMS</code> 竞争锁。启动过程中本身 <code>AMS</code> 和 <code>WMS</code> 的工作就很多，且 <code>AMS</code> 和 <code>WMS</code> 很多操作都是带锁的，如果此时 <code>App</code> 再有过多的 <code>Binder</code> 调用与 <code>AMS</code>、<code>WMS</code> 通信，<code>SystemServer</code> 就会出现大量的锁等待，阻塞关键操作</li><li><strong>启动过程中不要启动子进程</strong>，如果好几个进程同时启动，系统负担则会加倍，<code>SystemServer</code> 也会更繁忙</li><li><strong>启动过程中除了 Activity 之外的组件启动要谨慎</strong>，因为四大组件的启动都是在主线程的，如果组件启动慢，占用了 <code>Message</code> 通道，也会影响应用的启动速度</li><li><code>Application</code> 和主 <code>Activity</code> 的<code>onCreate</code> 中异步初始化某些代码</li></ul><p>在启动过程也不要过早地拉起应用的其他进程，System Server 和新的进程都会竞争 CPU 资源。</p><h3 id="线程优化"><a href="#线程优化" class="headerlink" title="线程优化"></a>线程优化</h3><p>线程优化就像做填空题和解锁题，我们希望能把所有的时间片都利用上，因此主线程和各个线程都是一直满载的。当然我们也希望每个线程都开足马力向前跑，而不是作为接力棒。所以线程的优化主要在于减少 CPU 调度带来的波动，让应用的启动时间更加稳定。</p><p>从具体的做法来看，线程的优化一方面是控制线程数量，线程数量太多会相互竞争 CPU 资源，因此要有统一的线程池，并且根据机器性能来控制数量。</p><p>3.2.1 启动器 提到，合理分配线程数量。</p><p>另一方面是检查线程间的锁。</p><h3 id="业务优化"><a href="#业务优化" class="headerlink" title="业务优化"></a>业务优化</h3><p>我们首先需要梳理清楚当前启动过程正在运行的每一个模块，哪些是一定需要的、哪些可以砍掉、哪些可以懒加载。</p><p>通过梳理之后，剩下的都是启动过程一定要用的模块。</p><p>这个时候，我们只能硬着头皮去做进一步的优化。优化前期需要“抓大放小”，先看看主线程究竟慢在哪里。</p><p>退而求其次，我们要考虑这些任务是不是可以通过异步线程预加载实现（上面有讲到），但需要注意的是过多的线程预加载会让我们的逻辑变得更加复杂。</p><h3 id="I-O-优化"><a href="#I-O-优化" class="headerlink" title="I/O 优化"></a>I/O 优化</h3><p>启动过程不建议出现网络 I/O</p><p>磁盘 I/O 是启动优化一定要抠的点</p><p>还有一个是数据结构的选择问题，我们在启动过程只需要读取 <code>Setting.sp</code> 的几项数据，不过 <code>SharedPreference</code> 在初始化的时候还是要全部数据一起解析。如果它的数据量超过 1000 条，启动过程解析时间可能就超过 100 毫秒。如果只解析启动过程用到的数据项则会很大程度减少解析时间，启动过程适合使用随机读写的数据结构。</p><h3 id="保活"><a href="#保活" class="headerlink" title="保活"></a>保活</h3><p>保活可以减少 Application 创建跟初始化的时间，让冷启动变成温启动。不过在 Target 26 之后，保活的确变得越来越难。</p><p>对于大厂来说，可能需要寻求厂商合作的机会，例如微信的 <a href="https://www.geekpark.net/news/233791" target="_blank" rel="noopener">Hardcoder</a> 方案和 <code>OPPO</code> 推出的 <code>Hyper Boost</code> 方案。根据<code>OPPO</code> 的数据，对于手机 <code>QQ</code>、淘宝、微信启动场景会直接有 20% 以上的优化。</p><p>有的时候你问为什么微信可以保活？为什么它可以运行的那么流畅？这里可能不仅仅是技术上的问题，当应用体量足够大，就可以倒逼厂商去专门为它们做优化。</p><h3 id="插件化和热修复"><a href="#插件化和热修复" class="headerlink" title="插件化和热修复"></a>插件化和热修复</h3><p>大部分的框架在设计上都存在大量的 Hook 和私有 <code>API</code> 调用，带来的缺点主要有两个：</p><ul><li>稳定性差。虽然大家都号称兼容 100% 的机型，由于厂商的兼容性、安装失败、<code>dex2oat</code> 失败等原因，还是会有那么一些代码和资源的异常。Android P 推出的 <code>non-sdk-interface</code> 调用限制，以后适配只会越来越难，成本越来越高。</li><li>性能差。Android Runtime 每个版本都有很多的优化，因为插件化和热修复用到的一些黑科技，导致底层 Runtime 的优化我们是享受不到的。Tinker 框架在加载补丁后，应用启动速度会降低 5%～10%。</li></ul><p>应用加固对启动速度来说简直是灾难，有时候我们需要做一些权衡和选择。</p><h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a><strong>感谢</strong></h1><blockquote><p><a href="https://time.geekbang.org/column/article/74044" target="_blank" rel="noopener">极客时间 Android开发高手课</a>  </p><p><a href="https://www.androidperformance.com/2019/11/18/Android-App-Lunch-Optimize/" target="_blank" rel="noopener">Android App 启动优化全记录</a> </p><p><a href="https://juejin.im/post/5be1077d518825171140dbfa" target="_blank" rel="noopener">支付宝客户端架构解析：Android 客户端启动速度优化之「垃圾回收」</a> </p><p>以及上文中的链接</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dalvik 寄存器</title>
      <link href="/2019/dalvikbase.html"/>
      <url>/2019/dalvikbase.html</url>
      
        <content type="html"><![CDATA[<h1 id="Dalvik-寄存器"><a href="#Dalvik-寄存器" class="headerlink" title="Dalvik 寄存器"></a>Dalvik 寄存器</h1><a id="more"></a><h2 id="寄存器命名法"><a href="#寄存器命名法" class="headerlink" title="寄存器命名法"></a>寄存器命名法</h2><h2 id="Dalvik-字节码"><a href="#Dalvik-字节码" class="headerlink" title="Dalvik 字节码"></a>Dalvik 字节码</h2><h2 id="Dalvik-指令集"><a href="#Dalvik-指令集" class="headerlink" title="Dalvik 指令集"></a>Dalvik 指令集</h2><p>Dalvik 指令在调用格式上模仿了 C 语言的调用约定。Dalvik 指令的语法与助记符有如下特点。</p><ul><li>参数采用从目标 (detination) 到 (source)的方式</li><li>根据字节码大小与类型的不同, 为一些字节码添加了名称后缀以消除歧义<ul><li>32 位常规类型的字节码未添加任何后缀。</li><li>64 位常规类型的字节码添加 -wide 后缀。</li><li>对特殊类型的字节码, 根据具体类型添加后缀, 可以使 -boolean、-byte、-char、-short、-int、-long、-float、-double、-object、-string、-class、-void中的一个</li></ul></li><li>根据字节码布局的选项不同, 为一些字节码添加了字节码后缀以消除歧义。这些后缀通过字节码主名称后添加斜杠来分割。</li><li>在指令集的描述中, 宽度值中的每个字母 都表示 4 位的宽度。</li></ul><h3 id="空操作指令"><a href="#空操作指令" class="headerlink" title="空操作指令"></a>空操作指令</h3><p>空操作指令的助记符为 nop, 它的值为 00。nop 指令通常用于对齐代码, 不进行实际操作。</p><h3 id="数据操作指令"><a href="#数据操作指令" class="headerlink" title="数据操作指令"></a>数据操作指令</h3><p>数据操作指令为 move, 其原型为 move destination, source。根据字节码大小与类型的不同, move 指令有不同的后缀, 如下：</p><table><thead><tr><th align="left"><strong>指令</strong></th><th align="left"><strong>描述</strong></th></tr></thead><tbody><tr><td align="left">move vA, vB</td><td align="left">指令用于将 vB 寄存器的值赋值给 vA 寄存器, <br/>源寄存器和目的寄存器都是 4 位</td></tr><tr><td align="left">move/from16 vAA, vBBBB</td><td align="left">指令用于将 vBBBB 寄存器的值赋值给 vAA 寄存器, <br/>源寄存器为 16 位, 目的寄存器为 8 位</td></tr><tr><td align="left">move/16 vAAAA, vBBBB</td><td align="left">指令用于将 vBBBB 寄存器的值赋值给 vAAAA 寄存器, <br>源寄存器和目的寄存器都是 16 位</td></tr><tr><td align="left">move-wide vA, vB</td><td align="left">指令用于为 4 位的寄存器对赋值, 源寄存器和目的寄存器都是 4 位</td></tr><tr><td align="left">move-wide/from16 vAA, vBBBB</td><td align="left">与 move-wide 相同</td></tr><tr><td align="left">move-wide/16 vAA, vBBBB</td><td align="left">与 move-wide 相同</td></tr><tr><td align="left">move-object vA,vB</td><td align="left">指令用于为对象赋值, 源寄存器和目的寄存器都是 4 位</td></tr><tr><td align="left">move-object/from16 vAA, vBBBB</td><td align="left">指令用于为对象赋值, 源寄存器为 16 位, 目的寄存器为 8 位</td></tr><tr><td align="left">move-object/16 vAAAA, vBBBB</td><td align="left">指令用于为对象赋值, 源寄存器和目的寄存器都是 16 位</td></tr><tr><td align="left">move-result vAA</td><td align="left">指令用于将上一个 invoke 类型指令操作的单字非对象结果赋给 vAA 寄存器</td></tr><tr><td align="left">move-result-wide vAA</td><td align="left">指令用于将上一个 invoke 类型指令操作的双字非对象结果赋给 vAA 寄存器</td></tr><tr><td align="left">move-result-object vAA</td><td align="left">指令用于将上一个 invoke 类型指令操作的对象结果赋给 vAA 寄存器</td></tr><tr><td align="left">move-exception vAA</td><td align="left">指令用于将一个在运行时发生的异常保存到 vAA 寄存器中。<br>这条指令必须在异常发生时由异常处理器使用, 否则指令无效</td></tr></tbody></table><h3 id="返回指令"><a href="#返回指令" class="headerlink" title="返回指令"></a>返回指令</h3><p>返回指令是指函数结束时运行的最后一条指令, 它的基础字节码为 return, 如下：  </p><table><thead><tr><th><strong>指令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>return-void</td><td>指令表示函数从一个 void 方法返回</td></tr><tr><td>return vAA</td><td>指令表示函数返回一个 32 位非对象类型的值, 返回值寄存器为 8 位的寄存器 vAA</td></tr><tr><td>return-wide vAA</td><td>指令表示函数返回一个 64 位非对象类型的值, 返回值寄存器为 8 位的寄存器对 vAA</td></tr><tr><td>return-object vAA</td><td>指令表示函数返回一个对象类型的值, 返回值为 8 位的寄存器 vAA</td></tr></tbody></table><h3 id="数据定义指令"><a href="#数据定义指令" class="headerlink" title="数据定义指令"></a>数据定义指令</h3><p>数据定义指令用来定义程序中用到的常量、字符串、类等数据, 它的基础字节码为 const, 如下：</p><table><thead><tr><th><strong>指令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>const/4 vA,#+B</td><td>指令用于将数值符号扩展为 32 位后赋给寄存器 vA</td></tr><tr><td>const/16 vAA,#+BBBB</td><td>指令用于将数值符号扩展为 32 位后赋给寄存器 vAA</td></tr><tr><td>const vAA,#+BBBBBBBB</td><td>指令用于将数值赋给寄存器 vAA</td></tr><tr><td>const/high16 vAA,#+BBBB0000</td><td>指令用于将数值右边零扩展为 32 位后赋给寄存器 vAA</td></tr><tr><td>const-wide/16 vAA,#+BBBB</td><td>指令用于将数值扩展为 64 位后赋给寄存器对 vAA</td></tr><tr><td>const-wide/32 vAA,#+BBBBBBBB</td><td>指令用于将数值扩展为 64 位后赋给寄存器对 vAA</td></tr><tr><td>const-wide vAA,#+BBBBBBBBBBBBBBBB</td><td>指令用于将数值赋给寄存器对 vAA</td></tr><tr><td>const-wide/hight16 vAA,#+BBBB000000000000</td><td>指令用于将数值右边零扩展为 64 位后赋给寄存器对 vAA</td></tr><tr><td>const-string vAA,string@BBBB</td><td>指令用于通过字符串索引构造一个字符串并赋给寄存器 vAA</td></tr><tr><td>const-string/jumbo vAA,string@BBBBBBBB</td><td>指令用于通过字符串索引(较大)构造一个字符串并赋给寄存器 vAA</td></tr><tr><td>const-class vAA,type@BBBB</td><td>指令用于通过类型索引获取一个类引用并赋给寄存器 vAA</td></tr><tr><td>const-class/jumbo vAAAA,type@BBBBBBBB</td><td>指令用于通过类型索引获取一个类引用并赋给寄存器 vAA<br>(这条指令占用两个字节, 值为 0x00ff)</td></tr></tbody></table><h3 id="锁指令"><a href="#锁指令" class="headerlink" title="锁指令"></a>锁指令</h3><p>锁指令多用在多线程中对同一对象的操作中, Dalvik 指令集中提供了如下两条锁指令：</p><table><thead><tr><th><strong>指令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>monitor-enter vAA</td><td>为指定的对象获取锁</td></tr><tr><td>monitor-exit vAA</td><td>释放指定对象的锁</td></tr></tbody></table><h3 id="实例操作指令"><a href="#实例操作指令" class="headerlink" title="实例操作指令"></a>实例操作指令</h3><p>与实例相关的操作包括实例的类型转换、检查及创建等。如下：</p><table><thead><tr><th><strong>指令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>check-cast vAA,type@BBBB</td><td>指令用于将 vAA 寄存器中的对象引用转换成指定的类型, <br/>如果失败会抛出 ClassCastException 异常, <br/>如果类型 B 指定的是基本类型, <br/>对于非基本类型的 A 来说, 运行时始终会失败。</td></tr><tr><td>instance-of vA,vB,type@CCCC</td><td>指令用于判断 vB 寄存器中的对象是否可以转换成指定的类型, <br/>如果可以 vA 赋给 1, 否则赋给 0。</td></tr><tr><td>new-instance vAA,type@BBBB</td><td>指令用于构造一个指定类型对象的新实例, 并将对象引用赋给 vAA,  <br/>类型符 type 指定的类型不是数组。</td></tr><tr><td>check-cast/jumbo vAAAA,type@BBBBBBBB</td><td>同 check-cast vAA,type@BBBB , <br>只是寄存器值和指令的索引取值返回更大 (android 4.0 新增)</td></tr><tr><td>instance-of/jumbo vAAAA,vBBBB,type@CCCCCCCC</td><td>同 instance-of vA,vB,type@CCCC , <br/>只是寄存器值和指令的索引取值返回更大 (android 4.0 新增)</td></tr><tr><td>new-instance/jumbo vAAAA,type@BBBBBBBB</td><td>同 new-instance vAA,type@BBBB , <br/>只是寄存器值和指令的索引取值返回更大 (android 4.0 新增)</td></tr></tbody></table><h3 id="数组操作指令"><a href="#数组操作指令" class="headerlink" title="数组操作指令"></a>数组操作指令</h3><p>数组操作包括获取数组长度、新建数组、数组赋值、数组元素取值与赋值等操作。如下：</p><table><thead><tr><th><strong>指令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>array-length vA, vB</td><td>获取给定 VB 寄存器中数组的长度并将值赋给 vA 寄存器</td></tr><tr><td>new-array vA, vB, type@CCCC</td><td>构造指定类型 (type@CCCC) 和大小 (vB) 的数组, 并将值赋给 vA</td></tr><tr><td>filled-new-array {vC, vD, vE, vF, vG}, type@BBBB</td><td>构造指定类型 (type@BBBB) 和大小 (vA) 的数组并填充数组内容。<br/>vA 寄存器是隐含使用的, 除了指定数组的大小外还指定了参数的个数, vC ~ vG 是使用到的参数寄存器序列</td></tr><tr><td>filled-new-array/range {vCCCC .. vNNNN}, type@BBBB</td><td>指令功能同 filled-new-array {vC,vD,vE,vF,vG},type@BBBB, <br/>只是参数寄存器使用 range 字节码后缀指定了取值范围, <br/>vC 是第一个参数寄存器,  N = A + C - 1</td></tr><tr><td>fill-array-data vAA, +BBBBBBBB</td><td>用指定的数据来填充数组, vAA 为数组引用, <br/>引用必须为基础类型的数组, 再指令后面会紧跟一个数据表</td></tr><tr><td>new-array/jumbo vAAAA, vBBBB, type@CCCCCCCC</td><td>同 new-array vA,vB,type@CCCC , <br/>只是寄存器值和指令的索引取值返回更大 (android 4.0 新增)</td></tr><tr><td>filled-new-array/jumbo {vCCCC .. vNNNN}, type@BBBBBBBB</td><td>同 filled-new-array/range {vCCCC … vNNNN},type@BBBB , <br/>只是索引取值返回更大 (android 4.0 新增)</td></tr><tr><td>arrayop vAA, vBB, vCC</td><td>对 vBB 寄存器指定的数组元素进行取值和赋值, <br/>vCC 指定数组元素索引, vAA 用来存放读取的或需要设置的数组元素的值, <br/>读取元素使用 aget 类指令, 元素赋值使用 aput 类指令, <br/>根据数组中存储的类型指令后面会紧跟不同的指令后缀, 指令列表有 <br/>( aget , aget-wide , aget-object , <br/>aget-boolean , aget-byte , aget-char , <br/>aget-short , aput , aput-wide , <br/>aput-object , aput-boolean , <br/>aput-byte , aput-char , aput-short )</td></tr></tbody></table><h3 id="异常指令"><a href="#异常指令" class="headerlink" title="异常指令"></a>异常指令</h3>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> delvik </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ViewPage滑动动画差值器</title>
      <link href="/2019/viewpage-indicator-bezierindicator.html"/>
      <url>/2019/viewpage-indicator-bezierindicator.html</url>
      
        <content type="html"><![CDATA[<p>很久以前看到一个这样的效果，很多文章都是只重点实现选择器，<code>ViewPager</code> 的差值器动画效果没有考虑，这里我努力做到最像，完成这个设计</p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://user-gold-cdn.xitu.io/2018/2/6/16169f802550c42e?imageslim" style="zoom:40%"><h2 id="本文知识点"><a href="#本文知识点" class="headerlink" title="本文知识点"></a>本文知识点</h2><ul><li></li><li><code>ViewPager</code>  滑动解析</li><li>自定义 <code>Scroller</code> </li><li>反射</li></ul><hr><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> ui </tag>
            
            <tag> viewpage </tag>
            
            <tag> ViewPageIndicator </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 网站管理</title>
      <link href="/2019/hexo-website-management.html"/>
      <url>/2019/hexo-website-management.html</url>
      
        <content type="html"><![CDATA[<p>目录请看  <a href="https://calmcenter.club/2019/Complete_works_of_hexo.html">Hexo 搭建博客大全</a></p><p><strong>注意：如果出现图片不显示问题请移步</strong> <a href="https://calmcenter.club/2019/PicNotShow.html">图片不显示问题</a></p><h1 id="本文主要记载"><a href="#本文主要记载" class="headerlink" title="本文主要记载"></a>本文主要记载</h1><ul><li>加入 <code>Coding</code> 服务器</li><li>个人域名</li><li><code>SEO</code>  推广</li></ul><hr><div class="note warning">            <p>重点： <code>hexo</code> 根目录配置文件 <code>hexo/_config.yml</code>  下文用 <code>Hexo 配置文件</code> 表示，<code>NexT</code> 样式配置文件 <code>hexo/theme/next/_config.yml</code> 下文用 <code>NexT 配置文件</code> 表示一定要分清，它们都叫 <code>_comfig.yml</code></p>          </div><p><strong>本文章写于 <code>2019/5/5</code> 图片内容可能和您现在看的内容不太一样，但是功能大体是不会变的。</strong></p><hr><h1 id="加入-Coding-服务器"><a href="#加入-Coding-服务器" class="headerlink" title="加入 Coding 服务器"></a>加入 <code>Coding</code> 服务器</h1><p>这里加入<code>Coding</code> 服务器的作用主要是访问速度，其次就是由于 <code>github</code> 屏蔽百度的爬虫，所以使用 <code>github page</code> 服务的站点的链接无法被抓取，可用  <code>Coding</code>  的 <code>page</code> 服务。</p><ol><li><p>登录 <a href="https://dev.tencent.com/" target="_blank" rel="noopener">Coding</a></p><p>登录 <a href="https://dev.tencent.com/" target="_blank" rel="noopener">Coding</a> ，并创建项目<img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/20190505114135.png" style="zoom:50%"></p></li><li><p>个人设置</p><p>首先你需要点击头像，找到个人设置，在个人设置中设置 <strong>密码</strong> 和 <strong>邮箱</strong> 才能设置 <strong>SSH</strong> ，如果你之前设置过 <code>github</code> 的 <code>SSH</code> 你只需要执行以下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clip &lt; ~&#x2F;.ssh&#x2F;id_rsa.pub</span><br></pre></td></tr></table></figure><p>然后点击 <code>SSH</code>公钥 设置即可，如果没有设置过 <code>github</code> 请参考 <a href="https://calmcenter.club/2019/Hexo_bash.html#2-3-%E9%85%8D%E7%BD%AE-SSH-%E5%AF%86%E9%92%A5">Hexo 基础搭建 - 配置 SSH 秘钥部分</a></p></li><li><p>验证</p><p>输入以下命令，查看 <code>SSH</code> 配置是否成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@git.coding.net</span><br></pre></td></tr></table></figure></li><li><p>添加配置</p><p>在  <code>Hexo 配置文件</code> 中注释掉之前的，添加 <code>repo</code> 中的内容 <code>SSH</code> 路径 <code>,master</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Deployment</span></span><br><span class="line"><span class="comment">#Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">    <span class="comment">#repository: git@github.com:CalmCenter/calmcenter.github.io.git</span></span><br><span class="line">    <span class="comment">#branch: master</span></span><br><span class="line">    <span class="attr">repo:</span></span><br><span class="line">    <span class="attr">github:</span> <span class="string">git@github.com:CalmCenter/calmcenter.github.io.git,master</span></span><br><span class="line">    <span class="attr">coding:</span> <span class="string">git@git.dev.tencent.com:CalmCenter/calmcenter.coding.me.git,master</span></span><br></pre></td></tr></table></figure></li><li><p>提交</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure></li><li><p>打开 <code>Coding Pages</code> 服务</p><p><code>头像 -&gt; 我的主页 -&gt; 项目 -&gt; 代码 -&gt; Pages 服务</code> 打钩已阅读服务，点击开启即可</p><p>会告诉你访问地址，打开如果排版不正常，不要慌，可能是子文件目录问题，设置域名后可解决。</p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/20190508105842.png" style="zoom:50%"></li></ol><hr><h1 id="个人域名"><a href="#个人域名" class="headerlink" title="个人域名"></a>个人域名</h1><ol><li><p>获得域名</p><p>首先你得有你自己的域名，几块钱就好~  <a href="https://cloud.tencent.com/act/domainsales?fromSource=gwzcw.2211770.2211770.2211770&utm_medium=cpc&utm_id=gwzcw.2211770.2211770.2211770" target="_blank" rel="noopener">腾讯云</a> 、<a href="https://wanwang.aliyun.com/domain/yumingheji" target="_blank" rel="noopener">阿里云</a> ，然后需要进行实名认证。完成后就可以添加域名解析地址啦~ </p></li><li><p>添加解析</p><p>这是 <a href="https://cloud.tencent.com/act/domainsales?fromSource=gwzcw.2211770.2211770.2211770&utm_medium=cpc&utm_id=gwzcw.2211770.2211770.2211770" target="_blank" rel="noopener">腾讯云</a> 的域名解析。</p><p><strong>注意：这里域名操作，每次操作完都会有一定缓冲时间，不会立即生效，每次操作完等待 10 分钟左右，再去配置域名</strong> </p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/20190508104813.png" style="zoom:50%"><p>这是添加的解析，因为添加了 <code>coding</code> ，所以有两条，分别将两个访问地址添加到域名解析中，<code>github</code> 用于境外访问，<code>coding</code> 本想着用于境内，但这里必须设置成默认才行。</p></li><li><p><code>github</code> 域名设置</p><p>点击你的博客项目的 <code>Setting</code> -&gt; <code>Options</code> 下滑找到 <code>GitHub Pages</code> </p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/20190508105420.png" style="zoom:50%"><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/20190508105344.png" style="zoom:50%"><p>这里会提示你站点发布在什么地方，记得开启 <code>HTTPS</code> 哦。</p></li><li><p><code>Coding</code> 域名设置</p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/20190508105715.png" style="zoom:50%"><p>自定义域名，将申请好的域名添加上去，点击绑定，然后刷新页面，知道 <code>SSL/TLS 安全证书</code> 出现结果，如果错误，请查看解析中 <code>coding</code> 线路类型配置是否是默认，如果是默认还不行，请将境外的 <code>github</code> 先暂停，再去重新绑定。记得开启 <code>HTTPS</code> 哦。</p><p><strong>操作时请留意 个人域名 开头说明的注意事项</strong></p></li></ol><hr><h1 id="SEO-推广"><a href="#SEO-推广" class="headerlink" title="SEO  推广"></a><code>SEO</code>  推广</h1><p>参考自作者 <a href="https://blog.enjoytoshare.club/article/hexo-do-optimization.html#5" target="_blank" rel="noopener">EnjoyToShare</a> </p><h2 id="SEO-是什么"><a href="#SEO-是什么" class="headerlink" title="SEO 是什么"></a><code>SEO</code> 是什么</h2><p>刚搭建完博客，可能你会发现你发表的文章在谷歌或者百度都搜索不到，因为需要进行 <code>SEO</code> 优化的，什么是 <code>SEO</code> ，顾名思义，<code>SEO</code> 即 <code>(Search Engine Optimization)</code> : 汉译为搜索引擎优化，它可以让自己的博文能在谷歌百度上搜索到。</p><h2 id="生成-sitemap"><a href="#生成-sitemap" class="headerlink" title="生成 sitemap"></a>生成 <code>sitemap</code></h2><p><code>sitemap</code> 用于通知搜索引擎网站上有哪些可供抓取的网页，以便搜索引擎可以更加智能地抓取网站。<br>安装 <code>sitemap</code> 站点地图自动生成插件 <code>hexo-generator-sitemap</code> 和 <code>hexo-generator-baidu-sitemap</code> </p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure><p>然后修改  <code>Hexo 配置文件</code> ，<strong>添加</strong>如下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sitemap:</span><br><span class="line">  path: sitemap.xml</span><br><span class="line">baidusitemap:</span><br><span class="line">  path: baidusitemap.xml</span><br></pre></td></tr></table></figure><p>并<strong>修改</strong> <code>url</code> 为你的域名地址 如 <code>url: https://blog.calmcenter.club/</code> </p><p>然后编译代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><p>就会生成在 <code>hexo\public</code> 下生成 <code>sitemap.xml</code> 和 <code>baidusitemap.xml</code> 一个是给谷歌的，一个给是百度的。</p><h2 id="添加协议"><a href="#添加协议" class="headerlink" title="添加协议"></a>添加协议</h2><p>网站通过 <code>Robots协议</code> 告诉搜索引擎哪些页面可以抓取，哪些页面不能抓取。 <code>robots.txt</code> 通常存放于网站根目录 ( <code>public</code> 目录)。由于我们每次 <code>hexo clean</code> 都会清空 <code>public</code> ，着实不方便，我们都知道 <code>source</code> 目录下的文件通过 <code>hexo g</code> 命令会转换成 <code>public</code> 中的文件，所以为了方便起见，我们把 <code>robots.txt</code> 文件放在<code>source</code>目录下，我的 <code>robots.txt</code> 内容为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">User-agent: *</span><br><span class="line">Allow: &#x2F;</span><br><span class="line">Allow: &#x2F;archives&#x2F;</span><br><span class="line">Allow: &#x2F;categories&#x2F;</span><br><span class="line">Allow: &#x2F;tags&#x2F;</span><br><span class="line">Allow: &#x2F;links&#x2F;</span><br><span class="line">Disallow: &#x2F;js&#x2F;</span><br><span class="line">Disallow: &#x2F;css&#x2F;</span><br><span class="line">Disallow: &#x2F;fonts&#x2F;</span><br><span class="line">Disallow: &#x2F;vendors&#x2F;</span><br><span class="line">Disallow: &#x2F;fancybox&#x2F;</span><br><span class="line">Sitemap: https:&#x2F;&#x2F;你的域名&#x2F;sitemap.xml</span><br><span class="line">Sitemap: https:&#x2F;&#x2F;你的域名&#x2F;baidusitemap.xml</span><br></pre></td></tr></table></figure><p>其中Allow后面的就是你的menu</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 域名 </tag>
            
            <tag> coding </tag>
            
            <tag> seo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 功能样式配置</title>
      <link href="/2019/hexo-functional-style.html"/>
      <url>/2019/hexo-functional-style.html</url>
      
        <content type="html"><![CDATA[<p>目录请看  <a href="https://calmcenter.club/2019/Complete_works_of_hexo.html">Hexo 搭建博客大全</a></p><p><strong>注意：如果出现图片不显示问题请移步</strong> <a href="https://calmcenter.club/2019/PicNotShow.html">图片不显示问题</a></p><h1 id="本文主要记载"><a href="#本文主要记载" class="headerlink" title="本文主要记载"></a>本文主要记载</h1><ul><li><code>NexT</code> 主题设置</li><li>基础样式设置</li><li>图片相关</li><li>打赏、评论、复制功能</li><li><code>DaoVoice</code> 实现在线联系</li><li>文章置顶</li><li>搜索功能</li><li>细节美化</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">本文环境是 win10 或 win 7。mac 再执行 npm 时需要在前面添加 sudo</span><br><span class="line">本文整理于各大佬文章，文中会给出相应链接，如有侵权，请联系我修改或删除。</span><br></pre></td></tr></table></figure><hr><h1 id="功能样式配置"><a href="#功能样式配置" class="headerlink" title="功能样式配置"></a>功能样式配置</h1><h2 id="NexT-主题设置"><a href="#NexT-主题设置" class="headerlink" title="NexT 主题设置"></a><code>NexT</code> 主题设置</h2><p>*<em>重点标注：<code>hexo</code> 根目录配置文件 <code>hexo/_config.yml</code>  下文用 <code>Hexo 配置文件</code> 表示，<code>NexT</code> 样式配置文件 <code>hexo/theme/next/_config.yml</code> 下文用 <code>NexT 配置文件</code> 表示一定要分清，它们都叫 <code>_cpmfig.yml</code> *</em></p><p><a href="https://hexo.io/themes/" target="_blank" rel="noopener">这里有很多主题</a> 这里主要说 <a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener">NexT</a> </p><p>进入 <code>hexo</code> 文件目录 ，执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;hexo-theme-next themes&#x2F;next</span><br></pre></td></tr></table></figure><p>成功后，在 <code>Hexo 配置文件</code> 找到 <code>theme</code> 字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure><p>这样 <code>next</code> 样式就设置好了，快打开看看吧  <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a></p><p><strong>注意:如果你是 <code>git</code> 直接 <code>clone</code> 的，会自带 <code>.git</code> 和 <code>.github</code> 文件，需要删掉 <code>.git</code> 和 <code>.github</code> 文件，如果不删在 <a href="https://calmcenter.club/2019/Hexo_code_management.html">Hexo 管理代码</a> 一文中会出现 <code>them/next</code> 里的文件提交不上去的问题</strong></p><h2 id="设置语言、标题等"><a href="#设置语言、标题等" class="headerlink" title="设置语言、标题等"></a>设置语言、标题等</h2><p>在  <code>Hexo 配置文件</code> 找到 <code>Site</code> 字段 </p><table><thead><tr><th align="left">字段</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">title</td><td align="left">网站标题</td></tr><tr><td align="left">subtitle</td><td align="left">副标题</td></tr><tr><td align="left">description</td><td align="left">描述</td></tr><tr><td align="left">author</td><td align="left">作者(您的名字)</td></tr><tr><td align="left">language</td><td align="left">语言 (zh-CN，en等)</td></tr><tr><td align="left">timezone</td><td align="left">网站时区，默认使用您电脑的时区</td></tr></tbody></table><h2 id="NexT-样式"><a href="#NexT-样式" class="headerlink" title="NexT 样式"></a><code>NexT</code> 样式</h2><p>在 <code>Hexo 配置文件</code> 找到 <code>Schemes</code> 字段，这里有四种样式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Schemes</span><br><span class="line">#scheme: Muse</span><br><span class="line">#scheme: Mist</span><br><span class="line">#scheme: Pisces</span><br><span class="line">scheme: Gemini</span><br></pre></td></tr></table></figure><h2 id="图片上传-PicGo-GitHub-图床"><a href="#图片上传-PicGo-GitHub-图床" class="headerlink" title="图片上传 PicGo + GitHub 图床"></a>图片上传 <code>PicGo</code> + <code>GitHub</code> 图床</h2><p>参考自作者 <a href="https://blog.enjoytoshare.club/article/hexo-do-optimization-picture.html" target="_blank" rel="noopener">EnjoyToShare 《PicGo+GitHub图床，让Markdown飞起》</a>  </p><ol><li><p>首先下载工具<br>下载地址 : <a href="https://github.com/Molunerfinn/PicGo/releases" target="_blank" rel="noopener">PicGo</a> </p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/picturespicgo_down.png" style="zoom:50%"></li><li><p>登录 <code>GitHub</code> </p><p>创建 <code>Repository</code> 之前都讲过怎么创建，名字可以取成 <code>PicGo</code> 类似的名字，主要用于存放图片。</p></li><li><p>生成 Token  </p><p>点击头像 <code>Settings -&gt; Developer settings -&gt; Personal access tokens</code> 点击  <code>Generate new token</code>  </p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/picturesnew_token.png" style="zoom:80%"><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/picturesaccess_tokens.png" style="zoom:30%"><p>点击最下面的  <code>Generate token</code> ，会出现 <code>token</code> ，这个 <code>token</code> 只出现一次，所以要保存一下</p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/picturesaccess_token.png" style="zoom:50%"></li><li><p>配置 <code>PicGo</code> 客户端</p></li></ol><p>打开 <code>PicGo</code> ，输入相关信息</p><ul><li>仓库名 即你的仓库名</li><li>分支名 默认 master</li><li>Token 就是刚刚复制的那一串字符</li><li>存储路径 这个可以填也可以不填，填了的话图片就上传到这个文件夹，比如 <code>picture/</code> 图中少一个 <code>/</code></li><li>自定义域名 这个要改一下 格式： <code>https://raw.githubusercontent.com/[仓库名]/master</code> </li></ul><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/picturespic_go_token.png" style="zoom:50%"><p>然后点确定就OK了，不妨试试。</p><p>还有一个方便的操作就是 修改上传快捷键 ，快捷键直接上传，跳过拖入上传区</p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/20190426111300.png" style="zoom:50%"><h2 id="图片全屏查看"><a href="#图片全屏查看" class="headerlink" title="图片全屏查看"></a>图片全屏查看</h2><p>首先进入 <code>hexo/themes/next/source/lib</code> 目录，下载插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;theme-next-fancybox3 fancybox</span><br></pre></td></tr></table></figure><p>然后更改 <code>NexT 配置文件</code> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fancybox: true</span><br></pre></td></tr></table></figure><p>完成 ~ </p><p><strong>注意:如果你是 <code>git</code> 直接 <code>clone</code> 的，会自带 <code>.git</code> 和 <code>.github</code> 文件，需要删掉 <code>.git</code> 和 <code>.github</code> 文件，如果不删在 <a href="https://calmcenter.club/2019/Hexo_code_management.html">Hexo 管理代码</a> 一文中会出现 <code>them/next/source/lib/fancybox</code> 里的文件提交不上去的问题</strong></p><h2 id="打赏功能"><a href="#打赏功能" class="headerlink" title="打赏功能"></a>打赏功能</h2><p>参考自作者 <a href="https://blog.enjoytoshare.club/article/hexo-do-donate.html" target="_blank" rel="noopener">EnjoyToShare 《Hexo的NexT主题打赏功能》</a>  </p><p>准备好收款二维码，放入 <code>hexo/themes/next/source/images</code> ，打开 <code>NexT 配置文件</code> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">reward_settings:</span><br><span class="line">  enable: true</span><br><span class="line">  animation: false</span><br><span class="line">  comment: 分享不易，可否赏杯咖啡钱</span><br><span class="line">reward:</span><br><span class="line">  wechatpay: &#x2F;images&#x2F;wechatpay.png</span><br><span class="line">  alipay: &#x2F;images&#x2F;alipay.png</span><br><span class="line">  #bitcoin: &#x2F;images&#x2F;bitcoin.png</span><br></pre></td></tr></table></figure><h2 id="评论功能"><a href="#评论功能" class="headerlink" title="评论功能"></a>评论功能</h2><p>参考自作者 <a href="https://blog.enjoytoshare.club/article/hexo-do-gitalk.html" target="_blank" rel="noopener">EnjoyToShare 《Hexo NexT 加入评论功能gitalk》</a>  </p><p><code>Gitalk</code> :</p><ul><li>一个基于 <code>Github Issue</code> 和 <code>Preact</code> 开发的评论插件</li><li>详情 <code>Demo</code> 可见:  <a href="https://gitalk.github.io/" target="_blank" rel="noopener">https://gitalk.github.io/</a></li></ul><p>增加评论区</p><ul><li>注册 <code>OAuth Application</code></li><li>在 <code>GitHub</code> 上注册新应用, 链接:  <a href="https://github.com/settings/applications/new" target="_blank" rel="noopener">https://github.com/settings/applications/new</a> </li></ul><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">Application name</td><td align="left">应用名称, 可以任意填入</td></tr><tr><td align="left">Homepage URL</td><td align="left">网站URL, 注意用https://开头</td></tr><tr><td align="left">Application description</td><td align="left">应用描述, 可以任意填入</td></tr><tr><td align="left">Authorization callback URL</td><td align="left">网站URL, 注意用https://开头</td></tr></tbody></table><p>注册后记录 <code>Client ID</code> 和 <code>Client Secret</code> , 后续要使用到。</p><p>打开 <code>NexT 配置文件</code> ， <strong>根据自己信息</strong> 进行一下修改，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gitalk:</span><br><span class="line">  enable: true</span><br><span class="line">  github_id: CalmCenter</span><br><span class="line">  repo: calmcenter.github.io</span><br><span class="line">  client_id: ****</span><br><span class="line">  client_secret: ****</span><br><span class="line">  admin_user: CalmCenter  </span><br><span class="line">  distraction_free_mode: true </span><br><span class="line">  language:</span><br></pre></td></tr></table></figure><p> 集成过程中出现的错误 <a href="https://liujunzhou.top/2018/8/10/gitalk-error/#%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B" target="_blank" rel="noopener">Junzhou Liu</a> 这里给出了很多，但是在我集成是发现有的 <code>NexT</code> 已经修正，所以这里说几点需要注意的地方。</p><ul><li>你的评论仓库或者 <code>GitHub Page</code> 仓库必须是 <code>public</code> ， <code>NexT 配置文件</code> 的 <code>reop</code> 指定的仓库名称也必须是 <code>public</code> ，否者可能出现 <code>404</code> 的错误</li><li><code>NexT</code> 中的字段配置 和 <code>Gitalk</code> 有两个不一样，需要用 <code>NexT</code> 指定的，否者会出现 <code>Erroe Not Found</code> </li></ul><p>如果错误修改后没反应，试一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure><p>重新编译运行。</p><p>成功后会提示你未找到相关 <code>issues</code>  ，需要你登录</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/20190426155441.png" alt=""></p><p><strong>如果有自己的域名记得把 Authorization callback URL 设置成自己的 域名地址</strong> <code>Authorization callback URL</code> 在 <a href="https://github.com/settings/developers" target="_blank" rel="noopener">github setting</a> 点击自己绑定的进去修改</p><p><strong>2019/5/10 踩坑记录，文章的文件名，中文会有问题，导致一直跳转首页并登陆不上，title  可以是中文</strong></p><h2 id="代码块复制功能"><a href="#代码块复制功能" class="headerlink" title="代码块复制功能"></a>代码块复制功能</h2><p>在 <code>NexT 配置文件</code> 中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">codeblock:</span><br><span class="line">  border_radius:</span><br><span class="line">  copy_button:</span><br><span class="line">    enable: true</span><br><span class="line">    show_result: true</span><br><span class="line">    style:</span><br></pre></td></tr></table></figure><p><code>NexT</code> 随着版本的升级，省去了很多操作，基本都剩开关的设置了</p><h2 id="DaoVoice-实现在线联系"><a href="#DaoVoice-实现在线联系" class="headerlink" title="DaoVoice 实现在线联系"></a><code>DaoVoice</code> 实现在线联系</h2><ol><li><p>注册登录 <code>DaoVoice</code></p><p><a href="http://www.daovoice.io/" target="_blank" rel="noopener">DaoVoice</a> 点击进行登录注册，邀请码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c1f73bd5</span><br></pre></td></tr></table></figure><p>登录成功后，你可能是这个目录</p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/20190428141105.png" style="zoom:50%"><p>这样的话你需要关掉这个页面，重新进入 <a href="http://www.daovoice.io/" target="_blank" rel="noopener">DaoVoice</a> 点击登录，如果最后看到是这个目录</p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/20190428141212.png" style="zoom:50%"><p>那就可以继续下面的 ~ </p></li><li><p>集成 </p><p>找到你的 <code>app_id</code></p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/20190428141938.png" style="zoom:30%"><p>并将 <code>1</code> 和 <code>2</code> 的代码 粘贴到 <code>themes/next/layout/_partials/head.swig</code> </p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/20200516194622.png" style="zoom:70%"><p><strong>有两处需要填写你的 <code>appid</code> 并且要加 <code>if</code> 开始和结束代码</strong></p><p>然后再  <code>NexT 配置文件</code> 中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">daovoice: true</span><br><span class="line">daovoice_app_id: 你的appid</span><br></pre></td></tr></table></figure><p>编译并运行 <code>Hexo</code> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure><p>会发现 <code>DaoVoice</code> 官网会提示</p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/20190428143112.png" style="zoom:30%"></li><li><p>绑定微信</p><p>点击右上角头像，然后点击绑定微信</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/20190428143854.png" alt=""></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/20190428143916.png" alt=""></p><p>这样，可以同时在 <code>DaoVoice</code> 网页的对话页面，和微信小程序 <code>DaoVoice</code> 同时回复~ </p></li></ol><h2 id="文章置顶"><a href="#文章置顶" class="headerlink" title="文章置顶"></a>文章置顶</h2><ol><li><p>将 <code>node_modules/hexo-generator-index/lib/generator.js</code> 文件内的内容替换为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#39;use strict&#39;;</span><br><span class="line">var pagination &#x3D; require(&#39;hexo-pagination&#39;);</span><br><span class="line">module.exports &#x3D; function(locals)&#123;</span><br><span class="line">    var config &#x3D; this.config;</span><br><span class="line">    var posts &#x3D; locals.posts;</span><br><span class="line">    posts.data &#x3D; posts.data.sort(function(a, b) &#123;</span><br><span class="line">        if(a.top &amp;&amp; b.top) &#123; &#x2F;&#x2F; 两篇文章top都有定义</span><br><span class="line">            if(a.top &#x3D;&#x3D; b.top) return b.date - a.date; &#x2F;&#x2F; 若top值一样则按照文章日期降序排</span><br><span class="line">            else return b.top - a.top; &#x2F;&#x2F; 否则按照top值降序排</span><br><span class="line">        &#125;</span><br><span class="line">        else if(a.top &amp;&amp; !b.top) &#123; &#x2F;&#x2F; 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233）</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(!a.top &amp;&amp; b.top) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else return b.date - a.date; &#x2F;&#x2F; 都没定义按照文章日期降序排</span><br><span class="line">    &#125;);</span><br><span class="line">    var paginationDir &#x3D; config.pagination_dir || &#39;page&#39;;</span><br><span class="line">    return pagination(&#39;&#39;, posts, &#123;</span><br><span class="line">    perPage: config.index_generator.per_page,</span><br><span class="line">    layout: [&#39;index&#39;, &#39;archive&#39;],</span><br><span class="line">    format: paginationDir + &#39;&#x2F;%d&#x2F;&#39;,</span><br><span class="line">    data: &#123;</span><br><span class="line">      __index: true</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>在文章头部添加 <code>top</code> 值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">title: Hexo 搭建博客大全</span><br><span class="line">date: 2019-04-18 17:32:22</span><br><span class="line">categories: Hexo</span><br><span class="line">tags: [Hexo, NexT, 博客]</span><br><span class="line">top: 100</span><br></pre></td></tr></table></figure></li></ol><h2 id="搜索功能"><a href="#搜索功能" class="headerlink" title="搜索功能"></a>搜索功能</h2><ol><li><p>安装插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure></li><li><p>在 <code>Hexo 配置文件</code> 中添加 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#本地搜索</span><br><span class="line">search:</span><br><span class="line">    path: search.xml</span><br><span class="line">    field: post</span><br><span class="line">    format: html</span><br><span class="line">    limit: 10000</span><br></pre></td></tr></table></figure></li><li><p>在 <code>NexT 配置文件</code> 启动搜索功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">local_search:</span><br><span class="line">    enable: true</span><br><span class="line">    trigger: auto</span><br><span class="line">    top_n_per_article: 1</span><br><span class="line">    unescape: false</span><br></pre></td></tr></table></figure></li><li><p>完成，清理缓存编译运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure></li></ol><h2 id="隐藏特定文章"><a href="#隐藏特定文章" class="headerlink" title="隐藏特定文章"></a>隐藏特定文章</h2><p>比如说没写完的 ~ </p><p>首先修改 <code>/themes/next/layout/index.swig</code> 文件，把</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% for post in page.posts %&#125;</span><br><span class="line">  &#123;&#123; post_template.render(post, true) &#125;&#125;</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure><p>替换成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;% for post in page.posts %&#125;</span><br><span class="line">   &#123;% set hide &#x3D; false %&#125;</span><br><span class="line">   &#123;% if theme.hide.hide_post %&#125;</span><br><span class="line">     &#123;% if post.hide %&#125;</span><br><span class="line">       &#123;% set hide &#x3D; true %&#125;</span><br><span class="line">     &#123;% endif %&#125;</span><br><span class="line">   &#123;% endif %&#125;</span><br><span class="line">   &#123;% if !hide %&#125;</span><br><span class="line">     &#123;&#123; post_template.render(post, true) &#125;&#125;</span><br><span class="line">   &#123;% endif %&#125;</span><br><span class="line"> &#123;% endfor %&#125;</span><br></pre></td></tr></table></figure><p>在 <code>NexT 配置文件</code>  添加代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Hide single post</span><br><span class="line">hide:</span><br><span class="line">  hide_post: true</span><br></pre></td></tr></table></figure><h2 id="细节美化"><a href="#细节美化" class="headerlink" title="细节美化"></a>细节美化</h2><h3 id="头像"><a href="#头像" class="headerlink" title="头像"></a>头像</h3><p>在<code>NexT 配置文件</code> 中，找到 <code>avatar</code> 字段</p><table><thead><tr><th>字段</th><th>作用</th></tr></thead><tbody><tr><td>url</td><td>图片相对位置(/image/xxx.png)图片保存在  \hexo\themes\next\source\images 文件下</td></tr><tr><td>rounded</td><td>是否启用圆角</td></tr><tr><td>opacity</td><td>透明度</td></tr><tr><td>rotated</td><td>旋转动画</td></tr></tbody></table><h3 id="回到顶部"><a href="#回到顶部" class="headerlink" title="回到顶部"></a>回到顶部</h3><p>打开 <code>NexT 配置文件</code> 搜索 <code>back2top</code>  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">back2top:</span><br><span class="line">  enable: true</span><br><span class="line">  # 回到侧边栏顶部.</span><br><span class="line">  sidebar: true</span><br><span class="line">  # 滚动%标签.</span><br><span class="line">  scrollpercent: true</span><br></pre></td></tr></table></figure><h3 id="页面底部优化"><a href="#页面底部优化" class="headerlink" title="页面底部优化"></a>页面底部优化</h3><ul><li>跳动的心</li></ul><p>参考自作者 <a href="https://11.tt/posts/2018/set-up-hexo-with-coding-and-github/" target="_blank" rel="noopener">十一種情緒的堆棧</a> 在这篇文章 1/2 处左右</p><p>效果就在本页面底部 ~ ，首先先去 <a href="https://fontawesome.com/v4.7.0/icons/" target="_blank" rel="noopener">The Icons</a> 选择一张图片，例如搜索 <code>heartbeat</code> ，点击进去将图片代码 <code>fa-heartbeat</code> 复制下来，打开<code>NexT 配置文件</code> ，搜索 <code>footer</code> 关键字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">footer:</span><br><span class="line">  icon:</span><br><span class="line">    name: fas fa-heartbeat</span><br><span class="line">    animated: true</span><br><span class="line">    color: &quot;#ff0000&quot;</span><br></pre></td></tr></table></figure><p>需要将复制的图片代码粘贴到 <code>name</code> 字段，并且前面加上 fas ，如果需要动画的话，将 <code>animated</code> 设置为 <code>true</code> ，并将 <code>color</code> 修改为 <code>#ff0000</code> 。就和我底部效果一样了啦。</p><ul><li>访问统计</li></ul><p>还是在 <code>NexT 配置文件</code> ，搜索 <code>busuanzi_count</code> 字段。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">busuanzi_count:</span><br><span class="line">  enable: true</span><br><span class="line">  total_visitors: true</span><br><span class="line">  total_visitors_icon: user</span><br><span class="line">  total_views: true</span><br><span class="line">  total_views_icon: eye</span><br><span class="line">  post_views: true</span><br><span class="line">  post_views_icon: eye</span><br></pre></td></tr></table></figure><p>将 <code>enable</code> 设置为 <code>true</code> 就有和我底部一样的 访问统计 功能了</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/picturesvisit.png" alt=""></p><p>统计这块还可以添加一个字数和阅读时长统计，在<code>hexo</code> 根目录配置文件 <code>hexo/_config.yml</code> 搜索 <code>symbols_count_time</code> 如果没有则添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">symbols_count_time:</span><br><span class="line"> symbols: true </span><br><span class="line"> time: true </span><br><span class="line"> total_symbols: true </span><br><span class="line"> total_time: true</span><br></pre></td></tr></table></figure><p>在 <code>NexT 配置文件</code> 搜索 <code>symbols_count_time</code> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">symbols_count_time:</span><br><span class="line">  separated_meta: true</span><br><span class="line">  item_text_post: true</span><br><span class="line">  item_text_total: false</span><br><span class="line">  awl: 4</span><br><span class="line">  wpm: 275</span><br></pre></td></tr></table></figure><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/picturesnumber.png" alt=""></p><p><strong>注: 格式很重要</strong> </p><h3 id="圆角布局"><a href="#圆角布局" class="headerlink" title="圆角布局"></a>圆角布局</h3><p>参考自作者 <a href="https://blog.enjoytoshare.club/article/hexo-do-optimization.html" target="_blank" rel="noopener">EnjoyToShare</a> 在这篇文章 3.12，这篇里边还有好多好看的样式 ~</p><p>在 <code>/themes/next/source/css/_variables</code> 中的 <code>Gemini.styl</code> 文件添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 修改主题页面布局为圆角</span><br><span class="line">$border-radius-inner            &#x3D; 15px 15px 15px 15px;</span><br><span class="line">$border-radius                  &#x3D; 15px;</span><br></pre></td></tr></table></figure><h3 id="文章标签、分类"><a href="#文章标签、分类" class="headerlink" title="文章标签、分类"></a>文章标签、分类</h3><p>我们在用 <code>hexo new post</code> 创建文件时</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new post &quot;name&quot;</span><br></pre></td></tr></table></figure><p><code>hexo</code> 自动为我们的文章头部生成了如下的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">title: 标题</span><br><span class="line">date: 2019-04-18 17:32:22</span><br></pre></td></tr></table></figure><ul><li>首先添加分类</li></ul><p>在 <code>data</code> 下方添加 <code>categories</code> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">title: 标题</span><br><span class="line">date: 2019-04-18 17:32:22</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">categories: Hexo</span><br></pre></td></tr></table></figure><p><strong>注意：英文冒号，还有一个空格</strong></p><p>这样分类就添加上了，还需要给分类一个跳转页，创建一个 <code>categories.md</code> 用于跳转</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure><p>会提示我们输入目录 <code>/source/categories/index.md</code>  ，打开这个 <code>index.md</code> ，加入 <code>type</code> 这个页面用于做什么的，<code>comment</code> 是否开启评论，前提是你有评论功能的话。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">title: categories</span><br><span class="line">date: 2019-04-25 14:53:31</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type: categories</span><br><span class="line">comments: false</span><br></pre></td></tr></table></figure><p>这样分类就设置好了，检查一下 <code>Hexo 配置文件</code> ，搜索  <code>category_dir</code> 字段 <code>category_dir: categories</code> 这里已经设置了分类夹的名称，如果之前创建的文件夹完成和这个不一样，需要统一才行。</p><ul><li>添加标签</li></ul><p>同样在 <code>Hexo 配置文件</code> 搜索，<code>tag_dir</code> 可以知道 <code>tag</code> 设置好的文件夹名称，<code>tag_dir: tags</code>  ，我们可以在 <code>categories</code> 下添加 <code>tags</code> 来添加标签。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tags: [Hexo, NexT, 博客]</span><br></pre></td></tr></table></figure><p>然后添加跳转页面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure><p>创建完成后，为 <code>tags/index.md</code> 添加内容 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">title: categories</span><br><span class="line">date: 2019-04-25 15:34:07</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type: tags</span><br><span class="line">comments: false</span><br></pre></td></tr></table></figure><p>标签比分类多一步，我们需要安装一个插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-tag --save</span><br></pre></td></tr></table></figure><p>这样 <code>hexo g &amp;&amp; hexo s</code> 编译并运行，本地就可以看到了，标签在文章底部，发现它是 <code># xxx</code> 很难看，修改的 <code>#</code> 需要找到 <code>/themes/next/layout/_macro/post.swig</code> ，搜索 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rel&#x3D;&quot;tag&quot;&gt;#</span><br></pre></td></tr></table></figure><p>将 <code>#</code> 换成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;i class&#x3D;&quot;fa fa-tag&quot;&gt;&lt;&#x2F;i&gt;</span><br></pre></td></tr></table></figure><p>这里的 <code>fa-tag</code> 也是在 <a href="https://fontawesome.com/v4.7.0/icons/" target="_blank" rel="noopener">The Icons</a> 中的图片。</p><ul><li>将标签、分类添加至做出菜单栏</li></ul><p>打开 <code>NexT 配置文件</code>   搜索 <code>menu</code> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: &#x2F; || home</span><br><span class="line">  #about: &#x2F;about&#x2F; || user</span><br><span class="line">  tags: &#x2F;tags&#x2F; || tags</span><br><span class="line">  categories: &#x2F;categories&#x2F; || th</span><br><span class="line">  archives: &#x2F;archives&#x2F; || archive</span><br><span class="line">  #schedule: &#x2F;schedule&#x2F; || calendar</span><br><span class="line">  #sitemap: &#x2F;sitemap.xml || sitemap</span><br><span class="line">  #commonweal: &#x2F;404&#x2F; || heartbeat</span><br></pre></td></tr></table></figure><p>将 <code>tags</code> 和 <code>categories</code> 打开，完成 ~ </p><h3 id="强调颜色"><a href="#强调颜色" class="headerlink" title="强调颜色"></a>强调颜色</h3><p>参考自作者 <a href="https://www.jianshu.com/p/f054333ac9e6" target="_blank" rel="noopener">Moorez</a> </p><ul><li>‘’ 内容样式的修改</li></ul><p>打开 <code>/hemes/next/source/css/_custom/custom.styl</code> ，在里面加入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Custom styles.</span><br><span class="line">code &#123;</span><br><span class="line">    color: #ff7600;</span><br><span class="line">    background: #fbf7f8;</span><br><span class="line">    margin: 2px;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 大代码块的自定义样式</span><br><span class="line">.highlight, pre &#123;</span><br><span class="line">    margin: 5px 0;</span><br><span class="line">    padding: 5px;</span><br><span class="line">    border-radius: 3px;</span><br><span class="line">&#125;</span><br><span class="line">.highlight, code, pre &#123;</span><br><span class="line">    border: 1px solid #d6d6d6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>链接样式修改</li></ul><p>修改文件 <code>/themes/next/source/css/_common/components/post/post.styl</code>，在末尾添加如下css样式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 文章内链接文本样式</span><br><span class="line">.post-body p a&#123;</span><br><span class="line">  color: #0593d3;</span><br><span class="line">  border-bottom: none;</span><br><span class="line">  border-bottom: 1px solid #0593d3;</span><br><span class="line">  &amp;:hover &#123;</span><br><span class="line">    color: #fc6423;</span><br><span class="line">    border-bottom: none;</span><br><span class="line">    border-bottom: 1px solid #fc6423;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置网站图标</p><h3 id="设置网站图标"><a href="#设置网站图标" class="headerlink" title="设置网站图标"></a>设置网站图标</h3><p>参考自作者 <a href="https://www.jianshu.com/p/f054333ac9e6" target="_blank" rel="noopener">Moorez</a> </p><p>首先找一张喜欢的图片，可以在 <a href="http://www.easyicon.net/" target="_blank" rel="noopener">EasyIcon</a> 中或其他任意地方，分别下载 <code>32px</code> 和 <code>16px</code> 两张，然后放到 <code>/themes/next/source/images</code> 里，然后修改 <code>NexT 配置文件</code>  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">favicon:</span><br><span class="line">  small: &#x2F;images&#x2F;c_16.png</span><br><span class="line">  medium: &#x2F;images&#x2F;c_32.png</span><br><span class="line">  apple_touch_icon: &#x2F;images&#x2F;apple-touch-icon-next.png</span><br><span class="line">  safari_pinned_tab: &#x2F;images&#x2F;logo.svg</span><br></pre></td></tr></table></figure><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/picturesblog_title.png" style="zoom:100%"><h3 id="主页文章添加边框阴影效果"><a href="#主页文章添加边框阴影效果" class="headerlink" title="主页文章添加边框阴影效果"></a>主页文章添加边框阴影效果</h3><p>在 <code>theme/next/source/css/_custom/custom.styl</code>  文件下添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 主页文章添加阴影效果</span><br><span class="line">.posts-expand &#123; </span><br><span class="line">.post &#123;</span><br><span class="line">margin-top: 30px;</span><br><span class="line">margin-bottom: 30px;</span><br><span class="line">&#x2F;&#x2F;border-radius: 15px;</span><br><span class="line">-webkit-box-shadow: 5px 5px 20px rgba(119,118,118,.6);</span><br><span class="line">-moz-box-shadow: 5px 5px 20px rgba(119,118,118,.6);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很多博客上都没有 <code>posts-expand</code> 这一层，如果没有这一层，你的归档页面将会变得很丑~如果你用了之前的圆角布局，需要把 <code>border-radius: 15px;</code> 的注释删掉。</p><p>应用主要作用实在 <code>-webkit-box-shadow</code> 和 <code>-moz-box-shadow</code> 属性上。</p><p>基于主流浏览器上使用 <code>box-shadow</code> 属性时，我们需要将属性的名称写成 <code>-webkit-box-shadow</code> 的形式。Firefox浏览器则需要写成 <code>-moz-box-shadow</code> 的形式。</p><p>四个值分别为 <code>X轴</code>与 <code>Y轴</code> 移动 、<code>阴影值大小</code> 、<code>阴影颜色rgba</code></p><hr><h1 id="更多样式修改-💦💦"><a href="#更多样式修改-💦💦" class="headerlink" title="更多样式修改 💦💦"></a>更多样式修改 💦💦</h1><p><a href="https://bestzuo.cn/posts/1689445187.html" target="_blank" rel="noopener">Sanarous Hexo博客界面美化2.0</a></p><p><a href="https://leafjame.github.io/posts/2114475547.html" target="_blank" rel="noopener">Leaface Hexo NexT主题美化2.0</a></p><p><a href="https://walesexcitedmei.github.io/2018/08/30/HEXO-NexT-%E4%B8%BB%E9%A2%98%E6%8F%90%E9%AB%98%E5%8D%9A%E5%AE%A2%E9%A2%9C%E5%80%BC/" target="_blank" rel="noopener">[HEXO] NexT 主题提高博客颜值</a></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> git </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Live2D 看板娘</title>
      <link href="/2019/hexo-live2d.html"/>
      <url>/2019/hexo-live2d.html</url>
      
        <content type="html"><![CDATA[<p>目录请看  <a href="https://calmcenter.club/2019/Complete_works_of_hexo.html">Hexo 搭建博客大全</a></p><p><strong>注意：如果出现图片不显示问题请移步</strong> <a href="https://calmcenter.club/2019/PicNotShow.html">图片不显示问题</a></p><h2 id="本文主要记载"><a href="#本文主要记载" class="headerlink" title="本文主要记载"></a>本文主要记载</h2><ul><li>使用 <code>hexo-helper-live2d</code> 完成看板娘</li><li>自定义看板娘(右下角那个~)<ul><li>运行、接入 <code>Demo</code></li><li>更换、修改模型</li></ul></li></ul><hr><h2 id="使用-hexo-helper-live2d-完成看板娘"><a href="#使用-hexo-helper-live2d-完成看板娘" class="headerlink" title="使用 hexo-helper-live2d 完成看板娘"></a>使用 <code>hexo-helper-live2d</code> 完成看板娘</h2><p>我的 <code>Live2D</code> 版本是 <code>3.1.1</code></p><p>首先安装配置 hexo-helper-live2d，在 <code>hexo</code> 根目录下执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-helper-live2d --save</span><br></pre></td></tr></table></figure><p>插件就安装完成了，你可一下选一个 <a href="https://huaji8.top/post/live2d-plugin-2.0/" target="_blank" rel="noopener">模型</a> 这个给出了展示效果，但是不全， <a href="https://github.com/xiazeyu/live2d-widget-models" target="_blank" rel="noopener">更多模型</a> 这个没有展示效果，比之前的全一点，可以自己试试效果 ~</p><p>在模型中记住自己选择模型的名字 <code>live2d-widget-model-你选中的模型名字</code> ，然后进行安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install live2d-widget-model-wanko --save</span><br></pre></td></tr></table></figure><p>然后再 <code>Hexo 配置文件</code> 中，添加如下代码，<strong>代码格式很重要！！！</strong> 有时候复制进去没有缩进，效果是出不来的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">live2d:</span><br><span class="line">  enable: true</span><br><span class="line">  scriptFrom: local</span><br><span class="line">  pluginRootPath: live2dw&#x2F;</span><br><span class="line">  pluginJsPath: lib&#x2F;</span><br><span class="line">  pluginModelPath: assets&#x2F;</span><br><span class="line">  tagMode: false</span><br><span class="line">  debug: false</span><br><span class="line">  model:</span><br><span class="line">    use: live2d-widget-model-wanko</span><br><span class="line">  display:</span><br><span class="line">    position: left</span><br><span class="line">    width: 150</span><br><span class="line">    height: 300</span><br><span class="line">  mobile:</span><br><span class="line">    show: true</span><br><span class="line">  react:</span><br><span class="line">    opacity: 0.7</span><br></pre></td></tr></table></figure><p>这样一只可爱的小白狗就出现了。</p><p>如果要加载自定义模型，需要在根目录新建文件夹 <code>live2d_models</code> 下，再新建一个文件夹 <code>kesshouban （此处自定义）</code> 然后将资源文件放入 <code>kesshouban</code> 内 。然后修改 <code>Hexo 配置文件</code> ，将 <code>model.use</code> 写成 <code>kesshouban</code> 。</p><h2 id="自定义看板娘"><a href="#自定义看板娘" class="headerlink" title="自定义看板娘"></a>自定义看板娘</h2><p>首先感谢 <a href="https://haokan.baidu.com/v?pd=wisenatural&vid=11405187949707723550" target="_blank" rel="noopener">大佬</a> 提供的视屏教程，清晰易懂。</p><p>感谢 <a href="https://github.com/galnetwen" target="_blank" rel="noopener">galnetwen</a> 提供的代码。</p><h3 id="1-运行-Demo"><a href="#1-运行-Demo" class="headerlink" title="1. 运行 Demo"></a>1. 运行 <code>Demo</code></h3><p>首先你需要将 <a href="https://github.com/galnetwen/Live2D" target="_blank" rel="noopener">代码</a> 下载下来</p><p>解压代码并将 <code>Live2D-master</code> 里的内容 <code>live2d</code> 和 <code>demo.html</code> ，解压到 <code>hexo</code> 根目录的 <code>public</code> 的文件夹下。并运行且进入本地访问</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:4000&#x2F;demo.html</span><br></pre></td></tr></table></figure><p>如果出现 <a href="https://play.google.com/store/apps/details?id=com.sinsiroad.potionmaker&hl=zh_CN" target="_blank" rel="noopener">药水制作师</a> 里的模型，就可以啦，如果出不来，证明你路径有问题，请检查路径， <code>live2d</code> 和 <code>demo.html</code> 文件在 <code>public</code> 文件夹下。</p><h3 id="2-接入-Demo"><a href="#2-接入-Demo" class="headerlink" title="2. 接入 Demo"></a>2. 接入 <code>Demo</code></h3><p>将 <code>live2d</code> 文件夹剪切到 <code>hexo/themes/next/source</code> , 文件夹内应该有三个文件夹 <code>css js model</code> 和一个文件 <code>message.json</code> 。</p><p>然后将 <code>demo.html</code> 中的代码整理出来</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"/live2d/css/live2d.css"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"landlord"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"message"</span> <span class="attr">style</span>=<span class="string">"opacity:0"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"live2d"</span> <span class="attr">width</span>=<span class="string">"280"</span> <span class="attr">height</span>=<span class="string">"250"</span> <span class="attr">class</span>=<span class="string">"live2d"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"hide-button"</span>&gt;</span>隐藏<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/jquery/2.2.4/jquery.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">  <span class="keyword">var</span> message_Path = <span class="string">'/live2d/'</span></span></span><br><span class="line"><span class="actionscript">  <span class="keyword">var</span> home_Path = <span class="string">'https://calmcenter.club/'</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"/live2d/js/live2d.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"/live2d/js/message.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">  loadlive2d(<span class="string">"live2d"</span>, <span class="string">"/live2d/model/tia/model.json"</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>粘贴到 <code>/theme/next/layout/layout.swig</code> 的 <code>&lt;footer&gt;</code> 标签下</p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/20190509151030.png" style="zoom:50%"><p>执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure><p>看板娘就到我们的博客上来啦~</p><h3 id="3-更换模型"><a href="#3-更换模型" class="headerlink" title="3. 更换模型"></a>3. 更换模型</h3><p>感谢 <a href="https://imjad.cn/" target="_blank" rel="noopener">猫与向日葵</a> 提供血小板模型 <a href="https://cdn.imjad.cn/usr/uploads/kesshouban_v2.7z" target="_blank" rel="noopener">下载地址</a></p><p>在 <code>hexo/next/source/live2d/model</code> 中新建一个文件夹，将压缩包里面的内容，也就是模型放到里面，然后修改 <code>model.json</code> </p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"Live2D Model Setting"</span>,</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"model"</span>,</span><br><span class="line">    <span class="attr">"version"</span>:<span class="string">"1.0.0"</span>,</span><br><span class="line">    <span class="attr">"model"</span>: <span class="string">"model.moc"</span>,</span><br><span class="line">    <span class="attr">"textures"</span>: [</span><br><span class="line">      <span class="string">"model.2048/texture_00.png"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"layout"</span>:&#123;</span><br><span class="line">      <span class="attr">"center_x"</span>:<span class="number">0.0</span>,</span><br><span class="line">      <span class="attr">"center_y"</span>:<span class="number">0.05</span>,</span><br><span class="line">      <span class="attr">"width"</span>:<span class="number">1.8</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"hit_areas_custom"</span>:&#123;</span><br><span class="line">      <span class="attr">"head_x"</span>:[<span class="number">-0.35</span>, <span class="number">0.6</span>],</span><br><span class="line">      <span class="attr">"head_y"</span>:[<span class="number">0.19</span>, <span class="number">-0.2</span>],</span><br><span class="line">      <span class="attr">"body_x"</span>:[<span class="number">-0.3</span>, <span class="number">-0.25</span>],</span><br><span class="line">      <span class="attr">"body_y"</span>:[<span class="number">0.3</span>, <span class="number">-0.9</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"motions"</span>:&#123;</span><br><span class="line">      <span class="attr">"idle"</span>:[</span><br><span class="line">        &#123;<span class="attr">"file"</span>:<span class="string">"motions/Idle.mtn"</span>&#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"sleepy"</span>:[</span><br><span class="line">      &#123;<span class="attr">"file"</span>:<span class="string">"motions/Nemui.mtn"</span>&#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"flick_head"</span>:[</span><br><span class="line">      &#123;<span class="attr">"file"</span>:<span class="string">"motions/Anone_Synced.mtn"</span>&#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"tap_body"</span>:[</span><br><span class="line">      &#123;<span class="attr">"file"</span>:<span class="string">"motions/Dance.mtn"</span>&#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终成这样，一个标点都不能错 ！主要是 <code>layout(用于移动模型位置)</code> 和 <code>hit_areas_custom(用于声明点击事件范围)</code> </p><p>值的算法很简单(自己一点一点试的 = =)，以父布局中心为原点，做直角坐标系~ </p><p>这里感谢 <a href="https://www.jbblogs.cn/" target="_blank" rel="noopener">jacob</a> 与我一起讨论相关内容</p><p>然后将  <code>/theme/next/layout/layout.swig</code> 的 <code>&lt;footer&gt;</code> 添加的那句话</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">loadlive2d(<span class="string">"live2d"</span>, <span class="string">"/live2d/model/xxb/model.json"</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>将 <code>xxb</code> 改成你新建的文件夹名字，编译运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure><h3 id="4-修改模型"><a href="#4-修改模型" class="headerlink" title="4. 修改模型"></a>4. 修改模型</h3><p><a href="https://imjad.cn/archives/lab/add-dynamic-poster-girl-with-live2d-to-your-blog-01" target="_blank" rel="noopener">大佬链接</a></p>]]></content>
      
      
      <categories>
          
          <category> live2D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> live2D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 管理代码</title>
      <link href="/2019/hexo-code-management.html"/>
      <url>/2019/hexo-code-management.html</url>
      
        <content type="html"><![CDATA[<p>目录请看  <a href="https://calmcenter.club/2019/Complete_works_of_hexo.html">Hexo 搭建博客大全</a></p><p><strong>注意：如果出现图片不显示问题请移步</strong> <a href="https://calmcenter.club/2019/PicNotShow.html">图片不显示问题</a></p><h2 id="本文主要记载"><a href="#本文主要记载" class="headerlink" title="本文主要记载"></a>本文主要记载</h2><ul><li><code>git</code> 拉取代码</li><li><code>git</code> 创建分支</li><li><code>git</code> 提交分支代码</li><li>其他终端如何使用 <code>Hexo</code> 源码</li></ul><hr><a id="more"></a><h2 id="一、管理代码"><a href="#一、管理代码" class="headerlink" title="一、管理代码"></a>一、管理代码</h2><p>当我们需要在不同的终端去写博客的时候，发现 <code>github</code> 库中只有编译后的代码，所以我们需要将我们的 <code>hexo</code> 源码页放入 <code>github</code> 的分支中</p><p>首先我们需要拉取所有代码，选择一个空文件夹例如 <code>D:\blog\github_hexo</code> </p><h3 id="1-1-拉取主分支代码"><a href="#1-1-拉取主分支代码" class="headerlink" title="1.1 拉取主分支代码"></a>1.1 拉取主分支代码</h3><h4 id="1-1-1-初始化-git"><a href="#1-1-1-初始化-git" class="headerlink" title="1.1.1 初始化 git"></a>1.1.1 初始化 <code>git</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><h4 id="1-1-2-clone-远程代码，复制刚才的-SSH-路径-或者-HTTPS-路径"><a href="#1-1-2-clone-远程代码，复制刚才的-SSH-路径-或者-HTTPS-路径" class="headerlink" title="1.1.2 clone 远程代码，复制刚才的 SSH 路径 或者 HTTPS 路径"></a>1.1.2 clone 远程代码，复制刚才的 <code>SSH</code> 路径 或者 <code>HTTPS</code> 路径</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone &lt;SSH&#x2F;HTTPS&gt;</span><br></pre></td></tr></table></figure><h4 id="1-1-3-和远程仓库建立关联"><a href="#1-1-3-和远程仓库建立关联" class="headerlink" title="1.1.3 和远程仓库建立关联"></a>1.1.3 和远程仓库建立关联</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin &lt;SSH&#x2F;HTTPS&gt;</span><br></pre></td></tr></table></figure><p>如果 <code>falal：remote origin already exists.</code> ，执行下面命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rm origin</span><br></pre></td></tr></table></figure><p>然后再次建立关联 <code>git remote add origin &lt;SSH/HTTPS&gt;</code> </p><h3 id="1-2-创建分支"><a href="#1-2-创建分支" class="headerlink" title="1.2 创建分支"></a>1.2 创建分支</h3><h4 id="1-2-1-查看分支情况"><a href="#1-2-1-查看分支情况" class="headerlink" title="1.2.1 查看分支情况"></a>1.2.1 查看分支情况</h4><p>进入拉取下来的目录 <code>cd &lt;文件名&gt;</code></p><p>查看分支，查看本地分支包括远程分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure><h4 id="1-2-2-创建本地分支"><a href="#1-2-2-创建本地分支" class="headerlink" title="1.2.2 创建本地分支"></a>1.2.2 创建本地分支</h4><p>创建本地分支并切换到新分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b test</span><br></pre></td></tr></table></figure><p>等价于 <code>git branch test</code> 和 <code>git checkout test</code> </p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/picturesgit_branch1.png" style="zoom:100%"><p>这里会告诉你本地当前所处的分支，切换分支可以用，<strong>当你切换分支时，如果本地没有但是远程有这个分支，它会自动给你拉取远程分支，并切换</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout test</span><br></pre></td></tr></table></figure><h4 id="1-2-3-更新远程分支"><a href="#1-2-3-更新远程分支" class="headerlink" title="1.2.3 更新远程分支"></a>1.2.3 更新远程分支</h4><p>上图你可以看到本地分支比远程分支多一个 <code>test</code> 下一步就是将新分支推送至远程GitHub</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin test</span><br></pre></td></tr></table></figure><p>完成后，执行查看分支命令 <code>git branch -a</code> 会发现远程 多了 <code>test</code> 分支。</p><p><strong>如果想删掉分支</strong>，删除本地分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d &lt;分支名称&gt;</span><br></pre></td></tr></table></figure><p>提交删除到远程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin --delete &lt;分支名称&gt;</span><br></pre></td></tr></table></figure><h3 id="1-3-提交源码到远程分支"><a href="#1-3-提交源码到远程分支" class="headerlink" title="1.3 提交源码到远程分支"></a>1.3 提交源码到远程分支</h3><h4 id="1-3-1-本地操作代码"><a href="#1-3-1-本地操作代码" class="headerlink" title="1.3.1 本地操作代码"></a>1.3.1 本地操作代码</h4><p>在确保是 <code>test</code> 分支下，然后将 <code>.git</code> 以外的所有文件删掉，将 <code>hexo</code> 源码复制到  <code>D:\blog\github_hexo</code> 下，查看文件状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><p><strong>注意:如果你之前是 <code>git</code> 直接 <code>clone</code> 的 <code>NexT</code> ，在拉取目录会自带 <code>.git</code> 和 <code>.github</code> 文件，需要删掉 <code>.git</code> 和 <code>.github</code> 文件，如果不删会出现拉取目录里的文件提交不上去的问题</strong></p><h3 id="设置语言、标题等"><a href="#设置语言、标题等" class="headerlink" title="设置语言、标题等"></a>设置语言、标题等</h3><h4 id="1-3-2-添加到暂存区"><a href="#1-3-2-添加到暂存区" class="headerlink" title="1.3.2 添加到暂存区"></a>1.3.2 添加到暂存区</h4><p><strong>(最后是一个 . 或者 -A 表示所有)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure><h4 id="1-3-3-提交本地代码库"><a href="#1-3-3-提交本地代码库" class="headerlink" title="1.3.3 提交本地代码库"></a>1.3.3 提交本地代码库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;描述&quot;</span><br></pre></td></tr></table></figure><h4 id="1-3-4-提交到远程分支"><a href="#1-3-4-提交到远程分支" class="headerlink" title="1.3.4 提交到远程分支"></a>1.3.4 提交到远程分支</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure><p>如果提示没有关联，则用下面指令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push --set-upstream origin &lt;分支名&gt;</span><br></pre></td></tr></table></figure><h3 id="1-5-其他终端操作"><a href="#1-5-其他终端操作" class="headerlink" title="1.5 其他终端操作"></a>1.5 其他终端操作</h3><h4 id="1-5-1-hexo-环境搭建"><a href="#1-5-1-hexo-环境搭建" class="headerlink" title="1.5.1 hexo 环境搭建"></a>1.5.1 <code>hexo</code> 环境搭建</h4><p>首先创建一个空目录，初始化 <code>git</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>安装 <code>hexo-cli</code> 执行下面命令，如果该终端执行过可跳过，再次执行会报错，需要删除掉 <code>C:\Users\&lt;电脑名字&gt;\AppData\Roaming</code> 目录下 <code>npm-cache</code> 和 <code>npm</code> 文件，重新执行这个命令就好。<code>(个人多次实践出来的，不行就删。。。)</code> </p><p>如果 <code>hexo</code> 命令执行过程中报 <code>bash: hexo: command not found</code> 就是没有安装 <code>hexo</code> ，需要执行下面的命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure><h4 id="1-5-2-拉取远程分支代码"><a href="#1-5-2-拉取远程分支代码" class="headerlink" title="1.5.2 拉取远程分支代码"></a>1.5.2 拉取远程分支代码</h4><p>然后执行 5.1 的操作 <code>git clone &lt;SSH/HTTPS&gt;</code>、<code>git remote add origin &lt;SSH/HTTPS&gt;</code> ，将远程所有代码拉下来。当前状态你只有主分支代码，你还需要拉取你 <code>test</code> 分支的代码，进入拉取下来的目录 <code>cd &lt;文件名&gt;</code> 。</p><p><code>git branch -a</code> 查看分支情况。然后切换并拉取 <code>test</code> 分支。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout test</span><br></pre></td></tr></table></figure><h4 id="1-5-3-安装环境"><a href="#1-5-3-安装环境" class="headerlink" title="1.5.3 安装环境"></a>1.5.3 安装环境</h4><p>首先在文件目录下，安装 <code>hexo</code> 和 <code>deployer</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo --save</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>然后编译并运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure><p>这样本地就好了，发布 <code>github</code> 需要配置 <code>SSH</code> 和之前 4.3 操作是一样的。</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> git </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 基础搭建</title>
      <link href="/2019/hexo-bash.html"/>
      <url>/2019/hexo-bash.html</url>
      
        <content type="html"><![CDATA[<p>目录请看 <a href="https://calmcenter.club/2019/Complete_works_of_hexo.html">Hexo 搭建博客大全</a></p><p><strong>注意：如果出现图片不显示问题请移步</strong> <a href="https://calmcenter.club/2019/PicNotShow.html">图片不显示问题</a></p><h2 id="本文主要记载"><a href="#本文主要记载" class="headerlink" title="本文主要记载"></a>本文主要记载</h2><ul><li>搭建本地博客</li><li>部署到 <code>Github Pages</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">本文环境是 win10 或 win 7。mac 再执行 npm 时需要在前面添加 sudo</span><br><span class="line">本文整理于各大佬文章，文中会给出相应链接，如有侵权，请联系我修改或删除。</span><br></pre></td></tr></table></figure><hr><a id="more"></a><h2 id="一、-搭建本地博客"><a href="#一、-搭建本地博客" class="headerlink" title="一、 搭建本地博客"></a>一、 搭建本地博客</h2><h3 id="1-1-首先安装-Node-js"><a href="#1-1-首先安装-Node-js" class="headerlink" title="1.1 首先安装 Node.js"></a>1.1 首先安装 <code>Node.js</code></h3><p>首先去 <a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">官方页面</a> 下载安装文件，无脑安装就好 （<del>。</del>）</p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/picturesnode.png" style="zoom:20%"><p>图中绿色选择部分，安装完成后输入 <code>npm -v</code> , 会告诉你版本号，就证明你安装成功了</p><p>3.2 安装 <code>Git</code></p><p>去 <a href="https://git-scm.com/download/win" target="_blank" rel="noopener">git官网</a> 下载电脑对应版本，进行安装，安装完成后，输入 <code>git version</code> ，会告诉你版本号，就证明你安装成功了。安装成功后，鼠标右键菜单里会多出 <code>Git GUI Here</code> 和 <code>Git Bash Here</code> 两个按钮。</p><p><strong><a href="https://www.cnblogs.com/wj-1314/p/7993819.html" target="_blank" rel="noopener">Git安装教程</a>  这个是百度的，如果不会查看本链接或重新百度就好~</strong></p><p><strong>我管理代码都是在 <a href="https://www.sourcetreeapp.com/" target="_blank" rel="noopener">Sourcetree</a> 上进行，后续会说，当然也是要 Git 的支持，这个还是很方便的，无脑操作~6</strong></p><h3 id="1-2-安装-Hexo"><a href="#1-2-安装-Hexo" class="headerlink" title="1.2 安装 Hexo"></a>1.2 安装 <code>Hexo</code></h3><p>*<em>注意执行命令期间 <code>WARN</code> 不管 只看 <code>ERR</code> *</em></p><p>在文件夹内如 <code>D:\blog</code> ，鼠标右键点击 <code>Git Bash Here</code> 一气呵成，来到了命令行界面。</p><p>首先安装 <code>hexo</code> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure><h4 id="1-2-1-镜像相关（如果-npm-可以正常使用这里跳过！）"><a href="#1-2-1-镜像相关（如果-npm-可以正常使用这里跳过！）" class="headerlink" title="1.2.1 镜像相关（如果 npm 可以正常使用这里跳过！）"></a>1.2.1 镜像相关（如果 npm 可以正常使用这里跳过！）</h4><p> 上面正常情况是没有问题的，但是由于国内访问官方 NPM 源速度较慢，为了一劳永逸，此处可以将 NPM 源更换为了淘宝 NPM 镜像源。<br><strong>请注意!!，如果你觉得你的 NPM 源速度够快，更换镜像源这部分可选择性使用</strong></p><p>在 <code>Git Bash Here</code> 中输入指令，将官方 npm 源更换为淘宝 npm 镜像源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>可以输入 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm config list</span><br></pre></td></tr></table></figure><p> 查看是否更换成功</p><p><strong>请注意，如需使用上方安装的淘宝源，需要在使用 npm 命令时将其改为 cnpm</strong>，但是如果用了 cnpm 再使用 npm 的话，好像有点问题，npm 一直报 err 。所以这里给出卸载镜像的命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall cnpm -g</span><br></pre></td></tr></table></figure><p>但是 npm 命令还是报错，还需要删除掉 <code>C:\Users\&lt;电脑名字&gt;\AppData\Roaming</code> 目录下  <code>npm-cache</code> 和 <code>npm</code> 文件，重新执行上面两个安装命令即可</p><h3 id="1-3-Hexo初始化"><a href="#1-3-Hexo初始化" class="headerlink" title="1.3 Hexo初始化"></a>1.3 Hexo初始化</h3><p>安装完成后，输入 <code>hexo -v</code> 会输出 hexo 版本号，证明安装成功。</p><p>然后在当前目录新建一个文件夹，比如 <code>D:\blog\hexos</code> ，在此目录下鼠标右键点击 <code>Git Bash Here</code> 执行，这条命令需要一个空文件夹所以新建一个。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><p>完成后，文件目录如下</p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/pictureshexo_file.png" style="zoom:100%"><p>这样就证明初始化完成了，然后我们继续要生成静态页面，用到的命令是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><p>其中，<code>g</code> 的全称是 <code>generate</code>，当然也可以用 <code>hexo generate</code> 这条命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-server --save</span><br></pre></td></tr></table></figure><p>然后就是运行了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>其中， <code>s</code> 的全称是 <code>server</code>，当然也可以用 <code>hexo server</code> 这条命令</p><p>然后，打开你的浏览器，输入<code>http://localhost:4000/</code> 即可看到本地静态博客</p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/pictureshexo_page.png" style="zoom:20%"><p>本地静态博客完成 ~ </p><p>如果出现 <code>Cannot GET/xxx</code> 等类似错误，意味着有文件未被找到。<code>Cannot GET/xxx</code> 错误本质是 <code>hexo server</code> 返回的一个404错误。</p><p>判断public目录下 <code>xxx</code> 文件是否存在。(我的错误是 <code>Cannot GET/</code> ，因此在public目录下寻找 <code>index.html</code> 是否存在。)</p><p>如果说 <code>index.html</code> 不存在，那么执行 <code>hexo clean</code>，<code>hexo g</code> 重新生成一次，回到步骤1。</p><p>步骤2执行完后 <code>index.html</code> 仍不存在，执行 <code>npm audit fix</code> ，查看是否少了什么组件，通过 <code>npm install hexo-xxx-xxx</code>  安装即可。</p><p>步骤3完成之后，执行 <code>hexo clean</code>，<code>hexo g</code> 重新生成静态文件。</p><p>仍然有问题，请再参考此文：<a href="https://www.cnblogs.com/Sroot/p/6305938.html" target="_blank" rel="noopener">https://www.cnblogs.com/Sroot/p/6305938.html</a></p><p>感谢 <a href="https://www.jianshu.com/p/af83fc73e525" target="_blank" rel="noopener">Cannot GET 错误解决方式 原文地址</a></p><hr><h2 id="二、部署到-Github-Pages"><a href="#二、部署到-Github-Pages" class="headerlink" title="二、部署到 Github Pages"></a>二、部署到 Github Pages</h2><h3 id="2-1-注册Github账户"><a href="#2-1-注册Github账户" class="headerlink" title="2.1 注册Github账户"></a>2.1 注册Github账户</h3><p>进入 <a href="https://github.com/" target="_blank" rel="noopener">github首页</a> ，点击右上角 <a href="https://github.com/join?source=header-home" target="_blank" rel="noopener">sign up</a> 进行注册。</p><h3 id="2-2-创建项目"><a href="#2-2-创建项目" class="headerlink" title="2.2 创建项目"></a>2.2 创建项目</h3><p>登录后，创建一个自己的 <code>GitHub Pages</code>。 点击头像中的 <a href="https://github.com/new" target="_blank" rel="noopener">New repository</a> 。</p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/picturesnew_repository.png" style="zoom:50%"><p>*<em>敲黑板！！ 这里重点就是项目名称必须是 <code>自己名称.github.io</code>  *</em></p><h3 id="2-3-配置-SSH-密钥"><a href="#2-3-配置-SSH-密钥" class="headerlink" title="2.3 配置 SSH 密钥"></a>2.3 配置 <code>SSH</code> 密钥</h3><h4 id="2-3-1-查看是否存在-SSH-密钥"><a href="#2-3-1-查看是否存在-SSH-密钥" class="headerlink" title="2.3.1 查看是否存在 SSH 密钥"></a>2.3.1 查看是否存在 <code>SSH</code> 密钥</h4><p>首先通过输入命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~&#x2F;. ssh</span><br></pre></td></tr></table></figure><p>如果存在则会进入此目录,可以略过 4.3.2，否则会提示你不存在，那么继续 4.3.2</p><h4 id="2-3-2-创建新的-SSH-密钥"><a href="#2-3-2-创建新的-SSH-密钥" class="headerlink" title="2.3.2 创建新的 SSH 密钥"></a>2.3.2 创建新的 <code>SSH</code> 密钥</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;your_email@example.com&quot;</span><br></pre></td></tr></table></figure><p>这将按照你提供的邮箱地址，创建一对密钥，然后让你输入 密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Enter passphrase (empty for no passphrase): [Type a passphrase]</span><br><span class="line">Enter same passphrase again: [Type passphrase again]</span><br></pre></td></tr></table></figure><p>如果你放心，可以不用密码，直接回车，这样每次提交的时候比较方便。</p><h4 id="2-3-3-在-GitHub-添加你的公钥"><a href="#2-3-3-在-GitHub-添加你的公钥" class="headerlink" title="2.3.3 在 GitHub 添加你的公钥"></a>2.3.3 在 <code>GitHub</code> 添加你的公钥</h4><ol><li>首先拷贝公钥内容（ mac 可能用不了，需要手动找到这个文件复制内容）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clip &lt; ~&#x2F;.ssh&#x2F;id_rsa.pub</span><br></pre></td></tr></table></figure><ol start="2"><li>然后登陆 <a href="https://github.com/" target="_blank" rel="noopener">GitHub</a> ，点击头像</li></ol><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/picturessetting.png" style="zoom:50%"><ol start="3"><li>进入设置页，选择 <code>SSH</code> </li></ol><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/picturessetting_list.png" style="zoom:50%"><ol start="4"><li>粘贴密钥，添加即可</li></ol><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/picturesssh_content.png" style="zoom:50%"><ol start="5"><li>测试</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/picturestest_ssh.png" style="zoom:100%"><ol start="6"><li>设置用户信息</li></ol><p><code>Git</code> 会根据用户的名字和邮箱来记录提交。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;name&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.email &quot;email&quot;</span><br></pre></td></tr></table></figure><p>这样就配置好了SSH</p><h3 id="2-4-将本地-Hexo-文件编译并上传-GitHub-的库中"><a href="#2-4-将本地-Hexo-文件编译并上传-GitHub-的库中" class="headerlink" title="2.4 将本地 Hexo 文件编译并上传 GitHub 的库中"></a>2.4 将本地 <code>Hexo</code> 文件编译并上传 <code>GitHub</code> 的库中</h3><ol><li>打开 <a href="https://github.com/" target="_blank" rel="noopener">github首页</a> 登录，找到左上角自己的项目</li></ol><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/picturesgithub_list.png" style="zoom:70%"><ol start="2"><li><p>点击 clone 点击 Use SSH 并复制 <code>SSH</code> 路径</p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/picturesgithub_ssh_path.png" style="zoom:70%"></li><li><p>打开 <code>hexo</code> 目录，找到 <code>_config</code> 文件</p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/pictureshexo_catalog_config.png" style="zoom:70%"></li><li><p>打开并找到 <code>deploy</code> 关键字</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:CalmCenter&#x2F;calmcenter.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p><strong>注意: 引号 后有一个空格，repository 填写 ssh 地址，branch 如果没有特殊要求，写master</strong></p><ol start="5"><li>编译并提交</li></ol><p>部署前需要先装 <code>deployer</code> ，<code>deployer</code> 用于将 <code>hexo</code> 部署到  <code>git page</code> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>提交前，有时候提交了不生效，需要清理一下缓存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure><p>编译并提交</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure><p> 和 <code>hexo g</code> 、 <code>hexo d</code> 一样</p><p><strong>提交后线上会有延迟才会展现最新效果，特别是配置样式之后</strong></p><p>提交过程中会让你输入一次密码，完成后就可以在外网访问博客了。<a href="https://calmcenter.github.io/" target="_blank" rel="noopener">https://calmcenter.github.io/</a> <code>https://用户名.github.io</code></p><p>假如这时候，报错 <code>ERROR Deployer not found: git</code>，那么就是你的 <code>deployer</code> 没有安装成功，你需要执行如下命令再安装一次：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>这样，你再执行 <code>hexo g -d</code> ，你的博客就部署到 <code>Github</code> 上了。</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> git </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>职场的真相</title>
      <link href="/2019/zhi-chang-de-zhen-xiang.html"/>
      <url>/2019/zhi-chang-de-zhen-xiang.html</url>
      
        <content type="html"><![CDATA[<p>各位同学，大家好，我是曹政，谢谢各位参与我的年终福利课程，职场的真相。<br>关于职场，说实话，我年轻的时候做的并不好，很多教训，很多很愚蠢的事情，所以，我不是说，一个成功职场精英，一个上市公司高管，给你们讲职场，当然，实话说，现在而言，上市高管对我来说不算什么很难的目标，但重要的是，当年我在混职场的时候，其实是很糟糕的。<br>直到自己参与创业，以及自己开公司的时候，站的地位不同了，反过来思考，才知道自己当年职场为什么糟糕。但我知道很多年轻人，可能会重蹈我的覆辙，经历很多教训，做很多自以为聪明的事情。所以这次分享，主要是面对年轻读者，特别是初入职场的读者，希望大家少走弯路，职场顺利。<br>有相当部分内容可能是去年提过的，如果看到了，就当复习吧，两年都提过的肯定是非常非常关键的，特意回看了一下去年的分享课内容，真的是太棒了，感觉今年内容很难超过去年。</p><a id="more"></a><h2 id="1-关于面试"><a href="#1-关于面试" class="headerlink" title="1 关于面试"></a>1 关于面试</h2><h3 id="1-1-做功课很重要"><a href="#1-1-做功课很重要" class="headerlink" title="1.1 做功课很重要"></a>1.1 做功课很重要</h3><p>什么是做功课，你去面试之前，应该先搜索了解这个公司的背景，诸如股权结构，公司负责人的背景，公司主要产品线构成和主要收入构成，公司主要竞品和竞争格局。如果有可能，尽量测试使用以下公司的产品，并搜索一下相关公司的口碑和介绍。</p><p><a href="https://mp.weixin.qq.com/s/9cT-Ng_hvj9V61_XEl-ZVg" target="_blank" rel="noopener">职场自救指南</a><br><a href="https://mp.weixin.qq.com/s/NQuWI2cg_JVJa4SJSpw9rg" target="_blank" rel="noopener">求职是需要诚意的</a></p><p>重复强调一下，有不少公司网上有一些坏的口碑，怎么办？要评估一下，其实大部分知名企业都会存在两极口碑，甚至是很糟糕的口碑，但不代表这个公司没价值，你要知道自己目的是什么。<br>当然也要根据你手里的offer数量和质量综合判断，你一把名企offer，你去甄别口碑，如果你现在要解决当下吃饭问题，只要公司不是那种骗子公司或者法律风险吓人的公司，其实都可以去的。</p><h3 id="1-2-简单而精确的自我介绍"><a href="#1-2-简单而精确的自我介绍" class="headerlink" title="1.2 简单而精确的自我介绍"></a>1.2 简单而精确的自我介绍</h3><p>面试一般都要自我介绍，那么介绍的环节要做到简单精确。</p><p>什么是简单精确</p><p>第一，最能体现你的价值，你的能力的点，要重点表达出来。不要不好意思说，不要以为面试官已经完整的审阅了你的简历或求职信。</p><p>第二，不要啰里啰唆，什么都讲，要分清重点，年轻人找工作有时候生怕少介绍了自己的成绩，什么都要列出来，说实话，有些学校里的证书价值含量极低，你越强调，别人会觉得，你的能力不过如此，还不如不提。</p><p><a href="https://mp.weixin.qq.com/s/v5uFBplY6lkcUqd7vuzETA" target="_blank" rel="noopener">「谈谈自我介绍与第一印象」</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI0MjA1Mjg2Ng==&mid=401539494&idx=1&sn=137441bcf08a53c84f67c5d859c66854&scene=21#wechat_redirect" target="_blank" rel="noopener">「谈谈写作」</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI0MjA1Mjg2Ng==&mid=400367085&idx=1&sn=108ac3dfc843baf5bc56f73edf646ae1&scene=21#wechat_redirect" target="_blank" rel="noopener">「所谓坚持」</a></p><p>大V系列<br><a href="https://mp.weixin.qq.com/s?__biz=MzI0MjA1Mjg2Ng==&mid=401981770&idx=1&sn=127123fb1ca12af53d77e3c567d75fca&scene=21#wechat_redirect" target="_blank" rel="noopener">「关于影响力」</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI0MjA1Mjg2Ng==&mid=401310703&idx=1&sn=979e25d208a6013b8c487726a5a2b020&scene=21#wechat_redirect" target="_blank" rel="noopener">「自我修养」</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI0MjA1Mjg2Ng==&mid=402041293&idx=1&sn=8ba4a204c76eb987f7a7b6130c304e71&chksm=7b0033a04c77bab6b9823c0d3ac21cc03771f5723c06205f0f48b1c50c751b3c4a98f1a14c76&scene=21#wechat_redirect" target="_blank" rel="noopener">「如何正确的勾搭大V」</a></p><h3 id="1-3提出有价值的问题"><a href="#1-3提出有价值的问题" class="headerlink" title="1.3提出有价值的问题"></a>1.3提出有价值的问题</h3><p>大部分公司面试都会有个让面试者提问的环节，很多面试者会问年终奖怎么发，休假怎么休之类的问题。<br>实话说，这类问题不是不能问，别人明确给你offer的时候，你问是没有问题的。<br>人家还在考核你的时候，问题本身是考核的一部分，能理解么？<br>前面为什么说要做功课，这里要问出有价值的问题。</p><p>什么是有价值的问题，关于对方的产品，竞品，业务方向，技术方案，提出自己认真思考后的疑惑。<br>实话说，做到有价值不容易，你可能觉得自己思考深度已经够深了，没准在别人眼里还是一个非常烂的差问题，这咋办，这岂不是弄巧成拙？</p><p>看你怎么理解了，你并不是只有一次面试，职场也并非只有一次选择，被 <code>Diss</code> 了，被别人批驳了，勤反思，为什么很关键的点自己没想到，为什么自己觉得很复杂的问题别人觉得不值一提？只要有收获，就不亏，每个人的职场认知都不是一步到位的，发现自己的不足，是成长的过程，只要成长够快，好的offer迟早是你的，不要在意一城一池的得失。</p><p>最怕的是什么，面试受了点挫折，出了点丑，问的问题被鄙视了，就觉得自己被针对了，被歧视了，加戏很多，对方不尊重自己了，企业文化糟糕了，有时候网上看看各种讨论，这样心态的年轻人还是挺多的。</p><p><a href="https://mp.weixin.qq.com/s/yW4rto4VF1AwFCs62UMZaw" target="_blank" rel="noopener">「别把自己当小受」</a></p><p>浅谈关于领导力<br><a href="https://mp.weixin.qq.com/s?__biz=MzI0MjA1Mjg2Ng==&mid=400713104&idx=1&sn=d38e44a244fb4125808124eb12a17299&scene=21#wechat_redirect" target="_blank" rel="noopener">「识人之能」</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI0MjA1Mjg2Ng==&mid=400819865&idx=1&sn=15fb195cb1cccc71430909a0b267ad2b&scene=21#wechat_redirect" target="_blank" rel="noopener">「授权与放权」</a></p><p>能力成长系列<br><a href="https://mp.weixin.qq.com/s?__biz=MzI0MjA1Mjg2Ng==&mid=209733294&idx=1&sn=111340c5aa21a98dd8b76abc1016dc68&scene=21#wechat_redirect" target="_blank" rel="noopener">「机会来自于担当」</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI0MjA1Mjg2Ng==&mid=209714599&idx=1&sn=1cd7f5ca6045be9da9374477871f1d3d&scene=21#wechat_redirect" target="_blank" rel="noopener">「归纳与总结」</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI0MjA1Mjg2Ng==&mid=209695455&idx=1&sn=4d9a296a87f9525907e1e58c85b0648b&scene=21#wechat_redirect" target="_blank" rel="noopener">「提问的技术」</a> </p><p>年轻人，如何抗造<br><a href="https://mp.weixin.qq.com/s?__biz=MzI0MjA1Mjg2Ng==&mid=2649868155&idx=1&sn=953dec87eb8af0ea29b6b0683f98ba36&chksm=f1075d16c670d4004438ab5a639eacfce8164caaec49d3c56727bc1e97cbceb0075889d3fd06&scene=21#wechat_redirect" target="_blank" rel="noopener">「无意义的忧虑与烦恼」</a><br><a href="https://mp.weixin.qq.com/s/YT85l1W9IqeybiE0fso0Bw" target="_blank" rel="noopener">「 预期管理及心态控制」</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI0MjA1Mjg2Ng==&mid=400665044&idx=1&sn=a8c001c227eb8e4b2559cde4c31db267&scene=21#wechat_redirect" target="_blank" rel="noopener">「从历史中讲创业的韧性」</a></p><h3 id="1-4-保持后续可行性"><a href="#1-4-保持后续可行性" class="headerlink" title="1.4 保持后续可行性"></a>1.4 保持后续可行性</h3><p>技术面试，或者产品运营的面试被难题考倒了，很多人当然会很沮丧，认为失去了一次机会。</p><p>其实这也是一种学习的机会，那么可以考虑这样的一种回答方式，“这道题确实超出了我的知识范畴，我回去想认真思考一下，方便留一下您的联系邮件么，我希望再次解答后还得到您的指点，不不不，我不是奢求再来一次面试，我只是想学会这个算法。”</p><p>或者这类“今天我回答的不好，谢谢您帮我发现了自己的差距和不足，能不能给我一些相关问题的学习资料，书籍和网址，我想回去认真学习一下，如果有可能，不知道以后还能不能得到您的指点，能否留一个您的联系方式。”</p><p>当然，以上并不只是面试的一套说辞，你回去之后还是要认真的完成学习并且认真的把更好的答案发给对方，并诚恳的希望得到对方的批评和指导。</p><p>每个求职者都会说自己热爱学习，愿意接受挑战，怎么证明啊？你看，你没拿到offer，都愿意去学习，这个印象分是什么。</p><p>下次这个公司有新的人力诉求的时候，或者其他岗位有诉求的时候，会不会想到你？我不能说肯定会，但我会说，这样的机会真的会有。</p><h3 id="1-5-关于离职原因的回答"><a href="#1-5-关于离职原因的回答" class="headerlink" title="1.5 关于离职原因的回答"></a>1.5 关于离职原因的回答</h3><p>这是最难回答的面试问题了，那么分三个情况。</p><p>第一，非裸辞的情况，这种相对容易一点，觉得这边机会更好，发展空间更大，能学到更多东西，待遇更有优势，这些都没问题的。尽量不要埋怨老东家，不要说老领导多不好，老东家多苛刻，实话说，人家会很担心，你以后去下一家公司的时候，还会这么说他们。</p><p>第二，裸辞的情况下，那么确实要解释的更多，有些是比较容易解释的，旧公司业务风险较高，所以赶紧撤出。加班太多，个人身体有些吃不消/家里人照顾不到。这种直说也无妨。</p><p>有些可能确实跟旧东家发生了较多矛盾，或者甚至是被裁员，被开除。可能讲出来不是很好听，我觉得把握一个原则，要敢承认自己的不足。比如当时争论的时候确实有些冲动，或者说认真反思了一下，当时确实可以做的更好一些。</p><p>不要一昧的指责旧东家和旧同事，要认真的反思和承认不足，摆事实讲道理，特别是情绪要稳定，一定要让面试官觉得你是讲道理的人，是不记仇的人，这点很重要，说实话，职场上的老江湖，没有谁会轻信一家之言，你真的特别委屈特别冤枉，别人也不会认为这是完全的事实。</p><p>第三，换工作较多的场景，比较碎的工作经验，说实话，尽量尽量不要有这样的职场记录，你说我抹去一些行不行，其实是可以的，但还是尽量不要有这样的职场记录。</p><p>现在一些年轻人，怎么说呢，挺任性的，工作不开心就辞职，换工作比换手机快，一年换好几份，当然，往好处说也是一种人生体验，但确实在后续求职应聘的时候，会有很不好的影响。</p><p>还是那句话，要坦诚自己的问题，面试官问了，别找太多借口，自己当时年轻，社会经验不足，求职的时候考虑不周全，工作的时候也有点任性，坦坦荡荡的说，尽量让人觉得你现在成熟了，认识问题了，不会那么毛躁了。</p><p>当然，有些换工作的经历并不是坏事情，比如前任领导离职创业把我拉出去了，后来创业失败了，投资人拉我进了另一个项目，但很不幸项目也没成功。这种其实不是坏事，说明你的能力被之前的领导，投资人认可，虽然项目换的多，但不会是负面。</p><p>现在不是说找份工作一定要干很多年，但换工作还是要谨慎，尽量找能坚持几年的事情做。</p><h3 id="1-6-关于项目经验的回答"><a href="#1-6-关于项目经验的回答" class="headerlink" title="1.6 关于项目经验的回答"></a>1.6 关于项目经验的回答</h3><p>面试官经常会问，你以前做过的项目，及你在项目中的工作是什么。我其实也强烈建议，日常工作中养成勤奋总结的好习惯。功夫当然还是在日常。</p><p>我以前说过这个案例，项目的方案描述，数据及逻辑清晰不清晰，比如性能优化，优化前的并发指标是什么，优化方案是怎么考虑的，优化后如何测试的，测试指标是怎样的。<br>上线后的数据指标是怎样的，进一步优化的预案有没有，对进一步并发压力的预警系统有没有做，怎么做的。很多人只是简单描述了优化方案，然后说问题解决了，这其实是不行的。</p><p>项目经验，你的总结能力比项目本身更重要，项目很牛逼，你讲出来都是泛泛而谈，我是里面的工程师，写了一个什么结构，你觉得你讲的很清楚，面试官怎么觉得？项目牛逼和你有关系么？项目很一般，你讲的逻辑很清晰，什么问题，如何解决，为什么选择这个方案，效果对比，说明什么，说明你分析问题，处理问题的思路清晰，逻辑严谨，这是人家看重的。</p><p>所以，面试前，把你当年最得意的，认为最能体现自己价值的项目经验，认真复盘一下，尽可能用数据化的方式展现出来，并整理好你的决策和分析逻辑，以及整个项目的分析逻辑。</p><p>为什么很多人觉得我牛逼，很多事情不是我做的，但是我整理后写出来，思路很清晰，逻辑很严谨，数据指标很给力，人家至少知道，这个事情，我是理解透彻了，面试官发现你对项目理解透彻了，能够驾驭了，是不是你完成的，还那么重要么。</p><p> <a href="https://mp.weixin.qq.com/s/A3k8aRbd7o4uuELZAMM_KA" target="_blank" rel="noopener">「面试官是怎么看简历里的项目经验」</a></p><h3 id="1-7-刷题"><a href="#1-7-刷题" class="headerlink" title="1.7 刷题"></a>1.7 刷题</h3><p>刷题有用没？其实是有用的，特别是巨头的面试，还是很看重的。技术面试，<code>leetcode</code> 的题目，如果有足够的刷题经验，还是会很有帮助。</p><p>刷题的几个要点，第一，举一反三，一定要对解题思路理解透彻，能够让算法适应不同的类似场景。第二，一定要增强题目理解力，因为面试官问问题的时候，往往不是题库里那么直接，很多人明明刷题做的很好，但是现场理解上出了偏差，本来是做过的东西，现场换了一个问题，就不知道怎么处理了。</p><p>那么现场如果对面试官的题目理解不到位，可以多问一些问题来理解，不要不好意思问，问清楚再回答。</p><p>刷题的时候自我感觉没问题，面试理解错，这种情况其实非常常见，那么同时，我也说过容错性的话题很多次，也要允许面试官，存在表达歧义的可能性，这就是为什么要追问，要通过追问明确问题的原因。</p><p>增加理解力和沟通能力，在职场永远都是非常重要的。</p><p>我有篇文章，找个小伙伴，日常沟通训练，不知道有多少读者去实践了。</p><p>沟通 <a href="https://mp.weixin.qq.com/s/f_CF8dRObw78k9b9DFAyKA" target="_blank" rel="noopener">「有效提升沟通能力」</a> </p><h3 id="1-8-交流得体"><a href="#1-8-交流得体" class="headerlink" title="1.8 交流得体"></a>1.8 交流得体</h3><p>沟通交流过程中，如何得体，不要太过拘谨，但也不要太过于随便。</p><p>这个度怎么把握？<br>说真的，有些年轻人学校里随便惯了，进入职场的时候，还是那种无所谓，各种玩笑，各种不在乎的样子，这种印象是很不好的。</p><p>第一，穿衣着装，不是说非要正装西服，但还是要相对正式一点，比如短裤背心是不合适的，当然如果你在业内是顶尖大牛，你穿什么都行，职场新人，求职的时候，着装稍微正式一点。</p><p>第二，称谓和交流，客气一些。多用“您”字，多说几句谢谢，多体谅一下面试官，“没关系，我可以等”。“今天学到了很多，感谢您的指导。”“对不起，我能稍微打断一下么，刚才那个问题没听清楚。”，“不好意思，我想多问一句，这个题目中的什么什么，我理解是这样这样，不知道是不是。”</p><p>第三，也不用过于拘谨，适当的主动表达也是很有意义的。“我试了一下咱们的产品，真的很好用，昨天还在跟同学安利呢。”，“咱们公司今年增长太快了，我还特意看了一下财报数据，太惊人了。”</p><p>第四，既要谦虚，也要有自信，不知道能不能理解这个尺度。“我们当年这个项目其实还是有些缺陷的，当时经验不足，时间也比较紧张，有几个地方这里那里的考虑不全，如果现在交给我来做，应该会好很多。” 要承认自己的不足，也要对自己的发展空间有信心。“您提的这个问题，确实我现在可能没办法回答到位，不过如果给我一周时间，我相信会给您一个满意的答案。”</p><p>第五，无论面试成败，都要感谢对方，保留好印象，行业不大，人生何处不相逢。</p><h2 id="2-什么是职场中的态度"><a href="#2-什么是职场中的态度" class="headerlink" title="2 什么是职场中的态度"></a>2 什么是职场中的态度</h2><h3 id="2-1-愿意尝试，愿意学习，积极沟通"><a href="#2-1-愿意尝试，愿意学习，积极沟通" class="headerlink" title="2.1 愿意尝试，愿意学习，积极沟通"></a>2.1 愿意尝试，愿意学习，积极沟通</h3><p>在职场里，态度是非常关键的。<br>遇到困难和障碍，是否愿意学习，是否愿意尝试，这是很重要的，还记得王兴不是贴过一段记录，说他们公司谁谁谁，问什么东西用过没有，人家的回答是，没用过，不过我可以学。</p><p>王兴为什么会贴这句话，“我不会，但我可以学”，在职场是几乎每个老板都看重的素质。</p><p>“我不是这个专业的”，“我来这里不是为了干这个的”，“这个事情不该我来做”，很糟糕，真的，很糟糕。</p><p>另一点就是积极沟通，什么是积极沟通，有问题就问，有观点要表达，当然表达方式可能需要一些技巧，但要敢于表达，有机会要争取，有责任要敢承担。</p><p>此外，项目出现问题，或者出现阻碍的时候，要主动通报，主动寻求协助，主动告知相关同事，这也是积极沟通很重要的一点。</p><p>我们一直说的，印度裔在欧美为什么比华裔吃香，积极沟通这件事上，我们很多人真的没有当回事。中国人干活，印度人表功，为什么会这样，真的是职场不公？其实不是的。</p><p>积极沟通对应的是消极沟通，什么是消极沟通，坐等老板给机会，坐等别人派任务，别人不问就闷头不说，遇到问题不找人帮忙，非要自己抗，影响全局还觉得自己很委屈。</p><p>当你作为老板，面临项目安排规划和人员调配的时候，你就会理解，为什么积极沟通如此重要，为什么闷头做事的中国人不如擅长表功的印度人。我非常希望读者能彻底理解这一点。</p><p><a href="https://mp.weixin.qq.com/s/tlw7hm9No7WNnaDqozyB7w" target="_blank" rel="noopener">「谈谈主动工作」</a><br><a href="https://mp.weixin.qq.com/s/QXEg4oK48G0X-AV3X9c2NQ" target="_blank" rel="noopener">「从校园到职场 - 提问与交流」</a><br><a href="https://mp.weixin.qq.com/s/WI-rFdNOQjRfcwnXNFYx9g" target="_blank" rel="noopener">「再谈职场沟通」</a></p><h3 id="2-2关于加班的话题"><a href="#2-2关于加班的话题" class="headerlink" title="2.2关于加班的话题"></a>2.2关于加班的话题</h3><p>我知道很多人不想加班，但确实很多公司可能存在较多加班场景。</p><p>第一，要理解临时性的加班任务，比如线上出了一个紧急bug，或者有个活动得组织和维护压力非常大，我觉得除非家里有紧急情况需要处理，这种加班还是多体谅一下公司。<br>比如所有国内电商周边公司双11可能都加班，你要想吃这碗饭，你说你坚决不加班，那可能这行真的没你位置了。</p><p>第二，在工作效率和表现上体现优势，你不加班，但你做的事情漂亮，任务完成的很好，那你跟领导沟通的时候，也有足够的底气。</p><p>第三，积极沟通，充分理解诉求和目标，减少无用功。这个去年分享课也提过，很多职场的人闷头做事，把简单的事情做复杂，把很容易处理的问题扩大化，实际上很多都是一厢情愿造成的。多沟通，深入了解诉求，学会把握重点，抓大放小，很多时候，看上去很复杂的工作任务，其实可能没那么复杂，要允许领导描述不清，但自己应该具有进一步核对和澄清的能力。事情多的做不完，最后发现都是无用功，这种情况在职场真的非常常见的！</p><p>第四，部分任务可以考虑在家完成，我在西雅图见一个老朋友，<code>FB</code> 的华人技术经理，美国名校博士，我们觉得美国公司不加班，其实他说很辛苦的，给我看他的日常任务排期，从早到下午都是会议，然后说，白天上班根本没时间写代码，而自己还是有很多代码任务的，怎么办，晚上回家写。</p><p>是的，因为要接孩子，从不在公司加班，但实际上每天都要工作到很晚。 据说在 <code>FB</code> 这种情况并不少见。 其实美国也不止是 <code>FB</code> 如此，西方互联网巨头，很多人工作也是蛮辛苦的。</p><p>这就存在一个跟领导沟通的问题，家里确实有事情，不能在公司加班，但应该完成的工作任务会在家里完成，不会影响进度。实际上家里如果干扰少一些，完成的效率会更高。可能在公司需要几个小时扯皮交流然后慢慢熬的任务，回家后一个小时，甚至半个小时就搞定了。而且你不用去想着如何偷懒摸鱼，早干完时间都是自己的。</p><p>第五，认清现实，我们讲正确呢，说一个好的企业不应该大量无效加班，但另一方面，我们在职场，确实很多事情不是自己认为对就可以的。</p><p>如果你能选择一个不加班，待遇好，成长好，而且还能发挥你优势的岗位，当然，我恭喜你。</p><p>如果你发现很多条件不能兼顾，想清楚自己想要什么，这点很重要。</p><p>选择offer 的时候，很多时候你不可能拿到完全满意的条件，这时候，什么是你当前最看重的，我不能替你做主。</p><p>我去年讲过职场的成长期，成熟期和变现期，不同期间不同诉求，但不同的人有不同选择，不要苛求完美的职场，不要苛求完美的工作，想好自己这一步能获得什么很重要。</p><p> <a href="https://mp.weixin.qq.com/s/Gz5rBTpMdFkNZUZKlV7D4Q" target="_blank" rel="noopener">「关于程序员的996，我们谈谈历史和逻辑」</a></p><h3 id="2-3-面对事故和问题"><a href="#2-3-面对事故和问题" class="headerlink" title="2.3 面对事故和问题"></a>2.3 面对事故和问题</h3><p>职场经常会遇到一些严重的事故，问题，障碍。<br>很多人觉得我必须努力解决掉所有问题，再去给领导汇报，这样可能显得自己比较厉害和负责。</p><p>当然，如果你能尽快的解决掉问题，处理完事故，然后写汇报，这是没问题的，但很多时候，你可能没办法快速解决，快速处理，而且，甚至可能这个问题会影响到很多关联的同事，很多相关工作和计划安排，这时候，你如果还是憋着自己去解决，不汇报，不通知，就非常要命了。</p><p>一定要有全局意识，如果问题会导致其他人的工作延期或者对别人的工作有重要影响，或者超出个人能力范围，一定要主动知会相关人员，并寻求协助。</p><p>就算你工作很努力，一直很拼，很竭尽全力的处理问题，你认为自己的表现已经足够好了，但因为你没有知会关联同事，影响了其他人的进度和主管的项目把控，你这个努力也不能扭转这个损害，你觉得自己委屈，出bug，出故障难道不是很常见的事情么，出问题可以说不是什么太大的责任，但不通报是严重的灾难。当你成为经理，总监，或更高层的管理者，你就明白为什么这么说了。</p><p>我经常对自己公司的员工说这样的话，但我发现很多人依然还是我行我素，自己闷头去处理问题，闷头解决问题，不通报，不知会，总想着解决完再告诉我。讲真，这种情况惹得我火很大，这是管理者不能容忍的。</p><p>面对事故和问题，还有一个责任的承担问题，其实遇到事故，遇到问题，第一重要的是尽快解决问题，责任不要急于撇清，不要急于去分辨，先解决问题。不要说，这不是我的责任，这不是我的错，先说，我现在就去检查，去解决。解决完，处理完，写汇报的时候，再去说明真实原因和逻辑。</p><p>那么该自己承担的责任，要敢于承担，不要总是想着甩锅，总是想着辩白，大部分主管和领导都不傻，年轻人进入职场，千万不要小聪明，很容易被识破，如果发现你不诚实，没担当，这个问题的严重性远远大于你犯了错误。</p><p>但承担责任，敢于担当，也要有具体的行动，比如如何弥补，如何有效的预防类似的问题，如何进一步提升自己的问题解决能力，而不是每次都态度诚恳的道歉，认错。你总是态度很诚恳，但总是犯同样的错误，这也不行对不对。</p><p>我在职场真的见识过那些会甩锅，会推卸责任的年轻人，我说实话，可能一次两次，领导没有真的追究，看上去好像平安无事，但后面遇到升职机会或者更好的项目安排的时候，基本上领导是不会给他们的，我是看在眼里的，这样的案例并不少。</p><p>很多时候这些人觉得自己很聪明，每次都没事，但他们并不知道，人家已经给他们在心里打上一个标签。后续无数好机会都跟他们没关系了。</p><h3 id="2-4-面对合作诉求"><a href="#2-4-面对合作诉求" class="headerlink" title="2.4 面对合作诉求"></a>2.4 面对合作诉求</h3><p>第一，是跟上司和领导通报。很多内部合作，别人来找你，你觉得不麻烦，或者是对方级别比较高，你不敢得罪，就去给人家做事情了，但你的直接上司不知道，你影响本职工作进度，或者有些数据和信息处理是未经授权的，这其实就非常糟糕了。我以前就不是太在意这个，总觉得我为了公司难道不对么？你的上司有权决定这件事该做还是不该做，以及该如何做。你说我私下不影响进度帮同事忙行不行，有些信息数据授权的问题要考虑的，企业内部也有风控，很多你不以为然的事情可能是有严重问题的。遇到严格的内部审计吃不了兜着走的。要通报，要征询上司的授权，不要总觉得无所谓，可能一两次上司没有追究你的问题，但是记着，他心理可能给你打标签了，你没有尊重他的管理职权，他以后怎么会信任你。</p><p><a href="https://mp.weixin.qq.com/s/RLy79oG-ovYr23oOWUPrgA" target="_blank" rel="noopener">「那些用力过猛的员工」</a></p><p>第二，是外部合作中，关于利益诉求和目标的问题，以前旧文也提过，很多职场的人会用力过猛，以为自己为公司特别尽力，各种事情务必在自己公司角度争取最大利益，其实是很糟糕的，因为长远的合作需要双赢，也需要持续的信任。太鸡贼太苛求实际上过犹不及。<br>包括自媒体合作也是，有些企业的公关恨不得自媒体作者所有数据都提供清清楚楚，内容版式改上七八遍各种调整，各种朋友圈微信群都要给他们发一轮，似乎他们这样是为了公司的宣传效果，体现工作价值。坦白说，遇到我和冯老师这种大V，合作一次就烦了，爱做不做，爱信不信，唧唧歪歪，不伺候行不行啊。反而有些简单明了的，他们轻松，我们也轻松，长期合作，我们特么的也不会为了赚他一笔广告费砸自己招牌对不对。确实效果不太好的，不用广告主说，看到数据不理想，我直接补送一个位置就是了。<br>合作的要点，总结一下，一是向上汇报，二是双赢互利互信。别鸡贼，别什么便宜都想赚，多换位思考。</p><h3 id="2-5-面对可能的误解和委屈"><a href="#2-5-面对可能的误解和委屈" class="headerlink" title="2.5 面对可能的误解和委屈"></a>2.5 面对可能的误解和委屈</h3><p>职场中会不会背锅，有没有委屈，会不会被误解。肯定有，而且很常见。</p><p>但我说句潜规则，领导会喜欢那些经得起委屈，扛得起批评的人。很多事情，时间会给出不同的答案。当年王坚博士搞阿里云的时候被批判的还少么，全公司大会上被几乎各个部门吐槽，最后怎样，现在叫王坚院士。</p><p>还有就是，其实有不少领导，只有对亲信才会批头就骂，毫不留情。你看他对你客客气气，从不大声指责，说实话，根本就没拿你当自己人。</p><p>做好手头的工作，用事实来证明自己，事实是最好的辩解。当然，并不是说遭到误解就不解释，有些真的需要时间来证明，有些可能需要深入的沟通，但这里有两点要说明，第一，就事论事，切忌情绪化和人身攻击。否则对的也会变错。第二，只列事实即可，不要臆测，不要假设，不要扣帽子。事实如此，不要说对方是怎样怎样陷害你，这些都是臆测，而且很多都是错误的臆测。</p><p>当然，职场还有一个潜规则，就是尽可能有证据留存，比如沟通邮件，会议记录，确认通知。遇到扯皮的时候，没有证据，就没办法证明责任了，比如某个需求到底是谁提出的，为什么这么提，你明明只是执行者，但是需求方说没提过，你百口莫辩。</p><p>最后，还是要强调，职场不能怕委屈，不能怕误解，时间真的会给出证明。你背了锅，也许你的领导不清楚，但也许别人清楚，公司发展过程中，每个人的角色都会变化，只要你自己不要自暴自弃，总会有新的机会，在某些人眼里，你的委屈甚至是加分项。</p><h3 id="2-6-不吝称赞"><a href="#2-6-不吝称赞" class="headerlink" title="2.6 不吝称赞"></a>2.6 不吝称赞</h3><p><a href="https://mp.weixin.qq.com/s/b0vPDniK3S1KcfWtTQ27lQ" target="_blank" rel="noopener">「再谈职场中的用力过猛」</a></p><p>读书的时候，经常会有一个坏习惯，嘴比较损，特别喜欢揶揄别人，并认为这是关系亲密的象征。说实话，这个问题很常见，我也不例外。</p><p>但职场有时候不自觉就会得罪人。而且自己还以为彼此关系很融洽。</p><p>很多人不喜欢称赞别人，觉得是拍马屁，觉得是奉承。</p><p>我这么说吧，如果人家做的真的好，确实体现了水平，你就应该正面的称赞别人，职场情商里，最重要的就是这条。</p><p>特别是团队合作，项目总结，要感谢所有帮助过你的同事，上司，下属，感谢每个做出贡献的人，并如实的称赞他们的功劳。<br>下属习惯想当然，不知道问一下主管–本来可以避免的。</p><p>赞美他人会让你的职场和社交关系突飞猛进，真的。<br>把那些用于揶揄挖苦的语言天赋转为赞美，你的职场之路会完全不同。<br>实话说，我也不喜欢奉承，拍马屁，很多名气很大的人我也不给面子的，但我认为如实称赞是非常值得的，很多人在某些领域很优秀，首先，你应该看的到，然后，也应该说出来。</p><h2 id="3-信任是如何产生的"><a href="#3-信任是如何产生的" class="headerlink" title="3 信任是如何产生的"></a>3 信任是如何产生的</h2><p>职场信任关系是极为关键的，取得信任才能获得更多的机会，那么信任不是一蹴而就的，需要积累，以下是信任关系的一些要点。</p><h3 id="3-1-正确而及时的汇报"><a href="#3-1-正确而及时的汇报" class="headerlink" title="3.1 正确而及时的汇报"></a>3.1 正确而及时的汇报</h3><p><a href="https://mp.weixin.qq.com/s/tlw7hm9No7WNnaDqozyB7w" target="_blank" rel="noopener">「谈谈主动工作」</a><br><a href="https://mp.weixin.qq.com/s/fWx_JY6tcrYr8DJ6YmPeog" target="_blank" rel="noopener">「职场推进屡屡受阻，别总找借口。」</a></p><p>常见问题，该汇报而不汇报<br>任何可能导致你所承诺的时间计划任务产生变动的因表和事任何可能需要上一级授权的事件和工作。<br>任何可能影响团队其他人或公司其他团队工作安排和计划的因素和事件。<br>里程碑事件，进度变化，任务状态需要其他团队协助，资源协助的事件和工作。</p><p>很多人闷头做事，自己闷头解决问题，不汇报。不知会，总想着自己解决完问题再汇报，我再次强调，这是极为糟糕的！我自己团队有这种情况，我是极为火大的，如果你是创业者，你就能理解为什么这种情况极为糟糕。因为很多项目进度和后续安排，彻底失控。</p><p>我希望读者理解，作为管理者，最怕的不是问题和困难，而是失控，完金无法掌握项目的进度，障碍和影响范畴。<br>很多闷头做事的人犯了严重的错误而自己不知道，觉得自己很辛若，觉得别人天天打小报告的还能升职，你导致了领导失控，你还觉得自己没问题。</p><p>常见误区，不该汇报而频繁汇报自己职权内完全可以处理并解决的问题和事件。<br>无意义的表功表忠心<br>流水账，工作清单记录</p><p>汇报什么呢，我今天做了什么，我完成了什么，我解决了什么问题，我学习体会了领导的讲话，一切都是表达我很努力，很认真，很勤奋的工作。<br>这种普通员工这么写呢，也不是什么大问题，但如果你有一定职务级别，这样写是很糖糕的。因为这些事情，很多是上级完全不关心的。</p><p>我为什么要关心你今天写了什么代码，解决了什么问题，我要关心的是你进度到哪里了，你任务完成的如何了，预计上线时间会不会有影响，对项目团队有没有影响，需要不需要我做什么<br>很多人觉得自己汇报的很详纽，工作量很大，但为什么每次升职都轮不到自己，人家觉得你就是一个闷头干活的，根本抓不住重点讲，连份汇报都写不好，还谈什么升职。</p><p>认真的想想，如果你是领导，底下人的汇报对你来说意味着什么，是让你继续掌控项目的进展和状况，同时让你知道你需要做什么来推动这个项目前进，解决中间的问题。很多人认为汇报就是说自己工作多努力多辛苦多了不起。骨子上就错了。</p><h3 id="3-2-完成任务是第一位的"><a href="#3-2-完成任务是第一位的" class="headerlink" title="3.2 完成任务是第一位的"></a>3.2 完成任务是第一位的</h3><p>很多人觉得怀才不遇，我有很好的想法领导不采纳，我有很棒的建议领导不肯听。或者我的方案比领导的更好。</p><p>是真的么？也许是真的，但问题是，领导凭什么相信你呢？这是需要过程的，而这个过程最核心的就是，你要先把交代的任务做好。</p><p>你可以说你有更好的建议，更多的想法，基本的工作没做好，你谈什么其他呢？</p><p>建立信任的第一步，先把交代的任务做好，不管大事小事，完成到位。你说领导的设计不合理，你完成到位，然后项目没有成功，这不是你的责任，但你已经证明你自己可以做好事情，建立了做事靠谱的印象分，你再提出新的方案，新的计划，被接受的可能性更大一些。</p><p>嫌弃工作不重要，嫌弃事情没有办法体现你的能力和价值，但又不好好做，应付，错漏百出，然后埋怨领导不给你更好的机会，不让你做更有挑战的工作或者完成你更伟大的梦想，信任基础啊。</p><p>很多失败的项目同样可以建立信任基础，你做的好不好，别人看的出来，失败的原因，别人能想明白，你自己没做好，说是别人设计问题，这个你推卸不出去的。你至少要让自己的表现足够好。</p><h3 id="3-3-提出有价值的问题，不断提出有价值的问题"><a href="#3-3-提出有价值的问题，不断提出有价值的问题" class="headerlink" title="3.3 提出有价值的问题，不断提出有价值的问题"></a>3.3 提出有价值的问题，不断提出有价值的问题</h3><p><a href="https://mp.weixin.qq.com/s?__biz=MzI0MjA1Mjg2Ng==&mid=209695455&idx=1&sn=4d9a296a87f9525907e1e58c85b0648b&scene=21#wechat_redirect" target="_blank" rel="noopener">「提问的技术」</a><br><a href="https://mp.weixin.qq.com/s/QXEg4oK48G0X-AV3X9c2NQ" target="_blank" rel="noopener">「从校园到职场 - 提问与交流」</a> </p><p>不要怕提问，不要不敢提问，其实提出有价值的问题，是建立职场信任很关键的步骤。</p><p>上司讲解了产品设计目标，你提出关键的一些要点问题，这证明什么，第一，你认真的去理解上司的讲话了，第二，你有自己的深入思考，第三，你能从中发现一些关键点，关键问题。</p><p>提出有价值问题的人，更容易得到好的项目机会和升迁机会，真的。欧美更是如此，我以前讲过，新加坡英语职场培训，案例里，乖乖记录不提问的是坏案例，而能举一反三提出有价值问题的是好案例。不懂必须问清楚是这边职场很重要的原则。</p><p>当然，尽量不要问蠢问题，什么是蠢问题，你一个设计师去问马云，集团下一步的海外战略是什么，听上去很高大上，其实是个蠢问题。</p><p>与自己工作职能目标密切相关，具有一定的合理选择范围，并且需要一定的洞察力才能回答的问题，那种根本不用选择的问题也是蠢问题，比如，问上司，咱们是要做合法的产品还是违法的？你说呢。</p><p>如果对问题的答案表示质疑，也可以合理指出，请问为什么我们会选择这样一个方案，从而理解方案动机和选择逻辑，这对工作中很多重要选择很有帮助，你才知道什么是你应该关注的，是应该重视的，什么不是。</p><h3 id="3-4-不要试图掩盖自己的弱点，要主动寻求帮助和提升"><a href="#3-4-不要试图掩盖自己的弱点，要主动寻求帮助和提升" class="headerlink" title="3.4 不要试图掩盖自己的弱点，要主动寻求帮助和提升"></a>3.4 不要试图掩盖自己的弱点，要主动寻求帮助和提升</h3><p>很多年轻人知道自己存在缺点和不足，不希望领导知道，尽量去隐瞒，用其他借口和理由规避自己的不足，其实我年轻时候也会这样。<br>主动寻求帮助和提升，其实更容易建立与领导的信任。</p><p>第一，坦诚是有长期复利的。<br>第二，从心理学来说，领导会认为，帮助你成长是他的成本，他有回报预期，而他的回报预期，就是你向上的机会。<br>第三，以前科举，学子们中榜后要去拜老师，递门生贴，我希望你们能理解这个背后的含义是什么，你主动寻求领导的帮助和提升，其实也是递门生贴。</p><h3 id="3-5-扛得住委屈，忍得住寂寞，坚持出成果"><a href="#3-5-扛得住委屈，忍得住寂寞，坚持出成果" class="headerlink" title="3.5 扛得住委屈，忍得住寂寞，坚持出成果"></a>3.5 扛得住委屈，忍得住寂寞，坚持出成果</h3><p>有些委屈，需要时间来证明，那就花点时间去证明。</p><p>有时候，别人风光在前，你觉得不公平，但自己做好自己的事情，很多时候，时间会给你公平，这样的案例我在职场看到太多了，不要说三十年河东，三十年河西，风光一时的可能没有一两年就原形必露，而扎扎实实做事情的不会总是被埋没。当然，这里依然要强调沟通和汇报的能力。但你要做出证明自己的成果，不要总是因为一时委屈和埋怨就半途而废。</p><p>市场需要成熟期，产品需要成熟期，用户也需要成熟期，一些被批评的体无完肤的产品，可能几年后就成为明星爆款，不说别的，当年大话西游不就是么。更早之前，周星驰龙套憋屈了多少年，做出证明自己的成果，是最令人信服的反击质疑和押击的方式。</p><h2 id="4-如何面对不公平"><a href="#4-如何面对不公平" class="headerlink" title="4 如何面对不公平"></a>4 如何面对不公平</h2><h3 id="4-1-世界就没有公平"><a href="#4-1-世界就没有公平" class="headerlink" title="4.1 世界就没有公平"></a>4.1 世界就没有公平</h3><p> <a href="https://mp.weixin.qq.com/s/Si_Hrk6GBP7uGbY3C-gOlA" target="_blank" rel="noopener">「从校园到职场，很抱歉，世界并不按你的计划前进」</a><br><a href="http://mp.weixin.qq.com/s?__biz=MzI0MjA1Mjg2Ng==&mid=2649867486&idx=1&sn=d5a15a242f7c55d5b62195f51b768722&chksm=f1075eb3c670d7a5b837eeefd98051c02b624668e3583afceee15eedb0a6ae3dfb6f0d4eae61&scene=21#wechat_redirect" target="_blank" rel="noopener">「从“自相矛盾”的一些问题来谈谈认知」</a><br><a href="http://mp.weixin.qq.com/s?__biz=MzI0MjA1Mjg2Ng==&mid=2649867005&idx=1&sn=8d2c47cead54264afbfc0bc628f48a0c&chksm=f1075890c670d186792521e0afa1ed2e1e8162d26786ba58fe384002cd566aa9721c76ee17ff&scene=21#wechat_redirect" target="_blank" rel="noopener">「谈谈容错性」</a></p><p>你需要的是机会，和提升自己把握机会的能力，别人机会比你多，别人比你条件优越，没办法的，人从基因就开始不公平，投胎也不公平，你怎么办，就放弃自己重新投胎了？<br>最重要的是有没有自己向上，前进的机会，没有机会，再好的企业氛围，领导重视，公司环境，不要留恋。有很好的机会，那些噪音，可能的不公平，真的不用那么看重。</p><h3 id="4-2-确认自己的投入产出合理性"><a href="#4-2-确认自己的投入产出合理性" class="headerlink" title="4.2 确认自己的投入产出合理性"></a>4.2 确认自己的投入产出合理性</h3><p>你投入的时间，精力，资源，和你所获得的回报，从行业来说，从其他平台对比来说，这份回报是否合理，是否值得，值得，这就是很好的工作，很好的事情。你说某某某不如你比你回报高，这种心态要不得。如果你觉得不值得，你可以找到投入产出回报更高的平台和职位，那就转身离开，你说公司已经特殊照顾你了，这不重要。</p><h3 id="4-3-良好的沟通方式"><a href="#4-3-良好的沟通方式" class="headerlink" title="4.3 良好的沟通方式"></a>4.3 良好的沟通方式</h3><p>确实遭遇到职场不平，涉及维权，涉及解释，涉及赔偿，几个原则。</p><p>其实前面段落提过的，重述一下<br>第一，就事论事，切忌情绪化和人身攻击。否则对的也会变错。<br>第二，只列事实即可，不要魔测，不要假设，不要扣帽子。第三，尽量留存足够的证据，如果真的没有证据，有些事也真的没办法追索。<br>那么这里多加一条，第四，一旦涉及维权相关，务必通过律师和第三方进行，尽量不要自己直接追索，维权尺度一定要听律师的，不要认为自己占理就过度维权。<br>这一条关键时刻是救命的。</p><h3 id="4-4-干净的离开"><a href="#4-4-干净的离开" class="headerlink" title="4.4 干净的离开"></a>4.4 干净的离开</h3><p>如果确实无法继续工作，希望换个环境，那我想说一点，干净的离开。</p><p>不要自作聪明的搞一些报复行为，不要做一些可能违反法律风险的事情，不要以为自己可以要挟东家或者可以通过某种手段逼对方就范。</p><p>中国现在的执法力度非常强大，而且，说实话，很多时候，你意气用事，对的也会变错，本来可以合法争取的权益，也会输得干干净净。</p><p>干净的离开，长期来说，会有很好的口碑，很多企业会做尽调，不干净的事情，就算一时得逞，你也瞒不了太久。江湖并不大，很多人总会在不同场合遇到，尽量不要树敌太多。</p><h2 id="5-晋升的秘密"><a href="#5-晋升的秘密" class="headerlink" title="5 晋升的秘密"></a>5 晋升的秘密</h2><p>领导是如何选择晋升的人选，是不是干活最多的那个，是不是能力最强的那个，很多时候，其实并不是，这一点，我希望读者能够理解，并不是因为谁谁会来事，会做人，而是你没有站在更高的角度看问题。</p><p><a href="https://mp.weixin.qq.com/s/_nx-v_-j_U9V1SRhp4Wltw" target="_blank" rel="noopener">「如何提拔骨干及挑选接班人」</a><br><a href="http://mp.weixin.qq.com/s?__biz=MzI0MjA1Mjg2Ng==&mid=2649867267&idx=1&sn=004bcc8fd248edf7340bdc5f45032b23&chksm=f1075e6ec670d778e98d7b18f85d7328184e22f44347392d6546040888723f36b791b7980b84&scene=21#wechat_redirect" target="_blank" rel="noopener">「当我们追求不可替代。。。」</a></p><h3 id="5-1-团队的信任和支持"><a href="#5-1-团队的信任和支持" class="headerlink" title="5.1 团队的信任和支持"></a>5.1 团队的信任和支持</h3><p>提拔一个新的负责人。很多时候，要看整个团队是否信任和支持，这一条几乎是绝大部分企业晋升都会考虑的关键因素。包括外聘空降，也会考虑内部团队的人接受程度。</p><p>提拔起来的人底下不服气，不支持，是很麻烦的事情。</p><p>所以，平时人缘要好，为什么我说要多称赞别人，团队都信任你，支持你，这一点对晋升机会来说，尤为重要。</p><p>有些人能力很强，但性格不好，处处得罪人，那么怎么提拔？</p><p>别说老板不给你机会，老板希望的是团队的稳定和可控。</p><h3 id="5-2-良好的汇报能力和沟通能力"><a href="#5-2-良好的汇报能力和沟通能力" class="headerlink" title="5.2 良好的汇报能力和沟通能力"></a>5.2 良好的汇报能力和沟通能力</h3><p>前面提到信任关系里，汇报能力很重要，那么沟通能力也很重要。</p><p>光闷头干活，不懂得及时汇报，或者什么破事小事都汇报，你让领导怎么用你，这种提拔起来，项目团队会失控的。</p><p>沟通能力也很重要，你可能团队里大家都很信服你，其他团队，其他部门，沟通少，经常互相不对付，老板也头大对不对，能不能协调资源，沟通不同团队的人员共同完成任务，既然要提拔你作为主管/经理，不能事事都靠上面的大老板，自己要担当这方面的事情对不对。</p><p>沟通还包括什么，如何培养新人，如何提升团队干劲，自己一个人吭哧吭哧加班干活，团队懒洋洋，新人不成长，你觉得做负责人合适么。</p><h3 id="5-3-具有向上管理的能力和思维方式"><a href="#5-3-具有向上管理的能力和思维方式" class="headerlink" title="5.3 具有向上管理的能力和思维方式"></a>5.3 具有向上管理的能力和思维方式</h3><p><a href="https://mp.weixin.qq.com/s/3kzCHGH1E9BXpT1TkS-xZw" target="_blank" rel="noopener">「如何管理和指挥你的上司」</a><br><a href="http://mp.weixin.qq.com/s?__biz=MzI0MjA1Mjg2Ng==&mid=2649867315&idx=1&sn=5e379424b25a683b8be38c3ef0bb83f0&chksm=f1075e5ec670d7488cf5149ac152028e70737963651a287992bf77a0126ab5c663a2b33c043f&scene=21#wechat_redirect" target="_blank" rel="noopener">「从校园到职场 - 技能与职位」</a><br><a href="http://mp.weixin.qq.com/s?__biz=MzI0MjA1Mjg2Ng==&mid=2649867335&idx=1&sn=6d160634a420161b936f53fa54bec4a2&chksm=f1075e2ac670d73c9777004711d959b725c0d8d471a6a7717bbe4b4d78d66904dee8db8606fd&scene=21#wechat_redirect" target="_blank" rel="noopener">「从技术到管理」</a><br><a href="http://mp.weixin.qq.com/s?__biz=MzI0MjA1Mjg2Ng==&mid=2649866907&idx=1&sn=df64810a067a9f1cbbb3c45f8ad8d38c&scene=21#wechat_redirect" target="_blank" rel="noopener">「浅谈领导力之 - 价值决策」</a></p><p>什么叫向上管理，不能什么事情都等着上面分配，上面指挥，上面发现问题告诉你如何解决。要更主动，更积极一点，主动发现问题，主动承揽任务，主动寻求上司的支持和资源调配。我以前也强调过，能把老板利用起来的才是好的项目负责人，老板有时候也是一手好牌，使不上劲懂不懂，老板的人脉资源，老板的社会影响力，如果你的项目足够好，让老板用他的资源配合你，老板开心还来不及。</p><p>当然，强调一下，向上管理是有前提的，信任关系，没有信任关系，老板不可能听你的。信任关系一定是基础，路要一步步走，饭要一口口吃。</p><h3 id="5-4-对产品，业务的理解具有全面性"><a href="#5-4-对产品，业务的理解具有全面性" class="headerlink" title="5.4 对产品，业务的理解具有全面性"></a>5.4 对产品，业务的理解具有全面性</h3><p>到达一定级别的时候，需要的不是你某个领域特定的能力，你需要站在一定高度看问题，所谓全局观，你需要对产品业务的逻辑具有完整的理解，因为你需要对很多关键行为，做出判断，什么是进一步优化的方向，什么是产品的阶段性目标，这时候，你不能只停留在可以把事情做好的地步。</p><p>不要急于上升到战略高度，但工作中做的每件事情，尽可能理解其背后的逻辑，来龙去脉，业务关系，商业途径。</p><p>以前我在百度的时候，做产品经理，我江湖经验多一点，百度很多研发都是那种，怎么说呢，刚毕业进百度，社会经验几乎是0，代码写的不错，但对所谓联盟流量获利的途径，个人草根站长和百度关系什么的，其实都是一知半解，甚至是没有感觉的。</p><p>这时候你会发现，有的人就好奇心很重，写程序看产品设计的时候，会多问一些为什么，会好奇背后的设计思路和逻辑是什么，我也好为人师，你来问，我就讲这些站长是怎么赚钱的，以及怎么赫百度羊毛的，所以我们的产品应该怎么设计，既要共赢，又要防止被对不对。</p><p>那么这些特别喜欢问，特别好奇的程序员，我都记着呢，后来发展的都特别好，跟着很厉害的人去创业，现在好几个这样的程序员身价都好几个亿了，比如多盟的 <code>CTO</code> 王鹏云，还有跟谁学的合伙人张怀亭，都是典型的例子，当年都是这么过来的。也有的就闷头做事，你让我干什么就干什么，懒得问，遇到问题就是你设计没写清楚。从代码能力来说，和前者有差距么？没什么差距的，但从职场发展来说，很容易就看到差距了。</p><h3 id="5-5-能把握关键问题，具有发现问题的能力"><a href="#5-5-能把握关键问题，具有发现问题的能力" class="headerlink" title="5.5 能把握关键问题，具有发现问题的能力"></a>5.5 能把握关键问题，具有发现问题的能力</h3><p>有的的人擅长解决问题，当然很好，但作为管理者，应该擅长发现问题。不要等服务器崩溃了才知道性能负载需要优化。不要等用户规模化流失了才知道产品体验需要改进，不要等无可挽回的时候才知道系统存在问题了。</p><p>要在出现苗头，或者有一些不好的迹象的时候，快速敏锐的发现问题，在还没有出现严重状况的时候，就把风险遏制住。这对管理者来说，非常重要。发现问题，才能有效的分配任务，安排任务，确立目标。</p><p>管理者发现问题不一定完全靠自己，毕竟个人的能力和所获取的信息是有限的，要懂得如何收集信息，如何建立信息分析的网络，以及如何有效的甄别不同渠道的信息反馈。</p><p>所谓发现问题的能力，既包括个人的信息敏锐度，其实也包括一整套信息分析的方法体系。哪怕这套信息架构是前任领导建立的，至少你要能透彻领悟和接手。</p><p>很多时候，一些新上任的管理者，习惯呼啦啦的解决一堆遗留问题彰显自己的才能，却忽视了发现问题和分析问题的手段，对前任留下的信息渠道和网络不重视，甚至从不使用，结果直到出现严重问题的时候无法收场。</p><h3 id="5-6-信任度是关键项"><a href="#5-6-信任度是关键项" class="headerlink" title="5.6 信任度是关键项"></a>5.6 信任度是关键项</h3><p>其实前面一直都强调过了，首先要建立与上司和老板信任关系，才有以上其他，信任是需要证明的，如果没有证明自己值得信任，那就什么都不用提了。</p><p>信任是怎么确立的，件件有着落，事事有回声。还是那句话，有时候你参与一个项目，项目失败了，是不是你失败了？如果在项目中，你的工作表现很好，指派的任务完成得很到位，项目失败不等于你的失败，领导依然会让你肩负其他重任，这一点在很多巨头里你都能看到案例，很多内部失败项目出来的人，有的人会被争抢，有的人还会升职。关键要自己做到位。</p><p>关于建立信任的章节，多仔细再看看。</p><h2 id="6-企业永远不是家"><a href="#6-企业永远不是家" class="headerlink" title="6 企业永远不是家"></a>6 企业永远不是家</h2><p> <a href="https://mp.weixin.qq.com/s/Yxks9eEohmtHCmJFDX37pA" target="_blank" rel="noopener">「谈谈企业福利」</a></p><p>我们讲半天说如何让老板信任，如何获得团队的认可，但这里为什么要说这句呢。再好的老板，再好的团队，不是你的家庭，不是你的亲人。我希望读者务必明确这一点。刘强东说，我们不会亏待和放弃任何一个兄弟。<br>刘强东又说，那些跟不上我们脚步的人，不是我们兄弟。</p><p>很简单，企业文化再吸引人，解释权不归你所有。</p><p>再者，任何企业都有持续维持的风险，哪怕老板特别好，真的人品没得挑，公司如果出现经营困难，老板也不可能变卖家产养你对不对。除非老板是你父母，另当别论。</p><h3 id="6-1-维持职场竞争力"><a href="#6-1-维持职场竞争力" class="headerlink" title="6.1 维持职场竞争力"></a>6.1 维持职场竞争力</h3><p><a href="https://mp.weixin.qq.com/s/qef3o4tygS2LR1AW56jcmA" target="_blank" rel="noopener">「当你面临选择，所谓经验可能一文不值」</a><br><a href="http://mp.weixin.qq.com/s?__biz=MzI0MjA1Mjg2Ng==&mid=2649867713&idx=1&sn=829698f78d0b922fe53f4fee8fa06b79&chksm=f1075facc670d6ba10ccae3d50a6fc068b27ea54e3efb67a598c8af9202cf69cd7dbc23d1122&scene=21#wechat_redirect" target="_blank" rel="noopener">「与时俱进，拥抱变化」</a></p><p>除非你能做到财务自由，或者已经有足够的养活自己的手段。否则，务必要维系自己的职场竞争力，保持自己在职场上有足够的选择权，永远不要认为自己的职场路线会越来越上升，35岁以后，很多工作机会会骤然消失。</p><p>如何维系职场竞争力，第一要不断学习新东西，保持知识面和信息面不要受限。第二要建立业内影响力，能够被一些业内有资源的人所赏识认可。第三要多帮助有潜质的人，现在你帮助过的有潜力年轻人，可能未来成长壮大，遇到一些状况，没准会给你机会收留你。</p><h3 id="6-2-有好的机会要把握"><a href="#6-2-有好的机会要把握" class="headerlink" title="6.2 有好的机会要把握"></a>6.2 有好的机会要把握</h3><p>公司对我很好，老板对我很好，但从职场而言，你尽职尽责的工作，就是对得起他们，如果遇到更好的机会，能够上一个台阶，能够在职场地位，收入上有较大的进步，我的建议是，不要舍不得老板，舍不得同事，真的不要舍不得。</p><p>当然，如果非要抬杠说，有可能留在原公司未来回报更高呢，比如当年阿里不也一穷二白么？我解释一下，这是职场判断问题，如果你判断错了，那就是判断错了，这是另一个话题。但我要说的是，不要为了所谓情感，而失去更好的发展机会。</p><p>我见过有这样的朋友，为了报答老板的知遇之恩，想再干几年，有个好的结果再走，但是，再干几年，不好意思，35岁以上了，以前很好的机会，已经没有了。其实真的不值得，而且，很可能，对老板而言，你没有自己想象的那么重要。</p><h3 id="6-3-止损，止损，一定要止损"><a href="#6-3-止损，止损，一定要止损" class="headerlink" title="6.3 止损，止损，一定要止损"></a>6.3 止损，止损，一定要止损</h3><p>如果公司遇到较大的风险，工资无法发放，经营存在法律风险。</p><p>该走立即要走，不要说，现在走了拿不到什么什么，再过几个月没准如何如何。</p><p>止损务必要果断！</p><p>维权也是，适度维权，不要为了一点点维权利益，把自己的时间和精力都耗进去，你要明白你的前途比那些值钱。</p><h3 id="6-4-注意个人信用，不要被企业滥用"><a href="#6-4-注意个人信用，不要被企业滥用" class="headerlink" title="6.4 注意个人信用，不要被企业滥用"></a>6.4 注意个人信用，不要被企业滥用</h3><p>很多人已经犯了这样的错误，加入一家金融理财公司，为了完成业绩，为了更好地获得晋升机会，不遗余力的发展身边的亲朋好友购买相关产品，最后爆雷，之前的社交网络完全崩渍。个人信用不要那么容易被企业滥用，不要为了几个月的奖金，一点点奖励，把个人信用和口碑都消耗掉，非常愚蠢的做法。</p><p>现在有些公司新员工入职要用身份证办信用卡，办电话卡，给公司业务用，这个那个的，我看着都觉得害怕，个人征信就这么不当回事么？就真的找不到工作了么？把自己当三和大神了么？</p><p>如果一个企业为了发展，不尊重个人信用，滥用员工个人信用，这种公司尽量脱身。</p><p>还有一种，明知公司快出问题，快要沉船，还出来撒谎安慰闹事的人，这种也很蠢，马上走人就对了，最多闭嘴不说话，这算是对得起老板了。这时候还要消耗个人信用，为了站好最后一班岗，还以为这是职场操守，你不想做反骨仔，你退出江湖行不行啊。</p><h3 id="6-5-再好的上司，老板，不要跟着一起沉船"><a href="#6-5-再好的上司，老板，不要跟着一起沉船" class="headerlink" title="6.5 再好的上司，老板，不要跟着一起沉船"></a>6.5 再好的上司，老板，不要跟着一起沉船</h3><p>如果一个企业存在经营风险，或者多年以来业务没有任何起色，不管上司，老板对你多么好，没必要陪着他们沉没。</p><p>我不会鼓励在职摸鱼，或者说那些违反职场道德和法律的事情，但从业者不要给自己加戏太多，真把企业当家一样，同生共死，那实在不值得。<br>不要认为自己是救世主，时间已经证明，你的忠诚拯救不了任何事情。</p><h3 id="6-6-忠诚度的体现是，在其位谋其事，而不是把命和前途都交给他们"><a href="#6-6-忠诚度的体现是，在其位谋其事，而不是把命和前途都交给他们" class="headerlink" title="6.6 忠诚度的体现是，在其位谋其事，而不是把命和前途都交给他们"></a>6.6 忠诚度的体现是，在其位谋其事，而不是把命和前途都交给他们</h3><p>在职的时候认真工作，全力投入，离职的时候遵守契约，这就是忠诚。不是把命和前途交给别人。记住，企业永远不是家，不要被一时的企业文化口号所蒙蔽，记住再好的企业文化，解释权不在你这里。</p><h2 id="7-所谓副业"><a href="#7-所谓副业" class="headerlink" title="7 所谓副业"></a>7 所谓副业</h2><p><a href="https://mp.weixin.qq.com/s/w8qCG-amQe6dm5yoY9jxbA" target="_blank" rel="noopener">「你适合搞副业么？」</a><br><a href="http://mp.weixin.qq.com/s?__biz=MzI0MjA1Mjg2Ng==&mid=2649868955&idx=1&sn=7fcd8e1d034bfce14c954207c05a1b18&chksm=f10750f6c670d9e0edb12ebae725d47780bf0aee01f7c3a7032e270fbc0d5521d0dba7a0c44d&scene=21#wechat_redirect" target="_blank" rel="noopener">「副业赚钱这事，靠谱么？」</a></p><p>很多人都关心副业话题，其实我旧文写过关于副业的文章，我的观点都在里面，今天不会展开太多。</p><h3 id="7-1-副业往往是职场忌讳"><a href="#7-1-副业往往是职场忌讳" class="headerlink" title="7.1 副业往往是职场忌讳"></a>7.1 副业往往是职场忌讳</h3><p>大部分企业和管理者，会忌讳员工搞副业，如果你想在职场精进，我建议你不要投入太多精力和时间在副业上。<br>副业的禁忌其实非常多，竞业，职务侵占，内幕交易等，很容易碰雷，一旦遭遇法务追究，基本上能幸免的极少。</p><p>有的人觉得，我的副业和我的工作没关系，那你分心二用，而且没有办法利用你职场优势，你折腾啥呢？</p><p>昨天新闻里说，<code>google</code> 也不是很允许个人业余研发当作副业。以及最近 <code>nginx</code> 创始人被抓的案例，真的不止是中国的公司不允许。</p><p> <a href="https://mp.weixin.qq.com/s/S3T6V3pevI8cM2PU0DALJA" target="_blank" rel="noopener">「程序员想搞点副业太难了：谷歌已将个人项目归属问题写进雇佣协议」</a></p><p>还有，要强调一句，职场的人会高估你副业的受益，哪怕你亏的一塌糊涂，人家也会认为你赚的很多，更不用说会把你所有工作的过失都归咎于你在副业，这种情况下，别人会心理不平衡，你会失去团队的信任，失去领导的信任，失去同事的支持，也就失去晋升的机会，哪怕你什么都没做错。</p><h3 id="7-2-投资行为相对宽容，但有告知义务"><a href="#7-2-投资行为相对宽容，但有告知义务" class="headerlink" title="7.2 投资行为相对宽容，但有告知义务"></a>7.2 投资行为相对宽容，但有告知义务</h3><p>如果对外有投资项目，相对来说，一些企业会宽松一些，毕竟你没有占用工作的时间和精力，但仍然有告知义务，并且在公司内部也有一些避嫌的考量，比如你投资的项目，恰好是公司的重要供货商和合作伙伴，这其实是非常尴尬的，有的公司是坚决禁止的，有的是你需要避嫌，不参与该供货商选择的任何决策讨论，但很多事是说不清的。</p><p>实际上，很多巨头的高管和中层在外面都有投资项目，也不算是完全的禁忌，只是规避自己职权获利这块注意就行。所以告知是非常重要的，你告知了，而没有规避，责任也容易分担，你没有告知，就很难说了。<br>还有，告知要留证据，不是走过去说一声叫告知，正式写封邮件抄送有关负责人，我在外面有参与某某项目投资，目前该项目与公司有合作洽谈，申请回避。日后追究起来，这封邮件能救命。</p><p>做基金的LP基本上没有任何风险，因为LP不参与决策，所以一般不需要忌讳。但实话说，有些巨头的高管，名义上是外面基金的LP，骨子里做的是GP的事情，这种事，只要大老板不认为有问题，也不会有问题。</p><p>其实很多公司的潜规则是，你投资的项目不去跟竞争对手合作就行。但并不是每个公司都是这么宽容的。</p><h3 id="7-3-企业的敏感度和容忍度"><a href="#7-3-企业的敏感度和容忍度" class="headerlink" title="7.3 企业的敏感度和容忍度"></a>7.3 企业的敏感度和容忍度</h3><p>不同的企业敏感度和容忍度不同，还是前面提到的，有的企业会特别在意你的副业和竞争对手的合作关系.但不在意和自己公司的合作关系。有的敏感度就很高，容忍度很低，这种也不会被允许。</p><p>还有就是职位的容忍度，有些高管可以做的副业，基层是不行的，高管和大老板有信任基础.大老板觉得你不会企业的羊毛.就算第一点，相对于历史贡献，也不会太在意。但基层就不一样了，没有信任基础，那就默认认为你是有问题的。</p><h3 id="7-4-风险性偏好和个人能力资源判断"><a href="#7-4-风险性偏好和个人能力资源判断" class="headerlink" title="7.4 风险性偏好和个人能力资源判断"></a>7.4 风险性偏好和个人能力资源判断</h3><p>网上绝大部分教你副业赚钱的课程和内容都是靠这个话题赚你的钱的，鉴于分辨能力，我建议你一个都不要信。所谓开连锁店.投资什么项目可以坐地收钱，基本没可能。真赚钱的也都是各种精打细算，累的要死，各种踩坑学习总结出来的，没有躺赚的。<br>写文章做自媒体赚钱，我旧文不断强调，可能性不是没有.极低极低。不要总问为什么写了那么久涨不了粉，涨不了是正常的。你写不过半佛仙人的，我都写不过的。</p><p>做影响力，做分享，价值是有的，我一直强调的是，提升业内影响力，一个月写一篇就好，让业内的人看到就好，只要写的够好，几百个人看到也是有价值的，不是靠这个赚钱，是靠这个让你获得更多的业内认可。同时锻炼你表达和总结的能力。坦白说，我看不出有快速复制的适合所有人做副业的项目，你说抖音好不好，快手好不好，公众号好不好，或者这个那个好不好，因人而异，可能极少数人可以成，不具备广泛的复制性。</p><p>先看看你自己能力在哪里，资源在哪里，你对风险的承担力是多少，以及如何正确的评估风险和机会。</p><p> <a href="https:/mp.weixin.qq.com/s/4RB/MifZlaAcYkM76aU8sQ" target="_blank" rel="noopener">「影响力阶级」</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzI0MjA1Mjg2Ng==&mid=2649867195&idx=1&sn=ed55de561442a7a34b162af611ce0c86&chksm=f10759d6c670d0c0ba10e37201199246b5e2c7b916a768afc59505fa2ce45f52e4faf13f6d3e&scene=21#wechat_redirect" target="_blank" rel="noopener">「给我的偷懒找点借口」</a></p><p>任何投资行为，我建议你做好交学费的心理准备。</p><p>其实我也交过不少学费了，我觉得验证一些事情，或者一些人.也不是不可以，关键足，这个学费我交得起才行。</p><h2 id="8-永远不要自作聪明"><a href="#8-永远不要自作聪明" class="headerlink" title="8 永远不要自作聪明"></a>8 永远不要自作聪明</h2><h3 id="8-1-诚实具有持续复利"><a href="#8-1-诚实具有持续复利" class="headerlink" title="8.1 诚实具有持续复利"></a>8.1 诚实具有持续复利</h3><p>很多年轻人会在职场耍小聪明，以为撒点小谎，推卸一下责任，领导不会察觉，其实职场上司很多是老江湖，阅人无数，你的那点伎俩根本逃不过人家眼光，就算一时逃得过，稍微过一段时间，很容易穿帮。</p><p>很多时候，上司和领导真的不会揭穿你，职场上并不是非要绝对正确，有时候看穿不说穿，留点面子给你，但会默默在心理给你打个标签，而你自己还不知道。</p><p>诚实是有复利的，坚持下来你才会知道。</p><h3 id="8-2-不要轻易否定别人"><a href="#8-2-不要轻易否定别人" class="headerlink" title="8.2 不要轻易否定别人"></a>8.2 不要轻易否定别人</h3><p>批评别人很容易，但实际上很多人容易忽视别人的优点，相互尊重是职场生存法则之一，而很多背景还不错的年轻人会有一种天然优越感，学校里惯出来的臭毛病，自以为自己很厉害，自以为职场的人毛病很多。</p><p>比如很多历史遗留问题，自己没有去了解，不知道来龙去脉，批评别人代码不规范，很多逻辑不清晰，其实当时解决的问题场景，所面临的复杂局面，自己根本不知道，人家所用到的技巧和思路，根本没领悟。上去自以为是的调整，很容易闯下大祸。</p><p>还有就是自己加戏的那种，总觉得别人是针对你，是歧视你，是如何的瞧不起你，甚至把别人试图保护你，试图栽培你的苦心当作是恶意，这种情况也挺常见的。</p><p>很多时候，很多年轻人在职场树敌，是自找的，而自己还不知道原委，自己一上来就把别人否定，把别人当敌人，那么人家也不笨，感受到你的恶意，自然会把你当敌人。</p><h3 id="8-3-尽量不要当众指责批评"><a href="#8-3-尽量不要当众指责批评" class="headerlink" title="8.3 尽量不要当众指责批评"></a>8.3 尽量不要当众指责批评</h3><p>有不同意见和不同观点，对对方的安排和决策不满意，可以提么，可以提，但尽可能私下提，一对一提出，如果想留存证据，写一封邮件，不要抄送无关的第三人，然后就事论事，注意态度，不要上纲上线，不要人身攻击。</p><p>除非是非常严重的人品道德问题或者迫不及待要指出的紧急问题，否则尽量留一点空间给别人。</p><h3 id="8-4-不要以己之长评人之短，尊重不同领域的专长"><a href="#8-4-不要以己之长评人之短，尊重不同领域的专长" class="headerlink" title="8.4 不要以己之长评人之短，尊重不同领域的专长"></a>8.4 不要以己之长评人之短，尊重不同领域的专长</h3><p>互相尊重非常重要，如果总是用自己的优点去对比别人，你总是比别人优秀，但别人也有比你强的地方。学会互相尊重，学会互相学习，这一点对个人职场成长和人际关系网络都非常重要。<br>要善于发现和挖掘别人的优点，并给予足够的肯定和鼓励。</p><h3 id="8-5学会对感恩和正向回馈"><a href="#8-5学会对感恩和正向回馈" class="headerlink" title="8.5学会对感恩和正向回馈"></a>8.5学会对感恩和正向回馈</h3><p>得到别人的帮助，一定要表达感谢，不是说一定要给与足够或等额的回馈，但必须有这个表达的过程，并给与正向回馈。不要以为别人帮你是理所当然的，哪怕对方是迫于工作任务，不情愿的帮你，也要表达感谢。<br>我常说的，你微信上请教别人一个问题，也是要给个红包回馈的。也许这个问题超级值钱，远远大于红包的价值，但给一个大红包，毕竟是一种心意。</p><p> <a href="https://mp.weixin.qq.com/s/hsjh6RLTboMYpEetWwb4AQ" target="_blank" rel="noopener">「感恩，不只是一种美德」</a></p><h3 id="8-6-学会站在不同立场的思维方式"><a href="#8-6-学会站在不同立场的思维方式" class="headerlink" title="8.6 学会站在不同立场的思维方式"></a>8.6 学会站在不同立场的思维方式</h3><p>不要总是站在自己的立场评判他人，每个人在不同的立场，会有不同的判断方式，我前面提到了很多，为什么上司，领导在看待一些人的时候，和我们想象的不一样，你站在他的位置的时候，你就会完全明白了。但今天你没机会站在那里，你也能理解，你的格局和视野就真的厉害了。</p><p>站在管理者的立场，你才能理解晋升的关键是什么。站在老板的立场，你才能理解工作的价值是什么。<br>要尽可能站在自己更上一级的立场思考问题，你才能更好的理解你当前工作的意义和价值。</p><h3 id="8-7-不要遮掩问题，要学会认错"><a href="#8-7-不要遮掩问题，要学会认错" class="headerlink" title="8.7 不要遮掩问题，要学会认错"></a>8.7 不要遮掩问题，要学会认错</h3><p><a href="https://mp.weixin.qq.com/s/SQDCbmseIQ-4PQrpzW3SAg" target="_blank" rel="noopener">「年轻人，如何抗造系列之 - 做好自己，留有空间」</a></p><p>遮掩问题，推卸责任往往是很拙劣的一种自作聪明，也是年轻人最容易犯得职场错误。<br>承认错误不丢人，对于大部分企业和领导来说，其实年轻人犯错是被允许的，是培养计划中的一部分。而对错误的反思，复盘，下一步的调整计划，更能体现出你的价值和能力。</p><p>遮掩问题，用更多的谎言去掩盖谎言，很容易穿帮，记住，你不是韦小宝，就算是韦小宝最后也会穿帮。</p><h2 id="9-关于不同领域的职场竞争力"><a href="#9-关于不同领域的职场竞争力" class="headerlink" title="9 关于不同领域的职场竞争力"></a>9 关于不同领域的职场竞争力</h2><p>不同领域，不同行业，可能职场有较大的差距，我不能说我分享的逻辑，一定可以通用所有领域和行业，或者所有企业，我只能说，这代表了我认为较为通用的职场环境，但这里有两个比较大的分支领域，其一，是所谓充分市场竞争领域；其二，是所谓垄断行业；这两个领域的职场，关于升职加薪的重点，有可能是完全不同的。</p><p>怎么思考这个问题呢，在充分市场竞争领域，你的职场竞争力是最重要的，什么是竞争力，就是你的能力和价值，一定会被同行中的某个公司所认可，所需要，这时候你谈领导是否赏识你，老板是否够大方，根本不重要，重要的是你要建立业内影响力，让更多同行老板知道你的能力，这时候就可以待价而沽。</p><p>在垄断领域，所谓职场竞争力就没那么重要了，家庭背景资源更重要，那如果没有怎么办，如何建立信任度就很重要，你必须获得领导和上司的充分信任，才有机会。</p><p>有人问问题，说银行利润这么高，为什么基层工资水平并不高，这个问题很可笑，银行是典型的垄断行业啊！虽然银行间也存在竞争，那是什么竞争，资源的竞争，人脉关系的竞争，你的竞争力在哪里，你说你代码写的好，不重要！那么信任关系如何建立，就是你需要思考的重点了。</p><p>市场竞争才会提升优质人才的身价，这其实是一个很简单的道理，互联网行业的高薪酬来自于残酷的市场竞争，很多人总是想不明白。以为去了利润高的垄断机构可以躺着拿高薪，凭什么啊，先问问你爹是谁？</p><h2 id="10-提升职场容错性"><a href="#10-提升职场容错性" class="headerlink" title="10 提升职场容错性"></a>10 提升职场容错性</h2><p>就是说呢，你要坚持做一些正确的事情，正确的选择，但要允许自己的领导，上司，不那么正确。</p><p>就具体企业，具体职位而言，可能做出了正确的选择，未必得到合理的回报，这是很常见的，世界并不是按照我们的计划前进。</p><p>但职场是个长期的事情，坚持正确的做法，相信时间的裁决。</p><h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><h3 id="1-我领导让我做一件事情，习惯性透出安给我的背景信息（大图、原因、合作方）比较少，曹大您有什么建议吗？"><a href="#1-我领导让我做一件事情，习惯性透出安给我的背景信息（大图、原因、合作方）比较少，曹大您有什么建议吗？" class="headerlink" title="1.我领导让我做一件事情，习惯性透出安给我的背景信息（大图、原因、合作方）比较少，曹大您有什么建议吗？"></a>1.我领导让我做一件事情，习惯性透出安给我的背景信息（大图、原因、合作方）比较少，曹大您有什么建议吗？</h3><p>追问就对了，当然注意态度和方法。</p><h3 id="2-说行政单位的公职人员也类比垄断行业吧？"><a href="#2-说行政单位的公职人员也类比垄断行业吧？" class="headerlink" title="2.说行政单位的公职人员也类比垄断行业吧？"></a>2.说行政单位的公职人员也类比垄断行业吧？</h3><p>是的，肯定是的</p><h3 id="3-问一下曹大，如果我已经在市场竞争行业，和领导起过冲突，后面被穿小鞋，是不是离职换下家才是最优解？"><a href="#3-问一下曹大，如果我已经在市场竞争行业，和领导起过冲突，后面被穿小鞋，是不是离职换下家才是最优解？" class="headerlink" title="3.问一下曹大，如果我已经在市场竞争行业，和领导起过冲突，后面被穿小鞋，是不是离职换下家才是最优解？"></a>3.问一下曹大，如果我已经在市场竞争行业，和领导起过冲突，后面被穿小鞋，是不是离职换下家才是最优解？</h3><p>试试开诚布公的和解，如果无解可以考虑换岗。<br>公司里如果人脉好一点，不要四处树敌，换岗机会应该很多。</p><h3 id="4-如果公司现在问题十分严重，是现在立即找工作吗？还是能等到年后？我在新能源汽车，才工作1年半一边投简历一边上班啊。"><a href="#4-如果公司现在问题十分严重，是现在立即找工作吗？还是能等到年后？我在新能源汽车，才工作1年半一边投简历一边上班啊。" class="headerlink" title="4.如果公司现在问题十分严重，是现在立即找工作吗？还是能等到年后？我在新能源汽车，才工作1年半一边投简历一边上班啊。"></a>4.如果公司现在问题十分严重，是现在立即找工作吗？还是能等到年后？我在新能源汽车，才工作1年半一边投简历一边上班啊。</h3><p>今年情况真不好说</p><h3 id="5-想请问下曹大，如果公司目前项目进度较慢或者有其他进度插入，那手头上自己的事情已经基本完成了，那该如何安排工作呢？"><a href="#5-想请问下曹大，如果公司目前项目进度较慢或者有其他进度插入，那手头上自己的事情已经基本完成了，那该如何安排工作呢？" class="headerlink" title="5.想请问下曹大，如果公司目前项目进度较慢或者有其他进度插入，那手头上自己的事情已经基本完成了，那该如何安排工作呢？"></a>5.想请问下曹大，如果公司目前项目进度较慢或者有其他进度插入，那手头上自己的事情已经基本完成了，那该如何安排工作呢？</h3><p>主动汇报，并申请一些新的事情做</p><h3 id="6-曹大，越级沟通在职场属于核弹式武器，所以职场明规则：不可以越级沟通，不然会死的很快。但是又有一条职场潜规则：不精通越级沟通，那么你这辈子都没法升上去。怎样合理的使用？"><a href="#6-曹大，越级沟通在职场属于核弹式武器，所以职场明规则：不可以越级沟通，不然会死的很快。但是又有一条职场潜规则：不精通越级沟通，那么你这辈子都没法升上去。怎样合理的使用？" class="headerlink" title="6.曹大，越级沟通在职场属于核弹式武器，所以职场明规则：不可以越级沟通，不然会死的很快。但是又有一条职场潜规则：不精通越级沟通，那么你这辈子都没法升上去。怎样合理的使用？"></a>6.曹大，越级沟通在职场属于核弹式武器，所以职场明规则：不可以越级沟通，不然会死的很快。但是又有一条职场潜规则：不精通越级沟通，那么你这辈子都没法升上去。怎样合理的使用？</h3><p>这种事情其实很常见，但是不能靠自己主动地这样的沟通，你可以被动地、因为你做得好，会产生跨级的被动的沟通。但如果大领导给你分配任务，你还是要如实汇报给你当前领导。</p><h3 id="7-能聊一聊转行吗？"><a href="#7-能聊一聊转行吗？" class="headerlink" title="7.能聊一聊转行吗？"></a>7.能聊一聊转行吗？</h3><p>这话题太大了，需要很多背景信息。在转行之前，我建议你先斜杠。</p><h3 id="8-曹大来讲讲2020年的一些机会与风险吧"><a href="#8-曹大来讲讲2020年的一些机会与风险吧" class="headerlink" title="8.曹大来讲讲2020年的一些机会与风险吧"></a>8.曹大来讲讲2020年的一些机会与风险吧</h3><p>出海这些年一直是机会，但是政策和合规性风险都很大。说实话我也不太好判断，要看国际关系的一个走势。</p><h3 id="9-请教曹大：我今年40，职位是研发经理，感觉这么发展下去路越走越窄，这种情况下如何规划未来？需要做些什么功课来提升自己？本来想效仿帅张做些副业，但听您这么一说，又不知道何去何从了"><a href="#9-请教曹大：我今年40，职位是研发经理，感觉这么发展下去路越走越窄，这种情况下如何规划未来？需要做些什么功课来提升自己？本来想效仿帅张做些副业，但听您这么一说，又不知道何去何从了" class="headerlink" title="9.请教曹大：我今年40，职位是研发经理，感觉这么发展下去路越走越窄，这种情况下如何规划未来？需要做些什么功课来提升自己？本来想效仿帅张做些副业，但听您这么一说，又不知道何去何从了"></a>9.请教曹大：我今年40，职位是研发经理，感觉这么发展下去路越走越窄，这种情况下如何规划未来？需要做些什么功课来提升自己？本来想效仿帅张做些副业，但听您这么一说，又不知道何去何从了</h3><p>第一个尽可能要懂业务，对行业业务要精通；第二点可以多扶持一些年轻人。<br>副业不是不能做，是你要平铺一下自己的优势在哪里，不是别人能赚这个钱你自己就能赚这个钱。</p><h3 id="10-曹大，如果投资了与公司业务完全无关的项目，有告知义务吗个人觉得没有这个义务，而且职位只是中层"><a href="#10-曹大，如果投资了与公司业务完全无关的项目，有告知义务吗个人觉得没有这个义务，而且职位只是中层" class="headerlink" title="10.曹大，如果投资了与公司业务完全无关的项目，有告知义务吗个人觉得没有这个义务，而且职位只是中层"></a>10.曹大，如果投资了与公司业务完全无关的项目，有告知义务吗个人觉得没有这个义务，而且职位只是中层</h3><p>是不是与公司的业务无关，不是你说了算而是公司法务说的算。我建议你先私下问一下你上司、或公司的管理人员。</p><h3 id="11-请教曹大，如果觉得不适合做技术，是不是应该提早转行"><a href="#11-请教曹大，如果觉得不适合做技术，是不是应该提早转行" class="headerlink" title="11.请教曹大，如果觉得不适合做技术，是不是应该提早转行"></a>11.请教曹大，如果觉得不适合做技术，是不是应该提早转行</h3><p>先要想好自己究竟适合做什么，以及你所想转过去的这个领域，你的职场竞争力在哪里。</p><h3 id="12-曹大，请教沟通能力应该怎么培养？"><a href="#12-曹大，请教沟通能力应该怎么培养？" class="headerlink" title="12.曹大，请教沟通能力应该怎么培养？"></a>12.曹大，请教沟通能力应该怎么培养？</h3><p>翻翻我的历史文章吧。</p><h3 id="13-请教下曹老师，团队有些高T喜欢带着大家加班导致大家工作效率很低，这种情况一般怎么办比较好？另外曹老师可以多聊聊35岁的问题么？如何及早的规划"><a href="#13-请教下曹老师，团队有些高T喜欢带着大家加班导致大家工作效率很低，这种情况一般怎么办比较好？另外曹老师可以多聊聊35岁的问题么？如何及早的规划" class="headerlink" title="13.请教下曹老师，团队有些高T喜欢带着大家加班导致大家工作效率很低，这种情况一般怎么办比较好？另外曹老师可以多聊聊35岁的问题么？如何及早的规划"></a>13.请教下曹老师，团队有些高T喜欢带着大家加班导致大家工作效率很低，这种情况一般怎么办比较好？另外曹老师可以多聊聊35岁的问题么？如何及早的规划</h3><p>第一如果效率很低的加班你无法改变，换岗呗。尽量换一下岗位。<br>另外说35岁这个问题有点大，在35岁之前让职位尽量高一些，人脉尽量广一点。</p><h3 id="14-曹大，如何建立职场人脉？"><a href="#14-曹大，如何建立职场人脉？" class="headerlink" title="14.曹大，如何建立职场人脉？"></a>14.曹大，如何建立职场人脉？</h3><p>多分享，而且是那种有价值的分享，多参与那种分享场合，通过这种过程让别人认可你。<br>人脉不是你认识多少人，你有多少人的联系方式，有多少人认可你才是人脉，一定要把这个当回事。</p><h3 id="15-请问曹大，领导对于自己的工作不太关注，并且不会分配给自己特别多任务，这种情况应该如何凸显自己的能力？"><a href="#15-请问曹大，领导对于自己的工作不太关注，并且不会分配给自己特别多任务，这种情况应该如何凸显自己的能力？" class="headerlink" title="15.请问曹大，领导对于自己的工作不太关注，并且不会分配给自己特别多任务，这种情况应该如何凸显自己的能力？"></a>15.请问曹大，领导对于自己的工作不太关注，并且不会分配给自己特别多任务，这种情况应该如何凸显自己的能力？</h3><p>无论事情大小要做好做透，多去问问领导对你的工作有什么不满意、有什么可以提升的地方，躲让领导提提批评，这样你态度到了，慢慢他就会重视你。</p><h3 id="16-曹大，请问一下作为基层的开发人员，领导在交任务并不会交代到具体细节，但是开发人员在梳理需求是发现细节可以有不同的做法，但是对应的做法产生的结果不同，这种时候罗列不同做法可能导致的后果，然后再交由领导决断是否可行？如果这种情况出现多次呢？"><a href="#16-曹大，请问一下作为基层的开发人员，领导在交任务并不会交代到具体细节，但是开发人员在梳理需求是发现细节可以有不同的做法，但是对应的做法产生的结果不同，这种时候罗列不同做法可能导致的后果，然后再交由领导决断是否可行？如果这种情况出现多次呢？" class="headerlink" title="16.曹大，请问一下作为基层的开发人员，领导在交任务并不会交代到具体细节，但是开发人员在梳理需求是发现细节可以有不同的做法，但是对应的做法产生的结果不同，这种时候罗列不同做法可能导致的后果，然后再交由领导决断是否可行？如果这种情况出现多次呢？"></a>16.曹大，请问一下作为基层的开发人员，领导在交任务并不会交代到具体细节，但是开发人员在梳理需求是发现细节可以有不同的做法，但是对应的做法产生的结果不同，这种时候罗列不同做法可能导致的后果，然后再交由领导决断是否可行？如果这种情况出现多次呢？</h3><p>这就是为什么要追问，要问上司具体的决策的依据和逻辑，因为你只有知道他的逻辑底层、知道哪些是重要的、哪些是可以忽略的，才可以理解。</p><h3 id="17-请问曹老师：从管理者的角度，如何培养和选拔有潜力成为管理者的员工？最为看重的品质有哪些？谢谢！"><a href="#17-请问曹老师：从管理者的角度，如何培养和选拔有潜力成为管理者的员工？最为看重的品质有哪些？谢谢！" class="headerlink" title="17.请问曹老师：从管理者的角度，如何培养和选拔有潜力成为管理者的员工？最为看重的品质有哪些？谢谢！"></a>17.请问曹老师：从管理者的角度，如何培养和选拔有潜力成为管理者的员工？最为看重的品质有哪些？谢谢！</h3><p>主动性很重要；敢担当、敢承担责任；人脉好，至少团队要服Ta。</p><h3 id="18-曹大，目前刚刚工作3年半，在一家新公司担任二级部门研发leader，目前感觉自己管理能力较弱，并且研发能力到达瓶颈。想问下是花更多经历在突破研发瓶颈呢，还是提升自己的管理能力？（行业为手机行业）"><a href="#18-曹大，目前刚刚工作3年半，在一家新公司担任二级部门研发leader，目前感觉自己管理能力较弱，并且研发能力到达瓶颈。想问下是花更多经历在突破研发瓶颈呢，还是提升自己的管理能力？（行业为手机行业）" class="headerlink" title="18.曹大，目前刚刚工作3年半，在一家新公司担任二级部门研发leader，目前感觉自己管理能力较弱，并且研发能力到达瓶颈。想问下是花更多经历在突破研发瓶颈呢，还是提升自己的管理能力？（行业为手机行业）"></a>18.曹大，目前刚刚工作3年半，在一家新公司担任二级部门研发leader，目前感觉自己管理能力较弱，并且研发能力到达瓶颈。想问下是花更多经历在突破研发瓶颈呢，还是提升自己的管理能力？（行业为手机行业）</h3><p>建议你直接问问自己的上司，哪些地方可以提升和改进。</p><h3 id="19-想请教下曹大，当前感觉技术进步不大，想跳槽，但能力又达不到好公司的要求，这时该怎么办？"><a href="#19-想请教下曹大，当前感觉技术进步不大，想跳槽，但能力又达不到好公司的要求，这时该怎么办？" class="headerlink" title="19.想请教下曹大，当前感觉技术进步不大，想跳槽，但能力又达不到好公司的要求，这时该怎么办？"></a>19.想请教下曹大，当前感觉技术进步不大，想跳槽，但能力又达不到好公司的要求，这时该怎么办？</h3><p>刷题，以及把以前的项目反复整理看怎么能做得更好一点。<br>可以在GitHub上做点好的开源项目，会加分。</p><h3 id="20-请问曹大之所以能成为曹大，最重要的因素是什么？"><a href="#20-请问曹大之所以能成为曹大，最重要的因素是什么？" class="headerlink" title="20.请问曹大之所以能成为曹大，最重要的因素是什么？"></a>20.请问曹大之所以能成为曹大，最重要的因素是什么？</h3><p>第一是我入行比较早，早期互联网人才比较少；<br>第二是我好为人师，攒了很多人脉，口碑比较好。</p><h3 id="21-曹老师，今天要续签合同，两年没有加薪了，我要怎么给领导提？"><a href="#21-曹老师，今天要续签合同，两年没有加薪了，我要怎么给领导提？" class="headerlink" title="21.曹老师，今天要续签合同，两年没有加薪了，我要怎么给领导提？"></a>21.曹老师，今天要续签合同，两年没有加薪了，我要怎么给领导提？</h3><p>两年没加薪你应该是几个月前就在找新的工作了而不是在续签的时候才想起来这个问题。<br>很多人总觉得自己的收入高低是取决于老板对你的赏识及老板够不够大方，很多时候你的价值取决于你在职场、你在你行业里公认的价值中，自己做到了什么程度。</p><h3 id="22-曹大公司有意把我培养成管理层，后续带团队。但目前我下面正在筹备着，还没有人员的补充（光棍司令）那我应该目前做哪些准备来应对接下来的安排呢？或者优先规划哪一块的工作内容呢？（在完成自己工作的前提下）"><a href="#22-曹大公司有意把我培养成管理层，后续带团队。但目前我下面正在筹备着，还没有人员的补充（光棍司令）那我应该目前做哪些准备来应对接下来的安排呢？或者优先规划哪一块的工作内容呢？（在完成自己工作的前提下）" class="headerlink" title="22.曹大公司有意把我培养成管理层，后续带团队。但目前我下面正在筹备着，还没有人员的补充（光棍司令）那我应该目前做哪些准备来应对接下来的安排呢？或者优先规划哪一块的工作内容呢？（在完成自己工作的前提下）"></a>22.曹大公司有意把我培养成管理层，后续带团队。但目前我下面正在筹备着，还没有人员的补充（光棍司令）那我应该目前做哪些准备来应对接下来的安排呢？或者优先规划哪一块的工作内容呢？（在完成自己工作的前提下）</h3><p>还是问上司，直接问Ta你应该学习什么，做什么，准备什么。</p><h3 id="23-请教曹大，职场如何更好处理与同事的关系呢？同级和上下级的"><a href="#23-请教曹大，职场如何更好处理与同事的关系呢？同级和上下级的" class="headerlink" title="23.请教曹大，职场如何更好处理与同事的关系呢？同级和上下级的"></a>23.请教曹大，职场如何更好处理与同事的关系呢？同级和上下级的</h3><p>多感谢别人的帮助多称赞别人的成绩<br>但注意，你不可能让每个人都认同你、称赞你，但你可以坚持正确的方法，这样才有正确的人认同你。<br>发现别人的优点，不是阿谀奉承。</p><h3 id="24-曹大，请问一下，基层开发，然后也算是小组长了。但是公司是扁平化管理，这种如何晋升。做的也是传统化互联网企业。"><a href="#24-曹大，请问一下，基层开发，然后也算是小组长了。但是公司是扁平化管理，这种如何晋升。做的也是传统化互联网企业。" class="headerlink" title="24.曹大，请问一下，基层开发，然后也算是小组长了。但是公司是扁平化管理，这种如何晋升。做的也是传统化互联网企业。"></a>24.曹大，请问一下，基层开发，然后也算是小组长了。但是公司是扁平化管理，这种如何晋升。做的也是传统化互联网企业。</h3><p>尽量做出令人信服的成绩，然后也要尽量建立职场影响力，你的晋升不一定在这家公司。</p><h3 id="25-大公司和创业公司如何选择？"><a href="#25-大公司和创业公司如何选择？" class="headerlink" title="25.大公司和创业公司如何选择？"></a>25.大公司和创业公司如何选择？</h3><p>今年除非特别好的创业公司，我不太建议别人去创业公司。<br>前些年我会建议，这两年我不太敢说这样的话。</p><h3 id="26-开发人员，加班太多，想找个轻松的工作，还适合继续干下去吗"><a href="#26-开发人员，加班太多，想找个轻松的工作，还适合继续干下去吗" class="headerlink" title="26.开发人员，加班太多，想找个轻松的工作，还适合继续干下去吗"></a>26.开发人员，加班太多，想找个轻松的工作，还适合继续干下去吗</h3><p>看你处于职场的什么阶段，以及你个人对自己职场的评估是什么，这种事情不要找别人提建议。</p><h3 id="27-曹大您好，请问职场中应该主动提加薪吗？该怎么提？"><a href="#27-曹大您好，请问职场中应该主动提加薪吗？该怎么提？" class="headerlink" title="27.曹大您好，请问职场中应该主动提加薪吗？该怎么提？"></a>27.曹大您好，请问职场中应该主动提加薪吗？该怎么提？</h3><p>让自己变得值钱。值钱的意思是在行业内很容易找到高工资的职位，如果他不给你加薪你可以直接走。<br>如果你没有变得值钱，提了之后他们也没有给你加薪，是不是很尴尬。</p><h3 id="28-曹大，我现在31了，还没有找到适合自己的职业，自己性格是内向的，现在做销售，一直做不好，想找一些技术向的工作，可是现在这个岁数，面试了不少，都拒绝了，我改怎么办"><a href="#28-曹大，我现在31了，还没有找到适合自己的职业，自己性格是内向的，现在做销售，一直做不好，想找一些技术向的工作，可是现在这个岁数，面试了不少，都拒绝了，我改怎么办" class="headerlink" title="28.曹大，我现在31了，还没有找到适合自己的职业，自己性格是内向的，现在做销售，一直做不好，想找一些技术向的工作，可是现在这个岁数，面试了不少，都拒绝了，我改怎么办"></a>28.曹大，我现在31了，还没有找到适合自己的职业，自己性格是内向的，现在做销售，一直做不好，想找一些技术向的工作，可是现在这个岁数，面试了不少，都拒绝了，我改怎么办</h3><p>面试被拒绝的时候，原因是什么？有没有深入沟通过？有没有保持后续的可能性？有没有在面试后把下一次做得更好？有没有去刷题？类似这样的。</p><h3 id="29-求问曹大，我在事业单位上班但是对做生意感兴趣，而且做了好几年了，想问问怎么结交商业上厉害的朋友并跟着他们学到东西？"><a href="#29-求问曹大，我在事业单位上班但是对做生意感兴趣，而且做了好几年了，想问问怎么结交商业上厉害的朋友并跟着他们学到东西？" class="headerlink" title="29.求问曹大，我在事业单位上班但是对做生意感兴趣，而且做了好几年了，想问问怎么结交商业上厉害的朋友并跟着他们学到东西？"></a>29.求问曹大，我在事业单位上班但是对做生意感兴趣，而且做了好几年了，想问问怎么结交商业上厉害的朋友并跟着他们学到东西？</h3><p>在事业单位上确实可以做副业，如果空余时间比较多的话。而且事业单位对副业这件事的企业敏感度也没有那么高。</p><p>在一些知识星球或者论坛分享你对商业的看法。实话说，你分享的价值越高，找你的人机会也越好，但事实上行业里骗子很多，你要做好鉴别。</p><h3 id="30-曹大，我是非科班培训出来做技术的，随着工龄增长感觉技术路越来越吃力，并且渐渐失去兴趣，但是由于经济压力暂时无法做出取舍的决定，能帮我分析一下我应该怎么做？"><a href="#30-曹大，我是非科班培训出来做技术的，随着工龄增长感觉技术路越来越吃力，并且渐渐失去兴趣，但是由于经济压力暂时无法做出取舍的决定，能帮我分析一下我应该怎么做？" class="headerlink" title="30.曹大，我是非科班培训出来做技术的，随着工龄增长感觉技术路越来越吃力，并且渐渐失去兴趣，但是由于经济压力暂时无法做出取舍的决定，能帮我分析一下我应该怎么做？"></a>30.曹大，我是非科班培训出来做技术的，随着工龄增长感觉技术路越来越吃力，并且渐渐失去兴趣，但是由于经济压力暂时无法做出取舍的决定，能帮我分析一下我应该怎么做？</h3><p>我前面强调过，技术人员如果对业务和商业有比较敏锐的觉察你的职场路会越走越宽的。<br>作为公司的老板和高层，他们有时和技术人员沟通很困难，可能说你的技术能力不是最好的、但他们和你沟通很方便的话，你很理解他们说的话，你能理解他们说的商业目标之类的，就会很有用。<br>所以我前面提到的人，他们现在不会再写代码了，但是他们很理解商业、很理解技术。</p><h3 id="31-请教曹大，关于职场上的人性世故开窍的晚，职场处处上碰壁，吃灰，该阿谀奉承，跟各种人混，还是秉持直白天真，按自己意愿做事，做人？"><a href="#31-请教曹大，关于职场上的人性世故开窍的晚，职场处处上碰壁，吃灰，该阿谀奉承，跟各种人混，还是秉持直白天真，按自己意愿做事，做人？" class="headerlink" title="31.请教曹大，关于职场上的人性世故开窍的晚，职场处处上碰壁，吃灰，该阿谀奉承，跟各种人混，还是秉持直白天真，按自己意愿做事，做人？"></a>31.请教曹大，关于职场上的人性世故开窍的晚，职场处处上碰壁，吃灰，该阿谀奉承，跟各种人混，还是秉持直白天真，按自己意愿做事，做人？</h3><p>沟通不讲方法，不叫直白天真，叫蠢。<br>不能说想怼谁就怼谁，这不对的。</p><h3 id="32-请问曹大，干程序员才4年，就感觉身体不舒服，尤其是颈椎，腰椎等工作一天特别僵硬，怎么平衡工作与身体健康的关系？"><a href="#32-请问曹大，干程序员才4年，就感觉身体不舒服，尤其是颈椎，腰椎等工作一天特别僵硬，怎么平衡工作与身体健康的关系？" class="headerlink" title="32.请问曹大，干程序员才4年，就感觉身体不舒服，尤其是颈椎，腰椎等工作一天特别僵硬，怎么平衡工作与身体健康的关系？"></a>32.请问曹大，干程序员才4年，就感觉身体不舒服，尤其是颈椎，腰椎等工作一天特别僵硬，怎么平衡工作与身体健康的关系？</h3><p>坚持锻炼身体，真的要坚持锻炼身体。</p><h3 id="33-曹老师，遇得那种不懂汇报，你说一句，他做一下，说几次的都没用的员工，是不是要舍得裁掉？"><a href="#33-曹老师，遇得那种不懂汇报，你说一句，他做一下，说几次的都没用的员工，是不是要舍得裁掉？" class="headerlink" title="33.曹老师，遇得那种不懂汇报，你说一句，他做一下，说几次的都没用的员工，是不是要舍得裁掉？"></a>33.曹老师，遇得那种不懂汇报，你说一句，他做一下，说几次的都没用的员工，是不是要舍得裁掉？</h3><p>做事行不行？行就丢在底层，这种人是没办法晋升的。</p><h3 id="34-对于领导强压的不太合理的制度，如何给团队传达？"><a href="#34-对于领导强压的不太合理的制度，如何给团队传达？" class="headerlink" title="34.对于领导强压的不太合理的制度，如何给团队传达？"></a>34.对于领导强压的不太合理的制度，如何给团队传达？</h3><p>跟领导沟通一下，要理解领导作出这种决策的逻辑和原因。</p><h3 id="35-请问曹大，作为职场新人想在公司推进新的业务，该怎么推进呢？除了自己调研业务的可行性以外，在协调同事和领导资源的时候该注意什么呢？"><a href="#35-请问曹大，作为职场新人想在公司推进新的业务，该怎么推进呢？除了自己调研业务的可行性以外，在协调同事和领导资源的时候该注意什么呢？" class="headerlink" title="35.请问曹大，作为职场新人想在公司推进新的业务，该怎么推进呢？除了自己调研业务的可行性以外，在协调同事和领导资源的时候该注意什么呢？"></a>35.请问曹大，作为职场新人想在公司推进新的业务，该怎么推进呢？除了自己调研业务的可行性以外，在协调同事和领导资源的时候该注意什么呢？</h3><p>调研能力是非常考验职场新人的点之一，百度会把这个作为他们考量新产品经理的指标。调研能做好，你在职场会加分很多。</p><h3 id="36-请教曹老师，一个非常普通的计算机本科毕业生需要在哪些方面发力才能进入互联网大厂，还是说建议考研？"><a href="#36-请教曹老师，一个非常普通的计算机本科毕业生需要在哪些方面发力才能进入互联网大厂，还是说建议考研？" class="headerlink" title="36.请教曹老师，一个非常普通的计算机本科毕业生需要在哪些方面发力才能进入互联网大厂，还是说建议考研？"></a>36.请教曹老师，一个非常普通的计算机本科毕业生需要在哪些方面发力才能进入互联网大厂，还是说建议考研？</h3><p>Google Code Jam，拿到前一百，大厂抢着要。</p><h3 id="37-曹大你好。我是程序员，报了挺多类似极客时间的这种技术课程。最大的感受是，学了但很多东西工作用不到，过段时间就忘光了。请问如何进行有效的学习提升？"><a href="#37-曹大你好。我是程序员，报了挺多类似极客时间的这种技术课程。最大的感受是，学了但很多东西工作用不到，过段时间就忘光了。请问如何进行有效的学习提升？" class="headerlink" title="37.曹大你好。我是程序员，报了挺多类似极客时间的这种技术课程。最大的感受是，学了但很多东西工作用不到，过段时间就忘光了。请问如何进行有效的学习提升？"></a>37.曹大你好。我是程序员，报了挺多类似极客时间的这种技术课程。最大的感受是，学了但很多东西工作用不到，过段时间就忘光了。请问如何进行有效的学习提升？</h3><p>你要看你工作中真的哪些东西用得到，带着问题去学习。然后再做做项目。<br>一定要学透，上十个课不如把一堂课学透学扎实。</p><p>「</p><p>」</p><p> <a href="">「」</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Android 性能优化篇</title>
      <link href="/2019/complete-works-of-android-performance.html"/>
      <url>/2019/complete-works-of-android-performance.html</url>
      
        <content type="html"><![CDATA[<p>随着项目版本的迭代，<code>App</code> 的性能问题会逐渐暴露出来，而好的用户体验与性能表现紧密相关。 最近项目核心功能收尾，准备开启优化之路，打造一个高用户体验的 <code>APP</code> </p><p>技术不断更新，我将在边学习边实践的过程中进行分享，并将实践结果与大家分享，希望大家看到文章中有不足的地方及时给我留言，我将与大家积极讨论。</p><p><strong>注意：如果出现图片不显示问题请移步</strong> <a href="https://calmcenter.club/2019/PicNotShow.html">图片不显示问题</a> </p><hr><h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><p><a href="https://calmcenter.club/2019/start-optimization.html">App 初体验-启动优化 more  💦</a> </p><p><a href="https://calmcenter.club/2020/memory-optimization.html">App 内存知识介绍 more 💦</a> </p><p><a href="https://calmcenter.club/2020/memory-optimization2.html">App 内存检测优化 more 💦 </a> </p><p><a href="https://calmcenter.club/2020/ui-optimization.html">App UI 优化 more 💦</a> </p><p><a href="https://calmcenter.club/2020/hobble-optimization.html">App 直观感受-卡顿优化 more 🌈</a> </p><p><a href="https://calmcenter.club/2020/power-optimization.html">App 电量优化</a> </p><p><a href="https://calmcenter.club/2020/storage-optimization.html">App 存储优化💦</a> </p><p><a href="https://calmcenter.club/2020/network-optimization.html">App 网络优化🌞</a> </p><p><a href="https://calmcenter.club/2020/package-optimization.html">App 刷脂</a> </p><hr><p><a href="https://time.geekbang.org/column/article/74044" target="_blank" rel="noopener">极客时间 Android开发高手课</a>  </p><p><a href="https://coding.imooc.com/learn/list/308.html" target="_blank" rel="noopener">慕课 Top团队大牛带你玩转Android性能分析与优化</a> </p><hr><h1 id="微信-Matrix-源码解读"><a href="#微信-Matrix-源码解读" class="headerlink" title="微信 Matrix  源码解读"></a>微信 Matrix  源码解读</h1><p>首先了解 <code>Matrix</code> 的配置源码 <a href="https://www.jianshu.com/p/95dfe1f41971" target="_blank" rel="noopener">腾讯 Apm 框架 Matrix 源码阅读 - gradle插件</a> 其中使用到了 <code>gradle</code> 中 <code>Transform</code> 和 <code>Task</code> 相关文章 <a href="https://www.jianshu.com/p/1b506e0f8a5b" target="_blank" rel="noopener">Gradle自定义插件实现自定义Task</a> 、<a href="https://www.jianshu.com/p/49425d46ea4f" target="_blank" rel="noopener">Android中Gradle插件和Transform</a> ，<code>Matrix</code> 在 <code>gradle</code> 的 <code>afterEvaluate</code> 时期 <code>hook</code> 系统 生成 <code>dex</code> 的 <code>Task</code> 为自定义的 <code>Task</code>，并在执行完相关流程后，再执行回原有 <code>Task</code> ，将控制权交还给系统。<code>Matrix</code> 使用 <code>Transform</code> 配合 <code>ASM</code> 完成侵入编译流程进行字节码插入操作。</p><p>然后了解 <code>Matrix</code> 代码架构 <a href="https://www.jianshu.com/p/d0f2164dd053" target="_blank" rel="noopener">腾讯 Apm 框架 Matrix 源码阅读 - 架构解析</a> ，<code>Matrix</code>是整个框架的入口也是所有插件的管理者，所有的插件都需要继承<code>Plugin</code>，<code>Plugin</code>本身已经具备了问题上报和感知 <code>APP</code> 前后台状态的能力。</p><p>不论是 <code>gradle</code> 的使用还是架构设计都有很多地方值得去学习。 </p><h2 id="Matrix-Android-TraceCanary"><a href="#Matrix-Android-TraceCanary" class="headerlink" title="Matrix-Android-TraceCanary"></a><a href="https://github.com/Tencent/matrix/wiki/Matrix-Android-TraceCanary" target="_blank" rel="noopener">Matrix-Android-TraceCanary</a></h2><p>先看看它的 <a href="https://www.jianshu.com/p/768b14dc0ffe" target="_blank" rel="noopener">TracePlugin 架构</a> ，其中重点是 <code>UIThreadMonitor</code> 和 <code>UIThreadMonitor</code> 。</p><ul><li><code>UIThreadMonitor</code>配合 <code>LooperMonitor</code> 获得每个刷新帧的各个阶段的耗时时间。其中涉及到 <code>Choreographer</code>(主要是配合 <code>Vsync</code> ，给上层 <code>App</code> 的渲染提供一个稳定的 <code>Message</code> 处理的时机，即 <code>Vsync</code> 到来的时候 ，系统通过对 <code>Vsync</code> 信号周期的调整，来控制每一帧绘制操作的时机)，相关文章 <a href="https://www.jianshu.com/p/538df44171b1" target="_blank" rel="noopener">Choreographer工作流程分析</a> 。</li><li><code>AppMethodBeat</code> 记录了 <code>Application</code> 的启动时间和结束，<code>hook ActivityThread</code> 中 <code>mH</code> 的 <code>Handler.Callback</code> 对象为自定义的<code>HackCallback</code>对象来记录最近一个 <code>Activity</code> 被打开的时间，每个方法的耗时时间。</li></ul><p><code>TracePlugin</code> 包含 <code>FrameTracer</code>、<code>StartupTracer</code>、<code>AnrTracer</code> </p><ul><li><strong>FrameTracer：</strong> 通过<code>UIThreadMonitor</code>提供的感知每帧耗时的能力。进行简单的整合再通知给各个<code>IDoFrameListener</code>。<code>Matrx</code> 中提供了两个 <code>IDoFrameListener</code> 一个就是 <code>FPSCollector</code> 用于上报 <code>FPS</code>，另一个是<code>FrameDecorator</code>用于直接显示 <code>FPS</code> 。当然也可以自己先 <code>IDoFrameListener</code> 自己实现分析逻辑。</li><li><strong>StartupTracer：</strong> 当 <code>onActivityFocused</code> 被回调时，进行各个时间点的计算，监控并上报 <code>App</code> 冷/暖启动时间，Activity启动时间，配合 <code>AppMethodBeat</code> 中记录的方法执行时间，筛选出导致启动时间长的方法并上报</li><li><strong>AnrTracer：</strong> 很好理解的一个 <code>Tracer</code> ，通过 <code>UIThreadMonitor</code> 感知 <code>Looper loop</code> 工作的开始，刷新帧，结束的时间，并在结束时分析是否超过阈值，如果超过就从 <code>AppMethodBeat</code> 中获取相关数据进行分析并上报。将上报<code>Task</code> 延迟发送，如果 <code>dispatchEnd</code> 在规定时间内没有回调，就发送上报 <code>Task</code> 。<code>Android</code> 源码中的 <code>ANR</code> 也是这么玩的 <a href="http://gityuan.com/2016/07/02/android-anr/" target="_blank" rel="noopener">理解Android ANR的触发原理</a> </li></ul><p><a href="https://www.jianshu.com/u/aae493aa9810" target="_blank" rel="noopener">原文作者 河里的枇杷树</a> </p><hr>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 搭建博客篇</title>
      <link href="/2019/complete-works-of-hexo.html"/>
      <url>/2019/complete-works-of-hexo.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、为什么要写这篇文章"><a href="#一、为什么要写这篇文章" class="headerlink" title="一、为什么要写这篇文章"></a>一、为什么要写这篇文章</h1><p>各大网站关于搭建博客的文章已经不是一篇两篇了，但是他们的文章也有坑~<code>(可能是版本问题)</code>也各有各的特点，这里带你踩坑，并带你实现他们的特点</p><blockquote><p>把无序的信息变的有序，本质上也是信息差，也是可以创造价值的。</p></blockquote><p>所以我准备整理一下各各博客的特点，尽力写成一本大全。</p><h1 id="二、本文主要记载"><a href="#二、本文主要记载" class="headerlink" title="二、本文主要记载"></a>二、本文主要记载</h1><ul><li><strong>Hexo</strong> 基础搭建</li><li>管理代码( <strong>git</strong> 基本操作)</li><li>装饰博客</li><li><strong>live2D</strong> 看板娘</li><li>网站管理<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">本文环境是 win10 或 win 7。mac 再执行 npm 时需要在前面添加 sudo</span><br><span class="line">本文整理于各大佬文章，文中会给出相应链接，如有侵权，请联系我修改或删除。</span><br></pre></td></tr></table></figure></li></ul><hr><a id="more"></a><h2 id="Hexo-基础搭建-more"><a href="#Hexo-基础搭建-more" class="headerlink" title="Hexo 基础搭建 more  "></a><a href="https://calmcenter.club/2019/hexo-bash.html">Hexo 基础搭建 more  </a></h2><ul><li>搭建本地博客</li><li>部署到 <strong>Github Pages</strong></li></ul><h2 id="管理代码-git-基本操作-more"><a href="#管理代码-git-基本操作-more" class="headerlink" title="管理代码( git 基本操作) more"></a><a href="https://calmcenter.club/2019/hexo-code-management.html">管理代码( git 基本操作) more</a></h2><ul><li><strong>git</strong> 拉取代码</li><li><strong>git</strong> 创建分支</li><li><strong>git</strong> 提交分支代码</li><li>其他终端如何使用 <strong>Hexo</strong> 源码</li></ul><h2 id="功能样式配置-more"><a href="#功能样式配置-more" class="headerlink" title="功能样式配置 more  "></a><a href="https://calmcenter.club/2019/hexo-functional-style.html">功能样式配置 more  </a></h2><ul><li><strong>NexT</strong> 主题设置</li><li>基础样式设置</li><li>图片相关</li><li>打赏、评论、复制功能</li><li><strong>DaoVoice</strong> 实现在线联系</li><li>文章置顶</li><li>搜索功能</li><li>细节美化</li></ul><h2 id="live2D-看板娘-more"><a href="#live2D-看板娘-more" class="headerlink" title="live2D 看板娘 more  "></a><a href="https://calmcenter.club/2019/hexo-live2d.html"><strong>live2D</strong> 看板娘 more  </a></h2><ul><li>使用 <strong>hexo-helper-live2d</strong> 完成看板娘</li><li>自定义看板娘(右下角那个~)<ul><li>运行、接入 <strong>Demo</strong></li><li>更换、修改模型</li></ul></li></ul><h2 id="网站管理-more"><a href="#网站管理-more" class="headerlink" title="网站管理 more  "></a><a href="https://calmcenter.club/2019/hexo-website-management.html">网站管理 more  </a></h2><ul><li>个人域名</li><li>加入 <strong>Coding</strong> 服务器</li><li><strong>SEO</strong>  推广</li></ul><hr><h1 id="来都来了-在评论留下你的足迹可否-？"><a href="#来都来了-在评论留下你的足迹可否-？" class="headerlink" title="来都来了 ~ 在评论留下你的足迹可否 ？"></a><code>来都来了 ~ 在评论留下你的足迹可否 ？</code></h1><p><strong>注意：如果出现图片不显示问题请移步</strong> <a href="https://calmcenter.club/2019/PicNotShow.html">图片不显示问题</a></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Next </tag>
            
            <tag> git </tag>
            
            <tag> github </tag>
            
            <tag> live2d </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitHub 博客图片不显示问题</title>
      <link href="/2019/picnotshow.html"/>
      <url>/2019/picnotshow.html</url>
      
        <content type="html"><![CDATA[<p>现在将图片都放在了 码云 上了，所以暂时不会出现图片问题~ 。</p><p>手机图片问题除了 翻 ，有知道的小伙伴可以留言。</p><p>因为我是自己上传的 <code>github</code> ，然后打不开了，所以查了一下 <code>ip</code> 和相关文章。网上文章都是在 <code>C:\Windows\System32\drivers\etc\hosts</code> 文件中复制固定内容，不同网段的用户查到的 <code>IP</code> 可能不一样，所以需要自己去查，而不是简单的copy。</p><ul><li>首先检测是哪个链接问题，这里我是调整好的。</li></ul><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/20200330134722.png" alt=""></p><ul><li>打开 <a href="http://tool.chinaz.com/dns/" target="_blank" rel="noopener">DNS查询网站</a> ，搜索 <code>avatars2.githubusercontent.com</code> </li></ul><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/20200330135205.png" alt=""></p><p>选择一个可以使用的 <code>IP</code>，在 <code>C:\Windows\System32\drivers\etc\hosts</code> 末尾 加上</p><p>在末尾加上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">151.101.108.133 avatars0.githubusercontent.com </span><br><span class="line">151.101.108.133 avatars1.githubusercontent.com </span><br><span class="line">151.101.108.133 avatars2.githubusercontent.com </span><br><span class="line">151.101.108.133 avatars3.githubusercontent.com </span><br><span class="line">151.101.108.133 avatars4.githubusercontent.com </span><br><span class="line">151.101.108.133 avatars5.githubusercontent.com </span><br><span class="line">151.101.108.133 avatars6.githubusercontent.com </span><br><span class="line">151.101.108.133 avatars7.githubusercontent.com </span><br><span class="line">151.101.108.133 avatars8.githubusercontent.com</span><br></pre></td></tr></table></figure><p>不同网段的用户查到的 <code>IP</code> 可能不一样，所以需要自己去查，而不是简单的copy，这是我最终的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># GitHub Start </span><br><span class="line">192.30.253.112 github.com </span><br><span class="line">192.30.253.119 gist.github.com </span><br><span class="line">185.199.111.154 github.githubassets.com </span><br><span class="line">185.199.108.154 github.githubassets.com </span><br><span class="line">185.199.109.154 github.githubassets.com </span><br><span class="line">185.199.110.154 github.githubassets.com </span><br><span class="line">151.101.108.133 assets-cdn.github.com </span><br><span class="line">151.101.108.133 raw.githubusercontent.com </span><br><span class="line">151.101.108.133 gist.githubusercontent.com </span><br><span class="line">151.101.108.133 cloud.githubusercontent.com </span><br><span class="line">151.101.108.133 camo.githubusercontent.com </span><br><span class="line">151.101.108.133 avatars0.githubusercontent.com </span><br><span class="line">151.101.108.133 avatars1.githubusercontent.com </span><br><span class="line">151.101.108.133 avatars2.githubusercontent.com </span><br><span class="line">151.101.108.133 avatars3.githubusercontent.com </span><br><span class="line">151.101.108.133 avatars4.githubusercontent.com </span><br><span class="line">151.101.108.133 avatars5.githubusercontent.com </span><br><span class="line">151.101.108.133 avatars6.githubusercontent.com </span><br><span class="line">151.101.108.133 avatars7.githubusercontent.com </span><br><span class="line">151.101.108.133 avatars8.githubusercontent.com </span><br><span class="line"> </span><br><span class="line"># GitHub End</span><br></pre></td></tr></table></figure><ul><li>刷新 <code>DNS</code></li></ul><p>在 <code>cmd</code> 中输入<code>ipconfig /flushdns</code> 即可刷新，不行的话再重启电脑，这样就能成功打开<code>github</code> 或博客了，所有图片和内容都能加载。</p>]]></content>
      
      
      <categories>
          
          <category> github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
