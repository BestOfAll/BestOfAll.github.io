<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>App 内存检测优化💦 | CalmCenter</title><meta name="keywords" content="Android"><meta name="author" content="CalmCenter"><meta name="copyright" content="CalmCenter"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="🌞一个好的架构可以减少甚至避免我们犯错，而一个好的监控可以帮助我们及时发现问题🌞内存优化的重点在于监控和平时代码规范。 Memory Profiler、MAT、LeakCanary 使用知识你值得拥有 ~">
<meta property="og:type" content="article">
<meta property="og:title" content="App 内存检测优化💦">
<meta property="og:url" content="https://calmcenter.club/2020/memory-optimization2.html">
<meta property="og:site_name" content="CalmCenter">
<meta property="og:description" content="🌞一个好的架构可以减少甚至避免我们犯错，而一个好的监控可以帮助我们及时发现问题🌞内存优化的重点在于监控和平时代码规范。 Memory Profiler、MAT、LeakCanary 使用知识你值得拥有 ~">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://calmcenter.club/img/avatar.jpg">
<meta property="article:published_time" content="2020-02-29T11:59:00.000Z">
<meta property="article:modified_time" content="2020-02-29T11:59:00.000Z">
<meta property="article:author" content="CalmCenter">
<meta property="article:tag" content="Android">
<meta property="article:tag" content="性能优化">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://calmcenter.club/img/avatar.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://calmcenter.club/2020/memory-optimization2"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  ClickShowText: undefined,
  lightbox: 'mediumZoom',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"top-right"},
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2020-02-29 19:59:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><meta name="generator" content="Hexo 5.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" data-lazy-src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">43</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://gitee.com/CalmCenter/Pic/raw/master/cover10.webp)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">CalmCenter</a></span><span id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><h1 class="post-title">App 内存检测优化💦</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-02-29T11:59:00.000Z" title="发表于 2020-02-29 19:59:00">2020-02-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-02-29T11:59:00.000Z" title="更新于 2020-02-29 19:59:00">2020-02-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Android/">Android</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">8.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>27分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>🌞一个好的架构可以减少甚至避免我们犯错，而一个好的监控可以帮助我们及时发现问题🌞内存优化的重点在于监控，和平时代码规范。这篇文章带你了解监控工具 Memory Profiler、MAT、LeakCanary 的使用以及分析。</p>
<h1 id="本文主要记载"><a href="#本文主要记载" class="headerlink" title="本文主要记载"></a>本文主要记载</h1><ul>
<li><strong>1 什么是 Memory Profiler？</strong><ul>
<li>1.1 使用介绍<ul>
<li>1.1.1 启用高级分析</li>
<li>1.1.2 计算内存(每个内存类别当前使用多少内存)</li>
<li>1.1.3 查看内存分配(分配的对象数)</li>
<li>1.1.4 在分析时提高应用性能</li>
<li>1.1.5 捕获堆转储</li>
<li>1.1.6 将堆转储另存为 HPROF 文件</li>
</ul>
</li>
</ul>
</li>
<li><strong>2 什么是 MAT？</strong><ul>
<li>2.1 使用前提</li>
<li>2.2 使用介绍</li>
</ul>
</li>
<li><strong>3 什么是 LeakCanary？</strong><ul>
<li>3.1 LeakCanary 原理</li>
<li>3.2 LeakCanary 使用</li>
</ul>
</li>
<li><strong>4 自定义实现 Demo</strong><ul>
<li>4.1 自动化监测 Demo</li>
<li>4.2 重复图片监测 Demo</li>
</ul>
</li>
<li><strong>5 优化思路</strong><ul>
<li>5.1 设备分级</li>
<li>5.2 Bitmap 优化</li>
</ul>
</li>
<li><strong>6 更多</strong></li>
</ul>
<hr>
<blockquote>
<p>一个好的架构可以减少甚至避免我们犯错，而一个好的监控可以帮助我们及时发现问题。</p>
</blockquote>
<p>检测工具常见的有 <code>Memory Profiler</code> <code>MAT</code> <code>LeakCanary</code></p>
<h1 id="1-什么是-Memory-Profiler"><a href="#1-什么是-Memory-Profiler" class="headerlink" title="1  什么是 Memory Profiler?"></a>1  什么是 Memory Profiler?</h1><p><code>Profiler</code> 是 <code>Android Studio</code> 为我们提供的性能分析工具，它包含了 <code>CPU</code>、<code>内存</code>、<code>网络</code>以及 <code>电量</code> 的分析信息，而 <code>Memory Profiler</code> 则是 <code>Profiler</code> 中的其中一个版块。</p>
<p>打开 <code>Profiler</code>  方式</p>
<ol>
<li>View &gt; Tool Windows &gt; Android Profiler</li>
<li>下方的 Profiler 标签</li>
<li>双击 shift 搜索 profiler</li>
</ol>
<h2 id="1-1-使用介绍"><a href="#1-1-使用介绍" class="headerlink" title="1.1 使用介绍"></a>1.1 使用介绍</h2><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/20200413144637.png" alt=""></p>
<ol>
<li><p>用于强制执行垃圾回收事件的按钮（强制 <code>GC</code> ）。</p>
</li>
<li><p>用于 <code>1.1.5 捕获堆转储</code> 的按钮。</p>
<p><strong>注意</strong>：只有在连接到搭载 <code>Android 7.1</code>（<code>API</code> 级别 25）或更低版本的设备时，才会在堆转储按钮右侧显示用于 <code>记录内存分配</code> 的按钮。</p>
</li>
<li><p>用于指定分析器多久捕获一次内存分配的下拉菜单。选择适当的选项可 <code>1.1.4 在分析时提高应用性能</code>。</p>
</li>
<li><p>用于缩放时间轴的按钮。</p>
</li>
<li><p>用于跳转到实时内存数据的按钮。</p>
</li>
<li><p>事件时间轴，显示活动状态、用户输入事件和屏幕旋转事件。</p>
</li>
<li><p>内存使用量时间轴，它会显示以下内容：</p>
<ul>
<li>一个堆叠图表，显示 <code>1.1.2 每个内存类别当前使用多少内存</code> ，如左侧的 y 轴以及顶部的彩色键所示。</li>
<li>一条虚线，表示 <code>1.1.3 分配的对象数</code>，如右侧的 y 轴所示。</li>
<li>每个垃圾回收事件的图标。</li>
</ul>
</li>
</ol>
<p>如果使用的是搭载 Android 7.1 或更低版本的设备，则并非所有分析数据在默认情况下都可见。如果看到一条消息，显示“Advanced profiling is unavailable for the selected process”，需要 <code>1.1.1 启用高级分析</code> 才能看到以下内容：</p>
<ul>
<li>事件时间轴</li>
<li>分配的对象数</li>
<li>垃圾回收事件</li>
</ul>
<p>在 Android 8.0 及更高版本上，始终为可调试应用启用高级分析。</p>
<h3 id="1-1-1-启用高级分析"><a href="#1-1-1-启用高级分析" class="headerlink" title="1.1.1  启用高级分析"></a>1.1.1  启用高级分析</h3><ol>
<li>依次选择 <strong>Run &gt; Edit Configurations</strong>。</li>
<li>在左侧窗格中选择本应用模块。</li>
<li>点击 <strong>Profiling</strong> 标签，然后勾选 <strong>Enable advanced profiling</strong>。</li>
<li>重新编译并运行应用。</li>
</ol>
<h3 id="1-1-2-计算内存-每个内存类别当前使用多少内存"><a href="#1-1-2-计算内存-每个内存类别当前使用多少内存" class="headerlink" title="1.1.2 计算内存(每个内存类别当前使用多少内存)"></a>1.1.2 计算内存(每个内存类别当前使用多少内存)</h3><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/20200414112438.png" alt=""></p>
<p>内存计数中的类别如下：</p>
<ul>
<li><p><strong>Java</strong>：从 <code>Java</code> 或 <code>Kotlin</code> 代码分配的对象的内存。</p>
</li>
<li><p><strong>Native</strong>：从 <code>C</code> 或 <code>C++</code> 代码分配的对象的内存。</p>
<p>即使应用中不使用 <code>C++</code>，也可能会看到此处使用的一些原生内存，因为 <code>Android</code> 框架使用原生内存处理各种任务，如处理图像资源和其他图形时。</p>
</li>
<li><p><strong>Graphics</strong>：图形缓冲区队列向屏幕显示像素（包括 <code>GL</code> 表面、<code>GL</code> 纹理等等）所使用的内存。（请注意，这是与 <code>CPU</code> 共享的内存，不是 <code>GPU</code> 专用内存。）</p>
</li>
<li><p><strong>Stack</strong>：应用中的原生堆栈和 <code>Java</code> 堆栈使用的内存。这通常与应用运行多少线程有关。</p>
</li>
<li><p><strong>Code</strong>：应用用于处理代码和资源（如 <code>dex</code> 字节码、经过优化或编译的 <code>dex</code> 代码、<code>.so</code> 库和字体）的内存。</p>
</li>
<li><p><strong>Others</strong>：应用使用的系统不确定如何分类的内存。</p>
</li>
<li><p><strong>Allocated</strong>：应用分配的 <code>Java/Kotlin</code> 对象数。此数字没有计入 C 或 C++ 中分配的对象。</p>
<p>如果连接到搭载 <code>Android 7.1</code> 及更低版本的设备，只有在 <code>Memory Profiler</code> 连接到运行的应用时，才开始此分配计数。因此，开始分析之前分配的任何对象都不会被计入。不过，<code>Android 8.0</code> 及更高版本附带一个设备内置分析工具，该工具可跟踪所有分配，因此，在 <code>Android 8.0</code> 及更高版本上，此数字始终表示应用中待处理的 Java 对象总数。</p>
</li>
</ul>
<p><strong>注意：</strong>高级分析配置会使编译过程变慢，所以仅在想要开始分析应用时，才应启用该配置。</p>
<h3 id="1-1-3-查看内存分配-分配的对象数"><a href="#1-1-3-查看内存分配-分配的对象数" class="headerlink" title="1.1.3 查看内存分配(分配的对象数)"></a>1.1.3 查看内存分配(分配的对象数)</h3><p>对于 <code>Android 8.0</code> 及更高版本，选择一个现有时间轴区域以查看对象分配</p>
<p>对于 <code>Android 7.1</code> 及更低版本，必须明确记录内存分配，点击 <code>Memory Profiler</code> 工具栏中的 <code>Record memory allocations</code> 图标或者 一个 <code>Record</code> 的按钮。记录时，<code>Memory Profiler</code> 会跟踪应用中发生的所有分配。完成后，请点击 <code>Stop recording</code> 图标或者一个 <code>Stop</code> 的按钮，查看分配。</p>
<p><strong>注意</strong>：在 <code>Android 7.1</code> 及更低版本上，最多可以记录 <code>65535</code> 个分配。 如果记录会话超出此限制，则记录中仅保存最新的 <code>65535</code> 个分配。（在 <code>Android 8.0</code> 及更高版本上，则没有实际的限制。）<br><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/20200414135710.png" alt=""></p>
<ol>
<li>浏览列表以查找堆计数异常大且可能存在泄露的对象。为帮助查找已知类，点击 <code>Class Name</code> 列标题以按字母顺序排序。然后，点击一个类名称。此时右侧将出现 <code>Instance View</code> 窗格，显示该类的每个实例。</li>
<li>在 <code>Instance View</code> 窗格中，点击一个实例。此时下方将出现 <code>Call Stack</code> 标签页，显示该实例被分配到何处以及在哪个线程中。</li>
<li>在 <code>Call Stack</code> 标签页中，右键点击任意行并选择 <code>Jump to Source</code>，以在编辑器中打开该代码。</li>
</ol>
<p><code>Live Allocation</code> 第一个选择框是选择要检查的堆：</p>
<ul>
<li><strong>default heap</strong>：当系统未指定堆时。</li>
<li><strong>image heap</strong>：系统启动映像，包含启动期间预加载的类。此处的分配保证绝不会移动或消失。</li>
<li><strong>zygote heap</strong>：写时复制堆，其中的应用进程是从 <code>Android</code> 系统中派生的。</li>
<li><strong>app heap</strong>：您的应用在其中分配内存的主堆。</li>
<li><strong>JNI heap</strong>：显示 Java 原生接口 (<code>JNI</code>) 引用被分配和释放到什么位置的堆。</li>
</ul>
<p>第二个选择框选择如何安排分配：</p>
<ul>
<li><strong>Arrange by class</strong>：根据类名称对所有分配进行分组。这是默认选项。</li>
<li><strong>Arrange by package</strong>：根据软件包名称对所有分配进行分组。</li>
<li><strong>Arrange by callstack</strong>：将所有分配分组到其对应的调用堆栈。只有在记录分配期间 <code>捕获堆转储</code> 时，此选项才有效。即便如此，堆中也很可能有在开始记录之前分配的对象，所以会先显示这些分配，直接按类名称列出它们。</li>
</ul>
<h3 id="1-1-4-在分析时提高应用性能"><a href="#1-1-4-在分析时提高应用性能" class="headerlink" title="1.1.4 在分析时提高应用性能"></a>1.1.4 在分析时提高应用性能</h3><p>为了在分析时提高应用性能，<code>Memory Profiler</code> 在默认情况下会定期对内存分配进行采样。在运行 <code>API</code> 级别 <code>26</code> 或更高级别的设备上进行测试时，可以使用 <code>Allocation Tracking</code> 下拉菜单来更改此行为。可用选项如下：</p>
<ul>
<li><strong>Full</strong>：捕获内存中的所有对象分配。这是 <code>Android Studio 3.2</code> 及更低版本中的默认行为。如果您有一个分配了大量对象的应用，则可能会在分析时观察到应用的运行速度明显减慢。</li>
<li><strong>Sampled</strong>：定期对内存中的对象分配进行采样。这是默认选项，在分析时对应用性能的影响较小。在短时间内分配大量对象的应用仍可能会表现出明显的速度减慢。</li>
<li><strong>Off</strong>：停止跟踪应用的内存分配。</li>
</ul>
<h3 id="1-1-5-捕获堆转储"><a href="#1-1-5-捕获堆转储" class="headerlink" title="1.1.5 捕获堆转储"></a>1.1.5 捕获堆转储</h3><p>堆转储显示在捕获堆转储时应用中哪些对象正在使用内存。特别是在长时间的用户会话后，堆转储会显示认为不应再位于内存中却仍在内存中的对象，从而帮助识别内存泄露。<br><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/20200414161957.png" alt=""></p>
<p>要捕获堆转储，请点击 Memory Profiler 工具栏中的 <strong>Dump Java heap</strong> 图标 <img src= "/img/loading.gif" data-lazy-src="https://developer.android.google.cn/studio/images/buttons/profiler-heap-dump.png" style="zoom:70%">  在转储堆期间，Java 内存量可能会暂时增加。 这很正常，因为堆转储与您的应用发生在同一进程中，并需要一些内存来收集数据。</p>
<ul>
<li><p><strong>Allocations</strong>：堆中的分配数。</p>
</li>
<li><p><strong>Native Size</strong>：此对象类型使用的原生内存总量（以字节为单位）。只有在使用 <code>Android 7.0</code> 及更高版本时，才会看到此列。</p>
<p>您会在此处看到采用 <code>Java</code> 分配的某些对象的内存，因为 <code>Android</code> 对某些框架类（如 <code>Bitmap</code>）使用原生内存。</p>
</li>
<li><p><strong>Shallow Size</strong>：此对象类型使用的 Java 内存总量（以字节为单位）。</p>
</li>
<li><p><strong>Retained Size</strong>：为此类的所有实例而保留的内存总大小（以字节为单位）。</p>
</li>
</ul>
<p>点击一个类名称可在右侧打开 <strong>Instance View</strong> 窗口。</p>
<ul>
<li><strong>Depth</strong>：从任意 <code>GC</code> 根到选定实例的最短跳数。</li>
<li><strong>Native Size</strong>：原生内存中此实例的大小。 只有在使用 Android 7.0 及更高版本时，才会看到此列。</li>
<li><strong>Shallow Size</strong>：<code>Java</code> 内存中此实例的大小。</li>
<li><strong>Retained Size</strong>：此实例所支配内存的大小。</li>
</ul>
<p>如果你 <code>ClassName</code> 选中的是 <code>Bitmap</code> ,在 <code>7.1</code> 及以下版本的设备中 <code>Call Sack</code>位置会出现 <code>Bitmap Preview</code> 功能，来预览是哪张图片</p>
<p><code>References</code> 标签页，显示对该对象的每个引用，如果发现某个引用可能在泄露内存，右键点击它并选择 <code>Go to Instance</code>。这样会从堆转储中选择相应的实例，从而显示它自己的实例数据。</p>
<h3 id="1-1-6-将堆转储另存为-HPROF-文件"><a href="#1-1-6-将堆转储另存为-HPROF-文件" class="headerlink" title="1.1.6 将堆转储另存为 HPROF 文件"></a>1.1.6 将堆转储另存为 HPROF 文件</h3><p>在 Android Studio 3.1 及更低版本中，<code>Export capture to file</code> 按钮 <img src= "/img/loading.gif" data-lazy-src="https://developer.android.google.cn/studio/images/buttons/profiler-export-hprof.png" alt="img"> 位于时间轴下方工具栏的左侧</p>
<p>在 Android Studio 3.2 及更高版本中，<code>Sessions</code> 窗格中每个 <code>Heap Dump</code>条目的右侧都有一个 <code>Export Heap Dump</code> 按钮。在随即显示的 <code>Export As</code> 对话框中，使用 <code>.hprof</code>  文件扩展名保存文件。</p>
<hr>
<h1 id="2-什么是-MAT"><a href="#2-什么是-MAT" class="headerlink" title="2 什么是 MAT?"></a>2 什么是 MAT?</h1><p>对于内存泄漏问题，Memory Profiler 只能给我们提供一个简单的分析，不能够帮我们确认具体发生问题的地方。</p>
<p>而 MAT 就可以帮我们做到这一点，MAT 的全称是 Memory Analyzer Tool，它是一款功能强大的 Java 堆内存分析工具，可以用于查找内存泄漏以及查看内存消耗情况。</p>
<h2 id="2-1-使用前提"><a href="#2-1-使用前提" class="headerlink" title="2.1 使用前提"></a>2.1 使用前提</h2><ol>
<li><p>到 MAT 的官网 <a target="_blank" rel="noopener" href="https://www.eclipse.org/mat/downloads.php">下载 MAT</a>。</p>
</li>
<li><p>使用 <code>Memory Profiler</code> 的堆转储功能，导出 <code>hprof（Heap Profile）</code>文件。</p>
</li>
<li><p>配置 <code>platform-tools</code> 环境变量</p>
</li>
<li><p>使用命令将 <code>Memory Profiler</code> 中导出来的 <code>hprof</code> 文件转换为 MAT 可以解析的 hprof 文件，命令如下</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hprof-conv ..&#x2F;原始文件.hprof ..&#x2F;输出文件.hprof</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>打开 MAT</li>
</ol>
<p><code>File &gt; open Heap dump</code> ，选择我们转换后的文件</p>
<h2 id="2-2-使用介绍"><a href="#2-2-使用介绍" class="headerlink" title="2.2 使用介绍"></a>2.2 使用介绍</h2><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/20200414173426.png" alt=""></p>
<ul>
<li><p><strong>Overview</strong>：概览信息</p>
<ul>
<li><strong>Unreachable Objects Histogram</strong>：可被回收的对象，但是仍在内存当中</li>
</ul>
</li>
<li><p><strong>Histogram</strong>：直方图，基于类来分析，会显示该类有多少个实例</p>
<p>第一行输入可以搜索，<code>Tool Bar</code> 中会多出一个 <code>Group by...</code>  选择 <code>package</code> 会变成已报名的形式来进行分类。</p>
<ul>
<li><strong>Object</strong>：有多少实例</li>
<li><strong>Shallow Heap</strong>：自己占了多少内存</li>
<li><strong>Retained Heap</strong>：应用链总共占了多少内存</li>
<li>选择一个类条目右键会出现 <code>List objects</code><ul>
<li><strong>with outgoing references</strong>：引用了些什么</li>
<li><strong>with incoming references</strong>：被谁引用着</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>dominator_tree</strong>：基于实例来分析，会显示具体的实例是哪个</p>
<p>第一行输入可以搜索，<code>Tool Bar</code> 中会多出一个 <code>Group by...</code>  选择 <code>package</code> 会变成已报名的形式来进行分类。</p>
<ul>
<li><strong>Percentage</strong>：当前所有对象中，此对象内存占用百分比，可以发现那些内存占用过大的对象</li>
<li>右键点击会出现 <code>List objects</code> ，会显示出具体事例</li>
</ul>
</li>
<li><p><strong>OQL</strong>：对象查询语言</p>
<ul>
<li>例如 <code>slect * from com.package.Activity</code> ，会查询出该类所有的实例</li>
</ul>
</li>
<li><p><strong>thread_overview</strong>：<code>dump</code> 内存这个时刻的所有线程</p>
</li>
<li><p><strong>top_consumers</strong>：用图形列出占用内存比较大的实例</p>
<ul>
<li><strong>Biggest Objects</strong>：详细信息，点击出现 <code>List objects</code></li>
</ul>
</li>
<li><p><strong>Leak Suspects</strong>：更详细的分析，可以从这里找到可以的泄漏点</p>
<ul>
<li><strong>Probleam Suspect (x)</strong> ：点击 <code>Details</code> 会出现可疑的 引用链，找到泄漏点</li>
</ul>
</li>
</ul>
<hr>
<h1 id="3-什么是-LeakCanary？"><a href="#3-什么是-LeakCanary？" class="headerlink" title="3 什么是 LeakCanary？"></a>3 什么是 LeakCanary？</h1><p>如果使用 MAT 来分析内存问题，会有一些难度，而且效率也不是很高。</p>
<p>为了能迅速发现内存泄漏，Square 公司基于 MAT 开源了 <a target="_blank" rel="noopener" href="https://square.github.io/leakcanary">LeakCanary</a>。</p>
<p><code>LeakCanary</code> 是一个内存泄漏检测框架。</p>
<h2 id="3-1-LeakCanary-原理"><a href="#3-1-LeakCanary-原理" class="headerlink" title="3.1 LeakCanary 原理"></a>3.1 LeakCanary 原理</h2><ol>
<li><p><strong>检测保留的实例</strong></p>
<p><code>LeakCanary</code> 是基于 <code>LeakSentry</code> 开发的，<code>LeakSentry</code> 会 <code>hook Android</code> 生命周期，自动检测当 <code>Activity</code> 或 <code>Fragment</code> 被销毁时，它们的实例是否被回收了。</p>
<p>销毁的实例会传给 <code>RefWatcher</code>，<code>RefWatcher</code> 会持有它们的弱引用。</p>
<p>你也可以观察所有不再需要的实例，比如一个不再使用的 <code>View</code>，不再使用的 <code>Presenter</code> 等。</p>
<p>如果等待了 5 秒，并且 <code>GC</code> 触发了之后，弱引用还没有被清理，那么 <code>RefWatcher</code> 观察的实例就可能处于内存泄漏状态了。</p>
</li>
<li><p><strong>堆转储</strong></p>
<p>当保留对象的数量达到阈值时，<code>LeakCanary</code> 将 <code>Java</code> 堆转储到<code>.hprof</code> 存储在 <code>Android</code> 文件系统中的文件中。</p>
<p>当应用程序可见时，默认的阈值是5个被保留的对象，当应用程序不可见时，默认的阈值是 1 个被保留的对象。如果您看到保留的对象通知，然后将应用程序放在后台(例如通过按Home按钮)，那么阈值将从 5 更改为 1 ，<code>LeakCanary</code> 将在 5 秒内转储堆。点击通知将迫使<code>LeakCanary</code> 立即转储堆。</p>
</li>
<li><p><strong>分析堆</strong></p>
<p><code>LeakCanary</code>  <code>.hprof</code>使用 <a target="_blank" rel="noopener" href="https://square.github.io/leakcanary/shark/">Shark</a> 解析文件，并在该堆转储中找到保留的对象。</p>
<p>对于每个保留的对象，<code>LeakCanary</code> 会找到引用的路径，以防止对该保留的对象进行垃圾回收：其<strong>泄漏跟踪</strong>。泄漏跟踪是<em>从垃圾回收根到保留对象</em>的<em>最佳强引用路径的</em>另一个名称。</p>
</li>
<li><p><strong>泄漏分组</strong></p>
<p>当有两个泄漏分析结果相同时，<code>LeakCanary</code> <strong>为每个泄漏跟踪</strong>创建一个<strong>签名</strong>，并将具有相同签名的泄漏（即，由同一 <code>bug</code> 引起的泄漏）组合在一起，以免重复显示同样的泄漏信息。</p>
</li>
</ol>
<h2 id="3-2-LeakCanary-使用"><a href="#3-2-LeakCanary-使用" class="headerlink" title="3.2 LeakCanary 使用"></a>3.2 LeakCanary 使用</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  debugImplementation <span class="string">&#x27;com.squareup.leakcanary:leakcanary-android:2.2&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>2.2</code> 不需要初始化，如果你添加了</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;android-aspectjx&#x27;</span></span><br></pre></td></tr></table></figure>

<p>需要在文章添加</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">aspectjx &#123; </span><br><span class="line">    exclude <span class="string">&#x27;com.squareup&#x27;</span> </span><br><span class="line">    exclude <span class="string">&#x27;leakcanary&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>否则会报 <code>Unable to get provider leakcanary.internal.LeakCanaryFileProvider: java.lang.ClassNotFoundException: Didn&#39;t find class &quot;leakcanary.internal.LeakCanaryFileProvider&quot;</code></p>
<h1 id="4-自定义实现-Demo"><a href="#4-自定义实现-Demo" class="headerlink" title="4 自定义实现 Demo"></a>4 自定义实现 Demo</h1><p><code>Profiler</code> 中使用了 <code>Allocation Tracker</code> 技术，<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/b_lFfL1mDrNVKj_VAcA2ZA?">Android内存申请分析</a> 这篇文章讲述了 <code>Allocation Tracker</code> 的使用方式，并且讲解了 <code>Android Studio</code> 是如何使用 <code>Allocation Tracker</code> 的。可以让我们更加熟悉 <code>Android Studio</code> 中 <code>Profiler</code> 各种工具的实现原理后。</p>
<p>文中提到了 <code>Allocation Tracker</code> 的三个缺点。</p>
<ul>
<li>获取的信息过于分散，中间夹杂着不少其他的信息，很多信息不是应用申请的，可能需要进行不少查找才能定位到具体的问题。</li>
<li>跟 <code>Traceview</code> 一样，无法做到自动化分析，每次都需要开发者手工开始 / 结束，这对于某些问题的分析可能会造成不便，而且对于批量分析来说也比较困难。</li>
<li>虽然在 <code>Allocation Tracking</code> 的时候，不会对手机本身的运行造成过多的性能影响，但是在停止的时候，直到把数据 <code>dump</code> 出来之前，经常会把手机完全卡死，如果时间过长甚至会直接 <code>ANR</code>。</li>
</ul>
<p>因此我们希望可以做到脱离 <code>Android Studio</code>，实现一个自定义的 <code>Allocation Tracker</code>，实现对象内存的自动化分析。通过这个工具可以获取所有对象的申请信息（大小、类型、堆栈等），可以找到一段时间内哪些对象占用了大量的内存。</p>
<p>我们可以用自定义的 <code>Allocation Tracker</code> 来监控 Java 内存的监控，也可以拓展成实时监控 <code>Java</code> 内存泄漏。不过任何一个工具如果只需要做到线下自动化测试，实现起来会相对简单，但想要移植到线上使用，那就要更加关注兼容性、稳定性和性能。</p>
<h2 id="4-1-自动化检测Demo"><a href="#4-1-自动化检测Demo" class="headerlink" title="4.1 自动化检测Demo"></a>4.1 自动化检测Demo</h2><p>这是一个自定义 <code>Allocation Tracker</code> 的 <code>Demo</code> <a target="_blank" rel="noopener" href="https://github.com/AndroidAdvanceWithGeektime/Chapter03">极客时间 Android 高手课 Chapter03</a></p>
<blockquote>
<p>项目使用了 inline hook 来拦截内存对象分配时候的 RecordAllocation 函数，通过拦截该接口可以快速获取到当时分配对象的类名和分配的内存大小。<br>在初始化的时候我们设置了一个分配对象数量的最大值，如果从 start 开始对象分配数量超过最大值就会触发内存 dump，然后清空 alloc 对象列表，重新计算。该功能和 Android Studio 里的 Allocation Tracker 类似，只不过可以在代码级别更细粒度的进行控制。可以精确到方法级别。</p>
</blockquote>
<ul>
<li><code>ndk_dlopen</code> 用来获取动态链接库</li>
<li><code>ndk_dlsym</code> 通过动态链接库和函数签名拿到函数地址</li>
<li><code>Substrate</code> <a target="_blank" rel="noopener" href="http://www.cydiasubstrate.com/api/c/MSHookFunction/">MSHookFunction</a>  一款经典的 <code>hook</code> 框架，支持 <code>hook C/C++</code> 代码 </li>
<li><a target="_blank" rel="noopener" href="https://github.com/facebookincubator/profilo/tree/master/deps/fbjni">fbjni</a> 是从 <code>Facebook</code> 开源的一款jni工具类库，主要提供了工具类，ref utils ，Global JniEnv。</li>
<li><code>native-lib</code> 中 <code>JNI_OnLoad</code>  在 <code>System.loadLibrary(&quot;xxx&quot;);</code> 时执行</li>
</ul>
<p>代码运行流程：</p>
<ol>
<li><p>在 <code>MainActivity</code> 中调用 <code>AllocTracker.initForArt</code> 去初始化，然后通过 <code>ndk_dlopen</code> 和<code>ndk_dlsym</code> 拿到所有需要的函数，只是拿到函数并没有调用</p>
</li>
<li><p><code>JNI_OnLoad</code> 调用 <code>hookFunc();</code>这个方法就是真正的把系统的 <code>tracking</code> 函数 <code>hook</code> 住的地方</p>
<ol>
<li>通过 <code>ndk_dlsym</code> 拿到函数地址。</li>
<li>通过 <code>MSHookFunction</code> 把 <code>newArtRecordAllocation26</code> <code>hook</code> 进原函数地址里，同时拿到旧函数的实现并导向 <code>oldArtRecordAllocation26</code> 。这样做可以保留旧函数。</li>
<li>在新函数中有一句 <code>allocObjectCount &gt; setAllocRecordMax</code> ，当分配对象数量大于初始化时设置的最大值，就把数据保存在 <code>log</code> 文件中。</li>
</ol>
</li>
</ol>
<p><code>C/C++</code> 的 <code>hook</code> 和 <code>java</code> 反射一样，如果系统在新版本把函数名，或者函数签名改了那就无法使用了，所以在文件中出现了很多版本适配的地方。</p>
<p><code>Logcat</code> 中 <code>saveARTAllocationData write file to XXXX</code> 能找到对应的日志文件路径</p>
<p>看不到日志的输出情况，每个人设备内存情况不一样，<code>GC</code> 回收的频率也不一致，在你不停生产对象的时候，<code>GC</code> 不断的跟随回收，导致无法达到设置的最大的数据量，所以一直没有日志的写入。</p>
<p><strong>总结：</strong></p>
<p>这个 <code>Demo</code>  主要学习了 <code>Substrate</code> <a target="_blank" rel="noopener" href="https://github.com/facebookincubator/profilo/tree/master/deps/fbjni">fbjni</a> <code>ndk_dlopen</code> 这几个库的简单使用，<code>CmakeList</code>  的很多写法，以及 <code>native</code> 函数简写</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JNI_METHOD_DECL(ret_type, method_name) \</span></span><br><span class="line">     <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> JNIEXPORT ret_type JNICALL Java_##com_dodola_alloctrack##_##AllocTracker##_##method_name</span><br></pre></td></tr></table></figure>

<p>还了解了一些 <code>hook</code> 点以及 <code>hook</code> 方法。</p>
<h2 id="4-2-重复图片检测Demo"><a href="#4-2-重复图片检测Demo" class="headerlink" title="4.2 重复图片检测Demo"></a>4.2 重复图片检测Demo</h2><p><a target="_blank" rel="noopener" href="https://github.com/simplezhli/Chapter04">极客时间 Android 高手课 Chapter04</a> 已完成的 <code>Demo</code> </p>
<blockquote>
<p>通过分析内存文件 hprof 快速判断内存中是否存在重复的图片，并且将这些重复图片的 PNG 、堆栈等信息输出。</p>
<p><strong>需要注意的是需要使用8.0以下的机器，因为8.0以后Bitmap中的buffer已经放到native内存中了</strong></p>
</blockquote>
<p>代码在开始加载了两张相同的图片。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Bitmap bitmap1 = BitmapFactory.decodeResource(getResources(), R.mipmap.test); </span><br><span class="line">Bitmap bitmap2 = BitmapFactory.decodeResource(getResources(), R.mipmap.test);</span><br><span class="line">imageView1.setImageBitmap(bitmap1); </span><br><span class="line">imageView2.setImageBitmap(bitmap2);</span><br></pre></td></tr></table></figure>

<p>然后手动 <code>GC</code> 生成 <code>hprof</code> 文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手动触发GC</span></span><br><span class="line">Runtime.getRuntime().gc();</span><br><span class="line">System.runFinalization();</span><br><span class="line"><span class="comment">// 生成Hprof文件</span></span><br><span class="line">Debug.dumpHprofData(file.getAbsolutePath());</span><br></pre></td></tr></table></figure>

<p>接下来在<code>DuplicatedBitmapAnalyzer</code> 的一个 <code>java</code> 项目里，利用 <a target="_blank" rel="noopener" href="https://github.com/square/haha">HAHA</a> 库进行文件分析，并输入重复图片。</p>
<p>作者已经将代码打成 <code>JAR</code> 包，可以直接调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar tools&#x2F;DuplicatedBitmapAnalyzer-1.0.jar hprof文件路径</span><br></pre></td></tr></table></figure>

<p>对于更多的信息，可以参看 <a target="_blank" rel="noopener" href="https://github.com/square/leakcanary">LeakCanary</a> 源码</p>
<p><strong>总结：</strong></p>
<p>这个 <code>Demo</code> 主要学到了如何主动生成 <code>hprof</code> 文件，以及如何用 <a target="_blank" rel="noopener" href="https://github.com/square/haha">HAHA</a> 这个库解析 <code>hprof</code> 文件。</p>
<p>联想：可以在特定场合去 <code>dump</code> 文件，比如内存大于最大内存 80%，因为 <code>hprof</code> 文件可能会很大，所以在用户 <code>wifi</code> 情况下回传。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Tencent/matrix#matrix_android_cn">Tencent/matrix</a> 这个框架拥有更丰富的检测方式。</p>
<hr>
<h1 id="5-优化思路"><a href="#5-优化思路" class="headerlink" title="5 优化思路"></a>5 优化思路</h1><h2 id="5-1-设备分级"><a href="#5-1-设备分级" class="headerlink" title="5.1 设备分级"></a>5.1 设备分级</h2><p>内存优化首先需要根据设备环境来综合考虑</p>
<ul>
<li><strong>设备分级</strong>。使用类似 <a target="_blank" rel="noopener" href="http://github.com/facebook/device-year-class">device-year-class</a> 的策略对设备分级，对于低端机用户可以关闭复杂的动画，或者是某些功能；使用 565 格式的图片，使用更小的缓存内存等。<ul>
<li><code>device-year-class</code> 会根据手机的内存、CPU 核心数和频率等信息决定设备属于哪一个年份，这个示例表示对于 2013 年之后的设备可以使用复杂的动画，对于 2010 年之前的低端设备则不添加任何动画。</li>
<li>565 格式图片：一张图片中每一个像素的大小取决于它的解码选项，而 Android 中能够选择的 Bitmap 解码选项有四种。<ul>
<li>ARGB_8888 ：ARGB 四个通道的值都是 8 位，加起来 32 位，也就是每个像素占 4 个字节</li>
<li>ARGB_4444： ARGB 四个通道的值都是 4 位，加起来 16 位，也就是每个像素占 2 个字节</li>
<li>RGB_565： RGB 三个通道分别是 5 位、6 位、5 位，加起来 16 位，也就是每个像素占 2 个字节</li>
<li>ALPHA_8：只有 A 通道，占 8 位，也就是每个像素占 1 个字节</li>
</ul>
</li>
</ul>
</li>
<li><strong>缓存管理</strong>。我们需要有一套统一的缓存管理机制，可以适当地使用内存；当“系统有难”时，也要义不容辞地归还。我们可以使用 <code>OnTrimMemory(本文 4.1.1 会讲到)</code> 回调，根据不同的状态决定释放多少内存。</li>
<li><strong>进程模型</strong>。一个空的进程也会占用 10MB 的内存，而有些应用启动就有十几个进程，甚至有些应用已经从双进程保活升级到四进程保活，所以减少应用启动的进程数、减少常驻进程、有节操的保活，对低端机内存优化非常重要。</li>
<li><strong>安装包大小</strong>。安装包中的代码、资源、图片以及 so 库的体积，跟它们占用的内存有很大的关系。一个 80MB 的应用很难在 512MB 内存的手机上流畅运行。这种情况我们需要考虑针对低端机用户推出 4MB 的轻量版本，例如 <code>Facebook Lite</code>、今日头条极速版都是这个思路。</li>
</ul>
<h2 id="5-2-Bitmap-优化"><a href="#5-2-Bitmap-优化" class="headerlink" title="5.2 Bitmap 优化"></a>5.2 Bitmap 优化</h2><p><code>Bitmap</code> 内存一般占应用总内存很大一部分，所以做内存优化永远无法避开图片内存这个“永恒主题”。</p>
<ol>
<li><p>统一图片库</p>
<p>图片内存优化的前提是收拢图片的调用，这样我们可以做整体的控制策略。就如设备分级中说的，低端设备策略等。</p>
</li>
<li><p>统一监控</p>
<ol>
<li><strong>大图片监控</strong>。我们需要注意某张图片内存占用是否过大，例如长宽远远大于 View 甚至是屏幕的长宽。在开发过程中，如果检测到不合规的图片使用，应该立即弹出对话框提示图片所在的 Activity 和堆栈，让开发同学更快发现并解决问题。<code>Glide</code> 可以有效的解决此类问题，因为 <code>Glide</code> 会根据 <code>ImageView</code> 的大小把图片大小调整成<code>ImageView</code> 的大小加载图片，并且 <code>Glide</code> 有三级缓存，在内存缓存中，<code>Glide</code> 会根据屏幕大小选择合适的大小作为图片内存缓存区的大小。</li>
<li><strong>重复图片监控</strong>。重复图片指的是 <code>Bitmap</code> 的像素数据完全一致，但是有多个不同的对象存在。这个监控不需要太多的样本量，一般只在内部使用。在检测模块中实现过一个内存 <code>Hprof</code> 的分析工具，它可以自动将重复 <code>Bitmap</code> 的图片和引用链输出。<ol>
<li><strong>图片总内存</strong>。通过收拢图片使用，我们还可以统计应用所有图片占用的内存，这样在线上就可以按不同的系统、屏幕分辨率等维度去分析图片内存的占用情况。在 <code>OOM</code> 崩溃的时候，也可以把图片占用的总内存、Top N 图片的内存都写到崩溃日志中，帮助我们排查问题。</li>
</ol>
</li>
</ol>
</li>
</ol>
<hr>
<h1 id="6-更多"><a href="#6-更多" class="headerlink" title="6 更多"></a>6 更多</h1><h2 id="6-1-监听系统内存状态"><a href="#6-1-监听系统内存状态" class="headerlink" title="6.1 监听系统内存状态"></a>6.1 监听系统内存状态</h2><p>Android 提供了两种方式让我们可以监听系统内存状态</p>
<h3 id="6-1-1-ComponentCallback2"><a href="#6-1-1-ComponentCallback2" class="headerlink" title="6.1.1 ComponentCallback2"></a>6.1.1 ComponentCallback2</h3><p>在 <code>Android 4.0</code> 后，<code>Android</code> 应用可以通过在 <code>Activity</code> 中实现 <code>ComponentCallback2</code> 接口获取系统内存的相关事件，这样就能在系统内存不足时提前知道这件事，提前做出释放内存的操作，避免我们自己的应用被系统干掉。</p>
<p><code>ComponentCallnback2</code> 提供了 <code>onTrimMemory(level)</code> 回调方法，在这个方法里我们可以针对不同的警告等级做出不同的释放内存操作。</p>
<p>原文是 <code>kotlin</code> 版，这里给出一个 <code>java</code> 版</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity2</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title">ComponentCallbacks2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTrimMemory</span><span class="params">(<span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onTrimMemory(level);</span><br><span class="line">        <span class="keyword">switch</span> (level) &#123;</span><br><span class="line">            <span class="keyword">case</span> ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN:</span><br><span class="line">                <span class="comment">// 应用界面处于后台</span></span><br><span class="line">                <span class="comment">// 可以在这里释放 UI 对象</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ComponentCallbacks2.TRIM_MEMORY_RUNNING_MODERATE:</span><br><span class="line">                <span class="comment">// 应用正常运行中，不会被杀掉，但是系统内存已经有点低了</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ComponentCallbacks2.TRIM_MEMORY_RUNNING_LOW:</span><br><span class="line">                <span class="comment">// 应用正常运行中，不会被杀掉，但是系统内存已经非常低了，</span></span><br><span class="line">                <span class="comment">// 这时候应该释放一些不必要的资源以提升系统性能</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL:</span><br><span class="line">                <span class="comment">// 应用正常运行，但是系统内存非常紧张，</span></span><br><span class="line">                <span class="comment">// 系统已经开始根据 LRU 缓存杀掉了大部分缓存的进程</span></span><br><span class="line">                <span class="comment">// 这时候我们要释放所有不必要的资源，不然系统可能会继续杀掉所有缓存中的进程</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ComponentCallbacks2.TRIM_MEMORY_BACKGROUND:</span><br><span class="line">                <span class="comment">// 系统内存很低，系统准备开始根据 LRU 缓存清理进程，</span></span><br><span class="line">                <span class="comment">// 这时我们的程序在 LRU 缓存列表的最近位置，不太可能被清理掉，</span></span><br><span class="line">                <span class="comment">// 但是也要去释放一些比较容易恢复的资源，让系统内存变得充足</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ComponentCallbacks2.TRIM_MEMORY_MODERATE:</span><br><span class="line">                <span class="comment">// 系统内存很低，并且我们的应用处于 LRU 列表的中间位置，</span></span><br><span class="line">                <span class="comment">// 这时候如果还不释放一些不必要资源，那么我们的应用可能会被系统干掉</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ComponentCallbacks2.TRIM_MEMORY_COMPLETE:</span><br><span class="line">                <span class="comment">// 系统内存非常低，并且我们的应用处于 LRU 列表的最边缘位置，</span></span><br><span class="line">                <span class="comment">// 系统会有限考虑干掉我们的应用，如果想活下来，就要把所有能释放的资源都释放了</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="comment">// 应用从系统接收到一个无法识别的内存等级值，</span></span><br><span class="line">                <span class="comment">// 跟一般的低内存消息提醒一样对待这个事件</span></span><br><span class="line">                <span class="comment">// 释放所有不重要的数据结构。</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-1-2-ActivityManager-getMemoryInfo"><a href="#6-1-2-ActivityManager-getMemoryInfo" class="headerlink" title="6.1.2 ActivityManager.getMemoryInfo()"></a>6.1.2 ActivityManager.getMemoryInfo()</h3><p>Android 提供了一个 <code>ActivityManager.getMemoryInfo()</code> 方法给我们查询内存信息，这个方法会返回一个 <code>ActivityManager.MemoryInfo</code> 对象，这个对象包含了系统当前内存状态，这些状态信息包括可用内存、总内存以及低杀内存阈值。</p>
<p><code>MemoryInfo</code> 中包含了一个 <code>lowMemory</code> 布尔值，这个布尔值用于表明系统是否处于低内存状态。</p>
<p>原文是 <code>kotlin</code> 版，这里给出一个 <code>java</code> 版</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomethingMemoryIntensive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在做一些需要很多内存的任务前，</span></span><br><span class="line">        <span class="comment">// 检查设备是否处于低内存状态、</span></span><br><span class="line">        <span class="keyword">if</span> (!getAvailableMemory().lowMemory) &#123;</span><br><span class="line">            <span class="comment">// 做需要很多内存的任务</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ActivityManager.<span class="function">MemoryInfo <span class="title">getAvailableMemory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ActivityManager activityManager = (ActivityManager) getSystemService(Context.ACTIVITY_SERVICE);</span><br><span class="line">        ActivityManager.MemoryInfo MemoryInfo = <span class="keyword">new</span> ActivityManager.MemoryInfo();</span><br><span class="line">        activityManager.getMemoryInfo(MemoryInfo);</span><br><span class="line">        <span class="keyword">return</span> MemoryInfo;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-2-内存优化技巧"><a href="#6-2-内存优化技巧" class="headerlink" title="6.2 内存优化技巧"></a>6.2 内存优化技巧</h2><h3 id="6-2-1-谨慎使用-Service"><a href="#6-2-1-谨慎使用-Service" class="headerlink" title="6.2.1 谨慎使用 Service"></a>6.2.1 谨慎使用 Service</h3><p>让一个没用的 <code>Service</code> 在后台运行对于一个应用的内存管理来说是一件最糟糕的事情。</p>
<p>要在 <code>Service</code> 的任务完成后停止它，不然 <code>Service</code> 占用的这块内存会泄漏。</p>
<p>当你的应用中运行着一个 <code>Service</code>，除非系统内存不足，否则它不会被干掉。</p>
<p>这就导致对于系统来说 <code>Service</code> 的运行成本很高，因为 <code>Service</code> 占用的内存其他的进程是不能使用的。</p>
<p><code>Android</code> 有一个缓存进程列表，当可用内存减少时，这个列表也会随之缩小，这就会导致应用间的切换变得很慢。</p>
<p>如果我们是用 <code>Service</code> 监听一些系统广播，希望在特定情况下再启动事务，可以考虑使用 <code>JobScheduler</code>。</p>
<p>如果你真的要用 <code>Service</code>，可以考虑使用 <code>IntentService</code>，<code>IntentService</code> 是 <code>Service</code> 的一个子类，在它的内部有一个工作线程来处理耗时任务，当任务执行完后，<code>IntentService</code> 就会自动停止。</p>
<h3 id="6-2-2-选择优化后的数据容器"><a href="#6-2-2-选择优化后的数据容器" class="headerlink" title="6.2.2 选择优化后的数据容器"></a>6.2.2 选择优化后的数据容器</h3><p><code>Java</code> 提供的部分数据容器并不适合 <code>Android</code>，比如 <code>HashMap</code>，<code>HashMap</code> 需要中存储每一个键值对都需要一个额外的 <code>Entry</code> 对象。</p>
<p>Android 提供了几个优化后的数据容器，包括 <code>SparseArray</code>、<code>SparseBooleanArray</code> 以及 <code>LongSparseArray</code>。</p>
<p><code>SparseArray</code>和<code>ArrayMap</code>是Android专门针对内存优化而设计的取代 <code>Java API</code> 中的<code>HashMap</code>的数据结构。对于 <code>key</code> 是 <code>int</code> 类型则使用<code>SparseArray</code>，可避免自动装箱过程；对于 <code>key</code> 为其他类型则使用<code>ArrayMap</code>。<code>HashMap</code>的查找和插入时间复杂度为 <code>O(1)</code> 的代价是牺牲大量的内存来实现的，而<code>SparseArray</code>和<code>ArrayMap</code>性能略逊于<code>HashMap</code>，但更节省内存。</p>
<h3 id="6-2-3-小心代码抽象"><a href="#6-2-3-小心代码抽象" class="headerlink" title="6.2.3 小心代码抽象"></a>6.2.3 小心代码抽象</h3><p>抽象可以优化代码的灵活性和可维护性，但是抽象也会带来其他成本。</p>
<p>抽象会导致更多的代码需要被执行，也就是需要更多的时间和把更多的代码映射到内存中。</p>
<p>如果某段抽象代码带来的好处不大，比如一个地方可以直接实现而不需要用到接口的，那就不用接口。</p>
<h3 id="6-2-4-使用-protobuf-作为序列化数据"><a href="#6-2-4-使用-protobuf-作为序列化数据" class="headerlink" title="6.2.4 使用 protobuf 作为序列化数据"></a>6.2.4 使用 protobuf 作为序列化数据</h3><p><code>Protocol buffers</code> 是 <code>Google</code> 设计的，它可以对结构化的数据序列化，与<code>XML</code> 类似，不过比<code>XML</code> 更小，更快，而且更简单。</p>
<p>如果你决定使用 <code>protobuf</code> 作为序列化数据格式，那在客户端代码中应该使用轻量级的 <code>protobuf</code>。</p>
<p>因为一般的 <code>protobuf</code> 会生成冗长的代码，这样会导致内存增加、<code>APK</code> 大小增加，执行速度变慢等问题。</p>
<p>更多关于 <code>protobuf</code> 的信息可以查看 <a target="_blank" rel="noopener" href="https://android.googlesource.com/platform/external/protobuf/+/master/java/README.md#installation-lite-version-with-maven">protobuf readme</a> 中的 “轻量级版本”  。</p>
<h3 id="6-2-5-Apk-瘦身"><a href="#6-2-5-Apk-瘦身" class="headerlink" title="6.2.5 Apk 瘦身"></a>6.2.5 Apk 瘦身</h3><p>有些资源和第三方库会在我们不知情的情况下大量消耗内存。</p>
<p><code>Bitmap</code> 大小、资源、动画以及第三方库会影响到 <code>APK</code> 的大小，<code>Android Studio</code> 提供了 <code>R8</code> 和 <code>ProGuard</code> 帮助我们缩小 <code>Apk</code>，去掉不必要的资源。</p>
<p>如果你使用的 <code>Android Studio</code> 版本是 3.3 以下的，可以使用 <code>ProGuard</code>，3.3 及以上版本的可以使用 <code>R8</code>。</p>
<h3 id="6-2-6-使用-Dagger2-进行依赖注入"><a href="#6-2-6-使用-Dagger2-进行依赖注入" class="headerlink" title="6.2.6 使用 Dagger2 进行依赖注入"></a>6.2.6 使用 Dagger2 进行依赖注入</h3><p>依赖注入框架不仅可以简化我们的代码，而且能让我们在测试代码的时候更方便。</p>
<p>如果我们想在应用中使用依赖注入，可以考虑使用 <code>Dagger2</code>。</p>
<p><code>Dagger2</code> 是在编译期生成代码，而不是用反射实现的，这样就避免了反射带来的内存开销，而是在编译期生成代码，</p>
<h3 id="6-2-7-谨慎使用第三方库"><a href="#6-2-7-谨慎使用第三方库" class="headerlink" title="6.2.7 谨慎使用第三方库"></a>6.2.7 谨慎使用第三方库</h3><p>当你决定使用一个不是为移动平台设计的第三方库时，你需要对它进行优化，让它能更好地在移动设备上运行。</p>
<p>这些第三方库包括日志、分析、图片加载、缓存以及其他框架，都有可能带来性能问题。</p>
<h3 id="6-2-8-使用-IntDef-和-StringDef-替代枚举类型"><a href="#6-2-8-使用-IntDef-和-StringDef-替代枚举类型" class="headerlink" title="6.2.8 使用  IntDef 和 StringDef 替代枚举类型"></a>6.2.8 使用  IntDef 和 StringDef 替代枚举类型</h3><p>使用枚举类型的 <code>dex size</code> 是普通常量定义的 <code>dex size</code> 的 13 倍以上，同时，运行时的内存分配，一个 <code>enum</code> 值的声明会消耗至少 <code>20 bytes</code> 。</p>
<p>枚举最大的优点是类型安全，但在Android平台上，枚举的内存开销是直接定义常量的三倍以上。所以Android提供了注解的方式检查类型安全。目前提供了int型和String型两种注解方式：<code>IntDef</code> 和 <code>StringDef</code> ，用来提供编译期的类型检查。</p>
<p>使用 <code>IntDef</code>和 <code>StringDef</code> 需要在 <code>Gradle</code> 配置中引入相应的依赖包：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile <span class="string">&#x27;com.android.support:support-annotations:22.0.0&#x27;</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a><strong>感谢</strong></h1><blockquote>
<p><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/74044">极客时间 Android开发高手课</a>  </p>
<p><a target="_blank" rel="noopener" href="https://coding.imooc.com/learn/list/308.html">慕课 Top团队大牛带你玩转Android性能分析与优化</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5d3ada056fb9a07eb94fd1bc">探索 Android 内存优化方法</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/58b80c3b61ff4b006cd8c33d">Android 性能优化（四）之内存优化实战</a></p>
<p><a target="_blank" rel="noopener" href="https://square.github.io/leakcanary">LeakCanary</a></p>
<p><a target="_blank" rel="noopener" href="https://developer.android.google.cn/studio/profile/memory-profiler">AndroidDeveloper</a> </p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">CalmCenter</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://calmcenter.club/2020/memory-optimization2.html">https://calmcenter.club/2020/memory-optimization2.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://calmcenter.club" target="_blank">CalmCenter</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Android/">Android</a><a class="post-meta__tags" href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">性能优化</a></div><div class="post_share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.png" target="_blank"><img class="post-qr-code-img" data-lazy-src="/img/wechat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.png" target="_blank"><img class="post-qr-code-img" data-lazy-src="/img/alipay.png" alt="支付寶"/></a><div class="post-qr-code-desc">支付寶</div></li></ul></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/ui-optimization.html"><img class="prev-cover" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/cover32.webp" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">App UI优化💦</div></div></a></div><div class="next-post pull-right"><a href="/2020/memory-optimization.html"><img class="next-cover" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/cover35.webp" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">App 内存知识介绍💦</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2020/memory-optimization.html" title="App 内存知识介绍💦"><img class="cover" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/cover35.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-02-28</div><div class="title">App 内存知识介绍💦</div></div></a></div><div><a href="/2019/complete-works-of-android-performance.html" title="Android 性能优化篇"><img class="cover" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/20200228233120.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-12-01</div><div class="title">Android 性能优化篇</div></div></a></div><div><a href="/2020/stability-optimization.html" title="稳定性优化"><img class="cover" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/cover26.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-06-02</div><div class="title">稳定性优化</div></div></a></div><div><a href="/2020/ui-optimization.html" title="App UI优化💦"><img class="cover" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/cover32.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-04-15</div><div class="title">App UI优化💦</div></div></a></div><div><a href="/2020/hobble-optimization.html" title="App 直观感受-卡顿优化🌈"><img class="cover" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/cover12.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-04-20</div><div class="title">App 直观感受-卡顿优化🌈</div></div></a></div><div><a href="/2020/network-optimization.html" title="App 网络优化🌞"><img class="cover" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/cover19.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-05-20</div><div class="title">App 网络优化🌞</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo"></div></div></div></div></div><div class="aside_content" id="aside_content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><img class="avatar-img" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">CalmCenter</div><div class="author-info__description">目标设置到月球，即使陨落也是在群星之间！</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">43</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/CalmCenter"><i class="fab fa-github"></i><span>Follow Me</span></a></div></div><div class="card-widget card-announcement"><div class="card-content"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">不要努力成为一个成功的人，而要努力成为一个有价值的人。</div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%AC%E6%96%87%E4%B8%BB%E8%A6%81%E8%AE%B0%E8%BD%BD"><span class="toc-text">本文主要记载</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF-Memory-Profiler"><span class="toc-text">1  什么是 Memory Profiler?</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D"><span class="toc-text">1.1 使用介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-1-%E5%90%AF%E7%94%A8%E9%AB%98%E7%BA%A7%E5%88%86%E6%9E%90"><span class="toc-text">1.1.1  启用高级分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-2-%E8%AE%A1%E7%AE%97%E5%86%85%E5%AD%98-%E6%AF%8F%E4%B8%AA%E5%86%85%E5%AD%98%E7%B1%BB%E5%88%AB%E5%BD%93%E5%89%8D%E4%BD%BF%E7%94%A8%E5%A4%9A%E5%B0%91%E5%86%85%E5%AD%98"><span class="toc-text">1.1.2 计算内存(每个内存类别当前使用多少内存)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-3-%E6%9F%A5%E7%9C%8B%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D-%E5%88%86%E9%85%8D%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%95%B0"><span class="toc-text">1.1.3 查看内存分配(分配的对象数)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-4-%E5%9C%A8%E5%88%86%E6%9E%90%E6%97%B6%E6%8F%90%E9%AB%98%E5%BA%94%E7%94%A8%E6%80%A7%E8%83%BD"><span class="toc-text">1.1.4 在分析时提高应用性能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-5-%E6%8D%95%E8%8E%B7%E5%A0%86%E8%BD%AC%E5%82%A8"><span class="toc-text">1.1.5 捕获堆转储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-6-%E5%B0%86%E5%A0%86%E8%BD%AC%E5%82%A8%E5%8F%A6%E5%AD%98%E4%B8%BA-HPROF-%E6%96%87%E4%BB%B6"><span class="toc-text">1.1.6 将堆转储另存为 HPROF 文件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E4%BB%80%E4%B9%88%E6%98%AF-MAT"><span class="toc-text">2 什么是 MAT?</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E4%BD%BF%E7%94%A8%E5%89%8D%E6%8F%90"><span class="toc-text">2.1 使用前提</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D"><span class="toc-text">2.2 使用介绍</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E4%BB%80%E4%B9%88%E6%98%AF-LeakCanary%EF%BC%9F"><span class="toc-text">3 什么是 LeakCanary？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-LeakCanary-%E5%8E%9F%E7%90%86"><span class="toc-text">3.1 LeakCanary 原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-LeakCanary-%E4%BD%BF%E7%94%A8"><span class="toc-text">3.2 LeakCanary 使用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%9E%E7%8E%B0-Demo"><span class="toc-text">4 自定义实现 Demo</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A3%80%E6%B5%8BDemo"><span class="toc-text">4.1 自动化检测Demo</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E9%87%8D%E5%A4%8D%E5%9B%BE%E7%89%87%E6%A3%80%E6%B5%8BDemo"><span class="toc-text">4.2 重复图片检测Demo</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF"><span class="toc-text">5 优化思路</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E8%AE%BE%E5%A4%87%E5%88%86%E7%BA%A7"><span class="toc-text">5.1 设备分级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-Bitmap-%E4%BC%98%E5%8C%96"><span class="toc-text">5.2 Bitmap 优化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E6%9B%B4%E5%A4%9A"><span class="toc-text">6 更多</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E7%9B%91%E5%90%AC%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E7%8A%B6%E6%80%81"><span class="toc-text">6.1 监听系统内存状态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-1-ComponentCallback2"><span class="toc-text">6.1.1 ComponentCallback2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-2-ActivityManager-getMemoryInfo"><span class="toc-text">6.1.2 ActivityManager.getMemoryInfo()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7"><span class="toc-text">6.2 内存优化技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-1-%E8%B0%A8%E6%85%8E%E4%BD%BF%E7%94%A8-Service"><span class="toc-text">6.2.1 谨慎使用 Service</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-2-%E9%80%89%E6%8B%A9%E4%BC%98%E5%8C%96%E5%90%8E%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AE%B9%E5%99%A8"><span class="toc-text">6.2.2 选择优化后的数据容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-3-%E5%B0%8F%E5%BF%83%E4%BB%A3%E7%A0%81%E6%8A%BD%E8%B1%A1"><span class="toc-text">6.2.3 小心代码抽象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-4-%E4%BD%BF%E7%94%A8-protobuf-%E4%BD%9C%E4%B8%BA%E5%BA%8F%E5%88%97%E5%8C%96%E6%95%B0%E6%8D%AE"><span class="toc-text">6.2.4 使用 protobuf 作为序列化数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-5-Apk-%E7%98%A6%E8%BA%AB"><span class="toc-text">6.2.5 Apk 瘦身</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-6-%E4%BD%BF%E7%94%A8-Dagger2-%E8%BF%9B%E8%A1%8C%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5"><span class="toc-text">6.2.6 使用 Dagger2 进行依赖注入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-7-%E8%B0%A8%E6%85%8E%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93"><span class="toc-text">6.2.7 谨慎使用第三方库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-8-%E4%BD%BF%E7%94%A8-IntDef-%E5%92%8C-StringDef-%E6%9B%BF%E4%BB%A3%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="toc-text">6.2.8 使用  IntDef 和 StringDef 替代枚举类型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%84%9F%E8%B0%A2"><span class="toc-text">感谢</span></a></li></ol></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 By CalmCenter</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>function loadTwikoo () {
  function init () {
    twikoo.init({ 
      envId: 'calm-9gof91dkfcacdb0a' 
    })
  }

  if (typeof twikoo.init === 'function') {
    init()
  } else {
    $.getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js', init)
  }
}

if ('Twikoo' === 'Twikoo' || !false) {
  if (false) btf.loadComment(document.getElementById('twikoo'), loadTwikoo)
  else loadTwikoo()
} else {
  function loadOtherComment () {
    loadTwikoo()
  }
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script></div></body></html>