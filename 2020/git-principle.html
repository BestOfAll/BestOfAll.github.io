<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Git 功能原理记录 | CalmCenter</title><meta name="keywords" content="HEXO"><meta name="author" content="CalmCenter"><meta name="copyright" content="CalmCenter"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="Git 是一个版本管理软件，由 Linux 之父花了 三天 搞出来的东西。">
<meta property="og:type" content="article">
<meta property="og:title" content="Git 功能原理记录">
<meta property="og:url" content="https://calmcenter.club/2020/git-principle.html">
<meta property="og:site_name" content="CalmCenter">
<meta property="og:description" content="Git 是一个版本管理软件，由 Linux 之父花了 三天 搞出来的东西。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/CalmCenter/Pic/raw/master/cover47.webp">
<meta property="article:published_time" content="2020-07-16T09:32:22.000Z">
<meta property="article:modified_time" content="2020-07-16T09:32:22.000Z">
<meta property="article:author" content="CalmCenter">
<meta property="article:tag" content="git">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/CalmCenter/Pic/raw/master/cover47.webp"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://calmcenter.club/2020/git-principle"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  ClickShowText: undefined,
  lightbox: 'mediumZoom',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"top-right"},
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2020-07-16 17:32:22'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><meta name="generator" content="Hexo 5.2.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" data-lazy-src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">50</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://gitee.com/CalmCenter/Pic/raw/master/cover47.webp)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">CalmCenter</a></span><span id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><h1 class="post-title">Git 功能原理记录</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-07-16T09:32:22.000Z" title="发表于 2020-07-16 17:32:22">2020-07-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-07-16T09:32:22.000Z" title="更新于 2020-07-16 17:32:22">2020-07-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Hexo/">Hexo</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">14.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>51分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><code>Git</code> 是一个版本管理软件，由 <code>Linux</code> 之父花了 <strong>三天</strong> 搞出来的东西。</p>
<p>手动惭愧 (〃’▽’〃)</p>
<h2 id="一-clone-项目"><a href="#一-clone-项目" class="headerlink" title="一 clone(项目)"></a>一 clone(项目)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;CalmCenter&#x2F;UiStarge.git ui-starge</span><br></pre></td></tr></table></figure>

<p>最后那个 <code>ui-starge</code> 表示手动指定本地仓库目录名称。</p>
<p>使用 <code>git clone</code> 时，除了从远程仓库把 <code>.git</code> 这个仓库目录下载到工作目录中，还会 <code>checkout</code> （签出） <code>master</code>（<code>checkout</code> 的意思就是把某个 <code>commit</code> 作为<strong>当前</strong> <code>commit</code>，把 <code>HEAD</code> 移动过去，并把工作目录的文件内容替换成这个 <code>commit</code> 所对应的内容）。</p>
<h2 id="二-push-提交"><a href="#二-push-提交" class="headerlink" title="二 push(提交)"></a>二 push(提交)</h2><h3 id="add-添加至暂存区"><a href="#add-添加至暂存区" class="headerlink" title="add(添加至暂存区)"></a>add(添加至暂存区)</h3><p><code>push</code> 做的事是：把当前 <code>branch</code> 的位置（即它指向哪个 <code>commit</code>）上传到远端仓库，并把它的路径上的  <code>commits</code>  一并上传。</p>
<p>基础步骤 <code>add -&gt; commit -&gt; push</code> ，接下来一个一个看</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add test.txt</span><br></pre></td></tr></table></figure>

<p><code>add</code> 后面可以使文件或者文件夹，如果是文件夹 <code>test/</code> 。如果文件或文件夹名字有空格，比如 <code>text 1.txt</code> 文件 或 <code>text 2</code> 文件夹 ，需要写成  <code>get add test\ 1.txt</code> 或 <code>get add test\ 2/</code> ，将空格转义一下。</p>
<p>还有一个更方便的方法 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure>

<p><code>add</code> 指令除了 <code>git add 文件名</code> 这种用法外，还可以使用 <code>add .</code> 来直接把工作目录下的所有改动全部放进暂存区。这个用法没什么特别的好处，但就一个字：方便 (^_−)☆。</p>
<p>添加或删除的文件都需要 <code>add</code> ，也包括<strong>改名</strong>前的文件。 </p>
<p>你在 <code>add</code> 后，如果再次修改的已经添加的文件，需要再次 <code>add</code> ，因为通过 add 添加进暂存区的不是文件名，而是具体的对改动内容的一个快照。</p>
<h3 id="commit-提交到本地仓库"><a href="#commit-提交到本地仓库" class="headerlink" title="commit(提交到本地仓库)"></a>commit(提交到本地仓库)</h3><p>正常提交 <code>-m</code> 后面写提交信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;test&quot;</span><br></pre></td></tr></table></figure>

<p>当提交后，发现内容有误，需要怎么办？修改后重新提交一个 <code>commit</code> ？ 当然可以，不过还有一个更加优雅和简单的解决方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -—amend</span><br></pre></td></tr></table></figure>

<p><code>&quot;amend&quot;</code> 是「修正」的意思。在提交时，如果加上 <code>--amend</code> 参数，<code>Git</code> 不会在当前 <code>commit</code> 上增加 <code>commit</code>，而是会把当前 <code>commit</code> 里的内容和暂存区里的内容合并起来后创建一个新的 <code>commit</code>，<strong>用这个新的 <code>commit</code> 把当前 <code>commit</code> 替换掉</strong>。</p>
<p>需要注意：<code>commit --amend</code> 并不是直接修改原 <code>commit</code> 的内容，而是生成一条新的 <code>commit</code> ，替换掉旧的 <code>commit</code> 。如果旧的 <code>commit</code> 已经 <code>push</code> 到远程仓库，替换后 <code>push</code> 的时候需要在 <code>push</code> 后加 <code>-f</code> ：<code>git push -f</code> 强制更新远程仓库历史。</p>
<p>这种方式只能修改最新的 <code>commit</code> ，那如果要修改倒数第二个、第三个 <code>commit</code> 怎么办呢？<code>八 rebase 4.1</code> 中会详细说明。</p>
<h3 id="push"><a href="#push" class="headerlink" title="push"></a>push</h3><p>提交到远程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure>

<p><code>git push</code> 是提交当前分支已经 <code>commit</code> 的文件。<strong>分支提交请查看  <code>Branch(分支)</code> 部分</strong></p>
<h3 id="push-上去了才发现写错怎么办？"><a href="#push-上去了才发现写错怎么办？" class="headerlink" title="push 上去了才发现写错怎么办？"></a>push 上去了才发现写错怎么办？</h3><p><strong>出错的内容在你自己的 <code>branch</code></strong>，不会影响到其他人，那没关系用本文的方法把写错的 <code>commit</code> 修改或者删除掉，然后再 <code>push</code> 上去就好了。</p>
<p>如果是修改或删掉了本地的 <code>commit</code> 需要用下面的命令强制更新远程才可以  ~</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin branch1 -f</span><br></pre></td></tr></table></figure>

<p><strong>当出错的内容已经合并到 <code>master</code></strong> ，同事的工作都在 <code>master</code> 上，永远不知道一次强制 <code>push</code> 会不会洗掉同事刚发上去的新提交。<br>除非人员数量和行为都完全可控的超小团队，可以和同事做到无死角的完美沟通，不然一定别在 <code>master</code> 上强制 <code>push</code>。</p>
<p>在这种时候，你只能退一步，选用另一种策略：<br>增加一个新的提交，把之前提交的内容抹掉。例如之前你增加了一行代码，你希望撤销它，那么你就做一个删掉这行代码的提交；<br>如果你删掉了一行代码，你希望撤销它，那么你就做一个把这行代码还原回来的提交。</p>
<p>这种事做起来也不算麻烦，因为 Git 有一个对应的指令：<code>revert</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert HEAD^</span><br></pre></td></tr></table></figure>

<p>上面这行代码就会增加一条新的 <code>commit</code>，它的内容和倒数第二个 <code>commit</code> 是相反的，从而和倒数第二个 <code>commit</code> 相互抵消，达到撤销的效果。</p>
<p>在 <code>revert</code> 完成之后，把新的 <code>commit</code> 再 <code>push</code> 上去，这个 <code>commit</code> 的内容就被撤销了。它和前面所介绍的撤销方式相比，最主要的区别是，这次改动只是被「反转」了，并没有在历史中消失掉，你的历史中会存在两条 <code>commit</code> ：一个原始 <code>commit</code> ，一个对它的反转 <code>commit</code>。</p>
<h2 id="三-pull-拉取"><a href="#三-pull-拉取" class="headerlink" title="三 pull(拉取)"></a>三 pull(拉取)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure>

<p>这个命令可以 <code>拉取文件</code> 比如其他人提交或合并了文件，还可以 <code>拉取远程分支</code> 比如其他人将分支提交到了远程仓库，<code>pull</code> 的实际操作其实是把远端仓库的内容用 <code>fetch</code> 取下来之后，用 <code>merge</code> 来合并。</p>
<h2 id="四-查看提交记录"><a href="#四-查看提交记录" class="headerlink" title="四 查看提交记录"></a>四 查看提交记录</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit 2c796942b103740176aae9eab1e2ead364c75787 (HEAD -&gt; master, origin&#x2F;master, origin&#x2F;HEAD)</span><br><span class="line">Author: Pc</span><br><span class="line">Date:   Thu Jul 16 16:04:31 2020 +0800</span><br><span class="line"></span><br><span class="line">    delete</span><br><span class="line"></span><br><span class="line">commit efc90131928c01ff3c8db1feae58461c766c78cd</span><br><span class="line">Author: Calm Lv</span><br><span class="line">Date:   Thu Jul 16 16:02:28 2020 +0800</span><br><span class="line"></span><br><span class="line">    Delete test 1.txt</span><br><span class="line"></span><br><span class="line">commit 24078eeecdaae6091e65170d86dcd4e20a474817</span><br><span class="line">Author: Pc</span><br><span class="line">Date:   Thu Jul 16 16:00:17 2020 +0800</span><br><span class="line"></span><br><span class="line">    test</span><br></pre></td></tr></table></figure>

<p>第一行的 <code>commit</code> 后面括号里的 <code>HEAD -&gt; master, origin/master, origin/HEAD</code> ，是几个指向这个 <code>commit</code> 的<strong>「引用」</strong>。</p>
<ul>
<li><p><strong>commit 唯一标识</strong></p>
<p>每一个 <code>commit</code> 都有一个它唯一的指定方式，它的 <code>SHA-1</code> 校验和，也就是上图中每个 <code>commit</code> 右边的那一长串字符。</p>
<p>两个 <code>SHA-1</code> 值的重复概率极低，所以可以使用这个 <code>SHA-1</code> 值来指代 <code>commit</code>，也可以只使用它的前几位来指代它（例如第一个 <code>2c796942b...75787</code>，你使用 ``2c79694<code>甚至</code>2c79` 来指代它）</p>
<p>但毕竟这种没有任何含义的字符串是很难记忆的，所以 <code>Git</code> 提供了「引用」的机制：使用固定的字符串作为「引用」，指向某个 <code>commit</code>，作为操作 <code>commit</code> 时的快捷方式。</p>
</li>
<li><p><strong>HEAD</strong></p>
<p> <code>HEAD</code> 是「引用」中最特殊的一个：它是指向当前 <code>commit</code> 的「引用」，也就是当前工作目录所对应的 <code>commit</code>。</p>
</li>
<li><p><strong>origin/master、origin/HEAD</strong></p>
<p> 它们是对远端仓库的 <code>master</code> 和 <code>HEAD</code> 的本地镜像</p>
</li>
</ul>
<p><code>git log</code> 可以查看提交记录，但是看不到更多的细节，如何查看更多的细节呢？</p>
<h3 id="查看每个-commit-单行显示"><a href="#查看每个-commit-单行显示" class="headerlink" title="查看每个 commit 单行显示"></a>查看每个 commit 单行显示</h3><p>只显示 <code>commit SHA-1</code> 校验和 ，以及 提交说明。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --oneline</span><br></pre></td></tr></table></figure>

<h3 id="查看每个-commit-图标显示"><a href="#查看每个-commit-图标显示" class="headerlink" title="查看每个 commit 图标显示"></a>查看每个 commit 图标显示</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --oneline --graph --all</span><br></pre></td></tr></table></figure>

<h3 id="查看每个-commit-大致改动"><a href="#查看每个-commit-大致改动" class="headerlink" title="查看每个 commit 大致改动"></a>查看每个 commit 大致改动</h3><p>如果你只想大致看一下改动内容，但并不想深入每一行的细节（例如你想回顾一下自己是在哪个 <code>commit</code> 中修改了 <code>xxx.txt</code> 文件）可以使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --stat</span><br></pre></td></tr></table></figure>

<h3 id="查看每个-commit-详细改动"><a href="#查看每个-commit-详细改动" class="headerlink" title="查看每个 commit 详细改动"></a>查看每个 commit 详细改动</h3><p><code>-p</code> 是 <code>--patch</code> 的缩写，通过 <code>-p</code> 参数，你可以看到具体每个 <code>commit</code> 的改动细节</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log -p</span><br></pre></td></tr></table></figure>

<h3 id="查看当前-commit-的改动内容"><a href="#查看当前-commit-的改动内容" class="headerlink" title="查看当前 commit 的改动内容"></a>查看当前 <code>commit</code> 的改动内容</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git show</span><br></pre></td></tr></table></figure>

<h3 id="查看任意一个-commit"><a href="#查看任意一个-commit" class="headerlink" title="查看任意一个 commit"></a>查看任意一个 commit</h3><p>在 <code>show</code> 后面加上这个 <code>commit</code> 的引用（<code>branch</code> 或 <code>HEAD</code> 标记）或它的 <code>SHA-1</code> 码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git show 03c8</span><br></pre></td></tr></table></figure>

<h3 id="查看指定-commit-中的指定文件改动内容"><a href="#查看指定-commit-中的指定文件改动内容" class="headerlink" title="查看指定 commit 中的指定文件改动内容"></a>查看指定 commit 中的指定文件改动内容</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git show 03c8 branch1.txt</span><br></pre></td></tr></table></figure>

<h3 id="查看未提交的内容"><a href="#查看未提交的内容" class="headerlink" title="查看未提交的内容"></a>查看未提交的内容</h3><p>使用 <code>git diff --staged</code> 可以显示 暂存区( <code>add</code> 后的内容) 和 上一条提交 之间的不同，换句话说，这条指令可以让你看到「输入 <code>git commit</code> 后，你将会提交什么」</p>
<h4 id="比对暂存区和上一条提交"><a href="#比对暂存区和上一条提交" class="headerlink" title="比对暂存区和上一条提交"></a>比对暂存区和上一条提交</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff --staged</span><br></pre></td></tr></table></figure>

<p><code>--staged</code> 有一个等价的选项叫做 <code>--cached</code>。这里所谓的「等价」，是真真正正的等价，它们的意思完全相同。</p>
<h4 id="比对工作目录和暂存区"><a href="#比对工作目录和暂存区" class="headerlink" title="比对工作目录和暂存区"></a>比对工作目录和暂存区</h4><p>使用 <code>git diff</code> （不加选项参数）可以显示 工作目录 和 暂存区之间 的不同。换句话说，这条指令可以让你看到「执行 <code>add .</code> ，你会向暂存区中增加哪些内容」</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></table></figure>

<h4 id="比对工作目录和上一条提交"><a href="#比对工作目录和上一条提交" class="headerlink" title="比对工作目录和上一条提交"></a>比对工作目录和上一条提交</h4><p>它是上面这二者的内容相加。换句话说，这条指令可以让你看到「现在把所有文件都 <code>add</code> 然后 <code>git commit</code>，你将会提交什么」（不过需要注意，没有被 <code>Git</code> 记录在案的文件（即从来没有被 <code>add</code> 过 的文件，<code>untracked files</code> 并不会显示出来。为什么？因为对 <code>Git</code> 来说它并不存在啊，新创建的文件不会显示）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff HEAD</span><br></pre></td></tr></table></figure>

<p>如果你把 <code>HEAD</code> 换成其他的 <code>commit</code>，也可以显示当前工作目录和这条 <code>commit</code> 的区别。</p>
<h3 id="Reflog-查看引用移动记录"><a href="#Reflog-查看引用移动记录" class="headerlink" title="Reflog 查看引用移动记录"></a>Reflog 查看引用移动记录</h3><p><code>reflog</code> 是 <code>&quot;reference log&quot;</code> 的缩写，使用它可以查看 <code>Git</code> 仓库中的引用的移动记录。如果不指定引用，它会显示 <code>HEAD</code> 的移动记录。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog</span><br><span class="line">347cd98 (HEAD -&gt; master, origin&#x2F;master, origin&#x2F;HEAD) HEAD@&#123;0&#125;: checkout: moving from feature2 to master</span><br><span class="line">3a10357 (feature2) HEAD@&#123;1&#125;: checkout: moving from master to feature2</span><br></pre></td></tr></table></figure>

<p>这里可以查看之前分支的 <code>commit</code> 信息，如果 <code>feature2</code> 在这之后被删除了，可以查看之前 <code>feature2</code> 最后的切换信息，例如上面的 <code>347cd98</code> 表示 <code>HEAD</code> 的最后一次移动行为是「从 <code>feature2</code> 移动到 <code>master</code>」，如果之后 <code>feature2</code> 被删除了，我们可以切换回 <code>347cd98</code>，然后重新创建 <code>feature2</code> ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout 347cd98</span><br><span class="line">git checkout -b feature2</span><br></pre></td></tr></table></figure>

<p>这样就实现了分支追回。</p>
<blockquote>
<p>注意：不再被引用直接或间接指向的 <code>commit</code> 会在一定时间后被 <code>Git</code> 回收，所以使用 <code>reflog</code> 来找回删除的 <code>branch</code> 的操作一定要及时，不然有可能会由于 <code>commit</code> 被回收而再也找不回来。</p>
</blockquote>
<h2 id="五-Branch-分支"><a href="#五-Branch-分支" class="headerlink" title="五 Branch(分支)"></a>五 Branch(分支)</h2><p><code>HEAD</code> 是 <code>Git</code> 中一个独特的「引用」，它是唯一的。而除了 <code>HEAD</code> 之外，<code>Git</code> 还有一种「引用」，叫做 <code>branch</code>（分支）。</p>
<p><code>HEAD</code> 除了可以指向 <code>commit</code>，还可以指向一个 <code>branch</code>，当它指向某个 <code>branch</code> 的时候，会通过这个 <code>branch</code> 来间接地指向某个 <code>commit</code></p>
<p>上面的 <code>git log</code> 输出中，<code>HEAD -&gt; master</code> 中的 <code>master</code> 就是一个 <code>branch</code> 的名字，并且它是默认的 <code>branch</code>，而它左边的箭头 <code>-&gt;</code> 表示 <code>HEAD</code> 正指向它（当然，也会间接地指向它所指向的 <code>commit</code>）。</p>
<p>当我们执行 <code>git commit</code> 后 ，<code>HEAD</code> 和 <code>master</code> 这两个「引用」都指向了新的 <code>commit</code>，而 <code>origin/master</code> 和 <code>origin/HEAD</code> 则依然停留在原先的位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit 0b4d1da7f998bc5fb724b0a74b4034c5dab9e35a (HEAD -&gt; master)</span><br><span class="line">Author: Pc </span><br><span class="line">Date:   Thu Jul 16 16:46:58 2020 +0800</span><br><span class="line"></span><br><span class="line">    add</span><br><span class="line"></span><br><span class="line">commit 2c796942b103740176aae9eab1e2ead364c75787 (origin&#x2F;master, origin&#x2F;HEAD)</span><br><span class="line">Author: Pc </span><br><span class="line">Date:   Thu Jul 16 16:04:31 2020 +0800</span><br><span class="line"></span><br><span class="line">    delete</span><br></pre></td></tr></table></figure>

<h3 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch &lt;分支名&gt;</span><br></pre></td></tr></table></figure>

<h3 id="提交分支"><a href="#提交分支" class="headerlink" title="提交分支"></a>提交分支</h3><p>这里会将本地创建的分支更新到远程，并提交分支中的 <code>commits</code>。</p>
<p>如果本地当前 <code>HEAD</code> 处于新分支并且没有和远程关联，需要输入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin &lt;分支名&gt;</span><br></pre></td></tr></table></figure>

<p>才能提交当前分支以及分支中的文件到远程仓库</p>
<p><code>origin</code> 是远程仓库的别名，是你在 <code>git clone</code> 的时候 <code>Git</code> 自动帮你起的，然后指明分支名称。这两个参数合起来指定了你要 <code>push</code> 到的目标仓库和目标分支。</p>
<p>如果进行了关联 （设置本地分支追踪远程分支）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push --set-upstream origin &lt;分支名&gt;</span><br><span class="line">git push -u origin &lt;分支名&gt;</span><br></pre></td></tr></table></figure>

<p>关联后就可以在当前分支使用 <code>git push</code> 直接提交。</p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/5697750/what-exactly-does-the-u-do-git-push-u-origin-master-vs-git-push-origin-ma">What exactly does the “u” do? “git push -u origin master” vs “git push origin master”</a></p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/20019419/answer/138627544">git push 的 -u 参数具体适合含义？</a></p>
<h3 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure>

<h3 id="切换分支（checkout）"><a href="#切换分支（checkout）" class="headerlink" title="切换分支（checkout）"></a>切换分支（checkout）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;分支名&gt;</span><br></pre></td></tr></table></figure>

<p>还有一种方式是创建分支，创建并切换到刚创建的分支。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b &lt;分支名&gt;</span><br></pre></td></tr></table></figure>

<h4 id="checkout-本质："><a href="#checkout-本质：" class="headerlink" title="checkout 本质："></a><code>checkout</code> 本质：</h4><p><code>checkout</code> 并不止可以切换 <code>branch</code>。<code>checkout</code> 本质上的功能其实是：签出（ checkout ）指定的 <code>commit</code>。</p>
<p><code>git checkout branch名</code> 的本质，其实是把 <code>HEAD</code> 指向指定的 <code>branch</code>，然后签出这个 <code>branch</code> 所对应的 <code>commit</code> 的工作目录。所以同样的，<code>checkout</code> 的目标也可以不是 <code>branch</code>，而直接指定某个 <code>commit</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout HEAD^^</span><br><span class="line">git checkout 78a4bc</span><br></pre></td></tr></table></figure>

<p>在 <code>git status</code> 的提示语中，<code>Git</code> 会告诉你可以用 <code>checkout -- 文件名</code> 的格式，通过「签出」的方式来撤销工作目录中指定文件的修改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is ahead of &#39;origin&#x2F;master&#39; by 8 commits.</span><br><span class="line">  (use &quot;git push&quot; to publish your local commits)</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">        modified:   branch1.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and&#x2F;or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- branch1.txt</span><br></pre></td></tr></table></figure>

<p>然后刚刚对这个文件的修改就都被撤回了 ~ </p>
<h4 id="checkout-和-reset-的不同"><a href="#checkout-和-reset-的不同" class="headerlink" title="checkout 和 reset 的不同"></a><code>checkout</code> 和 <code>reset</code> 的不同</h4><p><code>reset</code> 后面会讲，但是这里先说一下不同，既然说不同那肯定就有相同的地方：</p>
<p><code>checkout</code> 和 <code>reset</code> 都可以切换 <code>HEAD</code> 的位置，它们除了有许多细节的差异外，最大的区别在于：<code>reset</code> 在移动 <code>HEAD</code> 时会带着它所指向的 <code>branch(引用)</code> 一起移动，而 <code>checkout</code> 不会。</p>
<p><code>checkout</code> 有一个专门用来只让 <code>HEAD</code> 和 <code>branch</code> 脱离而不移动 <code>HEAD</code> 的用法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout --detach</span><br></pre></td></tr></table></figure>

<p>现在提交 <code>commit</code> 之前所依赖的 <code>branch</code> 将不会一起移动。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">commit 347cd9856e1edf4c0a96cb15bad227ab8d255cda (HEAD)</span><br><span class="line">Author: Pc</span><br><span class="line">Date:   Tue Sep 29 18:27:18 2020 +0800</span><br><span class="line"></span><br><span class="line">    head</span><br><span class="line"></span><br><span class="line">commit 81bb6988fc9698699f697613876f5ad43a698564 (master)</span><br><span class="line">Author: Pc</span><br><span class="line">Date:   Tue Sep 29 18:26:43 2020 +0800</span><br><span class="line"></span><br><span class="line">    c</span><br></pre></td></tr></table></figure>

<p>应用场景：<br>比如想在某个 <code>commit</code> 出写一些临时的新的 <code>commits</code>，但不确定是否保留这些内容（或者倾向于不保留），那么就：</p>
<ol>
<li>不希望把当前的 branch 带跑；</li>
<li>不想新建一个别的 branch。</li>
</ol>
<p>那么就可以 <code>detach</code> 一下，这样就可以在后面的 <code>commits</code> 中只有 <code>HEAD</code> 在跟着 <code>commits</code> 跑，而 <code>branch</code> 一直留在原地。</p>
<h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d &lt;分支名&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>HEAD</code> 指向的 <code>branch</code> 不能删除。如果要删除 <code>HEAD</code> 指向的 <code>branch</code>，需要先用 <code>checkout</code> 把 <code>HEAD</code> 指向其他地方。</li>
<li>由于 <code>Git</code> 中的 <code>branch</code> 只是一个「引用」，所以删除 <code>branch</code> 的操作也只会删掉这个「引用」，并不会删除任何的 <code>commit(分支提交的内容)</code>。（不过如果一个 <code>commit</code> 不在任何一个 <code>branch</code> 的「路径」上，或者换句话说，如果没有任何一个 <code>branch</code> 可以回溯到这条 <code>commit</code>（也许可以称为野生 <code>commit</code>？），那么在一定时间后，它会被 <code>Git</code> 的回收机制删除掉。）</li>
<li>出于安全考虑，没有被合并到 <code>master</code> 的 <code>branch</code> 在删除时会失败<code>(前提是有新内容)</code>，这种情况如果你确认是要删除这个 <code>branch</code> （例如某个未完成的功能被团队确认永久毙掉了，不再做了），可以把 <code>-d</code> 改成 <code>-D</code>，小写换成大写，就能删除了。</li>
</ul>
<p><strong>「引用」的本质</strong></p>
<p>所谓「引用」（<code>reference</code>），其实就是一个个的字符串。这个字符串可以是一个 <code>commit</code> 的 <code>SHA-1</code> 码（例：<code>c08de9a4d8771144cd23986f9f76c4ed729e69b0</code>），也可以是一个 <code>branch</code>（例：<code>ref: refs/heads/feature3</code>）。拿到这个字符串，就知道当前引用指向谁。</p>
<p><code>Git</code> 中的 <code>HEAD</code> 和每一个 <code>branch</code> 以及其他的引用，都是以文本文件的形式存储在本地仓库 <code>.git</code> 目录中，而 <code>Git</code> 在工作的时候，就是通过这些文本文件的内容来判断这些所谓的「引用」是指向谁的。</p>
<h2 id="六-merge-合并"><a href="#六-merge-合并" class="headerlink" title="六  merge(合并)"></a>六  merge(合并)</h2><p><code>merge</code> 的意思是「合并」，它做的事也是合并：指定一个 <code>commit</code>，把它合并到当前的 <code>commit</code> 来。</p>
<p><strong>把目标 <code>commit</code> 的路径上的所有 <code>commit</code> 的内容一并应用到当前 <code>commit</code> （即 <code>HEAD</code> 所指向的 <code>commit</code>），然后自动生成一个新的 <code>commit</code>。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge &lt;目标分支名&gt;</span><br></pre></td></tr></table></figure>

<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul>
<li><p>合并分支</p>
<p>当一个 <code>branch</code> 的开发已经完成，需要把内容合并回去时，用 <code>merge</code> 来进行合并。</p>
</li>
<li><p><code>pull</code> 的内部操作</p>
<p><code>pull</code> 的实际操作其实是把远端仓库的内容用 <code>fetch</code> 取下来之后，用 <code>merge</code> 来合并。</p>
</li>
</ul>
<h3 id="特殊情况-1：冲突"><a href="#特殊情况-1：冲突" class="headerlink" title="特殊情况 1：冲突"></a>特殊情况 1：冲突</h3><p><code>merge</code> 在做合并的时候，是有一定的自动合并能力的：<br>如果一个分支改了 <code>A</code> 文件，另一个分支改了 <code>B</code> 文件，那么合并后就是既改 <code>A</code>也改 <code>B</code>，这个动作会自动完成；<br>如果两个分支都改了同一个文件，但一个改的是第 <code>1</code> 行，另一个改的是第 <code>2</code> 行，那么合并后就是第 <code>1</code> 行和第 <code>2</code> 行都改，也是自动完成。</p>
<p>但是，如果两个分支修改了同一部分内容，<code>merge</code> 的自动算法就搞不定了。这种情况 <code>Git</code> 称之为：冲突（<code>Conflict</code>）。</p>
<p>两个分支改了相同的内容，<code>Git</code> 不知道应该以哪个为准。如果在 <code>merge</code> 的时候发生了这种情况，<code>Git</code> 就会把问题交给你来决定。它会告诉你 <code>merge</code> 失败，以及失败的原因。</p>
<p>我再 <code>feature1</code> 分支 <code>mergeTest.txt</code> 文件第一行写了几个字，并 <code>commit</code> 提交，然后切换到 <code>master</code> 分支，这时 <code>mergeTest.txt</code> 文件是没东西的，又在第一行写了几个字，并 <code>commit</code> 提交，最后在 <code>master</code> 分支去合并 <code>feature1</code> 分支，提示如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git merge feature1</span><br><span class="line">Auto-merging mergeTest.txt</span><br><span class="line">CONFLICT (content): Merge conflict in mergeTest.txt</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure>

<p>提示信息中心说 <code>mergeTest.txt</code> 中出现合并冲突，自动合并失败，要求把冲突解决后再提交。意思就是需要<strong>先 解决冲突 ，然后手动 <code>commit</code> 一下</strong></p>
<h4 id="1-解决冲突"><a href="#1-解决冲突" class="headerlink" title="1.解决冲突"></a>1.解决冲突</h4><p>现在打开冲突的文件，会发现是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">烦烦烦</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">奥德赛</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1</span><br></pre></td></tr></table></figure>

<p><code>Git</code> 虽然没有帮你完成自动 <code>merge</code>，但它对文件还是做了一些工作：它把两个分支冲突的内容放在了一起，并用 <code>=======</code> 符号标记出了它们的边界以及它们的出处。</p>
<p><code>HEAD</code> 中的内容是 <code>烦烦烦</code>，而 <code>feature1</code> 中的内容则是 <code>奥德赛</code>。这两个改动 <code>Git</code> 不知道应该怎样合并，于是把它们放在一起，由你来决定。假设你决定保留 <code>HEAD</code> 的修改，那么只要删除掉 <code>feature1</code> 的修改，再把 Git 添加的那三行 <code>&lt;&lt;&lt;</code> <code>===</code> <code>&gt;&gt;&gt;</code> 辅助文字也删掉，保存文件退出，所谓的「解决掉冲突」就完成了。</p>
<p>修改后只能剩下需要的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">烦烦烦</span><br></pre></td></tr></table></figure>

<h4 id="2-提交"><a href="#2-提交" class="headerlink" title="2.提交"></a>2.提交</h4><p>解决完冲突以后，就可以进行第二步—— <code>commit</code> 了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add mergeTest.txt</span><br><span class="line">git commit</span><br></pre></td></tr></table></figure>

<p>被冲突中断的 <code>merge</code>，在手动 <code>commit</code> 的时候依然会自动填写提交信息。这是因为在发生冲突后，<code>Git</code> 仓库处于一个「<code>merge</code> 冲突待解决」的中间状态，在这种状态下 <code>commit</code>，<code>Git</code> 就会自动地帮你添加「这是一个 <code>merge commit</code>」的提交信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Merge branch &#39;feature1&#39; into master</span><br><span class="line"></span><br><span class="line"># Conflicts:</span><br><span class="line">#	mergeTest.txt</span><br></pre></td></tr></table></figure>

<h4 id="3-放弃解决冲突，取消-merge"><a href="#3-放弃解决冲突，取消-merge" class="headerlink" title="3.放弃解决冲突，取消 merge"></a>3.放弃解决冲突，取消 merge</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge --abort</span><br></pre></td></tr></table></figure>

<p>输入这行代码，你的 <code>Git</code> 仓库就会回到 <code>merge</code> 前的状态。</p>
<h3 id="特殊情况-2：HEAD-领先于目标-commit"><a href="#特殊情况-2：HEAD-领先于目标-commit" class="headerlink" title="特殊情况 2：HEAD 领先于目标 commit"></a>特殊情况 2：HEAD 领先于目标 commit</h3><p>如果 <code>merge</code> 时的目标 <code>commit</code> 和 <code>HEAD</code> 处的 <code>commit</code> 并不存在分叉，而是 <code>HEAD</code> 领先于目标 <code>commit</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1          2          3</span><br><span class="line">           ↑          ↑</span><br><span class="line">       feature1  HEAD&#x2F;master</span><br></pre></td></tr></table></figure>

<p>那么 <code>merge</code> 就没必要再创建一个新的 <code>commit</code> 来进行合并操作，因为并没有什么需要合并的。在这种情况下， <code>Git</code> 什么也不会做，<code>merge</code> 是一个空操作。</p>
<h3 id="特殊情况-3：HEAD-落后于目标-commit"><a href="#特殊情况-3：HEAD-落后于目标-commit" class="headerlink" title="特殊情况 3：HEAD 落后于目标 commit"></a>特殊情况 3：HEAD 落后于目标 commit</h3><p>这种又叫 <code>fast-forward</code></p>
<p>另一种情况：如果 <code>HEAD</code> 和目标 <code>commit</code> 依然是不存在分叉，但 <code>HEAD</code> 不是领先于目标 <code>commit</code>，而是落后于目标 <code>commit</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1          2          3          4</span><br><span class="line">                      ↑          ↑</span><br><span class="line">                 HEAD&#x2F;master   origin&#x2F;master</span><br></pre></td></tr></table></figure>

<p>那么 <code>Git</code> 会直接把 <code>HEAD</code> 移动到目标 <code>commit</code> </p>
<p>这种操作有一个专有称谓，叫做 <code>&quot;fast-forward&quot;</code>（快速前移）。</p>
<p>一般情况下，创建新的 <code>branch</code> 都是会和原 <code>branch</code> 并行开发的，不然没必要开 <code>branch</code> ，直接在原 <code>branch</code> 上开发就好。</p>
<p>但事实上，这种情形其实很常见，因为这其实是 <code>pull</code> 操作的一种经典情形：<strong>本地的 <code>master</code> 没有新提交，而远端仓库中有同事提交了新内容到 <code>master</code>。</strong><br>那么这时如果在本地执行一次 <code>pull</code> 操作，就会由于 <code>HEAD</code> 落后于目标 <code>commit</code> （也就是远端的 <code>master</code>）而造成 <code>&quot;fast-forward&quot;</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ git pull</span><br><span class="line">remote: Enumerating objects: 2, done.</span><br><span class="line">remote: Counting objects: 100% (2&#x2F;2), done.</span><br><span class="line">remote: Total 2 (delta 1), reused 2 (delta 1), pack-reused 0</span><br><span class="line">Unpacking objects: 100% (2&#x2F;2), done.</span><br><span class="line">From https:&#x2F;&#x2F;github.com&#x2F;CalmCenter&#x2F;UiStarge</span><br><span class="line">   195efe8..61213f7  master     -&gt; origin&#x2F;master</span><br><span class="line">Updating 195efe8..61213f7</span><br><span class="line">Fast-forward</span><br><span class="line"> branch1.txt   | 1 +</span><br><span class="line"> mergeTest.txt | 1 +</span><br><span class="line"> test1.txt     | 1 +</span><br><span class="line"> 3 files changed, 3 insertions(+)</span><br><span class="line"> create mode 100644 branch1.txt</span><br><span class="line"> create mode 100644 mergeTest.txt</span><br></pre></td></tr></table></figure>

<p>现在把 <code>git pull</code> 拆分执行：</p>
<p>第一步</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch</span><br></pre></td></tr></table></figure>

<p>下载远端仓库内容时，这两个镜像引用得到了更新，<code>origin/master</code> 和 <code>origin/HEAD</code> 移动到了最新的 <code>commit</code>。</p>
<p>在输入 <code>git log</code> 后你会发现找不到 <code>(origin/master, origin/HEAD)</code>  这个引用了，因为到更新到最新的 <code>commit</code> 了，这里只能打印当前 <code>commit</code>  以下的信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit 61213f7813ad116abdd498bd3575e7b4173b4c8e (HEAD -&gt; master)</span><br><span class="line">Merge: 195efe8 75aa327</span><br><span class="line">Author: Pc </span><br><span class="line">Date:   Wed Sep 23 14:32:33 2020 +0800</span><br><span class="line"></span><br><span class="line">    Merge branch &#39;feature2&#39;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>而 <code>git pull</code> 的第二步操作 <code>merge</code> 的目标 <code>commit</code> ，是远端仓库的 <code>HEAD</code>，也就是 <code>origin/HEAD</code> ，所以 <code>git pull</code> 的第二步的完整内容是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git merge origin&#x2F;HEAD</span><br><span class="line">Updating 61213f7..6c2bcc2</span><br><span class="line">Fast-forward</span><br><span class="line"> mergeTest.txt | 2 +-</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit 6c2bcc2a8ca9d872338d36df45dee8a95d900148 (HEAD -&gt; master, origin&#x2F;master, origin&#x2F;HEAD)</span><br><span class="line">Author: Pc</span><br><span class="line">Date:   Wed Sep 23 14:39:43 2020 +0800</span><br><span class="line"></span><br><span class="line">    test</span><br><span class="line"></span><br><span class="line">commit 61213f7813ad116abdd498bd3575e7b4173b4c8e</span><br><span class="line">Merge: 195efe8 75aa327</span><br><span class="line">Author: Pc </span><br><span class="line">Date:   Wed Sep 23 14:32:33 2020 +0800</span><br><span class="line"></span><br><span class="line">    Merge branch &#39;feature2&#39;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>因此 <code>HEAD</code> 就会带着 <code>master</code> 一起，也指向了最新 <code>commit</code> 。</p>
<p>如果不想用 <code>fast-forward</code> ，可以使用如下命令 <code>--no-ff：不使用 fast-forward 方式合并，保留分支的 commit 历史</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge --no-ff feature</span><br></pre></td></tr></table></figure>

<h2 id="七-Feature-Branch-最流行的工作流"><a href="#七-Feature-Branch-最流行的工作流" class="headerlink" title="七 Feature Branch(最流行的工作流)"></a>七 Feature Branch(最流行的工作流)</h2><p>目前最流行（不论是中国还是世界）的团队开发的工作流：<code>Feature Branch</code>。</p>
<p>这种工作流的核心内容可以总结为两点：</p>
<ol>
<li>任何新的功能（<code>feature</code>）或 <code>bug</code> 修复全都新建一个 <code>branch</code> 来写；</li>
<li><code>branch</code> 写完后，合并到 <code>master</code>，然后删掉这个 <code>branch</code>。</li>
</ol>
<p>这种工作流似乎没什么特别之处。但实质上，<code>Feature Branching</code> 这种工作流，为团队开发时两个关键的问题—— <strong>代码分享</strong> 和 <strong>一人多任务</strong> ——提供了解决方案。</p>
<h3 id="1-代码分享"><a href="#1-代码分享" class="headerlink" title="1.代码分享"></a>1.代码分享</h3><p>假设需要开发一个新功能，于是创建了一个新的 <code>branch</code> 叫做 <code>books</code>，然后开始在 <code>books</code> 上进行开发工作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b books</span><br></pre></td></tr></table></figure>

<p>在十几个 <code>commit</code> 过后，功能开发完毕，把代码 <code>push</code> 到中央仓库（例如 <code>GitHub</code>）去，然后告诉 <code>review</code> 的同事：「嘿，功能写完了，分支名是 <code>books</code>，谁有空的话帮我 <code>review</code> 一下吧。」</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin books</span><br></pre></td></tr></table></figure>

<p>然后负责 <code>review</code> 的同事就可以从中央仓库拉下来你的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br><span class="line">git chekcout books</span><br></pre></td></tr></table></figure>

<p>然后可以根据同事要求修改、更新，<code>review</code> 通过后，就可以合并到 <code>master</code> 上了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git pull </span><br><span class="line">git merge books</span><br></pre></td></tr></table></figure>

<p><code>merge</code> 之前 <code>pull</code> 一下，让 <code>master</code> 更新到和远程仓库同步</p>
<p>然后把合并后的结果 <code>push</code> 到了中央仓库，并删掉了 <code>books</code> 这个 <code>branch</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br><span class="line">git branch -d books</span><br><span class="line">git push origin -d books </span><br></pre></td></tr></table></figure>

<p><code>git push origin -d books</code> 用 <code>-d</code>参数把远程仓库的 <code>branch</code> 也删了</p>
<h3 id="2-Pull-Request"><a href="#2-Pull-Request" class="headerlink" title="2.Pull Request"></a>2.Pull Request</h3><p>上面这个流程，还可以利用 <code>Pull Request</code> 来进一步简化。</p>
<p><code>Pull Request</code> 并不是 <code>Git</code> 的内容，而是一些 Git 仓库服务提供方（例如 <code>GitHub</code>）所提供的一种便捷功能，它可以让团队的成员方便地讨论一个 <code>branch</code> ，并在讨论结束后一键合并这个 <code>branch</code> 到 <code>master</code>。</p>
<p>同样是把写好的 <code>branch</code> 给同事看，使用 <code>Pull Request</code> 的话可以这样：</p>
<p>首先创建一个 <code>pull request</code> </p>
<p>这是在 <code>push</code> 分支之后，会有一个这么个按钮快捷创建 <code>pull request</code>，但我现在试着不是每次都出~</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/git/git_pull_requests_7.png" alt=""></p>
<p>下面是正常创建流程。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/git/git_pull_requests_1.webp" alt=""></p>
<p>点击 <code>New pull request</code> 然后选择需要分享的分支，这里是 <code>feature2</code> ，选择后就可以看到修改内容，并且 <code>create pull request</code> 也可以点击了。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/git/git_pull_requests_2.webp" alt=""></p>
<p>这里需要写修改内容 <code>md</code> 格式的。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/git/git_pull_requests_4.webp" alt=""></p>
<p>然后你的同事就可以在 <code>GitHub</code> 上看到你创建的 <code>Pull Request</code> 了。他们可以在 <code>GitHub</code> 的这个页面查看你的 <code>commits</code>，也可以给你评论表示赞同或提意见，你接下来也可以根据他们的意见把新的 <code>commits</code>  <code>push</code> 上来，页面会随着你新的 <code>push</code> 而展示出最新的 <code>commits</code>。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/git/git_pull_requests_5.webp" alt=""></p>
<p>在讨论结束以后，认为这个 <code>branch</code> 可以合并了，只需要点一下页面中那个绿色的 <code>&quot;Merge pull request&quot;</code> 按钮，<code>GitHub</code> 就会自动地在中央仓库帮你把 <code>branch</code> 合并到 <code>master</code> 了。</p>
<p>然后你只要在本地 <code>pull</code> 一下，把最新的内容拉到你的电脑上，这件事情就算完成了。</p>
<p>另外，<code>GitHub</code> 还设计了一个贴心的 <code>&quot;Delete branch&quot;</code> 按钮，方便你在合并之后一键删除 <code>branch</code>。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/git/git_pull_requests_6.webp" alt=""></p>
<h3 id="3-一人多任务"><a href="#3-一人多任务" class="headerlink" title="3.一人多任务"></a>3.一人多任务</h3><p>除了代码分享的便捷，基于 <code>Feature Branch</code> 的工作流对于<strong>一人多任务</strong>的工作需求也提供了很好的支持。</p>
<p>安安心心做事不被打扰，做完一件再做下一件自然是很美好的事，但现实往往不能这样。对于程序员来说，一种很常见的情况是，你正在认真写着代码，忽然紧急需要新填另外一个功能！</p>
<p>其实，虽然这种情况确实有点烦，但如果你是在独立的 <code>branch</code> 上做事，切换任务是很简单的。你只要稍微把目前未提交的代码简单收尾一下，然后做一个带有「未完成」标记的提交（例如，在提交信息里标上<code>「TODO」</code>），然后回到 <code>master</code> 去创建一个新的 <code>branch</code> 就好了。</p>
<p>如果有一天需要回来继续做这个 <code>branch</code>，你只要用 <code>checkout</code> 切回来，就可以继续了。</p>
<h2 id="八-rebase（变基）"><a href="#八-rebase（变基）" class="headerlink" title="八 rebase（变基）"></a>八 rebase（变基）</h2><p><code>rebase</code> ，又是一个中国人看不懂的词。这个词的意思，你如果查一下的话是 <code>变基</code>  (〃’▽’〃)    。 不忍直视 ~ (<em>/ω＼</em>)</p>
<p>其实这个翻译还是比较准确的。<code>rebase</code> 的意思是，给你的 <code>commit</code> 序列重新设置基础点（也就是父 <code>commit</code>）。展开来说就是，把你指定的 <code>commit</code> 以及它所在的 <code>commit</code> 串，以指定的目标 <code>commit</code> 为基础，依次重新提交一次。</p>
<p>一般情况下是在子分支去 <code>rebase</code> 主分支</p>
<h3 id="1-rebase-和-merge-的区别"><a href="#1-rebase-和-merge-的区别" class="headerlink" title="1. rebase 和 merge 的区别"></a>1. <code>rebase</code> 和 <code>merge</code> 的区别</h3><p>先看一下 <code>rebase</code> 的情况。</p>
<p>当前分支情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">                      master</span><br><span class="line">                        ↓</span><br><span class="line">1   →   2   →   3   →   4      </span><br><span class="line">          ↘</span><br><span class="line">             ↘</span><br><span class="line">                5   →   6</span><br><span class="line">                        ↑</span><br><span class="line">                     feature2</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout feature2</span><br><span class="line">git rebase master</span><br></pre></td></tr></table></figure>

<p>执行完后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">                      master         feature2</span><br><span class="line">                        ↓               ↓</span><br><span class="line">1   →   2   →   3   →   4   →   7   →   8      </span><br><span class="line">          ↘</span><br><span class="line">             ↘</span><br><span class="line">                5   →   6</span><br><span class="line">                       </span><br></pre></td></tr></table></figure>

<p>通过 <code>rebase</code>，<code>feature2</code> 把基础点从 <code>2</code> 换成了 <code>4</code> ，<code>feature2</code> 中的 <code>5</code> 和 <code>6</code> 两条 <code>commit</code> 也 变成了新的 <code>commit</code>  <code>7</code> 和 <code>8</code> ，但是内容是没有变的。<br>通过这样的方式，就让本来分叉了的提交历史重新回到了一条线。这种「重新设置基础点」的操作，就是 <code>rebase</code> 的含义。</p>
<p>更直观一点：</p>
<p>这是 <code>sourTree</code> 的历史日志，<code>feature2</code> 当前的在 <code>delete branch</code> 这个 <code>commit</code> 的基础下，更改了一些内容，并且当前 <code>master</code> 也有了新的更新，现在需要把 <code>master</code> 的内容合并到 <code>feature2</code> 上</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/git/git_log_2.png" alt=""></p>
<p>使用 <code>rebase</code> 合并后</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/git/git_log.png" alt=""></p>
<p><code>feature2</code> 的基准点变了，成了当前 <code>master</code> 指向的 <code>commit</code> ，并且他们的提交历史变成了一条直线。</p>
<p>那 <code>merge</code> 呢？</p>
<p><code>feature2</code> 当前的在 <code>branch 更新</code> 这个 <code>commit</code> 的基础下，更改了一些内容，并且当前 <code>master</code> 也有了新的更新，现在需要把 <code>master</code> 的内容合并到 <code>feature2</code> 上</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/git/git_log_3.png" alt=""></p>
<p>使用 <code>merge</code> 合并后</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/git/git_log_4.png" alt=""></p>
<p>这里可以明显的看到，多了一个 <code>commit</code> ，并且提交历史也是分叉的，如果分支多的情况下，会很乱的！</p>
<blockquote>
<p>现在，基本明白了 <code>rebase</code> 的作用，可以减少 <code>commit</code> 的数量以及减少分叉数量，使得提交历史干净整洁。</p>
</blockquote>
<p>当然这只是其中一部分作用。</p>
<h3 id="2-rebase-时出现了冲突怎么办？"><a href="#2-rebase-时出现了冲突怎么办？" class="headerlink" title="2.rebase 时出现了冲突怎么办？"></a>2.<code>rebase</code> 时出现了冲突怎么办？</h3><p>如果出现了冲突，在 <code>git</code> 页面中会出现 <code>REBASE 1/1</code> 。 <code>merge</code> 冲突时也会出现类似的提示，解决办法相同，把 <code>rebase</code> 改成 <code>merge</code> 即可。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/git/git_rebase_conflict.png" alt=""></p>
<p>需要手动解决，解决完后，用 <code>git add .</code> 或者某个文件名，来标记已解决，最后执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase --continue</span><br></pre></td></tr></table></figure>

<p>继续执行 <code>rebase</code> 完成变基。</p>
<p>如果想回到 <code>rebase</code> 执行之前的状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase --abort</span><br></pre></td></tr></table></figure>

<h3 id="3-使用-rebase-需要注意什么？"><a href="#3-使用-rebase-需要注意什么？" class="headerlink" title="3. 使用 rebase 需要注意什么？"></a>3. 使用 <code>rebase</code> 需要注意什么？</h3><p><code>rebase</code> 在为理解透彻之前，是不能随便使用的！</p>
<p>但是，有一个黄金定律，只要满足，就可以安全使用，并且比 <code>merge</code> 要好用很多。</p>
<blockquote>
<p><strong>只要你的分支上需要 <code>rebase</code> 的所有 <code>commits</code> 历史还没有被 <code>push</code> 过，就可以安全地使用 <code>git rebase</code> 来操作。</strong></p>
</blockquote>
<p>也就是说永远不要 <code>rebase</code> 一个已经在中央库中存在的 <code>commit</code> ，只能 <code>rebase</code> 你自己使用的私有 <code>commit</code>。</p>
<p>那 <code>rebase</code> 了一个已经 <code>push</code> 过的 <code>commit</code> 会怎么办呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">                      master</span><br><span class="line">                        ↓</span><br><span class="line">1   →   2   →   3   →   4      </span><br><span class="line">          ↘</span><br><span class="line">             ↘</span><br><span class="line">                5   →   6</span><br><span class="line">                ↑       ↑</span><br><span class="line">    origin&#x2F;feature2  feature2 </span><br><span class="line">                     </span><br></pre></td></tr></table></figure>

<p>还是这张图，假设 <code>5</code> 已经被 <code>push</code> 到远程，现在 <code>rebase</code> 到 <code>master</code> 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">                      master         feature2</span><br><span class="line">                        ↓               ↓</span><br><span class="line">1   →   2   →   3   →   4   →   7   →   8      </span><br><span class="line">          ↘</span><br><span class="line">             ↘</span><br><span class="line">                5   →   6</span><br><span class="line">                ↑</span><br><span class="line">         origin&#x2F;feature2</span><br></pre></td></tr></table></figure>

<p>现在看着没什么问题，但是你查看远程时，发现 <code>5</code> 那个 <code>commit</code> 是可以 <code>pull</code> 下来的。因为本地的 <code>5</code> 已经变成了新的  <code>commit 7</code> ，本地已经没有 <code>5</code> 的记录了，但是远程有。</p>
<p>如果你在 <code>5</code> 的时候添加的一些文件并 <code>push</code> 到了远程，在 <code>6</code> 的时候删除了那些文件，执行 <code>rebase</code> 后你是可以 <code>pull</code> 的， <code>pull</code> 远程后，你会发现那些删除的文件又回来了！</p>
<p>这里这种问题，可以通过下面的命令，强制提交，不需要 <code>pull</code> 而是直接覆盖中央仓库的历史。(<code>--force</code>)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -f</span><br></pre></td></tr></table></figure>

<p>这只是本人亲身经历过的一种情况，所以一定要遵循 <code>rebase 黄金定律</code> 。</p>
<h3 id="4-交互式-rebase-i"><a href="#4-交互式-rebase-i" class="headerlink" title="4.交互式 rebase -i"></a>4.交互式 <code>rebase -i</code></h3><h4 id="偏移符号"><a href="#偏移符号" class="headerlink" title="偏移符号"></a>偏移符号</h4><p>在了解交互式 <code>rebase -i</code> 之前，先了解下偏移符号。</p>
<p>说明：在 <code>Git</code> 中，有两个「偏移符号」： <code>^</code> 和 <code>~</code>。</p>
<p><code>^</code> 的用法：在 <code>commit</code> 的后面加一个或多个 <code>^</code> 号，可以把 <code>commit</code> 往回偏移，偏移的数量是 <code>^</code> 的数量。例如：<code>master^</code> 表示 <code>master</code> 指向的 <code>commit</code> 之前的那个 <code>commit</code>； <code>HEAD^^</code> 表示 <code>HEAD</code> 所指向的 <code>commit</code> 往前数两个 <code>commit</code>。</p>
<p><code>~</code> 的用法：在 <code>commit</code> 的后面加上 <code>~</code> 号和一个数，可以把 <code>commit</code> 往回偏移，偏移的数量是 <code>~</code> 号后面的数。例如：<code>HEAD~5</code> 表示 <code>HEAD</code> 指向的 <code>commit</code>往前数 5 个 <code>commit</code>。</p>
<p>下面详细说明。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git log --oneline --graph --all</span><br><span class="line">*   1699603 (HEAD -&gt; master) Merge branch &#39;feature2&#39;</span><br><span class="line">|\</span><br><span class="line">| * 2b21ec9 (feature2) feature2 第二次提交</span><br><span class="line">| * 2fb7de8 feature2 第一次提交</span><br><span class="line">* | 528eb23 (feature1) feature1 第二次提交</span><br><span class="line">* | d4faecf feature1 第一次提交</span><br><span class="line">|&#x2F;</span><br><span class="line">* 9001713 (origin&#x2F;master, origin&#x2F;feature2, origin&#x2F;feature1, origin&#x2F;HEAD) 第二次添加</span><br></pre></td></tr></table></figure>

<p>先看一下 <code>~</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git show --oneline HEAD~1</span><br><span class="line">528eb23 (feature1) feature1 第二次提交</span><br><span class="line"></span><br><span class="line">$ git show --oneline HEAD~2</span><br><span class="line">d4faecf feature1 第一次提交</span><br><span class="line"></span><br><span class="line">$ git show --oneline HEAD~3</span><br><span class="line">9001713 (origin&#x2F;master, origin&#x2F;feature2, origin&#x2F;feature1, origin&#x2F;HEAD) 第二次添加</span><br></pre></td></tr></table></figure>

<p>然后看 <code>^</code> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git show --oneline HEAD^</span><br><span class="line">528eb23 (feature1) feature1 第二次提交</span><br><span class="line"></span><br><span class="line">$ git show --oneline HEAD^^</span><br><span class="line">d4faecf feature1 第一次提交</span><br><span class="line"></span><br><span class="line">$ git show --oneline HEAD^^^</span><br><span class="line">9001713 (origin&#x2F;master, origin&#x2F;feature2, origin&#x2F;feature1, origin&#x2F;HEAD) 第二次添加</span><br></pre></td></tr></table></figure>

<p>可以看到这里并没有打印到 <code>feature2</code> 的提交，那如何就可以打印了呢？</p>
<p>切换分支 ~ </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git show --oneline HEAD^2</span><br><span class="line">2b21ec9 (feature2) feature2 第二次提交</span><br><span class="line"></span><br><span class="line">$ git show --oneline HEAD^2^</span><br><span class="line">2fb7de8 feature2 第一次提交</span><br><span class="line"></span><br><span class="line">$ git show --oneline HEAD^2~1</span><br><span class="line">2fb7de8 feature2 第一次提交</span><br></pre></td></tr></table></figure>

<p><code>^2</code> 这里没有偏移，只是切换分支。当然，还可以切换引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git show --oneline feature2^</span><br><span class="line">2fb7de8 feature2 第一次提交</span><br></pre></td></tr></table></figure>

<p>总结</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 当前提交</span><br><span class="line">HEAD &#x3D; HEAD~0 &#x3D; HEAD^0</span><br><span class="line"></span><br><span class="line"># 主线回溯(最靠左边的即为主线)</span><br><span class="line">HEAD~1 &#x3D; HEAD^ 主线的上一次提交</span><br><span class="line">HEAD~2 &#x3D; HEAD^^ 主线的上二次提交</span><br><span class="line">HEAD~3 &#x3D; HEAD^^^ 主线的上三次提交</span><br><span class="line"></span><br><span class="line"># 如果某个节点有其他分支并入</span><br><span class="line">HEAD^1 主线提交（第一个父提交）</span><br><span class="line">HEAD^2 切换到了第2个并入的分支并得到最近一次的提交</span><br><span class="line">HEAD^2~3 切换到了第2个并入的分支并得到最近第 4 次的提交</span><br><span class="line">HEAD^3~2 切换到了第3个并入的分支并得到最近第 3 次的提交</span><br><span class="line"></span><br><span class="line"># ^&#123;n&#125; 和 ^ 重复 n 次的区别 </span><br><span class="line">HEAD~1 &#x3D; HEAD^</span><br><span class="line">HEAD~2 &#x3D; HEAD^^</span><br><span class="line">HEAD~3 &#x3D; HEAD^^^</span><br><span class="line"></span><br><span class="line"># 切换父级</span><br><span class="line">HEAD^1~3 &#x3D; HEAD~4 </span><br><span class="line">HEAD^2~3 &#x3D; HEAD^2^^^</span><br><span class="line">HEAD^3~3 &#x3D; HEAD^3^^^</span><br></pre></td></tr></table></figure>

<h4 id="修改之前的-commit"><a href="#修改之前的-commit" class="headerlink" title="修改之前的 commit"></a>修改之前的 <code>commit</code></h4><p>之前讲过 <code>git commit -—amend</code> 可以 修复/替换 最新 <code>commit</code> 的错误，那倒数第二个，第三个 <code>commit</code> 需要修改怎么办呢？</p>
<p>那就需要用到 <code>rebase -i</code> 了，它是 <code>rebase --interactive</code> 的缩写形式，意为「交互式 <code>rebase</code>」。</p>
<p>所谓「交互式 <code>rebase</code>」，就是在 <code>rebase</code> 的操作执行之前，你可以指定要 <code>rebase</code> 的 <code>commit</code> 链中的每一个 <code>commit</code> 是否需要进一步修改。</p>
<p>当前我提交了几个 <code>commit</code> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">*   1699603 (HEAD -&gt; master) Merge branch &#39;feature2&#39;</span><br><span class="line">|\</span><br><span class="line">| * 2b21ec9 (feature2) feature2 第二次提交</span><br><span class="line">| * 2fb7de8 feature2 第一次提交</span><br><span class="line">* | 528eb23 (feature1) feature1 第二次提交</span><br><span class="line">* | d4faecf feature1 第一次提交</span><br><span class="line">|&#x2F;</span><br><span class="line">*</span><br></pre></td></tr></table></figure>

<p>但是我发现在 <code>feature1 第二次提交</code> 的 <code>commit</code> 中需要修改一些内容，这时使用 <code>commit --amend</code> 已经晚了。我们需要使用下面的命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i HEAD^^</span><br></pre></td></tr></table></figure>

<p>会进入编辑界面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">pick 528eb23 feature1 第二次提交</span><br><span class="line">pick 2fb7de8 feature2 第一次提交</span><br><span class="line">pick 2b21ec9 feature2 第二次提交</span><br><span class="line"></span><br><span class="line"># Rebase d4faecf..5b7f84f onto d4faecf (3 commands)</span><br><span class="line">#</span><br><span class="line"># Commands:</span><br><span class="line"># p, pick &lt;commit&gt; &#x3D; use commit</span><br><span class="line"># r, reword &lt;commit&gt; &#x3D; use commit, but edit the commit message</span><br><span class="line"># e, edit &lt;commit&gt; &#x3D; use commit, but stop for amending</span><br><span class="line"># s, squash &lt;commit&gt; &#x3D; use commit, but meld into previous commit</span><br><span class="line"># f, fixup &lt;commit&gt; &#x3D; like &quot;squash&quot;, but discard this commit&#39;s log message</span><br><span class="line"># x, exec &lt;command&gt; &#x3D; run command (the rest of the line) using shell</span><br><span class="line"># b, break &#x3D; stop here (continue rebase later with &#39;git rebase --continue&#39;)</span><br><span class="line"># d, drop &lt;commit&gt; &#x3D; remove commit</span><br><span class="line"># l, label &lt;label&gt; &#x3D; label current HEAD with a name</span><br><span class="line"># t, reset &lt;label&gt; &#x3D; reset HEAD to a label</span><br><span class="line"># m, merge [-C &lt;commit&gt; | -c &lt;commit&gt;] &lt;label&gt; [# &lt;oneline&gt;]</span><br><span class="line"># .       create a merge commit using the original merge commit&#39;s</span><br><span class="line"># .       message (or the oneline, if no original merge commit was</span><br><span class="line"># .       specified). Use -c &lt;commit&gt; to reword the commit message.</span><br><span class="line">#</span><br><span class="line"># These lines can be re-ordered; they are executed from top to bottom.</span><br><span class="line">#</span><br><span class="line"># If you remove a line here THAT COMMIT WILL BE LOST.</span><br></pre></td></tr></table></figure>

<p>这里可以看到， <code>rebase -i HEAD^^</code> 和我们之前讲的 <code>git show --oneline HEAD^^</code> 预期是不一样的。</p>
<p>为什么不一样呢？</p>
<p><code>rebase -i HEAD^^</code> 表示列出倒数第三个 <code>commit</code> 之前的提交记录，<strong>不包括倒数第三个</strong>。</p>
<p><code>git show --oneline HEAD^^</code> 表示显示倒数第三个 <code>commit</code> 的记录。</p>
<p>又因为这里用了 <code>merge</code> ，在 <code>rebase -i HEAD^</code> 时，会列出 <code>merge</code> 操作中合并的所有 <code>commit</code> ，这里正好 <code>merge</code> 了两个 <code>commit</code>，<br>所以第一个 <code>^</code> 会列出主线倒数第一个 <code>commit</code>，但是这个 <code>commit</code> 是个 <code>merge</code> 操作，然后就去寻找 <code>merge</code> 了那些 <code>commit</code> 并列出 ，第二个 <code>^</code> 是主线倒数第二个 <code>commit</code>。</p>
<p>这个编辑界面的最顶部，列出了将要「被 <code>rebase</code>」的所有 <code>commit</code> 。需要注意，这个排列是正序的，旧的 <code>commit</code> 会排在上面，新的排在下面。</p>
<p>这两行指示了两个信息：</p>
<ol>
<li>需要处理哪些 <code>commit</code>；</li>
<li>怎么处理它们。</li>
</ol>
<p>每个 <code>commit</code> 默认的操作都是 <code>pick</code> ，表示「直接应用这个 <code>commit</code>」。如果直接退出的话，那么这次就是一次空操作。</p>
<p>各个操作的意思：</p>
<ol>
<li><code>pick</code>：直接应用这个 <code>commit</code> </li>
<li><code>reword</code>：使用此 <code>commit</code>， 编辑 <code>commit message</code>，<code>message</code> 就是 <code>commit -m</code> 命令后面写到说明，下同。</li>
<li><code>edit</code>：使用此 <code>commit</code>，但是不编辑 <code>commit message</code>，保持原有 <code>commit message</code> </li>
<li><code>squash</code>：使用此 <code>commit</code>，但是合并到前一个 <code>commit</code> 中去 </li>
<li><code>fixup</code>： 和 <code>squash</code> 类似，但是放弃此 <code>commit</code> 的 <code>message</code> </li>
<li><code>drop</code>：删除 <code>commit</code></li>
<li>其余的没用过 ~ </li>
</ol>
<p>点击 <code>i</code> 键进行编辑。我们的目的是修改 <code>feature1 第二次提交</code> ，我们需要把那一行的 <code>pick</code> 改成 <code>edit</code> 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">edit 528eb23 feature1 第二次提交</span><br><span class="line">pick 2fb7de8 feature2 第一次提交</span><br><span class="line">pick 2b21ec9 feature2 第二次提交</span><br></pre></td></tr></table></figure>

<p>修改完后，按 <code>esc</code> 然后 <code>:wq</code> 这是三个按键依次按，之前我也不懂，但是学习 <code>linux</code> 之后就懂了 ~ 保存退出的意思 ~</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase -i HEAD^^</span><br><span class="line">Stopped at 528eb23...  feature1 第二次提交</span><br><span class="line">You can amend the commit now, with</span><br><span class="line"></span><br><span class="line">  git commit --amend</span><br><span class="line"></span><br><span class="line">Once you are satisfied with your changes, run</span><br><span class="line"></span><br><span class="line">  git rebase --continue</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上图的提示信息说明，<code>rebase</code> 过程已经停在了第二个 <code>commit</code> 的位置，那么现在可以去修改想修改的内容了。</p>
<p>修改完成之后，用 <code>commit --amend</code> 来把修正应用到当前最新的 <code>commit</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit --amend</span><br></pre></td></tr></table></figure>

<p>在修复完成之后，就可以用 <code>rebase --continue</code> 来继续 <code>rebase</code> 过程，把后面的 <code>commit</code> 直接应用上去。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase --continue</span><br></pre></td></tr></table></figure>

<p>这里可能出现冲突，解决办法之前讲过 ~</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ git log --oneline</span><br><span class="line">2d77504 (HEAD -&gt; master) feature2 第二次提交</span><br><span class="line">82d685f feature2 第一次提交</span><br><span class="line">5729656 feature1 第二次提交</span><br><span class="line">d4faecf feature1 第一次提交</span><br><span class="line"></span><br><span class="line">$ git log --oneline --graph --all</span><br><span class="line">* 2d77504 (HEAD -&gt; master) feature2 第二次提交</span><br><span class="line">* 82d685f feature2 第一次提交</span><br><span class="line">* 5729656 feature1 第二次提交</span><br><span class="line">| * 2b21ec9 (feature2) feature2 第二次提交</span><br><span class="line">| * 2fb7de8 feature2 第一次提交</span><br><span class="line">| | * 528eb23 (feature1) feature1 第二次提交</span><br><span class="line">| |&#x2F;</span><br><span class="line">|&#x2F;|</span><br><span class="line">* | d4faecf feature1 第一次提交</span><br><span class="line">|&#x2F;</span><br><span class="line">* 9001713 (origin&#x2F;master, origin&#x2F;feature2, origin&#x2F;feature1, origin&#x2F;HEAD) 第二次添加</span><br></pre></td></tr></table></figure>

<p>再次查看，<code>log</code> 发现后三个 <code>commit</code> 的 <code>SHA-1</code> 值都变了，说明是新的 <code>commit</code> 。查看图表会更明确一点，之前的 <code>commit</code> 都还在但是 <code>merge</code> 的那个 <code>commit</code> 不见了，子分支的 <code>commit</code> 的内容，都在主分支都复制了一份，说明使用 <code>rebase -i</code> 不仅可以执行我们制定的操作，还会重新组织历史记录合并在一条主线上，然后清理无用的 <code>commit</code> 。</p>
<h4 id="删除之前的-commit"><a href="#删除之前的-commit" class="headerlink" title="删除之前的 commit"></a>删除之前的 <code>commit</code></h4><p>和修改的炒作类似，只是在编辑的时候删除我们需要删除的那个 <code>commit</code> 即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pick 528eb23 feature1 第二次提交</span><br><span class="line">pick 2fb7de8 feature2 第一次提交</span><br><span class="line">pick 2b21ec9 feature2 第二次提交</span><br></pre></td></tr></table></figure>

<p>删掉 <code>feature1 第二次提交</code>，或者将 <code>pick</code> 改为 <code>drop</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pick 2fb7de8 feature2 第一次提交</span><br><span class="line">pick 2b21ec9 feature2 第二次提交</span><br></pre></td></tr></table></figure>

<p>如果把这一行删掉，那就相当于在 <code>rebase</code> 的过程中跳过了这个 <code>commit</code>，从而也就把这个 <code>commit</code> 撤销掉了。</p>
<p>那这两种操作有什么不同呢？ <code>emmm….</code> 表面上也没啥区别，具体实质性的却别就不清楚了 ~<br><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/35846154/git-rebase-interactive-drop-vs-deleting-the-commit-line">Git rebase interactive drop vs deleting the commit line</a></p>
<p>剩下的操作和上面一样。</p>
<h3 id="5-rebase-–onto"><a href="#5-rebase-–onto" class="headerlink" title="5. rebase –onto"></a>5. <code>rebase –onto</code></h3><p>我们之前讲过 <code>git rebase master</code> ，<code>rebase</code> 的「起点」是自动判定的：选取当前 <code>commit</code>  和目标 <code>commit</code> 在历史上的交叉点作为起点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">                      master</span><br><span class="line">                        ↓</span><br><span class="line">1   →   2   →   3   →   4      </span><br><span class="line">          ↘</span><br><span class="line">             ↘</span><br><span class="line">                5   →   6</span><br><span class="line">                        ↑</span><br><span class="line">                    HEAD&#x2F;feature2</span><br></pre></td></tr></table></figure>

<p>比如这里执行  <code>git rebase master</code> ，那么 <code>Git</code> 会自动选取 <code>4</code> 和 <code>6</code> 的历史交叉点 <code>2</code> 作为 <code>rebase</code> 的起点，依次将 <code>5</code> 和 <code>6</code> 重新提交到 <code>4</code> 的路径上去。</p>
<p>而 <code>--onto</code> 参数，就可以额外给 <code>rebase</code> 指定它的起点。例如同样以上图为例，如果我只想把 <code>6</code> 提交到 <code>4</code> 上，不想附带上 <code>5</code>，那么我可以执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase --onto 4(commit) 5(commit) feature2</span><br></pre></td></tr></table></figure>

<p><code>--onto</code> 参数后面有三个附加参数：目标 <code>commit</code>、起点 <code>commit</code>（注意：<code>rebase</code> 的时候会把起点排除在外）、终点 <code>commit</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">                      master HEAD&#x2F;feature2</span><br><span class="line">                        ↓       ↓</span><br><span class="line">1   →   2   →   3   →   4   →   7(6的内容)</span><br><span class="line">          ↘</span><br><span class="line">             ↘</span><br><span class="line">                5   →   6</span><br></pre></td></tr></table></figure>

<p>还可以撤销提交：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git log --oneline --graph --all</span><br><span class="line">* 0b6cb82 (HEAD -&gt; feature2) add</span><br><span class="line">* b8b5146 add new File</span><br><span class="line">* 8b2c2f7 new File</span><br><span class="line">* e657879 rebase</span><br><span class="line">* 99854db feature</span><br></pre></td></tr></table></figure>

<p>这是生成的一点测试记录，执行下面的命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase --onto HEAD^^^ HEAD^ feature2</span><br></pre></td></tr></table></figure>

<p>上面的意思为，以倒数第二个 <code>commit</code> 为起点（不包括起点），<code>feature2</code> 指向的 <code>commit</code> 为终点，<code>rebase</code> 到倒数第四个 <code>commit</code> 上， 结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git log --oneline --graph --all</span><br><span class="line">* 3a10357 (HEAD -&gt; feature2) add</span><br><span class="line">* e657879 rebase</span><br><span class="line">* 99854db feature</span><br></pre></td></tr></table></figure>

<p><code>HEAD^^^</code> 目标 <code>commit</code> 之后的 <code>commit</code> 都会被清除掉，起点（<code>HEAD^</code>） 到 终点（<code>feature2</code>） 之间的 <code>commit</code> （不包括 起点<code>HEAD^</code> 本身），会提前复制出一份生成新的 <code>commit</code>，最后连接到目标 <code>commit</code> 后面。<br>相当于 目标（<code>HEAD^^^</code>） 到 起点（<code>HEAD^</code>） 之间的 <code>commit</code> 都会被删除，不包括目标 <code>commit</code> ，包括起点 <code>commit</code> 。</p>
<h2 id="九-reset（重置）"><a href="#九-reset（重置）" class="headerlink" title="九 reset（重置）"></a>九 reset（重置）</h2><p><code>reset</code> 的本质：移动 <code>HEAD</code> 以及它所指向的 <code>branch</code></p>
<p>这样就可以起到撤销某个 <code>commit</code> 的作用 ，不是删除，只要记下 <code>SHA-1</code> 还可以再撤回来 ~</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br></pre></td></tr></table></figure>

<p>偏移符号之前讲过，如果移动后想回往回移动，但是已经没有了 <code>SHA-1</code>，可以使用 <code>git reflog</code> 来查看操作记录。</p>
<blockquote>
<p>Git 的历史只能往回看，不能向未来看，所以把 <code>HEAD</code> 和 <code>branch</code> 往回移动，就能起到撤回 <code>commit</code> 的效果。</p>
</blockquote>
<p>所以同理，<code>reset --hard</code> 不仅可以撤销提交，还可以用来把 <code>HEAD</code> 和 <code>branch</code> 移动到其他的任何地方。</p>
<h3 id="reset-–hard：重置工作目录"><a href="#reset-–hard：重置工作目录" class="headerlink" title="reset –hard：重置工作目录"></a>reset –hard：重置工作目录</h3><p><code>reset --hard</code> 会在重置 <code>HEAD</code> 和 <code>branch</code> 的同时，重置工作目录里的内容。当你在 <code>reset</code> 后面加了 <code>--hard</code> 参数时，你的工作目录里的内容会被完全重置为和 <code>HEAD</code> 的新位置相同的内容。换句话说，就是<strong>未提交（<code>commit</code>）的修改会被全部擦除，不管它们是否被放进暂存区。添加到暂存区的新增也会被擦除，但是没有添加到缓存区的新增不会！</strong> </p>
<p><code>modifiedFile.txt</code> 和 <code>addModifiedFile.txt</code> 是当前 <code>commit</code> 新增的（证明已经 <code>commit</code> 上去了），<br>然后修改 <code>addModifiedFile.txt</code> 文件并添加缓存区，然后修改 <code>modifiedFile.txt</code> 文件，不添加到缓存区。这里表示<strong>修改操作</strong>添加暂存区和不添加暂存区的情况。<br>添加 <code>newFile.txt</code> 和 <code>addNewFile.txt</code> 并把   <code>addNewFile.txt</code> 添加到缓存区。这里表示<strong>新增操作</strong>添加暂存区和不添加暂存区的情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch feature2</span><br><span class="line">Your branch and &#39;origin&#x2F;feature2&#39; have diverged,</span><br><span class="line">and have 1 and 2 different commits each, respectively.</span><br><span class="line">  (use &quot;git pull&quot; to merge the remote branch into yours)</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">        new file:   addNewFile.txt</span><br><span class="line">        modified:   addModifiedFile.txt</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">        modified:   modifiedFile.txt</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line"></span><br><span class="line">        newFile.txt</span><br></pre></td></tr></table></figure>

<p>然后执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br></pre></td></tr></table></figure>

<p>工作目录里的新改动也一起全都消失了，不管它们是否被放进暂存区<br>只有没有添加到缓冲区新创建的文件，不会清除，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch feature2</span><br><span class="line">Your branch is behind &#39;origin&#x2F;feature2&#39; by 2 commits, and can be fast-forwarded.</span><br><span class="line">  (use &quot;git pull&quot; to update your local branch)</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line"></span><br><span class="line">        newFile.txt</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>只留下了<strong>新创建的并且没有添加缓存区</strong>的 <code>addHard</code> 文件。其他的修改和添加都被清除了。</p>
<h3 id="reset-–soft：保留工作目录"><a href="#reset-–soft：保留工作目录" class="headerlink" title="reset –soft：保留工作目录"></a>reset –soft：保留工作目录</h3><p><code>reset --soft</code> 会在重置 <code>HEAD</code> 和 <code>branch</code> 时，保留工作目录和暂存区中的内容，<strong>并把重置 <code>HEAD</code> 所带来的新的差异</strong>放进暂存区。</p>
<p>「重置 <code>HEAD</code> 所带来的新的差异」 就是当前 <code>HEAD</code> 与 <code>reset</code> 目标之间的 <code>commit</code> 提交的文件。</p>
<p>初始文件状态和上面一样。</p>
<p>执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --soft HEAD^</span><br></pre></td></tr></table></figure>

<p>重点观看 <code>hard.txt</code> 和 <code>reset.txt</code> ，它俩被重新添加到暂存区，并且标记 <code>new file</code> 。这两个文件就是两个 <code>commit</code> 的差异。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch feature2</span><br><span class="line">Your branch is behind &#39;origin&#x2F;feature2&#39; by 2 commits, and can be fast-forwarded.</span><br><span class="line">  (use &quot;git pull&quot; to update your local branch)</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">        new file:   addModifiedFile.txt</span><br><span class="line">        new file:   addNewFile.txt</span><br><span class="line">        new file:   modifiedFile.txt</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">        modified:   modifiedFile.txt</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line"></span><br><span class="line">        newFile.txt</span><br></pre></td></tr></table></figure>

<p>这就是 <code>--soft</code> 和 <code>--hard</code> 的区别：<code>--hard</code> 会清空暂存目录的改动和新增，以及工作目录的改动，而 <code>--soft</code> 则会保留工作目录的内容，并把因为保留工作目录内容所带来的新的文件差异放进暂存区。</p>
<h3 id="reset-不加参数：保留工作目录，并清空暂存区（–mixed）"><a href="#reset-不加参数：保留工作目录，并清空暂存区（–mixed）" class="headerlink" title="reset 不加参数：保留工作目录，并清空暂存区（–mixed）"></a>reset 不加参数：保留工作目录，并清空暂存区（–mixed）</h3><p><code>reset</code> 如果不加参数，那么默认使用 <code>--mixed</code> 参数。它的行为是：保留工作目录，并且清空暂存区。</p>
<p>初始文件状态和上面一样。</p>
<p>执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD^</span><br></pre></td></tr></table></figure>

<p>将差异文件、暂存目录的文件、工作目录的文件都保存了下来，但是都放在了工作目录。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch feature2</span><br><span class="line">Your branch is behind &#39;origin&#x2F;feature2&#39; by 2 commits, and can be fast-forwarded.</span><br><span class="line">  (use &quot;git pull&quot; to update your local branch)</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line"></span><br><span class="line">        addModifiedFile.txt</span><br><span class="line">        addNewFile.txt</span><br><span class="line">        modifiedFile.txt</span><br><span class="line">        newFile.txt</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br></pre></td></tr></table></figure>

<h2 id="十-stash（临时存储）"><a href="#十-stash（临时存储）" class="headerlink" title="十 stash（临时存储）"></a>十 stash（临时存储）</h2><p><code>&quot;stash&quot;</code> 这个词，和它意思比较接近的中文翻译是「藏匿」，是「把东西放在一个秘密的地方以备未来使用」的意思。</p>
<p>在 <code>Git</code> 中，<code>stash</code> 指令可以帮你把工作目录的内容全部放在你本地的一个独立的地方，它不会被提交，也不会被删除，你把东西放起来之后就可以去做你的临时工作了，做完以后再来取走，就可以继续之前手头的事了。</p>
<p>具体说来，<code>stash</code> 的用法很简单。当你手头有一件临时工作要做，需要把工作目录暂时清理干净，那么可以：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure>

<p>现在工作目录的改动就被清空了，所有改动都被存了起来。</p>
<p>当手头工作做完后，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash pop</span><br></pre></td></tr></table></figure>

<p>之前的代码又回来了！</p>
<blockquote>
<p>注意：没有被 <code>track</code> 的文件（即从来没有被 add 过的文件不会被 stash 起来，因为 Git 会忽略它们。如果想把这些文件也一起 stash，可以加上 <code>-u</code> 参数，它是 <code>--include-untracked</code> 的简写。就像这样：</p>
</blockquote>
<h2 id="十一-tag（引用）"><a href="#十一-tag（引用）" class="headerlink" title="十一 tag（引用）"></a>十一 tag（引用）</h2><h3 id="添加-Tag"><a href="#添加-Tag" class="headerlink" title="添加 Tag"></a>添加 Tag</h3><p><code>tag</code> 是一个和 <code>branch</code> 非常相似的概念，它和 <code>branch</code> 最大的区别是：<code>tag</code> 不能移动。所以在很多团队中，<code>tag</code> 被用来在关键版本处打标记用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -a v1.1 -m &quot;my Tag 1.1&quot;</span><br></pre></td></tr></table></figure>

<p>这是在当前 <code>commit</code> 创建一个 名为 <code>v1.1</code> 的标签。<code>-m</code> 选项指定了一条将会存储在标签中的信息。 如果没有为附注标签指定一条信息，Git 会启动编辑器要求你输入信息。</p>
<p>如何给之前的 <code>commit</code> 添加 <code>tag</code> 呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -a v1.0 81bb698 -m &quot;my Tag 1.0&quot;</span><br></pre></td></tr></table></figure>

<p>只需要在标签名后面加入 <code>commit</code> 的 <code>SHA-1</code> 校验和 。</p>
<h3 id="查看-Tag"><a href="#查看-Tag" class="headerlink" title="查看 Tag"></a>查看 Tag</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git log --oneline</span><br><span class="line">347cd98 (HEAD -&gt; master, tag: v1.1, origin&#x2F;master, origin&#x2F;HEAD) head</span><br><span class="line">81bb698 (tag: v1.0) c</span><br></pre></td></tr></table></figure>

<p>也可以使用如下只查看标签</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git tag</span><br><span class="line">v1.0</span><br><span class="line">v1.1</span><br></pre></td></tr></table></figure>

<p>通过使用 <code>git show</code> 命令可以看到标签信息和与之对应的提交信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ git show v1.1</span><br><span class="line">tag v1.1</span><br><span class="line">Tagger: companyPc &lt;lvyanv@163.com&gt;</span><br><span class="line">Date:   Fri Oct 9 10:59:57 2020 +0800</span><br><span class="line"></span><br><span class="line">my Tag 1.1</span><br><span class="line"></span><br><span class="line">commit 347cd9856e1edf4c0a96cb15bad227ab8d255cda (HEAD -&gt; master, tag: v1.1, origin&#x2F;master, origin&#x2F;HEAD)</span><br><span class="line">Author: companyPc &lt;lvyanv@163.com&gt;</span><br><span class="line">Date:   Tue Sep 29 18:27:18 2020 +0800</span><br><span class="line"></span><br><span class="line">    head</span><br><span class="line"></span><br><span class="line">diff --git a&#x2F;branch1.txt b&#x2F;branch1.txt</span><br><span class="line">index b3a843b..b9176c0 100644</span><br><span class="line">--- a&#x2F;branch1.txt</span><br><span class="line">+++ b&#x2F;branch1.txt</span><br><span class="line">@@ -4,7 +4,7 @@</span><br><span class="line"> 11</span><br><span class="line"> 11</span><br><span class="line"> 11</span><br><span class="line">-</span><br><span class="line">+22</span><br></pre></td></tr></table></figure>

<p>输出显示了打标签者的信息、打标签的日期时间、附注信息，然后显示具体的提交信息。</p>
<h3 id="删除-Tag"><a href="#删除-Tag" class="headerlink" title="删除 Tag"></a>删除 Tag</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -d v1.0</span><br><span class="line">Deleted tag &#39;v1.0&#39; (was a390a5f)</span><br></pre></td></tr></table></figure>

<p>注意上述命令并不会从任何远程仓库中移除这个标签，通过如下命令可以更新远程分支情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin : refs&#x2F;tags&#x2F;v1.0</span><br></pre></td></tr></table></figure>

<p>第二种更直观的删除远程标签的方式是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin --delete v1.0</span><br></pre></td></tr></table></figure>

<h3 id="检出标签"><a href="#检出标签" class="headerlink" title="检出标签"></a>检出标签</h3><p><code>tag</code> 创建后，就相当于一个应用，可以同个 <code>checkout</code> 检出到当前标签的位置 ~ </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout v1.0</span><br><span class="line">Note: checking out &#39;v1.0&#39;.</span><br><span class="line"></span><br><span class="line">You are in &#39;detached HEAD&#39; state. You can look around, make experimental</span><br><span class="line">changes and commit them, and you can discard any commits you make in this</span><br><span class="line">state without impacting any branches by performing another checkout.</span><br><span class="line"></span><br><span class="line">If you want to create a new branch to retain commits you create, you may</span><br><span class="line">do so (now or later) by using -b with the checkout command again. Example:</span><br><span class="line"></span><br><span class="line">  git checkout -b &lt;new-branch-name&gt;</span><br><span class="line"></span><br><span class="line">HEAD is now at 81bb698 c</span><br></pre></td></tr></table></figure>

<h2 id="十二-Gitflow-工作流"><a href="#十二-Gitflow-工作流" class="headerlink" title="十二 Gitflow 工作流"></a>十二 Gitflow 工作流</h2><p><code>Git-flow</code> 是 <code>Git</code> 的包装器</p>
<h3 id="Develop-和-Master-分支"><a href="#Develop-和-Master-分支" class="headerlink" title="Develop 和 Master 分支"></a><code>Develop</code> 和 <code>Master</code> 分支</h3><p><strong>master</strong></p>
<ul>
<li>主分支 , 产品的功能全部实现后 , 最终在 <code>master</code> 分支对外发布</li>
<li>该分支为只读唯一分支 , 只能从其他分支 <code>(release/hotfix)</code> 合并 , 不能在此分支修改</li>
<li>另外所有在 <code>master</code> 分支的推送应该<strong>打标签做记录</strong>,方便追溯</li>
<li>例如 <code>release</code> 合并到 <code>master</code> , 或 <code>hotfix</code> 合并到 <code>master</code></li>
</ul>
<p><strong>develop</strong></p>
<ul>
<li>主开发分支 , 基于 <code>master</code> 分支克隆</li>
<li>包含所有要发布到下一个 <code>release</code> 的代码</li>
<li>该分支为只读唯一分支 , 只能从其他分支合并</li>
<li><code>feature</code> 功能分支完成 , 合并到 <code>develop</code> (不推送)</li>
<li><code>develop</code> 拉取 <code>release</code> 分支 , 提测</li>
<li><code>release/hotfix</code> 分支上线完毕 , 合并到 <code>develop</code> 并推送</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/git/git_flow_1.svg" alt="图片来源于文末链接中的 Gitflow"></p>
<p>这个工作流使用两个分支来记录项目的历史，而不是单一的 <code>master</code>。 <code>master</code> 存储官方发布历史记录，而 <code>develop</code> 分支充当功能的集成分支。用版本号标记 <code>master</code> 中的所有提交也很方便。</p>
<p>第一步是用一个 <code>develop</code> 分支来补充默认的 <code>master</code> 。一个简单的方法是一个开发人员在本地创建一个空的 <code>develop</code> 分支，并将其推到服务器:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch develop </span><br><span class="line">git push -u origin develop</span><br></pre></td></tr></table></figure>

<p>该分支将包含项目的完整历史记录，而<code>master</code>将包含简化版本。现在，其他开发人员现在应该 <code>clone</code> 中央存储库，并为 <code>develop</code> 创建 <code>tracking</code> 分支。</p>
<p>当使用 <code>git-flow</code> 扩展库时，在已有的 <code>repo</code> 上执行 <code>git flow init</code> 将创建开发分支:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ git flow init</span><br><span class="line"></span><br><span class="line">Which branch should be used for bringing forth production releases?</span><br><span class="line">   - develop</span><br><span class="line">   - master</span><br><span class="line">Branch name for production releases: [master]</span><br><span class="line"></span><br><span class="line">Which branch should be used for integration of the &quot;next release&quot;?</span><br><span class="line">   - develop</span><br><span class="line">Branch name for &quot;next release&quot; development: [develop]</span><br><span class="line"></span><br><span class="line">How to name your supporting branch prefixes?</span><br><span class="line">Feature branches? [] feature&#x2F;</span><br><span class="line">Bugfix branches? [] bugfix&#x2F;</span><br><span class="line">Release branches? [] release&#x2F;</span><br><span class="line">Hotfix branches? [] hotfix&#x2F;</span><br><span class="line">Support branches? [] support&#x2F;</span><br><span class="line">Version tag prefix? [] version&#x2F;</span><br><span class="line">Hooks and filters directory? [C:&#x2F;Users&#x2F;Beepay&#x2F;Desktop&#x2F;新建文件夹&#x2F;ui-starge&#x2F;.git&#x2F;hooks]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>git flow init</code> 命令是缺省 <code>git init</code> 命令的扩展，除了为您创建分支外，它不会更改存储库中的任何内容。</p>
<p>设置前缀的时候加上 <code>/</code> 相当于分组了。试一试下面的过程就知道啦。</p>
<p>如果使用 <code>Sourcetree</code> ，也可以点击工具中右上角 <code>Git 工作流</code> 切换到 <code>git flow</code> 工作流。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/git/git_flow_1_1.png" alt=""></p>
<p>之后的操作就是弹框中的，之后就不一一列出 <code>Sourcetree</code> 的操作了。</p>
<h3 id="Feature-功能-分支"><a href="#Feature-功能-分支" class="headerlink" title="Feature(功能) 分支"></a><code>Feature</code>(功能) 分支</h3><p><strong>feature</strong></p>
<ul>
<li>功能开发分支 , 基于 <code>develop</code> 分支克隆 , 主要用于新需求新功能的开发</li>
<li>功能开发完毕后合到 <code>develop</code> 分支(未正式上线之前不推送到远程中央仓库!!!)</li>
<li><code>feature</code> 分支可同时存在多个 , 用于团队中多个功能同时开发 , 属于临时分支 , 功能完成后可选删除</li>
</ul>
<p>每一个新功能的开发都应该各自使用独立的分支，可以推送到中央存储库进行备份/协作。但是，<code>feature</code> 分支使用 <code>develop</code> 作为它们的父分支，而不是 <code>master</code> 分支。当一个 功能 完成时，它会被合并回到 <code>feature</code> 中。<strong><code>feature</code> 不应该直接与 <code>master</code> 交互。</strong></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/git/git_flow_2.svg" alt="图片来源于文末链接中的 Gitflow"></p>
<p><strong>注意</strong>：组合使用 <code>feature</code> 分支和 <code>develop</code> 分支的这种设计，其实完全就是 <code>Feature Branch Workflow</code>的理念。然而，<code>Gitflow</code> 流程并不止于此。且看下文分解。</p>
<p><strong>创建一个工作分支：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout develop </span><br><span class="line">git checkout -b feature_branch </span><br></pre></td></tr></table></figure>

<p>使用 <code>git-flow</code> 扩展时：(这里注意 <code>init</code> 时的前缀加 <code>/</code> )</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git flow feature start feature_branch</span><br></pre></td></tr></table></figure>

<p>执行这个命令不需要切换分支，会自动已本地 <code>develop</code> 最新 <code>commit</code> 为基点， 之后像往常一样使用继续 <code>Git</code> 就可以。</p>
<p><strong>完成/合并 一个工作分支：</strong></p>
<p>（执行之前记得 <code>add</code> 以及 <code>commit</code> 更新的内容）当完成了 <code>feature</code> 的开发工作后，下一步是将 <code>feature_branch</code> 合并到 <code>develop</code> 中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout develop </span><br><span class="line">git merge feature_branch</span><br><span class="line">git branch -d feature_branch</span><br></pre></td></tr></table></figure>

<p>使用 <code>git-flow</code> 扩展时：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git flow feature finish feature_branch</span><br></pre></td></tr></table></figure>

<h3 id="Release-分支"><a href="#Release-分支" class="headerlink" title="Release 分支"></a><code>Release</code> 分支</h3><p><strong>release</strong></p>
<ul>
<li>测试分支 , 基于 <code>feature</code> 分支合并到 <code>develop</code> 之后  , 从 <code>develop</code> 分支克隆</li>
<li>主要用于提交给测试人员进行功能测试 , 测试过程中发现的 <code>BUG</code> 在本分支进行修复 , 修复完成上线后合并到 <code>develop/master</code> 分支并推送(完成功能) , 打<code>Tag</code> </li>
<li>属于临时分支 , 功能上线后可选删除</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/git/git_flow_3.svg" alt="图片来源于文末链接中的 Gitflow"></p>
<p>一旦 <code>develop</code> 分支积聚了足够多的新功能（或者预定的发布日期临近了），你可以基于 <code>develop</code> 分支建立一个用于产品发布的分支。这个分支的创建意味着一个发布周期的开始，也意味着本次发布不会再增加新的功能，在这个分支上只能修复 <code>bug</code> ，做一些文档工作或者跟发布相关的任务。在一切准备就绪的时候，这个分支会被合并入 <code>master</code> ，并且用版本号打上 <code>tag</code>。<br>另外，<code>release</code> 分支上的改动还应该合并入 <code>develop</code> 分支，在发布周期内，<code>develop</code> 分支仍然在被使用（一些开发者会把其他功能集成到 <code>develop</code> 分支）。</p>
<p>使用专门的一个分支来为发布做准备的好处是，在一个团队忙于当前的发布的同时，另一个团队可以继续为接下来的一次发布开发新功能。</p>
<p><strong>创建 <code>release</code> 分支</strong>是另一个简单的分支操作。与 <code>feature</code> 分支一样，<code>release</code> 分支也基于 <code>develop</code> 分支。可以使用以下方法创建一个新的 <code>release</code> 分支。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout develop </span><br><span class="line">git checkout -b release&#x2F;0.1.0</span><br></pre></td></tr></table></figure>

<p>使用 <code>git-flow</code> 扩展时：(这里注意 <code>init</code> 时的前缀加 <code>/</code> )</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git flow release start 0.1.0</span><br></pre></td></tr></table></figure>

<p><strong>要 完成/合并 一个发布分支</strong>（执行之前记得 <code>add</code> 以及 <code>commit</code> 更新的内容），使用以下方法: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git checkout master </span><br><span class="line">git merge release&#x2F;0.1.0</span><br><span class="line">git checkout develop </span><br><span class="line">git merge release&#x2F;0.1.0</span><br><span class="line">git branch -d release&#x2F;0.1.0</span><br></pre></td></tr></table></figure>

<p>使用 <code>git-flow</code> 扩展时：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git flow release finish &#39;0.1.0&#39; -m &quot;my version 0.1.0&quot;</span><br></pre></td></tr></table></figure>

<p>这里可以不写 <code>-m</code> ，但是在合并 <code>develop</code> 的时候弹出的编辑页面需要再次写入提交信息，否者会导致提交失败。如果写了 <code>-m</code> 只需要两次 <code>:wq</code> 即可。</p>
<h3 id="Hotfix-分支"><a href="#Hotfix-分支" class="headerlink" title="Hotfix 分支"></a><code>Hotfix</code> 分支</h3><p><strong>hotfix</strong></p>
<ul>
<li>补丁分支 , 基于 <code>master</code> 分支克隆 , 主要用于对线上的版本进行 <code>BUG</code> 修复</li>
<li>修复完毕后合并到 <code>develop/master</code> 分支并推送 , 打 <code>Tag</code> </li>
<li>属于临时分支 , 补丁修复上线后可选删除</li>
<li>所有 <code>hotfix</code> 分支的修改会进入到下一个 <code>release</code> </li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/git/git_flow_4.svg" alt="图片来源于文末链接中的 Gitflow"></p>
<p><code>hotfix</code> 分支用于快速对生产版本进行补丁。<code>hotfix</code> 分支很像 <code>release</code> 分支和 <code>feature</code> 分支，除了 <code>hotfix</code> 是基于 <code>master</code> 分支而不是 <code>develop</code>。这是唯一一个从主分支 <code>fork</code> 的。一旦修复完成，它应该被合并到 <code>master</code> 和 <code>develop</code> (或者当前的 <code>release</code> 分支)中，并且 <code>master</code> 应该被标记为一个更新的版本号。</p>
<p>拥有专门的 <code>bug</code> 修复开发线可以让团队解决问题同时，并且不会中断其余的工作流程或等待下一个发布周期。</p>
<p>可以将维护分支视为直接与 <code>master</code>一起工作的临时 <code>release</code> 分支。</p>
<p><strong>创建 <code>hotifx</code> 分支</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout master </span><br><span class="line">git checkout -b hotfix_branch</span><br></pre></td></tr></table></figure>

<p>使用 <code>git-flow</code> 扩展时：(这里注意 <code>init</code> 时的前缀加 <code>/</code> )</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git flow hotfix start hotfix_branch</span><br></pre></td></tr></table></figure>

<p><strong>完成/合并 一个 <code>hotfix</code> 分支</strong>（执行之前记得 <code>add</code> 以及 <code>commit</code> 更新的内容）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git checkout master </span><br><span class="line">git merge hotfix_branch </span><br><span class="line">git checkout develop </span><br><span class="line">git merge hotfix_branch </span><br><span class="line">git branch -d hotfix_branch</span><br></pre></td></tr></table></figure>

<p>使用 <code>git-flow</code> 扩展时：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git flow hotfix finish hotfix_branch  -m &quot;my hotfix commit&quot;</span><br></pre></td></tr></table></figure>

<p>这里可以不写 <code>-m</code> ，但是在合并 <code>develop</code> 的时候弹出的编辑页面需要再次写入提交信息，否者会导致提交失败。如果写了 <code>-m</code> 只需要两次 <code>:wq</code> 即可。</p>
<p><code>Gitflow</code> 的总体流程为：</p>
<ol>
<li>从<code>master</code> 创建一个 <code>develop</code>分支</li>
<li><code>release</code>从 <code>develop</code>  分支创建</li>
<li><code>feature</code> 从 <code>develop</code> 分支创建</li>
<li>当<code>feature</code>完成后，会合并到<code>develop</code> 分支</li>
<li>当<code>release</code>分支完成后，会合并到<code>develop</code>和<code>master</code></li>
<li>如果<code>master</code>检测到问题，则从 <code>master</code> 创建 <code>hotfix</code> 程序分支</li>
<li><code>hotfix</code>完成后，会被合并到两个<code>develop</code>及<code>master</code></li>
</ol>
<p><strong>感谢：</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow">Gitflow</a></p>
<p><a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v2">Git</a></p>
<p> <a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000022506884">git HEAD / HEAD^ / HEAD~ 的含义</a></p>
<p> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/kidsitcn/p/5339382.html">git rebase vs git merge详解</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.im/book/6844733697996881928/">Git 原理详解及实用指南</a></p>
<p><strong>更多：</strong></p>
<p><a target="_blank" rel="noopener" href="https://juejin.im/entry/6844903581087170574">Git+Gerrit如何永久删除历史文件（大文件/私密文件）</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">CalmCenter</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://calmcenter.club/2020/git-principle.html">https://calmcenter.club/2020/git-principle.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://calmcenter.club" target="_blank">CalmCenter</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/git/">git</a></div><div class="post_share"><div class="social-share" data-image="https://gitee.com/CalmCenter/Pic/raw/master/cover47.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.png" target="_blank"><img class="post-qr-code-img" data-lazy-src="/img/wechat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.png" target="_blank"><img class="post-qr-code-img" data-lazy-src="/img/alipay.png" alt="支付寶"/></a><div class="post-qr-code-desc">支付寶</div></li></ul></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/design-pattern-decorator.html"><img class="prev-cover" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/cover53.webp" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">设计模式-结构型-装饰模式</div></div></a></div><div class="next-post pull-right"><a href="/2020/design-pattern-bridge.html"><img class="next-cover" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/bg2/cover5.webp" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">设计模式-结构型-桥接模式</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2019/complete-works-of-hexo.html" title="Hexo 搭建博客篇"><img class="cover" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/cover18.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-12-01</div><div class="title">Hexo 搭建博客篇</div></div></a></div><div><a href="/2019/hexo-bash.html" title="Hexo 基础搭建"><img class="cover" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/cover11.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-12-18</div><div class="title">Hexo 基础搭建</div></div></a></div><div><a href="/2019/hexo-code-management.html" title="Hexo 管理代码"><img class="cover" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/cover12.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-12-19</div><div class="title">Hexo 管理代码</div></div></a></div><div><a href="/2019/hexo-functional-style.html" title="Hexo 功能样式配置"><img class="cover" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/cover16.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-12-21</div><div class="title">Hexo 功能样式配置</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside_content" id="aside_content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><img class="avatar-img" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">CalmCenter</div><div class="author-info__description">目标设置到月球，即使陨落也是在群星之间！</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">50</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/CalmCenter"><i class="fab fa-github"></i><span>Follow Me</span></a></div></div><div class="card-widget card-announcement"><div class="card-content"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">不要努力成为一个成功的人，而要努力成为一个有价值的人。</div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-clone-%E9%A1%B9%E7%9B%AE"><span class="toc-text">一 clone(项目)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-push-%E6%8F%90%E4%BA%A4"><span class="toc-text">二 push(提交)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#add-%E6%B7%BB%E5%8A%A0%E8%87%B3%E6%9A%82%E5%AD%98%E5%8C%BA"><span class="toc-text">add(添加至暂存区)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#commit-%E6%8F%90%E4%BA%A4%E5%88%B0%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93"><span class="toc-text">commit(提交到本地仓库)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#push"><span class="toc-text">push</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#push-%E4%B8%8A%E5%8E%BB%E4%BA%86%E6%89%8D%E5%8F%91%E7%8E%B0%E5%86%99%E9%94%99%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-text">push 上去了才发现写错怎么办？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-pull-%E6%8B%89%E5%8F%96"><span class="toc-text">三 pull(拉取)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E8%AE%B0%E5%BD%95"><span class="toc-text">四 查看提交记录</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%AF%8F%E4%B8%AA-commit-%E5%8D%95%E8%A1%8C%E6%98%BE%E7%A4%BA"><span class="toc-text">查看每个 commit 单行显示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%AF%8F%E4%B8%AA-commit-%E5%9B%BE%E6%A0%87%E6%98%BE%E7%A4%BA"><span class="toc-text">查看每个 commit 图标显示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%AF%8F%E4%B8%AA-commit-%E5%A4%A7%E8%87%B4%E6%94%B9%E5%8A%A8"><span class="toc-text">查看每个 commit 大致改动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%AF%8F%E4%B8%AA-commit-%E8%AF%A6%E7%BB%86%E6%94%B9%E5%8A%A8"><span class="toc-text">查看每个 commit 详细改动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D-commit-%E7%9A%84%E6%94%B9%E5%8A%A8%E5%86%85%E5%AE%B9"><span class="toc-text">查看当前 commit 的改动内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E4%BB%BB%E6%84%8F%E4%B8%80%E4%B8%AA-commit"><span class="toc-text">查看任意一个 commit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%8C%87%E5%AE%9A-commit-%E4%B8%AD%E7%9A%84%E6%8C%87%E5%AE%9A%E6%96%87%E4%BB%B6%E6%94%B9%E5%8A%A8%E5%86%85%E5%AE%B9"><span class="toc-text">查看指定 commit 中的指定文件改动内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%9C%AA%E6%8F%90%E4%BA%A4%E7%9A%84%E5%86%85%E5%AE%B9"><span class="toc-text">查看未提交的内容</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AF%94%E5%AF%B9%E6%9A%82%E5%AD%98%E5%8C%BA%E5%92%8C%E4%B8%8A%E4%B8%80%E6%9D%A1%E6%8F%90%E4%BA%A4"><span class="toc-text">比对暂存区和上一条提交</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AF%94%E5%AF%B9%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95%E5%92%8C%E6%9A%82%E5%AD%98%E5%8C%BA"><span class="toc-text">比对工作目录和暂存区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AF%94%E5%AF%B9%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95%E5%92%8C%E4%B8%8A%E4%B8%80%E6%9D%A1%E6%8F%90%E4%BA%A4"><span class="toc-text">比对工作目录和上一条提交</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reflog-%E6%9F%A5%E7%9C%8B%E5%BC%95%E7%94%A8%E7%A7%BB%E5%8A%A8%E8%AE%B0%E5%BD%95"><span class="toc-text">Reflog 查看引用移动记录</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94-Branch-%E5%88%86%E6%94%AF"><span class="toc-text">五 Branch(分支)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%88%86%E6%94%AF"><span class="toc-text">创建分支</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E4%BA%A4%E5%88%86%E6%94%AF"><span class="toc-text">提交分支</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%88%86%E6%94%AF"><span class="toc-text">查看分支</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%87%E6%8D%A2%E5%88%86%E6%94%AF%EF%BC%88checkout%EF%BC%89"><span class="toc-text">切换分支（checkout）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#checkout-%E6%9C%AC%E8%B4%A8%EF%BC%9A"><span class="toc-text">checkout 本质：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#checkout-%E5%92%8C-reset-%E7%9A%84%E4%B8%8D%E5%90%8C"><span class="toc-text">checkout 和 reset 的不同</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%88%86%E6%94%AF"><span class="toc-text">删除分支</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD-merge-%E5%90%88%E5%B9%B6"><span class="toc-text">六  merge(合并)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">适用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5-1%EF%BC%9A%E5%86%B2%E7%AA%81"><span class="toc-text">特殊情况 1：冲突</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%A7%A3%E5%86%B3%E5%86%B2%E7%AA%81"><span class="toc-text">1.解决冲突</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%8F%90%E4%BA%A4"><span class="toc-text">2.提交</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%94%BE%E5%BC%83%E8%A7%A3%E5%86%B3%E5%86%B2%E7%AA%81%EF%BC%8C%E5%8F%96%E6%B6%88-merge"><span class="toc-text">3.放弃解决冲突，取消 merge</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5-2%EF%BC%9AHEAD-%E9%A2%86%E5%85%88%E4%BA%8E%E7%9B%AE%E6%A0%87-commit"><span class="toc-text">特殊情况 2：HEAD 领先于目标 commit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5-3%EF%BC%9AHEAD-%E8%90%BD%E5%90%8E%E4%BA%8E%E7%9B%AE%E6%A0%87-commit"><span class="toc-text">特殊情况 3：HEAD 落后于目标 commit</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83-Feature-Branch-%E6%9C%80%E6%B5%81%E8%A1%8C%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81"><span class="toc-text">七 Feature Branch(最流行的工作流)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%A3%E7%A0%81%E5%88%86%E4%BA%AB"><span class="toc-text">1.代码分享</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Pull-Request"><span class="toc-text">2.Pull Request</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%B8%80%E4%BA%BA%E5%A4%9A%E4%BB%BB%E5%8A%A1"><span class="toc-text">3.一人多任务</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB-rebase%EF%BC%88%E5%8F%98%E5%9F%BA%EF%BC%89"><span class="toc-text">八 rebase（变基）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-rebase-%E5%92%8C-merge-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">1. rebase 和 merge 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-rebase-%E6%97%B6%E5%87%BA%E7%8E%B0%E4%BA%86%E5%86%B2%E7%AA%81%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-text">2.rebase 时出现了冲突怎么办？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BD%BF%E7%94%A8-rebase-%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">3. 使用 rebase 需要注意什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BA%A4%E4%BA%92%E5%BC%8F-rebase-i"><span class="toc-text">4.交互式 rebase -i</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%8F%E7%A7%BB%E7%AC%A6%E5%8F%B7"><span class="toc-text">偏移符号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E4%B9%8B%E5%89%8D%E7%9A%84-commit"><span class="toc-text">修改之前的 commit</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E4%B9%8B%E5%89%8D%E7%9A%84-commit"><span class="toc-text">删除之前的 commit</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-rebase-%E2%80%93onto"><span class="toc-text">5. rebase –onto</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D-reset%EF%BC%88%E9%87%8D%E7%BD%AE%EF%BC%89"><span class="toc-text">九 reset（重置）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#reset-%E2%80%93hard%EF%BC%9A%E9%87%8D%E7%BD%AE%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95"><span class="toc-text">reset –hard：重置工作目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#reset-%E2%80%93soft%EF%BC%9A%E4%BF%9D%E7%95%99%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95"><span class="toc-text">reset –soft：保留工作目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#reset-%E4%B8%8D%E5%8A%A0%E5%8F%82%E6%95%B0%EF%BC%9A%E4%BF%9D%E7%95%99%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95%EF%BC%8C%E5%B9%B6%E6%B8%85%E7%A9%BA%E6%9A%82%E5%AD%98%E5%8C%BA%EF%BC%88%E2%80%93mixed%EF%BC%89"><span class="toc-text">reset 不加参数：保留工作目录，并清空暂存区（–mixed）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81-stash%EF%BC%88%E4%B8%B4%E6%97%B6%E5%AD%98%E5%82%A8%EF%BC%89"><span class="toc-text">十 stash（临时存储）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%80-tag%EF%BC%88%E5%BC%95%E7%94%A8%EF%BC%89"><span class="toc-text">十一 tag（引用）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0-Tag"><span class="toc-text">添加 Tag</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B-Tag"><span class="toc-text">查看 Tag</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4-Tag"><span class="toc-text">删除 Tag</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%80%E5%87%BA%E6%A0%87%E7%AD%BE"><span class="toc-text">检出标签</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%BA%8C-Gitflow-%E5%B7%A5%E4%BD%9C%E6%B5%81"><span class="toc-text">十二 Gitflow 工作流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Develop-%E5%92%8C-Master-%E5%88%86%E6%94%AF"><span class="toc-text">Develop 和 Master 分支</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Feature-%E5%8A%9F%E8%83%BD-%E5%88%86%E6%94%AF"><span class="toc-text">Feature(功能) 分支</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Release-%E5%88%86%E6%94%AF"><span class="toc-text">Release 分支</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hotfix-%E5%88%86%E6%94%AF"><span class="toc-text">Hotfix 分支</span></a></li></ol></li></ol></div></div></div></div></div></main><footer id="footer" style="background-image: url(https://gitee.com/CalmCenter/Pic/raw/master/cover47.webp)"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By CalmCenter</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><link rel="stylesheet" href="/live2d/css/live2d.css"/></div><div id="landlord"><div class="message" style="opacity:0"></div><canvas class="live2d" id="live2d" width="240" height="250"></canvas><div class="hide-button">隐藏</div></div><script type="text/javascript" src="https://cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script><script type="text/javascript">var message_Path = '/live2d/'
var home_Path = 'https://calmcenter.club/'</script><script type="text/javascript" src="/live2d/js/live2d.js"></script><script type="text/javascript" src="/live2d/js/message.js"></script><script type="text/javascript">loadlive2d("live2d", "/live2d/model/xxb2/model.json");</script></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>function addGitalkSource () {
  const ele = document.createElement('link')
  ele.rel = 'stylesheet'
  ele.href= 'https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css'
  document.getElementsByTagName('head')[0].appendChild(ele)
}

function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk({
      clientID: '9b707b75b56f9e432b12',
      clientSecret: '6e2d5a012729aa6c9e8df3cc0a90d82f976a026e',
      repo: 'calmcenter.github.io',
      owner: 'CalmCenter',
      admin: ['CalmCenter'],
      id: 'f8d8adf89fb633d7ae742684920082a0',
      language: 'zh-CN',
      perPage: 10,
      distractionFreeMode: false,
      pagerDirection: 'last',
      createIssueManually: false,
      updateCountCallback: commentCount
    })
    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    addGitalkSource()
    $.getScript('https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js', initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !false) {
  if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></body></html>