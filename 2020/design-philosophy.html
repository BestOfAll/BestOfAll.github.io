<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>设计模式-设计原则篇 | CalmCenter</title><meta name="description" content="SOLID 原则并非单纯的 1 个原则，而是由 5 个设计原则组成的，它们分别是：单一职责原则、开闭原则、里式替换原则、接口隔离原则和依赖反转原则，依次对应 SOLID 中的 S、O、L、I、D 这 5 个英文字母。💙💚💛💜💝"><meta name="keywords" content="编码"><meta name="author" content="CalmCenter"><meta name="copyright" content="CalmCenter"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = 'false'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="canonical" href="https://calmcenter.club/2020/design-philosophy.html"><link rel="prev" title="设计模式篇" href="https://calmcenter.club/2020/design-mode.html"><link rel="next" title="稳定性优化" href="https://calmcenter.club/2020/stability-optimization.html"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: true,
  fancybox: false,
  Snackbar: {"bookmark":{"message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"top-right"},
  baiduPush: false,
  highlightCopy: true,
  highlightLang: false,
  highlightShrink: 'none',
  isFontAwesomeV5: false,
  isPhotoFigcaption: true,
  islazyload: true,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">38</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">17</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">5</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友情链接</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#本文主要记载"><span class="toc-text">本文主要记载</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#🚩单一责任原则"><span class="toc-text">🚩单一责任原则</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-如何理解-“单一职责原则”-？"><span class="toc-text">1 如何理解 “单一职责原则” ？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-如何判断类的职责是否足够单一？"><span class="toc-text">2 如何判断类的职责是否足够单一？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-类的职责是否设计得越单一越好？"><span class="toc-text">3 类的职责是否设计得越单一越好？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#🚩开闭原则"><span class="toc-text">🚩开闭原则</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-如何理解-“对扩展开放、修改关闭”-？"><span class="toc-text">1 如何理解 “对扩展开放、修改关闭”  ？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-如何做到-“对扩展开放、修改关闭”-？"><span class="toc-text">2 如何做到 “对扩展开放、修改关闭” ？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-如何在项目中灵活应用开闭原则？"><span class="toc-text">3 如何在项目中灵活应用开闭原则？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#🚩里氏替换原则"><span class="toc-text">🚩里氏替换原则</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-如何理解-“里式替换原则”-？"><span class="toc-text">1 如何理解 “里式替换原则” ？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-如何做到-“里式替换原则”-？"><span class="toc-text">2 如何做到 “里式替换原则” ？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-哪些代码明显违背了-LSP？"><span class="toc-text">3 哪些代码明显违背了 LSP？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#🚩接口隔离原则"><span class="toc-text">🚩接口隔离原则</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-如何理解-“接口隔离原则”-？"><span class="toc-text">1 如何理解 “接口隔离原则” ？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-如何做到-“接口隔离原则”-？"><span class="toc-text">2 如何做到 “接口隔离原则” ？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-接口隔离原则与单一职责原则的区别"><span class="toc-text">3 接口隔离原则与单一职责原则的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#🚩依赖反转原则"><span class="toc-text">🚩依赖反转原则</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-控制反转"><span class="toc-text">1 控制反转</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-依赖注入"><span class="toc-text">2 依赖注入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-依赖反转原则"><span class="toc-text">3 依赖反转原则</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#🚩KISS-原则"><span class="toc-text">🚩KISS 原则</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-代码行数越少就越“简单”吗？"><span class="toc-text">1 代码行数越少就越“简单”吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-代码逻辑复杂就违背-KISS-原则吗？"><span class="toc-text">2 代码逻辑复杂就违背 KISS 原则吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-如何写出满足-KISS-原则的代码？"><span class="toc-text">3 如何写出满足 KISS 原则的代码？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-YAGNI-原则跟-KISS-原则说的是一回事吗？"><span class="toc-text">4 YAGNI 原则跟 KISS 原则说的是一回事吗？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#🚩DRY-原则"><span class="toc-text">🚩DRY 原则</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-实现逻辑重复"><span class="toc-text">1 实现逻辑重复</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-功能语义重复"><span class="toc-text">2 功能语义重复</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-代码执行重复"><span class="toc-text">3 代码执行重复</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-怎么提高代码复用性？"><span class="toc-text">4 怎么提高代码复用性？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-辩证思考和灵活应用"><span class="toc-text">5 辩证思考和灵活应用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#🚩迪米特法则"><span class="toc-text">🚩迪米特法则</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-何为-“高内聚、松耦合”-？"><span class="toc-text">1 何为 “高内聚、松耦合” ？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-不该有直接依赖关系的类之间，不要有依赖"><span class="toc-text">2 不该有直接依赖关系的类之间，不要有依赖</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-有依赖关系的类之间，尽量只依赖必要的接口"><span class="toc-text">3 有依赖关系的类之间，尽量只依赖必要的接口</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#感谢"><span class="toc-text">感谢</span></a></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://gitee.com/CalmCenter/Pic/raw/master/cover38.webp)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">CalmCenter</a></span><span class="pull_right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友情链接</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">设计模式-设计原则篇</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-06-10 12:59:00"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-06-10</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-07-13 17:08:54"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-07-13</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E7%BC%96%E7%A0%81/">编码</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="post-meta__icon fa fa-file-word-o" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">15k</span><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-clock-o" aria-hidden="true"></i><span>阅读时长: 54 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="本文主要记载"><a href="#本文主要记载" class="headerlink" title="本文主要记载"></a>本文主要记载</h1><ul>
<li><strong>单一责任原则</strong><ul>
<li>如何理解 “单一职责原则”？</li>
<li>如何判断类的职责是否足够单一？</li>
<li>类的职责是否设计的越单一越好？</li>
</ul>
</li>
<li><strong>开闭原则</strong><ul>
<li>如何理解 “对扩展开放、修改关闭”？</li>
<li>如何做到 “对扩展开放、修改关闭”？</li>
<li>如何正在项目中灵活应用开闭原则？</li>
</ul>
</li>
<li><strong>里式替换原则</strong><ul>
<li>如何理解 “里式替换原则”？</li>
<li>如何做到 “里式替换原则”？</li>
<li>接口隔离原则和单一职责原则的区别</li>
</ul>
</li>
<li><strong>依赖反转原则</strong><ul>
<li>控制反转</li>
<li>依赖注入</li>
<li>依赖反转原则</li>
</ul>
</li>
<li><strong>KISS 原则</strong><ul>
<li>代码行数越少越 “简单” 吗？</li>
<li>代码逻辑复杂就违背 KISS 原则吗？</li>
<li>如何写出满足 KISS 原则的代码？</li>
<li>YANGNI 原则跟 KISS 原则说的是一回事吗？</li>
</ul>
</li>
<li><strong>DRY 原则</strong><ul>
<li>实现逻辑重复</li>
<li>功能语义重复</li>
<li>代码执行重复</li>
<li>怎么提高代码复用性？</li>
<li>思考和灵活应用</li>
</ul>
</li>
<li><strong>迪米特法则</strong><ul>
<li>何为 “高内聚，松耦合”？</li>
<li>不该有直接依赖关系的类之间，不要有依赖</li>
<li>有依赖关系的类之间，尽量只依赖必要的接口</li>
</ul>
</li>
</ul>
<hr>
<h1 id="🚩单一责任原则"><a href="#🚩单一责任原则" class="headerlink" title="🚩单一责任原则"></a>🚩单一责任原则</h1><p> (Single Responsibility Principle SRP)</p>
<h2 id="1-如何理解-“单一职责原则”-？"><a href="#1-如何理解-“单一职责原则”-？" class="headerlink" title="1 如何理解 “单一职责原则” ？"></a>1 如何理解 “单一职责原则” ？</h2><p><code>A class or module should have a single reponsibility(一个类或者模块只负责完成一个职责（或者功能）)</code></p>
<p>一个类只负责完成一个职责或者功能。不要设计大而全的类，要设计粒度小、功能单一的类。单一职责原则是为了实现代码高内聚、低耦合，提高代码的复用性、可读性、可维护性。</p>
<p><strong>就一个类而言，应该仅有一个引起变化的原因</strong>  </p>
<p><strong>把因为相同的原因而改变的事物聚集在一起。把那些因为不同原因而改变的东西分开。</strong></p>
<h2 id="2-如何判断类的职责是否足够单一？"><a href="#2-如何判断类的职责是否足够单一？" class="headerlink" title="2 如何判断类的职责是否足够单一？"></a>2 如何判断类的职责是否足够单一？</h2><p>不同的应用场景、不同阶段的需求背景、不同的业务层面，对同一个类的职责是否单一，可能会有不同的判定结果。举个栗子🌰</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> userId;</span><br><span class="line">  <span class="keyword">private</span> String username;</span><br><span class="line">  <span class="keyword">private</span> String email;</span><br><span class="line">  <span class="keyword">private</span> String telephone;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> createTime;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> lastLoginTime;</span><br><span class="line">  <span class="keyword">private</span> String avatarUrl;</span><br><span class="line">  <span class="keyword">private</span> String provinceOfAddress; <span class="comment">// 省</span></span><br><span class="line">  <span class="keyword">private</span> String cityOfAddress; <span class="comment">// 市</span></span><br><span class="line">  <span class="keyword">private</span> String regionOfAddress; <span class="comment">// 区 </span></span><br><span class="line">  <span class="keyword">private</span> String detailedAddress; <span class="comment">// 详细地址</span></span><br><span class="line">  <span class="comment">// ...省略其他属性和方法...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>UserInfo</code> 类的设计是否满足单一职责原则呢？</p>
<p>对于这个问题，有两种不同的观点。一种观点是，<code>UserInfo</code> 类包含的都是跟用户相关的信息，所有的属性和方法都隶属于用户这样一个业务模型，满足单一职责原则；另一种观点是，地址信息在 <code>UserInfo</code> 类中，所占的比重比较高，可以继续拆分成独立的 <code>UserAddress</code> 类，<code>UserInfo</code> 只保留除 <code>Address</code> 之外的其他信息，拆分之后的两个类的职责更加单一。</p>
<p>哪种观点更对呢？实际上，要从中做出选择，我们不能脱离具体的应用场景。如果在这个社交产品中，用户的地址信息跟其他信息一样，只是单纯地用来展示，那 <code>UserInfo</code> 现在的设计就是合理的。但是，如果这个社交产品发展得比较好，之后又在产品中添加了电商的模块，用户的地址信息还会用在电商物流中，那我们最好将地址信息从 <code>UserInfo</code> 中拆分出来，独立成用户物流信息（或者叫地址信息、收货信息等）。</p>
<p>一些侧面的判断指标更具有指导意义和可执行性，比如，出现下面这些情况就有可能说明这类的设计不满足单一职责原则：</p>
<ul>
<li>类中的代码行数、函数或者属性过多；</li>
<li>类依赖的其他类过多，或者依赖类的其他类过多；</li>
<li>私有方法过多；</li>
<li>比较难给类起一个合适的名字；</li>
<li>类中大量的方法都是集中操作类中的某几个属性；</li>
</ul>
<p>至于如何判断 <em>过多</em> ，实际上，这个问题并不好定量地回答，就像你问大厨 “放盐少许” 中的 “少许” 是多少，大厨也很难告诉你一个特别具体的量值，都是经验与感觉。</p>
<p>从另一个角度来看，当一个类的代码，读起来让你头大了，实现某个功能时不知道该用哪个函数了，想用哪个函数翻半天都找不到了，只用到一个小功能要引入整个类（类中包含很多无关此功能实现的函数）的时候，这就说明类的行数、函数、属性过多了。项目做多了，代码写多了，在开发中慢慢 “品尝” ，自然就知道什么是 “放盐少许” 了，这就是所谓的 “专业第六感” 。</p>
<h2 id="3-类的职责是否设计得越单一越好？"><a href="#3-类的职责是否设计得越单一越好？" class="headerlink" title="3 类的职责是否设计得越单一越好？"></a>3 类的职责是否设计得越单一越好？</h2><p>为了满足单一职责原则，是不是把类拆得越细就越好呢？答案是否定的。</p>
<p>单一职责原则通过避免设计大而全的类，避免将不相关的功能耦合在一起，来提高类的内聚性。<br>同时，类职责单一，类依赖的和被依赖的其他类也会变少，减少了代码的耦合性，以此来实现代码的高内聚、低耦合。<br>但是，如果拆分得过细，实际上会适得其反，反倒会降低内聚性，也会影响代码的可维护性。</p>
<p>举个栗子🌰 <code>Serialization</code> 类实现了一个 简单协议 的 序列化 和 反序列 功能</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Serialization</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(Map&lt;String, String&gt; object)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title">deserialize</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们想让类的职责更加单一，我们对 <code>Serialization</code> 类进一步拆分，拆分成一个只负责序列化工作的 <code>Serializer</code> 类和另一个只负责反序列化工作的 <code>Deserializer</code> 类。但是，现在如果我们修改了协议的格式，或者序列化方式从 <code>JSON</code> 改为了 <code>XML</code> ，那 <code>Serializer</code> 类和 <code>Deserializer</code> 类都需要做相应的修改，代码的内聚性显然没有原来 <code>Serialization</code> 高了。拆分之后，代码的可维护性变差了。</p>
<hr>
<h1 id="🚩开闭原则"><a href="#🚩开闭原则" class="headerlink" title="🚩开闭原则"></a>🚩开闭原则</h1><p>开闭原则 <code>(Open-Closed Principle 简称 OCP)</code> 是 <code>SOLID</code> 中最难理解、最难掌握，同时也是最有用的一条原则。</p>
<h2 id="1-如何理解-“对扩展开放、修改关闭”-？"><a href="#1-如何理解-“对扩展开放、修改关闭”-？" class="headerlink" title="1 如何理解 “对扩展开放、修改关闭”  ？"></a>1 如何理解 “对扩展开放、修改关闭”  ？</h2><p><code>software entities (modules, classes, functions, etc.) should be open for extension , but closed for modification(软件实体（模块、类、方法等）应该“对扩展开放、对修改关闭”。)</code></p>
<p>添加一个新的功能，应该是通过在已有代码基础上扩展代码（新增模块、类、方法、属性等），而非修改已有代码（修改模块、类、方法、属性等）的方式来完成。</p>
<ul>
<li>开闭原则并不是说完全杜绝修改，而是以最小的修改代码的代价来完成新功能的开发。</li>
<li>同样的代码改动，在粗代码粒度下，可能被认定为“修改”；在细代码粒度下，可能又被认定为“扩展”。</li>
</ul>
<h2 id="2-如何做到-“对扩展开放、修改关闭”-？"><a href="#2-如何做到-“对扩展开放、修改关闭”-？" class="headerlink" title="2 如何做到 “对扩展开放、修改关闭” ？"></a>2 如何做到 “对扩展开放、修改关闭” ？</h2><p>举个栗子🌰 一个警告通知系统，通过各种判断是否需要通知。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Alert</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> AlertRule rule;</span><br><span class="line">  <span class="keyword">private</span> Notification notification;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Alert</span><span class="params">(AlertRule rule, Notification notification)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.rule = rule;</span><br><span class="line">    <span class="keyword">this</span>.notification = notification;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(String api, <span class="keyword">long</span> requestCount, <span class="keyword">long</span> errorCount, <span class="keyword">long</span> durationOfSeconds)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> tps = requestCount / durationOfSeconds;</span><br><span class="line">    <span class="keyword">if</span> (tps &gt; rule.getMatchedRule(api).getMaxTps()) &#123;<span class="comment">//TPS 是否超过某个预先设置的最大值</span></span><br><span class="line">      notification.notify(NotificationEmergencyLevel.URGENCY, <span class="string">"..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (errorCount &gt; rule.getMatchedRule(api).getMaxErrorCount()) &#123;<span class="comment">//错误数 是否超过某个预先设置的最大值</span></span><br><span class="line">      notification.notify(NotificationEmergencyLevel.SEVERE, <span class="string">"..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>业务逻辑主要集中在 <code>check()</code> 函数中。现在，如果我们需要添加一个警告功能，当每秒钟接口超时请求个数，超过某个预先设置的最大阈值时，我们也要触发告警发送通知。这个时候，我们该如何改动代码呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Alert</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...省略AlertRule/Notification属性和构造函数...</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 改动一：添加参数timeoutCount</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(String api, <span class="keyword">long</span> requestCount, <span class="keyword">long</span> errorCount, <span class="keyword">long</span> timeoutCount, <span class="keyword">long</span> durationOfSeconds)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> tps = requestCount / durationOfSeconds;</span><br><span class="line">    <span class="keyword">if</span> (tps &gt; rule.getMatchedRule(api).getMaxTps()) &#123;...&#125;<span class="comment">//TPS 是否超过某个预先设置的最大值</span></span><br><span class="line">    <span class="keyword">if</span> (errorCount &gt; rule.getMatchedRule(api).getMaxErrorCount()) &#123;...&#125;<span class="comment">//错误数 是否超过某个预先设置的最大值</span></span><br><span class="line">    <span class="comment">// 改动二：添加接口超时处理逻辑</span></span><br><span class="line">    <span class="keyword">long</span> timeoutTps = timeoutCount / durationOfSeconds;</span><br><span class="line">    <span class="keyword">if</span> (timeoutTps &gt; rule.getMatchedRule(api).getMaxTimeoutTps()) &#123;</span><br><span class="line">      notification.notify(NotificationEmergencyLevel.URGENCY, <span class="string">"..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的代码修改实际上存在挺多问题的。</p>
<ul>
<li>一方面，我们对接口进行了修改，这就意味着调用这个接口的代码都要做相应的修改。</li>
<li>另一方面，修改了 <code>check()</code> 函数，相应的单元测试都需要修改</li>
</ul>
<p>这个代码改动是基于 “修改” 的方式来实现新功能的。如果我们遵循开闭原则，也就是 “对扩展开放、对修改关闭” 。那如何通过 “扩展” 的方式，来实现同样的功能呢？</p>
<p>先重构一下之前的 <code>Alert</code> 代码，让它的扩展性更好一些。重构的内容主要包含两部分：</p>
<ul>
<li>第一部分是将 <code>check()</code> 函数的多个入参封装成 <code>ApiStatInfo</code> 类；</li>
<li>第二部分是引入 <code>handler</code> 的概念，将 if 判断逻辑分散在各个 <code>handler</code> 中。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Alert</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> List&lt;AlertHandler&gt; alertHandlers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAlertHandler</span><span class="params">(AlertHandler alertHandler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.alertHandlers.add(alertHandler);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(ApiStatInfo apiStatInfo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (AlertHandler handler : alertHandlers) &#123;</span><br><span class="line">      handler.check(apiStatInfo);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiStatInfo</span> </span>&#123;<span class="comment">//省略constructor/getter/setter方法</span></span><br><span class="line">  <span class="keyword">private</span> String api;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> requestCount;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> errorCount;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> durationOfSeconds;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AlertHandler</span> </span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> AlertRule rule;</span><br><span class="line">  <span class="keyword">protected</span> Notification notification;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">AlertHandler</span><span class="params">(AlertRule rule, Notification notification)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.rule = rule;</span><br><span class="line">    <span class="keyword">this</span>.notification = notification;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(ApiStatInfo apiStatInfo)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TpsAlertHandler</span> <span class="keyword">extends</span> <span class="title">AlertHandler</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TpsAlertHandler</span><span class="params">(AlertRule rule, Notification notification)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(rule, notification);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(ApiStatInfo apiStatInfo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> tps = apiStatInfo.getRequestCount()/ apiStatInfo.getDurationOfSeconds();</span><br><span class="line">    <span class="keyword">if</span> (tps &gt; rule.getMatchedRule(apiStatInfo.getApi()).getMaxTps()) &#123;<span class="comment">//TPS 是否超过某个预先设置的最大值</span></span><br><span class="line">      notification.notify(NotificationEmergencyLevel.URGENCY, <span class="string">"..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErrorAlertHandler</span> <span class="keyword">extends</span> <span class="title">AlertHandler</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ErrorAlertHandler</span><span class="params">(AlertRule rule, Notification notification)</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(rule, notification);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(ApiStatInfo apiStatInfo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (apiStatInfo.getErrorCount() &gt; rule.getMatchedRule(apiStatInfo.getApi()).getMaxErrorCount()) &#123;<span class="comment">//错误数 是否超过某个预先设置的最大值</span></span><br><span class="line">      notification.notify(NotificationEmergencyLevel.SEVERE, <span class="string">"..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后再写一个单例提供配置和使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationContext</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> AlertRule alertRule;</span><br><span class="line">  <span class="keyword">private</span> Notification notification;</span><br><span class="line">  <span class="keyword">private</span> Alert alert;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initializeBeans</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    alertRule = <span class="keyword">new</span> AlertRule(<span class="comment">/*.省略参数.*/</span>); <span class="comment">//省略一些初始化代码</span></span><br><span class="line">    notification = <span class="keyword">new</span> Notification(<span class="comment">/*.省略参数.*/</span>); <span class="comment">//省略一些初始化代码</span></span><br><span class="line">    alert = <span class="keyword">new</span> Alert();<span class="comment">//添加警告方式</span></span><br><span class="line">    alert.addAlertHandler(<span class="keyword">new</span> TpsAlertHandler(alertRule, notification));</span><br><span class="line">    alert.addAlertHandler(<span class="keyword">new</span> ErrorAlertHandler(alertRule, notification));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Alert <span class="title">getAlert</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> alert; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 饿汉式单例</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ApplicationContext instance = <span class="keyword">new</span> ApplicationContext();</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">ApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    instance.initializeBeans();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ApplicationContext <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ApiStatInfo apiStatInfo = <span class="keyword">new</span> ApiStatInfo();</span><br><span class="line">    <span class="comment">// apiStatInfo.setxxx() ...省略设置apiStatInfo数据值的代码</span></span><br><span class="line">    ApplicationContext.getInstance().getAlert().check(apiStatInfo);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果再添加上面的那个新功能，每秒钟接口超时请求个数超过某个最大阈值就告警，我们又该如何改动代码呢？</p>
<ul>
<li>第一处改动是：在 <code>ApiStatInfo</code> 类中添加新的属性 <code>timeoutCount</code>。</li>
<li>第二处改动是：添加新的 <code>TimeoutAlertHander</code> 类。</li>
<li>第三处改动是：在 <code>ApplicationContext</code> 类的 <code>initializeBeans()</code> 方法中，往 alert 对象中注册新的 <code>timeoutAlertHandler</code>。</li>
<li>第四处改动是：在使用 <code>Alert</code> 类的时候，需要给 <code>check()</code> 函数的入参 <code>apiStatInfo</code> 对象设置 <code>timeoutCount</code> 的值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Alert</span> </span>&#123; <span class="comment">// 代码未改动... &#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiStatInfo</span> </span>&#123;<span class="comment">//省略constructor/getter/setter方法</span></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> timeoutCount; <span class="comment">// 改动一：添加新字段</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AlertHandler</span> </span>&#123; <span class="comment">//代码未改动... &#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TpsAlertHandler</span> <span class="keyword">extends</span> <span class="title">AlertHandler</span> </span>&#123;<span class="comment">//代码未改动...&#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErrorAlertHandler</span> <span class="keyword">extends</span> <span class="title">AlertHandler</span> </span>&#123;<span class="comment">//代码未改动...&#125;</span></span><br><span class="line"><span class="comment">// 改动二：添加新的handler</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeoutAlertHandler</span> <span class="keyword">extends</span> <span class="title">AlertHandler</span> </span>&#123;<span class="comment">//省略代码...&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationContext</span> </span>&#123;</span><br><span class="line">	  <span class="comment">//...</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initializeBeans</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    alert = <span class="keyword">new</span> Alert();</span><br><span class="line">    alert.addAlertHandler(<span class="keyword">new</span> TpsAlertHandler(alertRule, notification));</span><br><span class="line">    alert.addAlertHandler(<span class="keyword">new</span> ErrorAlertHandler(alertRule, notification));</span><br><span class="line">    <span class="comment">// 改动三：注册handler</span></span><br><span class="line">    alert.addAlertHandler(<span class="keyword">new</span> TimeoutAlertHandler(alertRule, notification));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...省略其他未改动代码...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ApiStatInfo apiStatInfo = <span class="keyword">new</span> ApiStatInfo();</span><br><span class="line">    <span class="comment">// ...省略apiStatInfo的set字段代码</span></span><br><span class="line">    apiStatInfo.setTimeoutCount(<span class="number">289</span>); <span class="comment">// 改动四：设置tiemoutCount值</span></span><br><span class="line">    ApplicationContext.getInstance().getAlert().check(apiStatInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重构之后的代码更加灵活和易扩展。如果我们要想添加新的告警逻辑，只需要基于扩展的方式创建新的 <code>handler</code> 类即可，不需要改动原来的 <code>check()</code> 函数的逻辑。而且，我们只需要为新的 handler 类添加单元测试，老的单元测试都不会失败，也不用修改。</p>
<h2 id="3-如何在项目中灵活应用开闭原则？"><a href="#3-如何在项目中灵活应用开闭原则？" class="headerlink" title="3 如何在项目中灵活应用开闭原则？"></a>3 如何在项目中灵活应用开闭原则？</h2><p>写出支持 “对扩展开放、对修改关闭” 的代码的关键是预留 <strong>扩展点</strong> 。那问题是如何才能识别出所有可能的扩展点呢？</p>
<p>要想识别出尽可能多的扩展点，就要对业务有足够的了解，能够知道当下以及未来可能要支持的业务需求。不过，有一句话说得好，“唯一不变的只有变化本身”。即便我们对业务、对系统有足够的了解，那也不可能识别出所有的扩展点，即便你能识别出所有的扩展点，为这些地方都预留扩展点，这样做的成本也是不可接受的。我们没必要为一些遥远的、不一定发生的需求去提前买单，做过度设计。</p>
<p>而且，开闭原则也并不是免费的。有些情况下，代码的扩展性会跟可读性相冲突。比如，我们之前举的 <code>Alert</code> 报警的例子。为了更好地支持扩展性，我们对代码进行了重构，重构之后的代码要比之前的代码复杂很多，理解起来也更加有难度。</p>
<p>总之，这里没有一个放之四海而皆准的参考标准，全凭实际的应用场景来决定。</p>
<hr>
<h1 id="🚩里氏替换原则"><a href="#🚩里氏替换原则" class="headerlink" title="🚩里氏替换原则"></a>🚩里氏替换原则</h1><p><code>(Liskov Substitution Principle 简称 LSP)</code></p>
<h2 id="1-如何理解-“里式替换原则”-？"><a href="#1-如何理解-“里式替换原则”-？" class="headerlink" title="1 如何理解 “里式替换原则” ？"></a>1 如何理解 “里式替换原则” ？</h2><p><code>If S is a subtype of T, then objects of type T may be replaced with objects of type S, without breaking the program。</code></p>
<p><code>Functions that use pointers of references to base classes must be able to use objects of derived classes without knowing it。</code></p>
<p><code>(子类对象能够替换程序中父类对象出现的任何地方，并且保证原来程序的逻辑行为不变及正确性不被破坏。)</code></p>
<p>里式替换原则更像是一个多态的规范。里式替换原则是用多态实现的，多态实现的子类不一定符合里式替换原则。</p>
<h2 id="2-如何做到-“里式替换原则”-？"><a href="#2-如何做到-“里式替换原则”-？" class="headerlink" title="2 如何做到 “里式替换原则” ？"></a>2 如何做到 “里式替换原则” ？</h2><p>举个栗子🌰 子类 <code>SecurityTransporter</code> 继承父类 <code>Transporter</code>，增加了额外的功能，支持传输 <code>appId</code> 和 <code>appToken</code> 安全认证信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Transporter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> HttpClient httpClient;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Transporter</span><span class="params">(HttpClient httpClient)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.httpClient = httpClient;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Response <span class="title">sendRequest</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...use httpClient to send request</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityTransporter</span> <span class="keyword">extends</span> <span class="title">Transporter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String appId;</span><br><span class="line">  <span class="keyword">private</span> String appToken;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SecurityTransporter</span><span class="params">(HttpClient httpClient, String appId, String appToken)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(httpClient);</span><br><span class="line">    <span class="keyword">this</span>.appId = appId;</span><br><span class="line">    <span class="keyword">this</span>.appToken = appToken;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Response <span class="title">sendRequest</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isNotBlank(appId) &amp;&amp; StringUtils.isNotBlank(appToken)) &#123;</span><br><span class="line">      request.addPayload(<span class="string">"app-id"</span>, appId);</span><br><span class="line">      request.addPayload(<span class="string">"app-token"</span>, appToken);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.sendRequest(request);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demoFunction</span><span class="params">(Transporter transporter)</span> </span>&#123;    </span><br><span class="line">    Reuqest request = <span class="keyword">new</span> Request();</span><br><span class="line">    <span class="comment">//...省略设置request中数据值的代码...</span></span><br><span class="line">    Response response = transporter.sendRequest(request);</span><br><span class="line">    <span class="comment">//...省略其他逻辑...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 里式替换原则</span></span><br><span class="line">Demo demo = <span class="keyword">new</span> Demo();</span><br><span class="line">demo.demofunction(<span class="keyword">new</span> SecurityTransporter(<span class="comment">/*省略参数*/</span>););</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，子类 SecurityTransporter 的设计完全符合里式替换原则，可以替换父类出现的任何位置，并且原来代码的逻辑行为不变且正确性也没有被破坏。</p>
<p>如果我们对 <code>SecurityTransporter</code> 类中 <code>sendRequest()</code> 函数稍加改造一下。改造前，如果 <code>appId</code> 或者 <code>appToken</code> 没有设置，我们就不做校验；改造后，如果 <code>appId</code> 或者 <code>appToken</code> 没有设置，则直接抛出 <code>NoAuthorizationRuntimeException</code> 未授权异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 改造后：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityTransporter</span> <span class="keyword">extends</span> <span class="title">Transporter</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...省略其他代码..</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Response <span class="title">sendRequest</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(appId) || StringUtils.isBlank(appToken)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoAuthorizationRuntimeException(...);</span><br><span class="line">    &#125;</span><br><span class="line">    request.addPayload(<span class="string">"app-id"</span>, appId);</span><br><span class="line">    request.addPayload(<span class="string">"app-token"</span>, appToken);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.sendRequest(request);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在改造之后的代码中，如果传递进 <code>demoFunction()</code> 函数的是父类 <code>Transporter</code> 对象，那 <code>demoFunction()</code> 函数并不会有异常抛出。<br>但如果传递给 <code>demoFunction()</code> 函数的是子类 <code>SecurityTransporter</code> 对象，那 <code>demoFunction()</code> 有可能会有异常抛出。<br>子类替换父类传递进 <code>demoFunction</code> 函数之后，整个程序的逻辑行为有了改变。这样就违背了里式替换原则，但是他还是由多态实现的。</p>
<p>多态 和 里式替换 有点类似，但它们关注的角度是不一样的。<br>多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法。它是一种代码实现的思路。<br>而里式替换是一种设计原则，是用来指导继承关系中子类该如何设计的，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑以及不破坏原有程序的正确性。</p>
<h2 id="3-哪些代码明显违背了-LSP？"><a href="#3-哪些代码明显违背了-LSP？" class="headerlink" title="3 哪些代码明显违背了 LSP？"></a>3 哪些代码明显违背了 LSP？</h2><ul>
<li><p>子类违背父类声明要实现的功能</p>
<p>父类中提供的 <code>sortOrdersByAmount()</code> 订单排序函数，是按照金额从小到大来给订单排序的，而子类重写这个 <code>sortOrdersByAmount()</code> 订单排序函数之后，是按照创建日期来给订单排序的。那子类的设计就违背里式替换原则。</p>
</li>
<li><p>子类违背父类对输入、输出、异常的约定</p>
<p>在父类中，某个函数约定：运行出错的时候返回 <code>null</code>；获取数据为空的时候返回空集合 <code>（empty collection）</code> 。而子类重载函数之后，实现变了，运行出错返回异常 <code>（exception）</code> ，获取不到数据返回 <code>null</code> 。那子类的设计就违背里式替换原则。</p>
<p>在父类中，某个函数约定，输入数据可以是任意整数，但子类实现的时候，只允许输入数据是正整数，负数就抛出，也就是说，子类对输入的数据的校验比父类更加严格，那子类的设计就违背了里式替换原则。</p>
<p>在父类中，某个函数约定，只会抛出 <code>ArgumentNullException</code> 异常，那子类的设计实现中只允许抛出 <code>ArgumentNullException</code> 异常，任何其他异常的抛出，都会导致子类违背里式替换原则。</p>
</li>
<li><p>子类违背父类注释中所罗列的任何特殊说明</p>
<p>父类中定义的 <code>withdraw()</code> 提现函数的注释是这么写的：“用户的提现金额不得超过账户余额……”，而子类重写 <code>withdraw()</code> 函数之后，针对 <code>VIP</code> 账号实现了透支提现的功能，也就是提现金额可以大于账户余额，那这个子类的设计也是不符合里式替换原则的。</p>
</li>
</ul>
<hr>
<h1 id="🚩接口隔离原则"><a href="#🚩接口隔离原则" class="headerlink" title="🚩接口隔离原则"></a>🚩接口隔离原则</h1><p><code>(Interface Segregation Principle 简称 ISP)</code></p>
<h2 id="1-如何理解-“接口隔离原则”-？"><a href="#1-如何理解-“接口隔离原则”-？" class="headerlink" title="1 如何理解 “接口隔离原则” ？"></a>1 如何理解 “接口隔离原则” ？</h2><p><code>Clients should not be forced to depend upon interfaces that they do not use (客户端不应该被强迫依赖它不需要的接口。其中的“客户端”，可以理解为接口的调用者或者使用者)</code></p>
<p>在这条原则中，我们可以把“接口”理解为下面三种东西：</p>
<ul>
<li>一组 <code>API</code> 接口集合</li>
<li>单个 <code>API</code> 接口或函数</li>
<li><code>OOP</code> 中的接口概念</li>
</ul>
<h2 id="2-如何做到-“接口隔离原则”-？"><a href="#2-如何做到-“接口隔离原则”-？" class="headerlink" title="2 如何做到 “接口隔离原则” ？"></a>2 如何做到 “接口隔离原则” ？</h2><ul>
<li>一组 <code>API</code> 接口集合</li>
</ul>
<p>微服务用户系统提供了一组跟用户相关的 <code>API</code> 给其他系统使用，比如：注册、登录、获取用户信息等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">register</span><span class="params">(String cellphone, String password)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">login</span><span class="params">(String cellphone, String password)</span></span>;</span><br><span class="line">  <span class="function">UserInfo <span class="title">getUserInfoById</span><span class="params">(<span class="keyword">long</span> id)</span></span>;</span><br><span class="line">  <span class="function">UserInfo <span class="title">getUserInfoByCellphone</span><span class="params">(String cellphone)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我们的后台管理系统要实现删除用户的功能，希望用户系统提供一个删除用户的接口。</p>
<p>删除用户是一个非常慎重的操作，我们只希望通过后台管理系统来执行，所以这个接口只限于给后台管理系统使用。如果我们把它放到 <code>UserService</code> 中，那所有使用到 <code>UserService</code> 的系统，都可以调用这个接口。不加限制地被其他业务系统调用，就有可能导致误删用户。</p>
<p>我们参照接口隔离原则，调用者不应该强迫依赖它不需要的接口，将删除接口单独放到另外一个接口 <code>RestrictedUserService</code> 中，然后将 <code>RestrictedUserService</code> 只打包提供给后台管理系统来使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RestrictedUserService</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">deleteUserByCellphone</span><span class="params">(String cellphone)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">deleteUserById</span><span class="params">(<span class="keyword">long</span> id)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span>, <span class="title">RestrictedUserService</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...省略实现代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在刚刚的这个例子中，我们把接口隔离原则中的接口，理解为一组接口集合，它可以是某个微服务的接口，也可以是某个类库的接口等等。</p>
<ul>
<li>单个 <code>API</code> 接口或函数</li>
</ul>
<p>把接口理解为单个接口或函数，那接口隔离原则就可以理解为：函数的设计要功能单一，不要将多个不同的功能逻辑在一个函数中实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Statistics</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Long max;</span><br><span class="line">  <span class="keyword">private</span> Long min;</span><br><span class="line">  <span class="keyword">private</span> Long average;</span><br><span class="line">  <span class="keyword">private</span> Long sum;</span><br><span class="line">  <span class="keyword">private</span> Long percentile99;</span><br><span class="line">  <span class="keyword">private</span> Long percentile999;</span><br><span class="line">  <span class="comment">//...省略constructor/getter/setter等方法...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Statistics <span class="title">count</span><span class="params">(Collection&lt;Long&gt; dataSet)</span> </span>&#123;</span><br><span class="line">  Statistics statistics = <span class="keyword">new</span> Statistics();</span><br><span class="line">  <span class="comment">//...省略计算逻辑 求最大值、最小值、平均值...</span></span><br><span class="line">  <span class="keyword">return</span> statistics;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按照接口隔离原则，我们应该把 <code>count()</code>  函数拆成几个更小粒度的函数，每个函数负责一个独立的统计功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">max</span><span class="params">(Collection&lt;Long&gt; dataSet)</span> </span>&#123; <span class="comment">//... &#125;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">min</span><span class="params">(Collection&lt;Long&gt; dataSet)</span> </span>&#123; <span class="comment">//... &#125; </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">average</span><span class="params">(Colletion&lt;Long&gt; dataSet)</span> </span>&#123; <span class="comment">//... &#125;</span></span><br><span class="line"><span class="comment">// ...省略其他统计函数...</span></span><br></pre></td></tr></table></figure>

<p>在某种意义上讲，<code>count()</code> 函数也不能算是职责不够单一，毕竟它做的事情只跟统计相关。判定功能是否单一，除了很强的主观性，还需要结合具体的场景。</p>
<p>如果在项目中，对每个统计需求，<code>Statistics</code> 定义的那几个统计信息都有涉及，那 <code>count()</code> 函数的设计就是合理的。如果每个统计需求只涉及 <code>Statistics</code> 罗列的统计信息中一部分，就会做很多无用功，势必影响代码的性能，特别是在需要统计的数据量很大的时候。<code>count()</code> 函数的设计就有点不合理了。</p>
<ul>
<li><code>OOP</code> 中的接口概念</li>
</ul>
<p>我们还可以把“接口”理解为 <code>OOP</code> 中的接口概念，比如 <code>Java</code> 中的 <code>interface</code>。</p>
<p>举个栗子🌰 假设我们的项目中用到了三个外部系统：<code>Redis</code>、<code>MySQL</code>、<code>Kafka</code>。每个系统都对应一系列配置信息，比如地址、端口、访问超时时间等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ConfigSource configSource; <span class="comment">//配置中心（比如zookeeper）</span></span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> timeout;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxTotal;</span><br><span class="line">    <span class="comment">//省略其他配置: maxWaitMillis,maxIdle,minIdle...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedisConfig</span><span class="params">(ConfigSource configSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.configSource = configSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.address;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...省略其他get()、init()方法...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//从configSource加载配置到address/timeout/maxTotal...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaConfig</span> </span>&#123; <span class="comment">//...省略... &#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MysqlConfig</span> </span>&#123; <span class="comment">//...省略... &#125;</span></span><br></pre></td></tr></table></figure>

<p>现在，我们有一个新的功能需求，以固定时间频率（<code>periodInSeconds</code>）来调用 <code>RedisConfig</code>、<code>KafkaConfig</code> 的 <code>update()</code> 方法更新配置信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Updater</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> <span class="title">implemets</span> <span class="title">Updater</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...省略其他属性和方法...</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123; <span class="comment">//... &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaConfig</span> <span class="keyword">implements</span> <span class="title">Updater</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...省略其他属性和方法...</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123; <span class="comment">//... &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MysqlConfig</span> </span>&#123; <span class="comment">//...省略其他属性和方法... &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledUpdater</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> initialDelayInSeconds;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> periodInSeconds;</span><br><span class="line">    <span class="keyword">private</span> Updater updater;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ScheduleUpdater</span><span class="params">(Updater updater, <span class="keyword">long</span> initialDelayInSeconds, <span class="keyword">long</span> periodInSeconds)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.updater = updater;</span><br><span class="line">        <span class="keyword">this</span>.initialDelayInSeconds = initialDelayInSeconds;</span><br><span class="line">        <span class="keyword">this</span>.periodInSeconds = periodInSeconds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        executor.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                updater.update();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="keyword">this</span>.initialDelayInSeconds, <span class="keyword">this</span>.periodInSeconds, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">  ConfigSource configSource = <span class="keyword">new</span> ZookeeperConfigSource(<span class="comment">/*省略参数*/</span>);</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> RedisConfig redisConfig = <span class="keyword">new</span> RedisConfig(configSource);</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> KafkaConfig kafkaConfig = <span class="keyword">new</span> KakfaConfig(configSource);</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> MySqlConfig mysqlConfig = <span class="keyword">new</span> MysqlConfig(configSource);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ScheduledUpdater redisConfigUpdater = <span class="keyword">new</span> ScheduledUpdater(redisConfig, <span class="number">300</span>, <span class="number">300</span>);</span><br><span class="line">    redisConfigUpdater.run();</span><br><span class="line">    </span><br><span class="line">    ScheduledUpdater kafkaConfigUpdater = <span class="keyword">new</span> ScheduledUpdater(kafkaConfig, <span class="number">60</span>, <span class="number">60</span>);</span><br><span class="line">    redisConfigUpdater.run();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新的 <code>ScheduledUpdater</code> 类，只依赖 <code>Updater</code> 这个相关的接口，不需要被强迫去依赖不需要的 <code>Viewer</code> 接口，满足接口隔离原则。功能是定时调用传入的 <code>Updater</code> 的 <code>update</code>  方法。</p>
<p>现在，我们又有了一个新的监控功能需求。我们想暴露 <code>MySQL</code> 和 <code>Redis</code> 的配置信息，输出项目的配置信息到一个固定的 HTTP 地址。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Viewer</span> </span>&#123;</span><br><span class="line">  <span class="function">String <span class="title">outputInPlainText</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">Map&lt;String, String&gt; <span class="title">output</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> <span class="title">implemets</span> <span class="title">Updater</span>, <span class="title">Viewer</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...省略其他属性和方法...</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123; <span class="comment">//... &#125;</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">outputInPlainText</span><span class="params">()</span> </span>&#123; <span class="comment">//... &#125;</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title">output</span><span class="params">()</span> </span>&#123; <span class="comment">//...&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaConfig</span> <span class="keyword">implements</span> <span class="title">Updater</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...省略其他属性和方法...</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123; <span class="comment">//... &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MysqlConfig</span> <span class="keyword">implements</span> <span class="title">Viewer</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...省略其他属性和方法...</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">outputInPlainText</span><span class="params">()</span> </span>&#123; <span class="comment">//... &#125;</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title">output</span><span class="params">()</span> </span>&#123; <span class="comment">//...&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleHttpServer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String host;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line">  <span class="keyword">private</span> Map&lt;String, List&lt;Viewer&gt;&gt; viewers = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SimpleHttpServer</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;<span class="comment">//...&#125;</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addViewers</span><span class="params">(String urlDirectory, Viewer viewer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!viewers.containsKey(urlDirectory)) &#123;</span><br><span class="line">      viewers.put(urlDirectory, <span class="keyword">new</span> ArrayList&lt;Viewer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.viewers.get(urlDirectory).add(viewer);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="comment">//... &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    ConfigSource configSource = <span class="keyword">new</span> ZookeeperConfigSource();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> RedisConfig redisConfig = <span class="keyword">new</span> RedisConfig(configSource);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> KafkaConfig kafkaConfig = <span class="keyword">new</span> KakfaConfig(configSource);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> MySqlConfig mysqlConfig = <span class="keyword">new</span> MySqlConfig(configSource);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ScheduledUpdater redisConfigUpdater =<span class="keyword">new</span> ScheduledUpdater(redisConfig, <span class="number">300</span>, <span class="number">300</span>);</span><br><span class="line">        redisConfigUpdater.run();</span><br><span class="line">        </span><br><span class="line">        ScheduledUpdater kafkaConfigUpdater =<span class="keyword">new</span> ScheduledUpdater(kafkaConfig, <span class="number">60</span>, <span class="number">60</span>);</span><br><span class="line">        kafkaConfigUpdater.run();</span><br><span class="line">        </span><br><span class="line">        SimpleHttpServer simpleHttpServer = <span class="keyword">new</span> SimpleHttpServer(“<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>”, <span class="number">2389</span>);</span><br><span class="line">        simpleHttpServer.addViewer(<span class="string">"/config"</span>, redisConfig);</span><br><span class="line">        simpleHttpServer.addViewer(<span class="string">"/config"</span>, mysqlConfig);</span><br><span class="line">        simpleHttpServer.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>SimpleHttpServer</code> 只依赖跟查看信息相关的 <code>Viewer</code> 接口，不依赖不需要的 <code>Updater</code> 接口，也满足接口隔离原则。</p>
<p>这种方式比普通大而全的 <code>Config</code> 接口更加灵活、易扩展、易复用，因为 <code>Updater</code>、<code>Viewer</code> 职责更加单一，添加新需求也容易应对。同时也防止了重写无用的接口，可读性更高。</p>
<h2 id="3-接口隔离原则与单一职责原则的区别"><a href="#3-接口隔离原则与单一职责原则的区别" class="headerlink" title="3 接口隔离原则与单一职责原则的区别"></a>3 接口隔离原则与单一职责原则的区别</h2><p>单一职责原则针对的是模块、类、接口的设计。</p>
<p>接口隔离原则相对于单一职责原则，一方面更侧重于接口的设计，另一方面它的思考角度也是不同的。</p>
<p>接口隔离原则提供了一种判断接口的职责是否单一的标准：通过调用者如何使用接口来间接地判定。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。</p>
<hr>
<h1 id="🚩依赖反转原则"><a href="#🚩依赖反转原则" class="headerlink" title="🚩依赖反转原则"></a>🚩依赖反转原则</h1><p>在讲 “依赖反转原则 <code>(Dependency Inversion Principe 简称 DIP)</code>” 之前，我们先讲一讲基础知识。</p>
<h2 id="1-控制反转"><a href="#1-控制反转" class="headerlink" title="1 控制反转"></a>1 控制反转</h2><p><code>（ Inversion Of Control IOC）</code></p>
<p>这里的 ”控制” 指的是对程序执行流程的控制，而 “反转” 指的是在没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流程可以通过框架来控制。流程的控制权从程序员 “反转” 到了框架。</p>
<p>举个栗子🌰 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">doTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;<span class="comment">//这部分逻辑可以放到框架中</span></span><br><span class="line">    <span class="keyword">if</span> (doTest()) &#123;</span><br><span class="line">      System.out.println(<span class="string">"Test succeed."</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">"Test failed."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，所有的流程都由程序员来控制。我们再来看，如何利用 ”控制反转“ 来实现同样的功能。</p>
<p>首先是框架代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCase</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (doTest()) &#123;</span><br><span class="line">      System.out.println(<span class="string">"Test succeed."</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">"Test failed."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">doTest</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JunitApplication</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;TestCase&gt; testCases = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(TestCase testCase)</span> </span>&#123;</span><br><span class="line">    testCases.add(testCase);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (TestCase <span class="keyword">case</span>: testCases) &#123;</span><br><span class="line">      <span class="keyword">case</span>.run();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>我们只需要在框架预留的扩展点，也就是 <code>TestCase</code> 类中的 <code>doTest()</code> 抽象函数中，填充具体的测试代码就可以实现之前的功能了，完全不需要写负责执行流程的 <code>main()</code> 函数了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceTest</span> <span class="keyword">extends</span> <span class="title">TestCase</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">doTest</span><span class="params">()</span> </span>&#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册操作还可以通过配置的方式来实现，不需要程序员显示调用register()</span></span><br><span class="line">JunitApplication.register(<span class="keyword">new</span> UserServiceTest();</span><br></pre></td></tr></table></figure>

<p>这就是典型的通过框架来实现 “控制反转” 的例子。</p>
<p>框架提供了一个可扩展的代码骨架，用来组装对象、管理整个执行流程。<br>程序员利用框架进行开发的时候，只需要往预留的扩展点上，添加跟自己业务相关的代码，就可以利用框架来驱动整个程序流程的执行。</p>
<p>控制反转并不是一种具体的实现技巧，而是一个比较笼统的设计思想，一般用来指导框架层面的设计。</p>
<h2 id="2-依赖注入"><a href="#2-依赖注入" class="headerlink" title="2 依赖注入"></a>2 依赖注入</h2><p><code>（Dependency Injection DI）</code></p>
<p>有一个非常形象的说法，那就是：依赖注入是一个标价 <code>25</code> 美元，实际上只值 <code>5</code> 美分的概念。也就是说，这个概念听起来很 “高大上” ，实际上，理解、应用起来非常简单。</p>
<p>那到底什么是依赖注入呢？<br>我们用一句话来概括就是：不通过 <code>new()</code> 的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类使用。</p>
<p>举个栗子🌰 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Notification</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> MessageSender messageSender;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 通过构造函数将messageSender传递进来</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Notification</span><span class="params">(MessageSender messageSender)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.messageSender = messageSender;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String cellphone, String message)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...省略校验逻辑等...</span></span><br><span class="line">    <span class="keyword">this</span>.messageSender.send(cellphone, message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用Notification</span></span><br><span class="line">MessageSender messageSender = <span class="keyword">new</span> MessageSender();</span><br><span class="line">Notification notification = <span class="keyword">new</span> Notification(messageSender);</span><br></pre></td></tr></table></figure>

<p>通过依赖注入的方式来将依赖的类对象传递进来，这样就提高了代码的扩展性，我们可以灵活地替换依赖的类。</p>
<p>这一点在我们之前讲 “开闭原则” 的时候也提到过。</p>
<p>上面代码还有继续优化的空间，我们还可以把 MessageSender 定义成接口，<strong>基于接口而非实现编程</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Notification</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> MessageSender messageSender;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Notification</span><span class="params">(MessageSender messageSender)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.messageSender = messageSender;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String cellphone, String message)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.messageSender.send(cellphone, message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MessageSender</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(String cellphone, String message)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 短信发送类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsSender</span> <span class="keyword">implements</span> <span class="title">MessageSender</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String cellphone, String message)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 站内信发送类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InboxSender</span> <span class="keyword">implements</span> <span class="title">MessageSender</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String cellphone, String message)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用Notification</span></span><br><span class="line">MessageSender messageSender = <span class="keyword">new</span> SmsSender();</span><br><span class="line">Notification notification = <span class="keyword">new</span> Notification(messageSender);</span><br></pre></td></tr></table></figure>

<p>依赖注入非常简单，但却非常有用！！它是编写可测试性代码最有效的手段。</p>
<p><strong>“基于接口而非实现编程” 跟 “依赖注入” ，看起来非常类似，那它俩有什么区别和联系呢？</strong></p>
<p>二者都是从外部传入依赖对象而不是在内部去 <code>new</code> 一个出来。</p>
<p>区别是 “基于接口而非实现编程” 强调的是 “接口” ，强调依赖的对象是接口，而不是具体的实现类；而 “依赖注入” 不强调这个，类或接口都可以，只要是从外部传入不是在内部 <code>new</code> 出来都可以称为依赖注入。</p>
<h2 id="3-依赖反转原则"><a href="#3-依赖反转原则" class="headerlink" title="3 依赖反转原则"></a>3 依赖反转原则</h2><p><code>（Dependency Inversion Principle DIP）</code></p>
<p><code>High-level modules shouldn’t depend on low-level modules. Both modules should depend on abstractions. In addition, abstractions shouldn’t depend on details. Details depend on abstractions. (高层模块（high-level modules）不要依赖低层模块（low-level）。高层模块和低层模块应该通过抽象（abstractions）来互相依赖。除此之外，抽象（abstractions）不要依赖具体实现细节（details），具体实现细节（details）依赖抽象（abstractions）。)</code></p>
<p>所谓高层模块和低层模块的划分，简单来说就是，在调用链上，<strong>调用者</strong> 属于高层，<strong>被调用者</strong> 属于低层。</p>
<p>依赖反转原则也叫作依赖倒置原则。这条原则跟控制反转有点类似，主要用来指导框架层面的设计。</p>
<p>举个栗子🌰 </p>
<p><code>Tomcat</code> 是运行 <code>Java Web</code> 应用程序的容器。<br>我们编写的 <code>Web</code> 应用程序代码只需要部署在 <code>Tomcat</code> 容器下，便可以被 <code>Tomcat</code> 容器调用执行。按照之前的划分原则，<code>Tomcat</code> 就是高层模块，我们编写的 <code>Web</code> 应用程序代码就是低层模块。<code>Tomcat</code> 和应用程序代码之间并没有直接的依赖关系，两者都依赖同一个 “抽象” ，也就是 <code>Servlet</code> 规范。<code>Servlet</code> 规范不依赖具体的 <code>Tomcat</code> 容器和应用程序的实现细节，而 <code>Tomcat</code> 容器和应用程序依赖 <code>Servlet</code> 规范。</p>
<hr>
<h1 id="🚩KISS-原则"><a href="#🚩KISS-原则" class="headerlink" title="🚩KISS 原则"></a>🚩KISS 原则</h1><p><code>Keep It Simple and Stupid.</code>  </p>
<p><code>Keep It Short and Simple.</code>   </p>
<p><code>Keep It Simple and Straightforward.</code> </p>
<p><code>(尽量保持简单。)</code></p>
<p>代码的可读性和可维护性是衡量代码质量非常重要的两个标准。而 <code>KISS</code> 原则就是保持代码可读和可维护的重要手段。代码足够简单，也就意味着很容易读懂，<code>bug</code> 比较难隐藏。即便出现 <code>bug</code>，修复起来也比较简单。</p>
<h2 id="1-代码行数越少就越“简单”吗？"><a href="#1-代码行数越少就越“简单”吗？" class="headerlink" title="1 代码行数越少就越“简单”吗？"></a>1 代码行数越少就越“简单”吗？</h2><p>举几个栗子🌰 对比一下。 检查输入的字符串 <code>ipAddress</code> 是否是合法的 IP 地址。一个合法的 <code>IP</code> 地址由四个数字组成，并且通过 “.” 来进行分割。每组数字的取值范围是 <code>0~255</code>。第一组数字比较特殊，不允许为 <code>0</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种实现方式: 使用正则表达式</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidIpAddressV1</span><span class="params">(String ipAddress)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (StringUtils.isBlank(ipAddress)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  String regex = <span class="string">"^(1\\d&#123;2&#125;|2[0-4]\\d|25[0-5]|[1-9]\\d|[1-9])\\."</span></span><br><span class="line">          + <span class="string">"(1\\d&#123;2&#125;|2[0-4]\\d|25[0-5]|[1-9]\\d|\\d)\\."</span></span><br><span class="line">          + <span class="string">"(1\\d&#123;2&#125;|2[0-4]\\d|25[0-5]|[1-9]\\d|\\d)\\."</span></span><br><span class="line">          + <span class="string">"(1\\d&#123;2&#125;|2[0-4]\\d|25[0-5]|[1-9]\\d|\\d)$"</span>;</span><br><span class="line">  <span class="keyword">return</span> ipAddress.matches(regex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种实现方式: 使用现成的工具类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidIpAddressV2</span><span class="params">(String ipAddress)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (StringUtils.isBlank(ipAddress)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  String[] ipUnits = StringUtils.split(ipAddress, <span class="string">'.'</span>);</span><br><span class="line">  <span class="keyword">if</span> (ipUnits.length != <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> ipUnitIntValue;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      ipUnitIntValue = Integer.parseInt(ipUnits[i]);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ipUnitIntValue &lt; <span class="number">0</span> || ipUnitIntValue &gt; <span class="number">255</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; ipUnitIntValue == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三种实现方式: 不使用任何工具类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidIpAddressV3</span><span class="params">(String ipAddress)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span>[] ipChars = ipAddress.toCharArray();</span><br><span class="line">  <span class="keyword">int</span> length = ipChars.length;</span><br><span class="line">  <span class="keyword">int</span> ipUnitIntValue = -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">boolean</span> isFirstUnit = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">int</span> unitsCount = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">    <span class="keyword">char</span> c = ipChars[i];</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">'.'</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (ipUnitIntValue &lt; <span class="number">0</span> || ipUnitIntValue &gt; <span class="number">255</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (isFirstUnit &amp;&amp; ipUnitIntValue == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (isFirstUnit) isFirstUnit = <span class="keyword">false</span>;</span><br><span class="line">      ipUnitIntValue = -<span class="number">1</span>;</span><br><span class="line">      unitsCount++;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ipUnitIntValue == -<span class="number">1</span>) ipUnitIntValue = <span class="number">0</span>;</span><br><span class="line">    ipUnitIntValue = ipUnitIntValue * <span class="number">10</span> + (c - <span class="string">'0'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (ipUnitIntValue &lt; <span class="number">0</span> || ipUnitIntValue &gt; <span class="number">255</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (unitsCount != <span class="number">3</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>第一种实现方式利用的是正则表达式<br>只用三行代码就把这个问题搞定了。它的代码行数最少，那是不是就最符合 KISS 原则呢？答案是否定的。虽然代码行数最少，看似最简单，实际上却很复杂。这正是因为它使用了正则表达式。</p>
<p>一方面，正则表达式本身是比较复杂的，写出完全没有 <code>bug</code> 的正则表达本身就比较有挑战；另一方面，并不是每个程序员都精通正则表达式。这种实现方式会导致代码的可读性和可维护性变差，所以，从 <code>KISS</code> 原则的设计初衷上来讲，这种实现方式并不符合 <code>KISS</code> 原则。</p>
</li>
<li><p>第二种实现方式使用了 <code>StringUtils</code> 类、<code>Integer</code> 类提供的一些现成的工具函数处理 <code>IP</code> 地址字符串。</p>
</li>
<li><p>第三种实现方式，不使用任何工具函数，而是通过逐一处理 <code>IP</code> 地址中的字符，来判断是否合法。</p>
<p>第三种实现方式完全是自己操作底层字符，只针对 <code>IP</code> 地址这一种格式的数据输入来做处理，没有太多多余的函数调用和其他不必要的处理逻辑，所以，在执行效率上，这种类似定制化的处理代码方式肯定比通用的工具类要高些。</p>
<p>从性能上来说，尽管第三种实现方式性能更高些，但还是更倾向于选择第二种实现方法。那是因为第三种实现方式实际上是一种过度优化。除非 <code>isValidIpAddress()</code> 函数是影响系统性能的瓶颈代码，否则，这样优化的投入产出比并不高，增加了代码实现的难度、牺牲了代码的可读性，性能上的提升却并不明显。</p>
<p>从代码行数上来说，这两种方式差不多。但是，第三种要比第二种更加有难度，更容易写出 <code>bug</code>。</p>
<p>从可读性上来说，第二种实现方式的代码逻辑更清晰、更好理解。</p>
<p>所以，在这两种实现方式中，第二种实现方式更加 “简单” ，更加符合 <code>KISS</code> 原则。</p>
</li>
</ul>
<h2 id="2-代码逻辑复杂就违背-KISS-原则吗？"><a href="#2-代码逻辑复杂就违背-KISS-原则吗？" class="headerlink" title="2 代码逻辑复杂就违背 KISS 原则吗？"></a>2 代码逻辑复杂就违背 KISS 原则吗？</h2><p>刚刚我们提到，并不是代码行数越少就越“简单”，还要考虑逻辑复杂度、实现难度、代码的可读性等。那如果一段代码的逻辑复杂、实现难度大、可读性也不太好，是不是就一定违背 <code>KISS</code> 原则呢？其实这也是由业务场景决定的。举个栗子🌰 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// KMP algorithm: a, b分别是主串和模式串；n, m分别是主串和模式串的长度。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kmp</span><span class="params">(<span class="keyword">char</span>[] a, <span class="keyword">int</span> n, <span class="keyword">char</span>[] b, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[] next = getNexts(b, m);</span><br><span class="line">  <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; a[i] != b[j]) &#123; <span class="comment">// 一直找到a[i]和b[j]</span></span><br><span class="line">      j = next[j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a[i] == b[j]) &#123;</span><br><span class="line">      ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j == m) &#123; <span class="comment">// 找到匹配模式串的了</span></span><br><span class="line">      <span class="keyword">return</span> i - m + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b表示模式串，m表示模式串的长度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getNexts(<span class="keyword">char</span>[] b, <span class="keyword">int</span> m) &#123;</span><br><span class="line">  <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">  next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> k = -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">    <span class="keyword">while</span> (k != -<span class="number">1</span> &amp;&amp; b[k + <span class="number">1</span>] != b[i]) &#123;</span><br><span class="line">      k = next[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (b[k + <span class="number">1</span>] == b[i]) &#123;</span><br><span class="line">      ++k;</span><br><span class="line">    &#125;</span><br><span class="line">    next[i] = k;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一段 <code>KMP</code> 字符串匹配算法，它以快速高效著称。<code>KMP</code> 字符串匹配算法完全符合我们刚提到的逻辑复杂、实现难度大、可读性差的特点，但当我们需要处理长文本字符串匹配问题（几百 <code>MB</code> 大小文本内容的匹配），或者字符串匹配是某个产品的核心功能（比如 <code>Vim</code>、<code>Word</code> 等文本编辑器），又或者字符串匹配算法是系统性能瓶颈的时候，这时它并不违反 <code>KISS</code> 原则。</p>
<p>本身就复杂的问题，用复杂的方法解决，并不违背 <code>KISS</code> 原则。</p>
<p>不过，平时的项目开发中涉及的字符串匹配问题，大部分都是针对比较小的文本。在这种情况下，直接调用编程语言提供的现成的字符串匹配函数就足够了。如果非得用 <code>KMP</code> 算法、BM 算法来实现字符串匹配，那就真的违背 <code>KISS</code> 原则了。</p>
<p>也就是说，同样的代码，在某个业务场景下满足 <code>KISS</code> 原则，换一个应用场景可能就不满足了。</p>
<h2 id="3-如何写出满足-KISS-原则的代码？"><a href="#3-如何写出满足-KISS-原则的代码？" class="headerlink" title="3 如何写出满足 KISS 原则的代码？"></a>3 如何写出满足 KISS 原则的代码？</h2><ul>
<li>不要使用同事可能不懂的技术来实现代码。比如前面例子中的正则表达式，还有一些编程语言中过于高级的语法等。</li>
<li>不要重复造轮子，要善于使用已经有的工具类库。经验证明，自己去实现这些类库，出 <code>bug</code> 的概率会更高，维护的成本也比较高。</li>
<li>不要过度优化。不要过度使用一些奇技淫巧（比如，位运算代替算术运算、复杂的条件语句代替 <code>if-else</code>、使用一些过于底层的函数等）来优化代码，牺牲代码的可读性。</li>
</ul>
<p>评判代码是否简单，有一个很有效的间接方法，那就是 <code>code review</code>。如果在 <code>code review</code> 的时候，同事对你的代码有很多疑问，那就说明你的代码有可能不够 “简单” ，需要优化啦。</p>
<p>我们在做开发的时候，一定不要过度设计，不要觉得简单的东西就没有技术含量。实际上，越是能用简单的方法解决复杂的问题，越能体现一个人的能力。</p>
<h2 id="4-YAGNI-原则跟-KISS-原则说的是一回事吗？"><a href="#4-YAGNI-原则跟-KISS-原则说的是一回事吗？" class="headerlink" title="4 YAGNI 原则跟 KISS 原则说的是一回事吗？"></a>4 YAGNI 原则跟 KISS 原则说的是一回事吗？</h2><p><code>You Ain’t Gonna Need It(你不会需要它)</code> </p>
<p>不要去设计当前用不到的功能；不要去编写当前用不到的代码。实际上，这条原则的核心思想就是：不要做过度设计。</p>
<p>对于 <code>Java</code> 程序员来说，我们经常使用 <code>Maven</code> 或者 <code>Gradle</code> 来管理依赖的类库（<code>library</code>），有些同事为了避免开发中 <code>library</code> 包缺失而频繁地修改 <code>Maven</code> 或者 <code>Gradle</code> 配置文件，提前往项目里引入大量常用的 <code>library</code> 包。实际上，这样的做法也是违背 YAGNI 原则的。</p>
<p><code>KISS</code> 原则讲的是 “如何做” 的问题（尽量保持简单），而 <code>YAGNI</code> 原则说的是 “要不要做” 的问题（当前不需要的就不要做）。</p>
<hr>
<h1 id="🚩DRY-原则"><a href="#🚩DRY-原则" class="headerlink" title="🚩DRY 原则"></a>🚩DRY 原则</h1><p><code>Don’t Repeat Yourself(不要重复自己)</code> </p>
<p>可以理解为：不要写重复的代码。</p>
<p>你可能会觉得，这条原则非常简单、非常容易应用。只要两段代码长得一样，那就是违反 <code>DRY</code> 原则了。真的是这样吗？<br>答案是否定的。这是很多人对这条原则存在的误解。实际上，重复的代码不一定违反 <code>DRY</code> 原则，而且有些看似不重复的代码也有可能违反 <code>DRY</code> 原则。</p>
<h2 id="1-实现逻辑重复"><a href="#1-实现逻辑重复" class="headerlink" title="1 实现逻辑重复"></a>1 实现逻辑重复</h2><p>举个栗子🌰 有两处非常明显的重复的代码片段：<code>isValidUserName()</code> 函数和 <code>isValidPassword()</code> 函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserAuthenticator</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">authenticate</span><span class="params">(String username, String password)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isValidUsername(username)) &#123;</span><br><span class="line">      <span class="comment">// ...throw InvalidUsernameException...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isValidPassword(password)) &#123;</span><br><span class="line">      <span class="comment">// ...throw InvalidPasswordException...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...省略其他代码...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValidUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// check not null, not empty</span></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(username)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// check length: 4~64</span></span><br><span class="line">    <span class="keyword">int</span> length = username.length();</span><br><span class="line">    <span class="keyword">if</span> (length &lt; <span class="number">4</span> || length &gt; <span class="number">64</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// contains only lowcase characters</span></span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.isAllLowerCase(username)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// contains only a~z,0~9,dot</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">      <span class="keyword">char</span> c = username.charAt(i);</span><br><span class="line">      <span class="keyword">if</span> (!(c &gt;= <span class="string">'a'</span> &amp;&amp; c &lt;= <span class="string">'z'</span>) || (c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) || c == <span class="string">'.'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValidPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// check not null, not empty</span></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(password)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// check length: 4~64</span></span><br><span class="line">    <span class="keyword">int</span> length = password.length();</span><br><span class="line">    <span class="keyword">if</span> (length &lt; <span class="number">4</span> || length &gt; <span class="number">64</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// contains only lowcase characters</span></span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.isAllLowerCase(password)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// contains only a~z,0~9,dot</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">      <span class="keyword">char</span> c = password.charAt(i);</span><br><span class="line">      <span class="keyword">if</span> (!(c &gt;= <span class="string">'a'</span> &amp;&amp; c &lt;= <span class="string">'z'</span>) || (c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) || c == <span class="string">'.'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重复的代码被敲了两遍，或者简单 <code>copy-paste</code> 了一下，看起来明显违反 <code>DRY</code> 原则。为了移除重复的代码，我们对上面的代码做下重构，将 <code>isValidUserName()</code> 函数和 <code>isValidPassword()</code> 函数，合并为一个更通用的函数 <code>isValidUserNameOrPassword()</code> 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserAuthenticatorV2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">authenticate</span><span class="params">(String userName, String password)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isValidUsernameOrPassword(userName)) &#123;</span><br><span class="line">      <span class="comment">// ...throw InvalidUsernameException...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isValidUsernameOrPassword(password)) &#123;</span><br><span class="line">      <span class="comment">// ...throw InvalidPasswordException...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValidUsernameOrPassword</span><span class="params">(String usernameOrPassword)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//省略实现逻辑</span></span><br><span class="line">    <span class="comment">//跟原来的isValidUsername()或isValidPassword()的实现逻辑一样...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过重构之后，代码行数减少了，也没有重复的代码了，是不是更好了呢？答案是否定的！！</p>
<p>合并之后的 <code>isValidUserNameOrPassword()</code> 函数，负责两件事情：验证用户名和验证密码，违反了 “单一职责原则” 和 “接口隔离原则” 。</p>
<p>从代码实现逻辑上看起来是重复的，但是从语义上并不重复。所谓 “语义不重复” 指的是：从功能上来看，这两个函数干的是完全不重复的两件事情，一个是校验用户名，另一个是校验密码。<br>经过重构之后，在未来的某一天，如果我们修改了密码的校验逻辑，我们就要把合并后的函数，重新拆成合并前的那两个函数。</p>
<p>尽管代码的实现逻辑是相同的，但语义不同，我们判定它并不违反 <code>DRY</code> 原则。对于包含重复代码的问题，我们可以通过抽象成更细粒度函数的方式来解决。</p>
<h2 id="2-功能语义重复"><a href="#2-功能语义重复" class="headerlink" title="2 功能语义重复"></a>2 功能语义重复</h2><p>在同一个项目代码中有下面两个函数：<code>isValidIp()</code> 和 <code>checkIfIpValid()</code>。尽管两个函数的命名不同，实现逻辑不同，但功能是相同的，都是用来判定 <code>IP</code>地址是否合法的。</p>
<p>之所以在同一个项目中会有两个功能相同的函数，那是因为这两个函数是由两个不同的同事开发的，这时经常遇到的，其中一个同事在不知道已经存在相同功能的情况下又写了一个。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidIp</span><span class="params">(String ipAddress)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (StringUtils.isBlank(ipAddress)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  String regex = <span class="string">"^(1\\d&#123;2&#125;|2[0-4]\\d|25[0-5]|[1-9]\\d|[1-9])\\."</span></span><br><span class="line">          + <span class="string">"(1\\d&#123;2&#125;|2[0-4]\\d|25[0-5]|[1-9]\\d|\\d)\\."</span></span><br><span class="line">          + <span class="string">"(1\\d&#123;2&#125;|2[0-4]\\d|25[0-5]|[1-9]\\d|\\d)\\."</span></span><br><span class="line">          + <span class="string">"(1\\d&#123;2&#125;|2[0-4]\\d|25[0-5]|[1-9]\\d|\\d)$"</span>;</span><br><span class="line">  <span class="keyword">return</span> ipAddress.matches(regex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkIfIpValid</span><span class="params">(String ipAddress)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (StringUtils.isBlank(ipAddress)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  String[] ipUnits = StringUtils.split(ipAddress, <span class="string">'.'</span>);</span><br><span class="line">  <span class="keyword">if</span> (ipUnits.length != <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> ipUnitIntValue;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      ipUnitIntValue = Integer.parseInt(ipUnits[i]);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ipUnitIntValue &lt; <span class="number">0</span> || ipUnitIntValue &gt; <span class="number">255</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; ipUnitIntValue == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，尽管两段代码的实现逻辑不重复，但语义重复，也就是功能重复，我们认为它违反了 DRY 原则。我们应该在项目中，统一一种实现思路，所有用到判断 <code>IP</code> 地址是否合法的地方，都统一调用同一个函数。</p>
<p>假设我们不统一实现思路，给不熟悉这部分代码的同事增加了阅读的难度。同事有可能研究了半天，觉得功能是一样的，但又有点疑惑，觉得是不是有更高深的考量，才定义了两个功能类似的函数，最终发现居然是代码设计的问题。</p>
<p>除此之外，如果哪天项目中 <code>IP</code> 地址是否合法的判定规则改变了，相应地，我们对 <code>isValidIp()</code> 的实现逻辑做了相应的修改，但却忘记了修改 <code>checkIfIpValid()</code> 函数。又或者，我们压根就不知道还存在一个功能相同的 <code>checkIfIpValid()</code> 函数，这样就会导致有些代码仍然使用老的 <code>IP</code> 地址判断逻辑，导致出现一些莫名其妙的 <code>bug</code>。</p>
<h2 id="3-代码执行重复"><a href="#3-代码执行重复" class="headerlink" title="3 代码执行重复"></a>3 代码执行重复</h2><p>第三个栗子🌰 <code>UserService</code> 中 <code>login()</code> 函数用来校验用户登录是否成功。如果失败，就返回异常；如果成功，就返回用户信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> UserRepo userRepo;<span class="comment">//通过依赖注入或者IOC框架注入</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> User <span class="title">login</span><span class="params">(String email, String password)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> existed = userRepo.checkIfUserExisted(email, password);</span><br><span class="line">    <span class="keyword">if</span> (!existed) &#123;<span class="comment">/*...throw AuthenticationFailureException...*/</span>&#125;</span><br><span class="line">    User user = userRepo.getUserByEmail(email);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRepo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkIfUserExisted</span><span class="params">(String email, String password)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!EmailValidation.validate(email)) &#123;<span class="comment">/*...throw InvalidEmailException...*/</span>&#125;</span><br><span class="line">    <span class="keyword">if</span> (!PasswordValidation.validate(password)) &#123;<span class="comment">/*...throw InvalidPasswordException...*/</span>&#125;</span><br><span class="line">    <span class="comment">//...query db to check if email&amp;password exists...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> User <span class="title">getUserByEmail</span><span class="params">(String email)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!EmailValidation.validate(email)) &#123;<span class="comment">/*...throw InvalidEmailException...*/</span>&#125;</span><br><span class="line">    <span class="comment">//...query db to get user by email...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码，既没有逻辑重复，也没有语义重复，但仍然违反了 <code>DRY</code> 原则。这是因为代码中存在 “执行重复” 。</p>
<p><code>email</code> 的校验逻辑被执行了两次。一次是在调用 <code>checkIfUserExisted()</code> 函数的时候，另一次是调用 <code>getUserByEmail()</code> 函数的时候。我们只需要将校验逻辑从 <code>UserRepo</code> 中移除，统一放到 <code>UserService</code> 中就可以了。</p>
<p>代码中还有一处比较隐蔽的执行重复，<code>login()</code> 函数并不需要调用 <code>checkIfUserExisted()</code> 函数，只需要调用一次 <code>getUserByEmail()</code> 函数，从数据库中获取到用户的 <code>email</code>、<code>password</code> 等信息，然后跟用户输入的 <code>email</code>、<code>password</code> 信息做对比，依次判断是否登录成功。</p>
<p>这样的优化是很有必要的。因为 <code>checkIfUserExisted()</code> 函数和 <code>getUserByEmail()</code> 函数都需要查询数据库，而数据库这类的 <code>I/O</code> 操作是比较耗时的。我们在写代码的时候，应当尽量减少这类 <code>I/O</code> 操作。</p>
<p>按照刚刚的修改思路，我们把代码重构一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> UserRepo userRepo;<span class="comment">//通过依赖注入或者IOC框架注入</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> User <span class="title">login</span><span class="params">(String email, String password)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!EmailValidation.validate(email)) &#123;<span class="comment">/*...throw InvalidEmailException...*/</span>&#125;</span><br><span class="line">    <span class="keyword">if</span> (!PasswordValidation.validate(password)) &#123;<span class="comment">/*...throw InvalidPasswordException...*/</span>&#125;</span><br><span class="line"></span><br><span class="line">    User user = userRepo.getUserByEmail(email);</span><br><span class="line">    <span class="keyword">if</span> (user == <span class="keyword">null</span> || !password.equals(user.getPassword())  &#123;<span class="comment">/*...throw AuthenticationFailureException...*/</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRepo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> User <span class="title">getUserByEmail</span><span class="params">(String email)</span> </span>&#123;<span class="comment">/*...query db to get user by email...*/</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-怎么提高代码复用性？"><a href="#4-怎么提高代码复用性？" class="headerlink" title="4 怎么提高代码复用性？"></a>4 怎么提高代码复用性？</h2><ul>
<li><p>减少代码耦合</p>
<p>对于高度耦合的代码，当我们希望复用其中的一个功能，想把这个功能的代码抽取出来成为一个独立的模块、类或者函数的时候，往往会发现牵一发而动全身。移动一点代码，就要牵连到很多其他相关的代码。所以，高度耦合的代码会影响到代码的复用性，我们要尽量减少代码耦合。</p>
</li>
<li><p>满足单一职责原则</p>
<p>如果职责不够单一，模块、类设计得大而全，那依赖它的代码或者它依赖的代码就会比较多，进而增加了代码的耦合。根据上一点，也就会影响到代码的复用性。相反，越细粒度的代码，代码的通用性会越好，越容易被复用。</p>
</li>
<li><p>模块化</p>
<p>这里的 “模块” ，不单单指一组类构成的模块，还可以理解为单个类、函数。我们要善于将功能独立的代码，封装成模块。独立的模块就像一块一块的积木，更加容易复用，可以直接拿来搭建更加复杂的系统。</p>
</li>
<li><p>业务与非业务逻辑分离</p>
<p>越是跟业务无关的代码越是容易复用，越是针对特定业务的代码越难复用。所以，为了复用跟业务无关的代码，我们将业务和非业务逻辑代码分离，抽取成一些通用的框架、类库、组件等。</p>
</li>
<li><p>通用代码下沉</p>
<p>从分层的角度来看，越底层的代码越通用、会被越多的模块调用，越应该设计得足够可复用。一般情况下，在代码分层之后，为了避免交叉调用导致调用关系混乱，我们只允许上层代码调用下层代码及同层代码之间的调用，杜绝下层代码调用上层代码。所以，通用的代码我们尽量下沉到更下层。</p>
</li>
<li><p>继承、多态、抽象、封装</p>
<p>利用继承，可以将公共的代码抽取到父类，子类复用父类的属性和方法。利用多态，我们可以动态地替换一段代码的部分逻辑，让这段代码可复用。除此之外，抽象和封装，从更加广义的层面、而非狭义的面向对象特性的层面来理解的话，越抽象、越不依赖具体的实现，越容易复用。代码封装成模块，隐藏可变的细节、暴露不变的接口，就越容易复用。</p>
</li>
<li><p>应用模板等设计模式</p>
<p>一些设计模式，也能提高代码的复用性。比如，模板模式利用了多态来实现，可以灵活地替换其中的部分代码，整个流程模板代码可复用。</p>
</li>
</ul>
<h2 id="5-辩证思考和灵活应用"><a href="#5-辩证思考和灵活应用" class="headerlink" title="5 辩证思考和灵活应用"></a>5 辩证思考和灵活应用</h2><p>实际上，编写可复用的代码并不简单。<br>除非有非常明确的复用需求，否则，为了暂时用不到的复用需求，花费太多的时间、精力，投入太多的开发成本，并不是一个值得推荐的做法。这也违反我们之前讲到的 <code>YAGNI</code> 原则。</p>
<p>有一个著名的原则，叫作 <code>“Rule of Three”</code> 。这条原则可以用在很多行业和场景中，我们在第一次写代码的时候，如果当下没有复用的需求，而未来的复用需求也不是特别明确，并且开发可复用代码的成本比较高，那我们就不需要考虑代码的复用性。<br>在之后我们开发新的功能的时候，发现可以复用之前写的这段代码，那我们就重构这段代码，让其变得更加可复用。</p>
<p>也就是说，第一次编写代码的时候，我们不考虑复用性；第二次遇到复用场景的时候，再进行重构使其复用。需要注意的是，<code>“Rule of Three”</code> 中的 <code>“Three”</code> 并不是真的就指确切的 <code>“三”</code> 。</p>
<hr>
<h1 id="🚩迪米特法则"><a href="#🚩迪米特法则" class="headerlink" title="🚩迪米特法则"></a>🚩迪米特法则</h1><p><code>Law of Demeter LOD</code></p>
<p><code>Each unit should have only limited knowledge about other units: only units “closely” related to the current unit. Or: Each unit should only talk to its friends; Don’t talk to strangers.(每个模块（unit）只应该了解那些与它关系密切的模块（units: only units “closely” related to the current unit）的有限知识（knowledge）。或者说，每个模块只和自己的朋友“说话”（talk），不和陌生人“说话”（talk）。)</code></p>
<p><code>不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口（也就是定义中的“有限知识”）。</code></p>
<p>迪米特法则。尽管它不像 <code>SOLID</code>、<code>KISS</code>、<code>DRY</code> 原则那样，人尽皆知，但它却非常实用。利用这个原则，能够帮我们实现代码的 “高内聚、松耦合” 。</p>
<h2 id="1-何为-“高内聚、松耦合”-？"><a href="#1-何为-“高内聚、松耦合”-？" class="headerlink" title="1 何为 “高内聚、松耦合” ？"></a>1 何为 “高内聚、松耦合” ？</h2><p>在这个设计思想中，“高内聚” 用来指导类本身的设计，“松耦合” 用来指导类与类之间依赖关系的设计。不过，这两者并非完全独立不相干。高内聚有助于松耦合，松耦合又需要高内聚的支持。</p>
<ul>
<li><p>所谓高内聚，就是指相近的功能应该放到同一个类中，不相近的功能不要放到同一个类中。</p>
<p>相近的功能往往会被同时修改，放到同一个类中，修改会比较集中，代码容易维护。实际上，单一职责原则是实现代码高内聚非常有效的设计原则。</p>
</li>
<li><p>所谓松耦合是说，在代码中，类与类之间的依赖关系简单清晰。</p>
<p>即使两个类有依赖关系，一个类的代码改动不会或者很少导致依赖类的代码改动。实际上，我们前面讲的依赖注入、接口隔离、基于接口而非实现编程，以及迪米特法则，都是为了实现代码的松耦合。</p>
</li>
</ul>
<p>##2 不该有直接依赖关系的类之间，不要有依赖</p>
<p>迪米特法则的前半部分，</p>
<h2 id="2-不该有直接依赖关系的类之间，不要有依赖"><a href="#2-不该有直接依赖关系的类之间，不要有依赖" class="headerlink" title="2 不该有直接依赖关系的类之间，不要有依赖"></a>2 不该有直接依赖关系的类之间，不要有依赖</h2><p>举个栗子🌰 代码中包含三个主要的类。其中，<code>NetworkTransporter</code> 类负责底层网络通信，根据请求获取数据；<code>HtmlDownloader</code> 类用来通过 <code>URL</code> 获取网页；<code>Document</code> 表示网页文档，后续的网页内容抽取、分词、索引都是以此为处理对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NetworkTransporter</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略属性和其他方法...</span></span><br><span class="line">    <span class="keyword">public</span> Byte[] send(HtmlRequest htmlRequest) &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HtmlDownloader</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> NetworkTransporter transporter;<span class="comment">//通过构造函数或IOC注入</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Html <span class="title">downloadHtml</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">    Byte[] rawHtml = transporter.send(<span class="keyword">new</span> HtmlRequest(url));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Html(rawHtml);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Document</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Html html;</span><br><span class="line">  <span class="keyword">private</span> String url;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Document</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.url = url;</span><br><span class="line">    HtmlDownloader downloader = <span class="keyword">new</span> HtmlDownloader();</span><br><span class="line">    <span class="keyword">this</span>.html = downloader.downloadHtml(url);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>首先看 <code>NetworkTransporter</code> 类</strong></p>
<p>作为一个底层网络通信类，我们希望它的功能尽可能通用，而不只是服务于下载 <code>HTML</code>，所有这里的参数 <code>HtmlRequest</code> 就限制了这个功能，我们不应该直接依赖太具体的发送对象 <code>HtmlRequest</code>。从这一点上讲，<code>NetworkTransporter</code> 类的设计违背迪米特法则，依赖了不该有直接依赖关系的 <code>HtmlRequest</code> 类。</p>
<p>有一个很形象的比喻。假如你现在要去商店买东西，你肯定不会直接把钱包给收银员，让收银员自己从里面拿钱，而是你从钱包里把钱拿出来交给收银员。这里的 <code>HtmlRequest</code> 对象就相当于钱包，<code>HtmlRequest</code> 里的 <code>address</code> 和 <code>content</code> 对象就相当于钱。我们应该把 <code>address</code> 和 <code>content</code> 交给 <code>NetworkTransporter</code>，而非是直接把 <code>HtmlRequest</code> 交给 <code>NetworkTransporter</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NetworkTransporter</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略属性和其他方法...</span></span><br><span class="line">    <span class="keyword">public</span> Byte[] send(String address, Byte[] data) &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>再来看 <code>HtmlDownloader</code> 类</strong></p>
<p>根据 <code>NetworkTransporter</code> 的修改 <code>HtmlDownloader</code> 也得做相应的修改。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HtmlDownloader</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> NetworkTransporter transporter;<span class="comment">//通过构造函数或IOC注入</span></span><br><span class="line">  <span class="comment">// HtmlDownloader这里也要有相应的修改</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Html <span class="title">downloadHtml</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">    HtmlRequest htmlRequest = <span class="keyword">new</span> HtmlRequest(url);</span><br><span class="line">    Byte[] rawHtml = transporter.send(</span><br><span class="line">      htmlRequest.getAddress(), htmlRequest.getContent().getBytes());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Html(rawHtml);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>最后是 <code>Document</code> 类</strong></p>
<p>主要有三点。<br>第一，构造函数中的 <code>downloader.downloadHtml()</code> 逻辑复杂，耗时长，不应该放到构造函数中，会影响代码的可测试性<br>第二，<code>HtmlDownloader</code> 对象在构造函数中通过 <code>new</code> 来创建，违反了基于接口而非实现编程的设计思想，也会影响到代码的可测试性<br>第三，从业务含义上来讲，<code>Document</code> 网页文档没必要依赖 HtmlDownloader 类，违背了迪米特法则。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Document</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Html html;</span><br><span class="line">  <span class="keyword">private</span> String url;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Document</span><span class="params">(String url, Html html)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.html = html;</span><br><span class="line">    <span class="keyword">this</span>.url = url;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过一个工厂方法来创建Document</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DocumentFactory</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> HtmlDownloader downloader;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DocumentFactory</span><span class="params">(HtmlDownloader downloader)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.downloader = downloader;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Document <span class="title">createDocument</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">    Html html = downloader.downloadHtml(url);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Document(url, html);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就很好的解决了三个问题。</p>
</li>
</ul>
<h2 id="3-有依赖关系的类之间，尽量只依赖必要的接口"><a href="#3-有依赖关系的类之间，尽量只依赖必要的接口" class="headerlink" title="3 有依赖关系的类之间，尽量只依赖必要的接口"></a>3 有依赖关系的类之间，尽量只依赖必要的接口</h2><p>举个之前的栗子🌰  <code>Serialization</code> 类负责对象的序列化和反序列化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Serialization</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">    String serializedResult = ...;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> serializedResult;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">deserialize</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    Object deserializedResult = ...;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> deserializedResult;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单看这个类的设计，没有一点问题。<br>假设在我们的项目中，有些类只用到了序列化操作，而另一些类只用到反序列化操作。那基于迪米特法则后半部分 “有依赖关系的类之间，尽量只依赖必要的接口” ，只用到序列化操作的那部分类不应该依赖反序列化接口。同理，只用到反序列化操作的那部分类不应该依赖序列化接口。<br>那我们是不是又得把这个类拆开成两个类？那不就和之前在单一职责中说的冲突了吗？之前我们就说拆分后代码的内聚性显然没有原来 <code>Serialization</code> 高了。那有没有既不违背高内聚的设计思想，也不违背迪米特法则的方法呢？🤔🤔<br>既然在这说了，肯定是有的😁<br>我们可以利用 “接口隔离原则” 来解决这个问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  <span class="function">String <span class="title">serialize</span><span class="params">(Object object)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Deserializable</span> </span>&#123;</span><br><span class="line">  <span class="function">Object <span class="title">deserialize</span><span class="params">(String text)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Serialization</span> <span class="keyword">implements</span> <span class="title">Serializable</span>, <span class="title">Deserializable</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">    String serializedResult = ...;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> serializedResult;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">deserialize</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    Object deserializedResult = ...;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> deserializedResult;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoClass_1</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Serializable serializer;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Demo</span><span class="params">(Serializable serializer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.serializer = serializer;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoClass_2</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Deserializable deserializer;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Demo</span><span class="params">(Deserializable deserializer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.deserializer = deserializer;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尽管我们还是要往 <code>DemoClass_1</code> 的构造函数中，传入包含序列化和反序列化的 <code>Serialization</code> 实现类，但是，我们依赖的 <code>Serializable</code> 接口只包含序列化操作，<code>DemoClass_1</code> 无法使用 <code>Serialization</code> 类中的反序列化接口，对反序列化操作无感知，这也就符合了迪米特法则后半部分所说的 “依赖有限接口”的要求 。</p>
<p>上面的代码实现思路，也体现了 “基于接口而非实现编程” 的设计原则，结合迪米特法则，我们可以总结出一条新的设计原则，那就是 “基于最小接口而非最大实现编程”。</p>
<p>新的设计模式和设计原则是怎么创造出来的，实际上，就是在大量的实践中，针对开发痛点总结归纳出来的套路。</p>
<h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h1><blockquote>
<p><a href="https://time.geekbang.org/column/intro/250?utm_source=pinpaizhuanqu&utm_medium=geektime&utm_campaign=guanwang&utm_term=guanwang&utm_content=0511" target="_blank" rel="noopener">设计模式之美</a></p>
<p><a href="https://juejin.im/post/5d669bfc6fb9a06b1b19d25e" target="_blank" rel="noopener">通过代码示例来学习面向对象六大原则</a></p>
<p><a href="https://blog.cleancoder.com/" target="_blank" rel="noopener">The Clean Code Blog</a></p>
</blockquote>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">CalmCenter</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://calmcenter.club/2020/design-philosophy.html">https://calmcenter.club/2020/design-philosophy.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://calmcenter.club" target="_blank">CalmCenter</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%BC%96%E7%A0%81/">编码</a></div><div class="post_share"></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="/img/wechat.png" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="post-qr-code__img" src="/img/alipay.png" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/design-mode.html"><img class="prev_cover" data-src="https://gitee.com/CalmCenter/Pic/raw/master/cover42.webp" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">设计模式篇</div></div></a></div><div class="next-post pull_right"><a href="/2020/stability-optimization.html"><img class="next_cover" data-src="https://gitee.com/CalmCenter/Pic/raw/master/cover26.webp" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">稳定性优化</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/design-pattern-proxy.html" title="设计模式-结构型-代理模式"><img class="relatedPosts_cover" data-src="https://gitee.com/CalmCenter/Pic/raw/master/cover40.webp"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-07-13</div><div class="relatedPosts_title">设计模式-结构型-代理模式</div></div></a></div><div class="relatedPosts_item"><a href="/2020/design-mode.html" title="设计模式篇"><img class="relatedPosts_cover" data-src="https://gitee.com/CalmCenter/Pic/raw/master/cover42.webp"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-06-11</div><div class="relatedPosts_title">设计模式篇</div></div></a></div><div class="relatedPosts_item"><a href="/2020/design-pattern-decorator.html" title="设计模式-结构型-装饰模式"><img class="relatedPosts_cover" data-src="https://gitee.com/CalmCenter/Pic/raw/master/cover53.webp"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-07-29</div><div class="relatedPosts_title">设计模式-结构型-装饰模式</div></div></a></div><div class="relatedPosts_item"><a href="/2020/oop.html" title="设计模式篇-面向对象"><img class="relatedPosts_cover" data-src="https://gitee.com/CalmCenter/Pic/raw/master/cover23.webp"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-06-11</div><div class="relatedPosts_title">设计模式篇-面向对象</div></div></a></div><div class="relatedPosts_item"><a href="/2020/design-pattern-composite.html" title="设计模式-结构型-组合模式"><img class="relatedPosts_cover" data-src="https://gitee.com/CalmCenter/Pic/raw/master/cover51.webp"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-09-18</div><div class="relatedPosts_title">设计模式-结构型-组合模式</div></div></a></div><div class="relatedPosts_item"><a href="/2020/design-pattern-bridge.html" title="设计模式-结构型-桥接模式"><img class="relatedPosts_cover" data-src="https://gitee.com/CalmCenter/Pic/raw/master/cover15.webp"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-07-15</div><div class="relatedPosts_title">设计模式-结构型-桥接模式</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var requestSetting = function (from,set) {
  var from = from
  var setting = set.split(',').filter(function(item){
  return from.indexOf(item) > -1
  });
  setting = setting.length == 0 ? from :setting;
  return setting
}

var guestInfo = requestSetting(['nick','mail','link'],'nick,mail,link')
var requiredFields = requestSetting(['nick','mail','link'],'nick,mail')

window.valine = new Valine({
  el:'#vcomment',
  appId: 'KiQHU70TUHYrumpFuuhC3UEg-gzGzoHsz',
  appKey: 'wX1m2ATu8q4CyeRhOQ3FUucn',
  notify: true,
  verify: true,
  placeholder: '💦💦既然来了何不留下你的足迹(支持 Markdown 哦~)',
  avatar: 'robohash',
  meta: guestInfo,
  pageSize: '10',
  lang: 'zh-CN',
  recordIP: false,
  serverURLs: '',
  emojiCDN: '',
  emojiMaps: "",
  enableQQ: false,
  requiredFields: requiredFields
});</script></div></article></main><footer id="footer" style="background-image: url(https://gitee.com/CalmCenter/Pic/raw/master/cover38.webp)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 By CalmCenter</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div><div id="landlord"><div class="message" style="opacity:0"></div><canvas class="live2d" id="live2d" width="240" height="250"></canvas><div class="hide-button">隐藏</div></div><script type="text/javascript" src="https://cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script><script type="text/javascript">var message_Path = '/live2d/'
var home_Path = 'https://calmcenter.club/'</script><script type="text/javascript" src="/live2d/js/live2d.js"></script><script type="text/javascript" src="/live2d/js/message.js"></script><script type="text/javascript">loadlive2d("live2d", "/live2d/model/xxb2/model.json");</script><link rel="stylesheet" href="/live2d/css/live2d.css"/></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script id="ribbon_piao" mobile="true" src="/js/third-party/piao.js"></script><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script src="/js/search/local-search.js"></script></body></html>