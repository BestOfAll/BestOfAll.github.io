<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>设计模式-结构型-享元模式 | CalmCenter</title><meta name="description" content="所谓“享元”，顾名思义就是被共享的单元。享元模式的意图是复用对象，节省内存，前提是享元对象是不可变对象。"><meta name="keywords" content="编码"><meta name="author" content="CalmCenter"><meta name="copyright" content="CalmCenter"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = 'false'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="canonical" href="https://calmcenter.club/2020/design-pattern-flyweight.html"><link rel="next" title="设计模式-结构型-组合模式" href="https://calmcenter.club/2020/design-pattern-composite.html"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: true,
  fancybox: false,
  Snackbar: {"bookmark":{"message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"top-right"},
  baiduPush: false,
  highlightCopy: true,
  highlightLang: false,
  highlightShrink: 'none',
  isFontAwesomeV5: false,
  isPhotoFigcaption: true,
  islazyload: true,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">38</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">17</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">5</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友情链接</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-享元模式-UML"><span class="toc-text">1 享元模式 UML</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-简单实现"><span class="toc-text">2 简单实现</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-享元模式-vs-单例、缓存、对象池"><span class="toc-text">3 享元模式 vs 单例、缓存、对象池</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-享元模式跟单例的区别"><span class="toc-text">3.1 享元模式跟单例的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-享元模式跟缓存的区别"><span class="toc-text">3.2 享元模式跟缓存的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-享元模式跟对象池的区别"><span class="toc-text">3.3 享元模式跟对象池的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-享元模式在-Integer、String-中的应用"><span class="toc-text">4 享元模式在 Integer、String 中的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-Integer"><span class="toc-text">4.1 Integer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-String"><span class="toc-text">4.2 String</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-Android-源码中的享元（Handler）"><span class="toc-text">5 Android 源码中的享元（Handler）</span></a></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://gitee.com/CalmCenter/Pic/raw/master/cover17.webp)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">CalmCenter</a></span><span class="pull_right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友情链接</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">设计模式-结构型-享元模式</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-09-21 18:59:00"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-09-21</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-09-22 16:37:56"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-09-22</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E7%BC%96%E7%A0%81/">编码</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="post-meta__icon fa fa-file-word-o" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">5k</span><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-clock-o" aria-hidden="true"></i><span>阅读时长: 18 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><p>所谓 “享元”，顾名思义就是被共享的单元。享元模式的意图是复用对象，节省内存，前提是享元对象是不可变对象。</p>
<p>当一个系统中存在大量重复对象的时候，如果这些重复的对象是<strong>不可变对象</strong>，我们就可以利用享元模式将对象设计成享元，在内存中只保留一份实例，供多处代码引用。这样可以减少内存中对象的数量，起到节省内存的目的。</p>
<p>实际上，不仅仅相同对象可以设计成享元，对于相似对象，我们也可以将这些对象中相同的部分（字段）提取出来，设计成享元，让这些大量相似对象引用这些享元。</p>
<p>定义中的 “<strong>不可变对象</strong>” 指的是，一旦通过构造函数初始化完成之后，它的状态（对象的成员变量或者属性）就不会再被修改了。所以，不可变对象不能暴露任何 <code>set()</code> 等修改内部状态的方法。之所以要求享元是不可变对象，那是因为它会被多处代码共享使用，避免一处代码对享元进行了修改，影响到其他使用它的代码。</p>
<h1 id="1-享元模式-UML"><a href="#1-享元模式-UML" class="headerlink" title="1 享元模式 UML"></a>1 享元模式 UML</h1><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/design/design_uml_flyweight.webp" alt="图片来源于《Android 源码设计模式解析与实战》"></p>
<p>举个 🌰</p>
<p>过年回家买火车票是一件很困难的事，无数人用刷票插件软件在向服务端发出请求，对于每一个请求服务器都必须做出应答。</p>
<p>在用户设置好出发地和目的地之后，每次请求都返回一个查询的车票结果。那么当数以万计的人不间断在请求数据时，如果每次都重新创建一个查询的车票结果，那么必然会造成大量重复对象的创建、销毁，使得 <code>GC</code> 任务繁重、内存占用率高居不下。</p>
<p>而这类问题通过享元模式就能够得到很好地改善，从城市 <code>A</code> 到城市 <code>B</code> 的车辆是有限的，车上的铺位也就是硬卧、硬卧、坐票 3 种。我们将这些可以公用的对象缓存起来，在用户查询时优先使用缓存，如果没有缓存则重新创建。这样就将成千上万的对象变为了可选择的有限数量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Ticket</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showTicketInfo</span><span class="params">(String bunk)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrainTicket</span> <span class="keyword">implements</span> <span class="title">Ticket</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String from;</span><br><span class="line">    <span class="keyword">private</span> String to;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TrainTicket</span><span class="params">(String from, String to)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.from = from;</span><br><span class="line">        <span class="keyword">this</span>.to = to;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showTicketInfo</span><span class="params">(String bunk)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> price = <span class="keyword">new</span> Random().nextInt(<span class="number">300</span>);</span><br><span class="line">        System.out.println(<span class="string">"购买 从 "</span> + from + <span class="string">" 到 "</span> + to + <span class="string">" 的 "</span> + bunk + <span class="string">" 火车票，价格："</span> + price);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Map&lt;String, Ticket&gt; sTringTicketMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Ticket <span class="title">getTicket</span><span class="params">(String from, String to)</span> </span>&#123;</span><br><span class="line">        String key = from + <span class="string">"-"</span> + to;</span><br><span class="line">        <span class="keyword">if</span> (sTringTicketMap.containsKey(key)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"使用缓存 ==&gt;"</span> + key);</span><br><span class="line">            <span class="keyword">return</span> sTringTicketMap.get(key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"创建对象 ==&gt;"</span> + key);</span><br><span class="line">            Ticket ticket = <span class="keyword">new</span> TrainTicket(from, to);</span><br><span class="line">            sTringTicketMap.put(key, ticket);</span><br><span class="line">            <span class="keyword">return</span> ticket;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-简单实现"><a href="#2-简单实现" class="headerlink" title="2 简单实现"></a>2 简单实现</h1><p>举个 🌰</p>
<p>假设我们在开发一个棋牌游戏（比如象棋）。一个游戏厅中有成千上万个“房间”，每个房间对应一个棋局。棋局要保存每个棋子的数据，比如：棋子类型（将、相、士、炮等）、棋子颜色（红方、黑方）、棋子在棋局中的位置。利用这些数据，我们就能显示一个完整的棋盘给玩家。</p>
<p>为了记录每个房间当前的棋局情况，我们需要给每个房间都创建一个 <code>ChessBoard</code> 棋局对象。因为游戏大厅中有成千上万的房间（实际上，百万人同时在线的游戏大厅也有很多），那保存这么多棋局对象就会消耗大量的内存。</p>
<p>这个时候，<strong>享元模式</strong>就可以派上用场了。像刚刚的实现方式，在内存中会有大量的相似对象。这些相似对象的 <code>id</code>、<code>text</code>、<code>color</code> 都是相同的，唯独 <code>positionX</code>、<code>positionY</code> 不同。实际上，我们可以将棋子的 <code>id</code>、<code>text</code>、<code>color</code> 属性拆分出来，设计成独立的类，并且作为享元供多个棋盘复用。这样，棋盘只需要记录每个棋子的位置信息就可以了。</p>
<p>棋盘上旗子颜色和字都是固定的，只需要全部添加，并且缓存使用就好。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChessPieceUnit</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String text;</span><br><span class="line">    <span class="keyword">private</span> Color color;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChessPieceUnit</span><span class="params">(<span class="keyword">int</span> id, String text, Color color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.text = text;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">enum</span> Color &#123;RED, BLACK&#125; <span class="comment">// ...省略其他属性和getter/setter方法...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChessPiece</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ChessPieceUnit chessPieceUnit;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> positionX;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> positionY;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChessPiece</span><span class="params">(ChessPieceUnit chessPieceUnit, <span class="keyword">int</span> positionX, <span class="keyword">int</span> positionY)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.chessPieceUnit = chessPieceUnit;</span><br><span class="line">        <span class="keyword">this</span>.positionX = positionX;</span><br><span class="line">        <span class="keyword">this</span>.positionY = positionX;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChessPieceUnitFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Integer, ChessPieceUnit&gt; pieces = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        pieces.put(<span class="number">1</span>, <span class="keyword">new</span> ChessPieceUnit(<span class="number">1</span>, <span class="string">"車"</span>, ChessPieceUnit.Color.BLACK));</span><br><span class="line">        pieces.put(<span class="number">2</span>, <span class="keyword">new</span> ChessPieceUnit(<span class="number">2</span>, <span class="string">"馬"</span>, ChessPieceUnit.Color.BLACK));</span><br><span class="line">        <span class="comment">//...省略摆放其他棋子的代码...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ChessPieceUnit <span class="title">getChessPiece</span><span class="params">(<span class="keyword">int</span> chessPieceId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pieces.get(chessPieceId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们利用工厂类来缓存 <code>ChessPieceUnit</code> 信息（也就是 <code>id</code>、<code>text</code>、<code>color</code>）。通过工厂类获取到的 <code>ChessPieceUnit</code> 就是享元。所有的 <code>ChessBoard</code> 对象共享这 30 个 <code>ChessPieceUnit</code> 对象（因为象棋中只有 30 个棋子）。在使用享元模式之前，记录 1 万个棋局，我们要创建 30 万（ 30*1 万）个棋子的 <code>ChessPieceUnit</code> 对象。利用享元模式，我们只需要创建 30 个享元对象供所有棋局共享使用即可，大大节省了内存。</p>
<p>享元模式实际上，它的代码实现非常简单，主要是通过工厂模式，在工厂类中，通过一个 <code>Map</code> 来缓存已经创建过的享元对象，来达到复用的目的。</p>
<h1 id="3-享元模式-vs-单例、缓存、对象池"><a href="#3-享元模式-vs-单例、缓存、对象池" class="headerlink" title="3 享元模式 vs 单例、缓存、对象池"></a>3 享元模式 vs 单例、缓存、对象池</h1><p>在上面的讲解中，我们多次提到 “共享” “缓存” “复用” 这些字眼，那它跟单例、缓存、对象池这些概念有什么区别呢？</p>
<h2 id="3-1-享元模式跟单例的区别"><a href="#3-1-享元模式跟单例的区别" class="headerlink" title="3.1 享元模式跟单例的区别"></a>3.1 享元模式跟单例的区别</h2><p>在单例模式中，一个类只能创建一个对象，而在享元模式中，一个类可以创建多个对象，每个对象被多处代码引用共享。实际上，享元模式有点类似于之前讲到的单例的变体：多例。</p>
<p>区别两种设计模式，不能光看代码实现，而是要看设计意图，也就是要解决的问题。应用享元模式是为了对象复用，节省内存，而应用多例模式是为了限制对象的个数。</p>
<h2 id="3-2-享元模式跟缓存的区别"><a href="#3-2-享元模式跟缓存的区别" class="headerlink" title="3.2 享元模式跟缓存的区别"></a>3.2 享元模式跟缓存的区别</h2><p>在享元模式的实现中，我们通过工厂类来 “缓存” 已经创建好的对象。这里的 “缓存” 实际上是 “存储” 的意思，跟我们平时所说的 “数据库缓存” “CPU 缓存” “<code>MemCache</code> 缓存” 是两回事。我们平时所讲的缓存，主要是为了提高访问效率，而非复用。</p>
<h2 id="3-3-享元模式跟对象池的区别"><a href="#3-3-享元模式跟对象池的区别" class="headerlink" title="3.3 享元模式跟对象池的区别"></a>3.3 享元模式跟对象池的区别</h2><p>池化技术中的 “复用” 可以理解为 “重复使用” ，主要目的是节省时间（比如从数据库池中取一个连接，不需要重新创建）。<strong>在任意时刻，每一个对象、连接、线程，并不会被多处使用，而是被一个使用者独占，当使用完成之后，放回到池中，再由其他使用者重复利用</strong>。享元模式中的“复用”可以理解为 “共享使用”，<strong>在整个生命周期中，都是被所有使用者共享的</strong>，主要目的是节省空间。</p>
<h1 id="4-享元模式在-Integer、String-中的应用"><a href="#4-享元模式在-Integer、String-中的应用" class="headerlink" title="4 享元模式在 Integer、String 中的应用"></a>4 享元模式在 Integer、String 中的应用</h1><h2 id="4-1-Integer"><a href="#4-1-Integer" class="headerlink" title="4.1 Integer"></a>4.1 Integer</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 = <span class="number">56</span>;</span><br><span class="line">Integer i2 = <span class="number">56</span>;</span><br><span class="line">Integer i3 = <span class="number">129</span>;</span><br><span class="line">Integer i4 = <span class="number">129</span>;</span><br><span class="line">System.out.println(i1 == i2);</span><br><span class="line">System.out.println(i3 == i4);</span><br></pre></td></tr></table></figure>

<p>要正确地分析上面的代码，我们需要弄清楚下面两个问题：</p>
<ul>
<li>如何判定两个 <code>Java</code> 对象是否相等（也就代码中的 “==” 操作符的含义）？</li>
<li>什么是自动装箱（<code>Autoboxing</code>）和自动拆箱（<code>Unboxing</code>）？</li>
</ul>
<p>所谓的<strong>自动装箱</strong>，就是自动将基本数据类型转换为包装器类型。所谓的<strong>自动拆箱</strong>，也就是自动将包装器类型转化为基本数据类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="number">56</span>; <span class="comment">//自动装箱</span></span><br><span class="line"><span class="keyword">int</span> j = i; <span class="comment">//自动拆箱</span></span><br></pre></td></tr></table></figure>

<p>数值 <code>56</code> 是基本数据类型 <code>int</code>，当赋值给包装器类型（<code>Integer</code>）变量的时候，触发自动装箱操作，创建一个 <code>Integer</code> 类型的对象，并且赋值给变量 <code>i</code>。其底层相当于执行了下面这条语句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="number">59</span>；底层执行了：Integer i = Integer.valueOf(<span class="number">59</span>);</span><br></pre></td></tr></table></figure>

<p>当我们通过 “==” 来判定两个对象是否相等的时候，实际上是在<strong>判断两个局部变量存储的地址是否相同</strong>，换句话说，是在<strong>判断两个局部变量是否指向相同的对象</strong>。</p>
<p>回头看那段代码，前 <code>4</code> 行赋值语句都会触发自动装箱操作，也就是会创建 <code>Integer</code> 对象并且赋值给 <code>i1</code>、<code>i2</code>、<code>i3</code>、<code>i4</code> 这四个变量。根据刚刚的讲解，<code>i1</code>、<code>i2</code> 尽管存储的数值相同，都是 <code>56</code>，但是指向不同的 <code>Integer</code> 对象，所以通过 <code>“==”</code> 来判定是否相同的时候，会返回 false。同理，<code>i3==i4</code> 判定语句也会返回 <code>false</code>。</p>
<p>以为这样就完了吗？上面的分析还是不对，答案并非是两个 <code>false</code>，而是一个 <code>true</code>，一个 <code>false</code>。<br>这正是因为 <code>Integer</code> 用到了享元模式来复用对象，才导致了这样的运行结果。当我们通过自动装箱，也就是调用 <code>valueOf()</code> 来创建 <code>Integer</code> 对象的时候，如果要创建的 <code>Integer</code> 对象的值在 <code>-128</code> 到 <code>127</code> 之间，会从 <code>IntegerCache</code> 类中直接返回，否则才调用 <code>new</code> 方法创建。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 <code>IntegerCache</code> 相当于享元对象的工厂类，只不过名字不叫 <code>xxxFactory</code> 而已。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Cache to support the object identity semantics of autoboxing for values between</span></span><br><span class="line"><span class="comment"> * -128 and 127 (inclusive) as required by JLS.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The cache is initialized on first usage.  The size of the cache</span></span><br><span class="line"><span class="comment"> * may be controlled by the &#123;<span class="doctag">@code</span> -XX:AutoBoxCacheMax=&lt;size&gt;&#125; option.</span></span><br><span class="line"><span class="comment"> * During VM initialization, java.lang.Integer.IntegerCache.high property</span></span><br><span class="line"><span class="comment"> * may be set and saved in the private system properties in the</span></span><br><span class="line"><span class="comment"> * sun.misc.VM class.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">        String integerCacheHighPropValue =</span><br><span class="line">            sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</span><br><span class="line">        <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        high = h;</span><br><span class="line"></span><br><span class="line">        cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> j = low;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">        <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么 <code>IntegerCache</code> 只缓存 <code>-128</code> 到 <code>127</code> 之间的整型值呢？</p>
<p>在 <code>IntegerCache</code> 的代码实现中，当这个类被加载的时候，缓存的享元对象会被集中一次性创建好。毕竟整型值太多了，我们不可能在 <code>IntegerCache</code> 类中预先创建好所有的整型值，这样既占用太多内存，也使得加载 <code>IntegerCache</code> 类的时间过长。所以，我们只能选择缓存对于大部分应用来说最常用的整型值，也就是一个字节的大小（<code>-128</code> 到 <code>127</code> 之间的数据）。</p>
<p>如何修改这个值呢？</p>
<p><code>JDK</code> 提供了方法来让我们可以自定义缓存的最大值，但没有提供设置最小值的方法。这里只有 <code>idea</code> 的设置参数。<code>Android Studio</code> 还没有找到相关的设置方法，我试过了再 <code>studio64.exe.vmoptions</code> 中设置，并且执行了 <code>Invalidate Caches/Restart...</code> 但是没有效果。</p>
<p>希望哪位大佬指点一下 ~</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;方法一：</span><br><span class="line">-Djava.lang.Integer.IntegerCache.high&#x3D;255</span><br><span class="line">&#x2F;&#x2F;方法二：</span><br><span class="line">-XX:AutoBoxCacheMax&#x3D;255</span><br></pre></td></tr></table></figure>

<p>除了 <code>Integer</code> 类型之外，其他包装器类型，比如 <code>Long</code>、<code>Short</code>、<code>Byte</code> 等，也都利用了享元模式来缓存 <code>-128</code> 到 <code>127</code> 之间的数据。具体查看对应的 <code>valueOf()</code> 方法。</p>
<p>在我们平时的开发中，对于下面这样三种创建整型对象的方式，我们优先使用后两种。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer a = <span class="keyword">new</span> Integer(<span class="number">123</span>);</span><br><span class="line">Integer a = <span class="number">123</span>;</span><br><span class="line">Integer a = Integer.valueOf(<span class="number">123</span>);</span><br></pre></td></tr></table></figure>

<p>第一种创建方式并不会使用到 <code>IntegerCache</code>，而后面两种创建方法可以利用 <code>IntegerCache</code> 缓存，返回共享的对象，以达到节省内存的目的。</p>
<h2 id="4-2-String"><a href="#4-2-String" class="headerlink" title="4.2 String"></a>4.2 String</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"abc"</span>;</span><br><span class="line">String s2 = <span class="string">"abc"</span>;</span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(s1 == s2);</span><br><span class="line">System.out.println(s1 == s3);</span><br></pre></td></tr></table></figure>

<p>上面代码的运行结果是：一个 <code>true</code>，一个 <code>false</code>。</p>
<p><code>String</code> 类利用享元模式来复用相同的字符串常量。<code>JVM</code> 会专门开辟一块存储区来存储字符串常量，这块存储区叫作 <strong>“字符串常量池”</strong>。</p>
<p><code>String</code> 类的享元模式的设计，跟 <code>Integer</code> 类稍微有些不同。<code>Integer</code> 类中要共享的对象，是在类加载的时候，就集中一次性创建好的。但是，对于字符串来说，我们没法事先知道要共享哪些字符串常量，所以没办法事先创建好，只能在某个字符串常量第一次被用到的时候，存储到常量池中，当之后再用到的时候，直接引用常量池中已经存在的即可，就不需要再重新创建了。</p>
<h1 id="5-Android-源码中的享元（Handler）"><a href="#5-Android-源码中的享元（Handler）" class="headerlink" title="5 Android 源码中的享元（Handler）"></a>5 Android 源码中的享元（Handler）</h1><p>万万没想到，很不常用的享元模式，竟然在我们经常使用的 <code>Handler</code> 中用到了！说起 <code>Handler</code> ，一般都是在耗时操作的时候才会使用 <code>Handler</code> ，比如更新 <code>UI</code>，大家肯定听过一句话，<code>UI</code> 不能够在子线程中更新。这原本就是一个伪命题，因为并不是 <code>UI</code> 不可以在子线程更新，而是 <code>UI</code> 不可以在不是它的创建线程里进行更新。只是绝大多数情况下 <code>UI</code> 都是从 <code>UI</code> 线程中创建的，因此，在其他线程更新时会抛出异常。</p>
<p><a href="https://blog.csdn.net/lmj623565791/article/details/105624391" target="_blank" rel="noopener">Android UI 线程更新UI也会崩溃？？？</a></p>
<p>这里插入一个小小的知识点，然后回到我们的猪脚 ^(*￣(oo)￣)^  <code>handler</code> 中。</p>
<p>我们在通过 <code>Handler</code> 中传递消息时会传递一个 <code>Runnable</code>，<code>Runnable</code> 会被包装到一个 <code>Message</code> 对象中，然后再投递到 <code>UI</code> 线程的消息队列。具体看 <code>post</code> 代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span>  sendMessageDelayed(getPostMessage(r), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Message <span class="title">getPostMessage</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">    Message m = Message.obtain();</span><br><span class="line">    m.callback = r;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里可以看到，<code>Message</code> 并不是 <code>new</code> 出来的，这个 <code>obtain</code> 有点蹊跷 ~ 这里只研究和享元模式相关的部分，其他部分看下面扩展 ~ </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sPool != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Message m = sPool;</span><br><span class="line">            sPool = m.next;</span><br><span class="line">            m.next = <span class="keyword">null</span>;<span class="comment">// 从sPool中取出一个 Message 对象，并消息链表断开(单独的一个节点)</span></span><br><span class="line">            m.flags = <span class="number">0</span>; <span class="comment">// clear in-use flag</span></span><br><span class="line">            sPoolSize--; <span class="comment">//消息池的可用大小进行减1操作</span></span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Message();<span class="comment">// 当消息池为空时，直接创建Message对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里可以看到，在 <code>mPool</code> 为 <code>null</code> 时才会去重新 <code>new</code> 一个 <code>Message</code> ，那我们只需要知道这个 <code>sPoolSync</code> 和 <code>sPool</code> 是什么，就可以知道这里的缓存是怎么做的了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Defines a message containing a description and arbitrary data object that can be</span></span><br><span class="line"><span class="comment"> * sent to a &#123;<span class="doctag">@link</span> Handler&#125;.  This object contains two extra int fields and an</span></span><br><span class="line"><span class="comment"> * extra object field that allow you to not do allocations in many cases.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p class="note"&gt;While the constructor of Message is public, the best way to get</span></span><br><span class="line"><span class="comment"> * one of these is to call &#123;<span class="doctag">@link</span> #obtain Message.obtain()&#125; or one of the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Handler#obtainMessage Handler.obtainMessage()&#125; methods, which will pull</span></span><br><span class="line"><span class="comment"> * them from a pool of recycled objects.&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object sPoolSync = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Message sPool;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> sPoolSize = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>首先 <code>Message</code> 文档第一段的意思就是介绍了一下这个 <code>Message</code> 类的字段，以及说明 <code>Message</code> 对象是被发送到 <code>Handler</code> 的，对于我们来说作用不大。</p>
<p>第二段的意思是建议我们使用 <code>Message</code> 的 <code>obtain</code> 方法获取 <code>Message</code> 对象，而不是通过 <code>Message</code> 的构造函数，因为 <code>obtain</code> 方法会从被回收的对象池中获取 <code>Message</code> 对象。</p>
<p>然后再看看关键的字段，<code>sPoolSync</code> 是一个普通的 <code>Object</code> 对象，它的作用就是用于在获取 <code>Message</code> 对象时进行同步锁。再看 <code>sPool</code> 居然是一个 <code>Message</code> 对象，居然不是消息池之类的东西，既然它命名为 <code>sPool</code> 不可能是有名无实吧。原来还有一个比较总要的字段</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sometimes we store linked lists of these things</span></span><br><span class="line">Message next;</span><br></pre></td></tr></table></figure>

<p>原来 <code>Message</code> 消息池没有使用 <code>map</code> 这样的容器，使用的是链表！这个 <code>next</code> 就是指向下一个 <code>Message</code> 的。</p>
<p>每个 <code>Message</code> 对象都有一个同类型的 <code>next</code> 字段，这个 <code>next</code> 指向的就是下一个可用的 <code>Message</code> ，最后一个可用的 <code>Message</code> 的 <code>next</code> 则为空。这样一来，所有可用的 <code>Message</code> 对象就通过 <code>next</code> 串连成一个可用的 <code>Message</code> 池。</p>
<p>我们在 <code>obtain</code> 函数中只看到了从链表中获取，并且看到存储。如果消息池链表中没有可用对象的时候，<code>obtain</code> 中则是直接返回一个通过 <code>new</code> 创建的 <code>Message</code> 对象，而且并没有存储到链表中。那么这些 <code>Message</code> 对象什么时候会被放到链表中呢？</p>
<p><code>“which will pull them from a pool of recycled objects.”</code>，这是 <code>Message</code> 注释中的第二句话末尾的一句话，原来在创建的时候不会把 <code>Message</code> 对象放到池中，在回收（这里的回收并不是指虚拟机回收<code>Message</code> 对象）该对象时才会将该对象添加到链表中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否该消息还在使用</span></span><br><span class="line">    <span class="keyword">if</span> (isInUse()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (gCheckRecycle) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"This message cannot be recycled because it "</span></span><br><span class="line">                    + <span class="string">"is still in use."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清空状态，并且将消息添加到消息池中</span></span><br><span class="line">    recycleUnchecked();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对于不再使用的消息，加入到消息池 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recycleUnchecked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//清空消息状态，设置该消息 in - use flag</span></span><br><span class="line">    flags = FLAG_IN_USE;</span><br><span class="line">    what = <span class="number">0</span>;</span><br><span class="line">    arg1 = <span class="number">0</span>;</span><br><span class="line">    arg2 = <span class="number">0</span>;</span><br><span class="line">    obj = <span class="keyword">null</span>;</span><br><span class="line">    replyTo = <span class="keyword">null</span>;</span><br><span class="line">    sendingUid = -<span class="number">1</span>;</span><br><span class="line">    when = <span class="number">0</span>;</span><br><span class="line">    target = <span class="keyword">null</span>;</span><br><span class="line">    callback = <span class="keyword">null</span>;</span><br><span class="line">    data = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 回收消息到消息池中</span></span><br><span class="line">    <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sPoolSize &lt; MAX_POOL_SIZE) &#123; <span class="comment">//当消息池没有满时，将Message对象加入消息池</span></span><br><span class="line">            next = sPool;</span><br><span class="line">            sPool = <span class="keyword">this</span>;</span><br><span class="line">            sPoolSize++;<span class="comment">//消息池的可用大小进行加1操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>recycle</code> 函数会将一个 <code>Message</code> 对象回收到一个全局的池中，这个池也就是链表。<br><code>recycle</code> 函数首先判断该消息是否还在使用，如果还在使用则抛出异常，否则调用 <code>recycleUnchecked</code> 函数处理该消息。</p>
<p><code>recycleUnchecked</code> 函数中先清空该消息的各字段，并且将 <code>flags</code> 设置为 <code>FLAG_IN_USE</code> ，表明该消息已被使用，这个 <code>flag</code> 在 <code>obtain</code> 函数中会被置为 <code>0</code> ，这样根据这个 <code>flag</code> 就能够追踪该消息的状态。</p>
<p>然后判断是否要将该消息回收到消息池中，如果池的大小小于 <code>MAX_POOL_SIZE</code> 时，将<strong>自身添加到链表的表头</strong>。</p>
<p>例如，当链表中还没有元素时，将第一个<code>Message</code> 对象添加到链表中，此时 <code>sPool</code> 为null，<code>next</code> 指向了 <code>sPool</code> ，因此，<code>next</code> 也为 <code>null</code> ，然后 <code>sPool</code> 又指向了 <code>this</code> ，因此，<code>sPool</code> 就指向了当前这个被回收的对象，并且 <code>sPoolSize</code> 加1。<strong>相当于当前要回收的 <code>Message</code> (既然是要被回收的，肯定是一个独立的节点) <code>next</code> 指向回收池的头节点，再将 <code>sPool(头指针)</code>  指向当前节点，作为头节点。<code>obtain</code> 取的时候就是将头节点与之后的节点断开，单独取出来使用。</strong></p>
<p>这里的 <code>Message</code> 相当于承担了享元模式中 3 个元素的职责，即是 <code>Flyweight</code> 抽象，又是 <code>ConcreteFlyweight</code> 角色，同时又承担了 <code>FlyweightFactory</code> 管理对象池的职责。因为 <code>Android</code> 应用是事件驱动的，因此，如果通过 <code>new</code> 创建 <code>Message</code> 就会创建大量重复的 <code>Message</code> 对象，导致内存占用率高、频繁 <code>GC</code> 等问题，通过享元模式创建一个大小为 50 的消息池，避免了上述问题的产生，使得这些问题迎刃而解。</p>
<p><strong><code>Handler</code> 扩展</strong></p>
<p><a href="http://gityuan.com/2015/12/26/handler-message-framework/" target="_blank" rel="noopener">Android消息机制-Handler(framework篇)</a></p>
<p><a href="http://gityuan.com/2015/12/27/handler-message-native/" target="_blank" rel="noopener">Android消息机制-Handler(native篇)</a></p>
<p><a href="http://gityuan.com/2016/01/01/handler-message-usage/" target="_blank" rel="noopener">Android消息机制3-Handler(实战)</a></p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">CalmCenter</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://calmcenter.club/2020/design-pattern-flyweight.html">https://calmcenter.club/2020/design-pattern-flyweight.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://calmcenter.club" target="_blank">CalmCenter</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%BC%96%E7%A0%81/">编码</a></div><div class="post_share"></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="/img/wechat.png" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="post-qr-code__img" src="/img/alipay.png" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="next-post pull-full"><a href="/2020/design-pattern-composite.html"><img class="next_cover" data-src="https://gitee.com/CalmCenter/Pic/raw/master/cover51.webp" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">设计模式-结构型-组合模式</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/design-pattern-proxy.html" title="设计模式-结构型-代理模式"><img class="relatedPosts_cover" data-src="https://gitee.com/CalmCenter/Pic/raw/master/cover40.webp"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-07-13</div><div class="relatedPosts_title">设计模式-结构型-代理模式</div></div></a></div><div class="relatedPosts_item"><a href="/2020/design-pattern-adapter.html" title="设计模式-结构型-适配器模式"><img class="relatedPosts_cover" data-src="https://gitee.com/CalmCenter/Pic/raw/master/cover22.webp"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-08-27</div><div class="relatedPosts_title">设计模式-结构型-适配器模式</div></div></a></div><div class="relatedPosts_item"><a href="/2020/design-pattern-decorator.html" title="设计模式-结构型-装饰模式"><img class="relatedPosts_cover" data-src="https://gitee.com/CalmCenter/Pic/raw/master/cover53.webp"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-07-29</div><div class="relatedPosts_title">设计模式-结构型-装饰模式</div></div></a></div><div class="relatedPosts_item"><a href="/2020/oop.html" title="设计模式篇-面向对象"><img class="relatedPosts_cover" data-src="https://gitee.com/CalmCenter/Pic/raw/master/cover23.webp"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-06-11</div><div class="relatedPosts_title">设计模式篇-面向对象</div></div></a></div><div class="relatedPosts_item"><a href="/2020/design-pattern-bridge.html" title="设计模式-结构型-桥接模式"><img class="relatedPosts_cover" data-src="https://gitee.com/CalmCenter/Pic/raw/master/cover11.webp"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-07-15</div><div class="relatedPosts_title">设计模式-结构型-桥接模式</div></div></a></div><div class="relatedPosts_item"><a href="/2020/design-pattern-composite.html" title="设计模式-结构型-组合模式"><img class="relatedPosts_cover" data-src="https://gitee.com/CalmCenter/Pic/raw/master/cover51.webp"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-09-18</div><div class="relatedPosts_title">设计模式-结构型-组合模式</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var requestSetting = function (from,set) {
  var from = from
  var setting = set.split(',').filter(function(item){
  return from.indexOf(item) > -1
  });
  setting = setting.length == 0 ? from :setting;
  return setting
}

var guestInfo = requestSetting(['nick','mail','link'],'nick,mail,link')
var requiredFields = requestSetting(['nick','mail','link'],'nick,mail')

window.valine = new Valine({
  el:'#vcomment',
  appId: 'KiQHU70TUHYrumpFuuhC3UEg-gzGzoHsz',
  appKey: 'wX1m2ATu8q4CyeRhOQ3FUucn',
  notify: true,
  verify: true,
  placeholder: '💦💦既然来了何不留下你的足迹(支持 Markdown 哦~)',
  avatar: 'robohash',
  meta: guestInfo,
  pageSize: '10',
  lang: 'zh-CN',
  recordIP: false,
  serverURLs: '',
  emojiCDN: '',
  emojiMaps: "",
  enableQQ: false,
  requiredFields: requiredFields
});</script></div></article></main><footer id="footer" style="background-image: url(https://gitee.com/CalmCenter/Pic/raw/master/cover17.webp)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 By CalmCenter</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div><div id="landlord"><div class="message" style="opacity:0"></div><canvas class="live2d" id="live2d" width="240" height="250"></canvas><div class="hide-button">隐藏</div></div><script type="text/javascript" src="https://cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script><script type="text/javascript">var message_Path = '/live2d/'
var home_Path = 'https://calmcenter.club/'</script><script type="text/javascript" src="/live2d/js/live2d.js"></script><script type="text/javascript" src="/live2d/js/message.js"></script><script type="text/javascript">loadlive2d("live2d", "/live2d/model/xxb2/model.json");</script><link rel="stylesheet" href="/live2d/css/live2d.css"/></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script id="ribbon_piao" mobile="true" src="/js/third-party/piao.js"></script><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script src="/js/search/local-search.js"></script></body></html>