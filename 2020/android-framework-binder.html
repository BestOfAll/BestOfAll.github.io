<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>无 Binder 不 Android | CalmCenter</title><meta name="keywords" content="Android"><meta name="author" content="CalmCenter"><meta name="copyright" content="CalmCenter"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="Android 的内核也是基于 Linux 内核，为何不直接采用 Linux 现有的进程 IPC 方案呢，难道 Linux 社区那么多优秀人员都没有考虑到有 Binder 这样一个更优秀的方案？">
<meta property="og:type" content="article">
<meta property="og:title" content="无 Binder 不 Android">
<meta property="og:url" content="https://calmcenter.club/2020/android-framework-binder.html">
<meta property="og:site_name" content="CalmCenter">
<meta property="og:description" content="Android 的内核也是基于 Linux 内核，为何不直接采用 Linux 现有的进程 IPC 方案呢，难道 Linux 社区那么多优秀人员都没有考虑到有 Binder 这样一个更优秀的方案？">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/CalmCenter/Pic/raw/master/background/cover4.webp">
<meta property="article:published_time" content="2020-12-11T04:59:00.000Z">
<meta property="article:modified_time" content="2020-12-11T04:59:00.000Z">
<meta property="article:author" content="CalmCenter">
<meta property="article:tag" content="Android">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/CalmCenter/Pic/raw/master/background/cover4.webp"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://calmcenter.club/2020/android-framework-binder"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  ClickShowText: undefined,
  lightbox: 'mediumZoom',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"top-right"},
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2020-12-11 12:59:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><meta name="generator" content="Hexo 5.2.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" data-lazy-src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">58</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://gitee.com/CalmCenter/Pic/raw/master/background/cover4.webp)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">CalmCenter</a></span><span id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><h1 class="post-title">无 Binder 不 Android</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-12-11T04:59:00.000Z" title="发表于 2020-12-11 12:59:00">2020-12-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-12-11T04:59:00.000Z" title="更新于 2020-12-11 12:59:00">2020-12-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Android/">Android</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">8.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>27分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Binder-是什么？"><a href="#Binder-是什么？" class="headerlink" title="Binder 是什么？"></a>Binder 是什么？</h1><p><code>Binder</code> 是一种进程间通信机制，基于开源的 <a target="_blank" rel="noopener" href="http://www.angryredplanet.com/~hackbod/openbinder/docs/html/BinderIPCMechanism.html">OpenBinder</a> 实现；<code>OpenBinder</code> 起初由 <code>Be Inc.</code> 开发，后由 <code>Plam Inc.</code> 接手，现在 <code>OpenBinder</code> 的作者在 <code>Google</code> 工作，这也为后来的 <code>Binder</code> 。从字面上来解释 <code>Binder</code> 有胶水、粘合剂的意思，顾名思义就是粘和不同的进程，使之实现通信。</p>
<h1 id="Binder-有那么重要吗"><a href="#Binder-有那么重要吗" class="headerlink" title="Binder 有那么重要吗 ?"></a>Binder 有那么重要吗 ?</h1><p>作为一个 <code>Android</code> 攻城狮，会不会有这也的疑惑？</p>
<ul>
<li>为什么 <code>Activity</code> 间传递对象需要序列化？</li>
<li><code>Activity</code> 的启动流程是什么样的？</li>
<li>四大组件底层的通信机制是怎样的？</li>
<li><code>AIDL</code> 内部的实现原理是什么？</li>
<li>插件化编程技术应该从何学起？</li>
</ul>
<p>这些都是因为 <code>Binder</code> 才让无数 <code>Android</code> 小伙伴疑惑重重，想要知道 <code>Android</code> 中血液是如何流动的，就必须正确认识 <code>Binder</code> 。</p>
<h1 id="为什么选中了-Binder-实现-IPC-机制？"><a href="#为什么选中了-Binder-实现-IPC-机制？" class="headerlink" title="为什么选中了 Binder 实现 IPC 机制？"></a>为什么选中了 Binder 实现 IPC 机制？</h1><p><code>Android</code> 内核是基于 <code>Linux</code> 系统, 而 <code>Linux</code> 现存多种进程间 <code>IPC(Inter-Process Communication)</code> 方式</p>
<ul>
<li><strong>管道：</strong>在创建时分配一个 page 大小的内存，管道是由内核管理的一个缓冲区，缓存区大小比较有限；</li>
<li><strong>消息队列：</strong>信息复制两次，额外的 CPU 消耗；不合适频繁或信息量大的通信；</li>
<li><strong>共享内存：</strong>无须复制，共享缓冲区直接付附加到进程虚拟地址空间，速度快；但进程间的同步问题操作系统无法实现，必须各进程利用同步工具解决；</li>
<li><strong>套接字：</strong>作为更通用的接口，传输效率低，主要用于不通机器或跨网络的通信；</li>
<li><strong>信号量：</strong>常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</li>
<li><strong>信号：</strong>不适用于信息交换，更适用于进程中断控制，比如非法内存访问，杀死某个进程等；</li>
</ul>
<p>为何不直接采用 <code>Linux</code> 现有的进程 <code>IPC</code> 方案呢，难道 <code>Linux</code> 社区那么多优秀人员都没有考虑到有 <code>Binder</code> 这样一个更优秀的方案，还是 <code>google</code> 太过于牛 <code>B</code> ？</p>
<p>这得从各个方面考虑到</p>
<ol>
<li><p><strong>性能角度（数据拷次数）：</strong> <code>Binder</code> 数据拷贝只需要一次，而管道、消息队列、<code>Socket</code> 都需要 <code>2</code> 次，但共享内存方式一次内存拷贝都不需要；从性能角度看，<code>Binder</code> 性能仅次于共享内存。</p>
</li>
<li><p><strong>稳定性：</strong> <code>Binder</code>是基于 <code>C/S</code> 架构的，<code>C/S</code> 架构，是指客户端 <code>(Client)</code> 和服务端 <code>(Server)</code> 组成的架构，<code>Client</code> 端有什么需求，直接发送给 <code>Server</code> 端去完成，架构清晰明朗，<code>Server</code> 端与 <code>Client</code> 端相对独立，稳定性较好；而共享内存实现方式复杂，没有客户与服务端之别， 需要充分考虑到访问临界资源的并发同步问题，否则可能会出现死锁等问题；从这稳定性角度看，<code>Binder</code> 架构优越于共享内存。</p>
</li>
<li><p><strong>安全性：</strong> <code>Android</code> 作为一个开放性的平台，市场上有各类海量的应用供用户选择安装，因此安全性对于 <code>Android</code> 平台而言极其重要。对于我们普通用户，绝不希望从 <code>App</code> 商店下载偷窥隐射数据、后台造成手机耗电等等问题，传统 <code>Linux IPC</code> 无任何保护措施，完全由上层协议来确保。</p>
<p>传统 <code>Linux IPC</code> 的接收方无法获得对方进程可靠的 <code>UID/PID</code> ，从而无法鉴别对方身份；而 <code>Android</code> 为每个安装好的应用程序分配了自己的 <code>UID</code> ，故进程的 <code>UID</code> 是鉴别进程身份的重要标志；传统 <code>IPC</code> 只能由用户在数据包里填入<code>UID/PID</code>；另外，可靠的身份标记只有由 <code>IPC</code> 机制本身在内核中添加。其次传统 <code>IPC</code> 访问接入点是开放的，无法建立私有通道。从安全角度，<code>Binder</code> 的安全性更高。</p>
<p>但是 <code>Android</code> 就算用了 <code>Binder</code> 架构，而现如今 <code>Android</code> 手机的各种流氓软件，不就是干着这种偷窥隐射，后台偷偷跑流量的事吗？没错，确实存在，但这不能说 <code>Binder</code> 的安全性不好，因为 <code>Android</code> 系统仍然是掌握主控权，可以控制这类 <code>App</code> 的流氓行为，只是对于该采用何种策略来控制，在这方面 <code>android</code> 的确存在很多有待进步的空间，这也是 <code>google</code> 以及各大手机厂商一直努力改善的地方之一。</p>
</li>
</ol>
<h1 id="Linux-传统-IPC-如何通信的？"><a href="#Linux-传统-IPC-如何通信的？" class="headerlink" title="Linux 传统 IPC 如何通信的？"></a>Linux 传统 IPC 如何通信的？</h1><p>了解 <code>Linux IPC</code> 相关的概念和原理有助于理解 <code>Binder</code> 通信原理。因此，在介绍 <code>Binder</code> 跨进程通信原理之前，先聊聊 <code>Liunx</code> 中的几个概念以及 <code>Linux</code> 系统下传统的进程间通信是如何实现。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/android/android_linux_ipc.jpg" alt="图片来源于《写给 Android 应用工程师的 Binder 原理剖析》"></p>
<p><strong>进程隔离</strong></p>
<p>操作系统中进程隔离指的是，进程与进程间内存是不共享的，也就是一个进程不能直接操作或者访问另一个进程，A 进程和 B 进程之间要进行数据交互就得采用特殊的通信机制：进程间通信（<code>IPC</code>）。</p>
<p><strong>进程空间划分：用户空间(User Space)/内核空间(Kernel Space)</strong></p>
<p>现在操作系统都是采用的虚拟存储器，对于 <code>32</code> 位系统而言，它的寻址空间（虚拟存储空间）就是 <code>2</code> 的 <code>32</code> 次方，也就是 <code>4GB</code>。</p>
<p>操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也可以访问底层硬件设备的权限。<code>Liunx</code>为了保护用户进程不能直接操作内核，保证内核的安全，操作系统从逻辑上将虚拟空间划分为用户空间和内核空间。针对 <code>Linux</code> 操作系统而言，将最高的 <code>1GB</code> 字节供内核使用，称为内核空间；较低的 <code>3GB</code> 字节供各进程使用，称为用户空间。</p>
<blockquote>
<p>内核空间（Kernel）是系统内核运行的空间，用户空间（User Space）是用户程序运行的空间。为了保证安全性，它们之间是隔离的。每个进程可以通过<strong>系统调用</strong>进入内核，因此，Linux 内核对系统内的所有进程共享。</p>
</blockquote>
<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/android/android_linux_space.png" alt="图片来源于《用户空间与内核空间，进程上下文与中断上下文总结》"></p>
<p><strong>系统调用</strong></p>
<p>系统调用是用户空间访问内核空间的唯一方式，保证了所有的资源访问都是在内核的控制下进行的，避免了用户程序对系统资源的越权访问，提升了系统安全性和稳定性。</p>
<p>当一个任务（进程）执行系统调用而陷入内核代码中执行时，称进程处于<strong>内核运行态（内核态）</strong>。当进程在执行用户自己的代码的时候，我们称其处于<strong>用户运行态（用户态）</strong>。</p>
<p>系统调用主要通过如下两个函数来实现：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">copy_from_user() //将数据从用户空间拷贝到内核空间</span><br><span class="line">copy_to_user() //将数据从内核空间拷贝到用户空间</span><br></pre></td></tr></table></figure>

<h2 id="Linux-的-IPC-通信原理"><a href="#Linux-的-IPC-通信原理" class="headerlink" title="Linux 的 IPC 通信原理"></a>Linux 的 IPC 通信原理</h2><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/android/android_linux_ipc2.jpg" alt="图片来源于《写给 Android 应用工程师的 Binder 原理剖析》"></p>
<ol>
<li>消息发送方将要发送的数据存放在内存缓存区中，通过系统调用进入内核态。</li>
<li>然后内核程序在内核空间分配内存，开辟一块内核缓存区，调用 <code>copy_from_user()</code> 函数将数据从用户空间的内存缓存区拷贝到内核空间的内核缓存区中。</li>
<li>接收方进程在接收数据时在自己的用户空间开辟一块内存缓存区，然后内核程序调用 <code>copy_to_user()</code> 函数将数据从内核缓存区拷贝到接收进程的内存缓存区。这样数据发送方进程和数据接收方进程就完成了一次数据传输，我们称完成了一次进程间通信。</li>
</ol>
<p><code>Linux</code> 的 <code>IPC</code> 通信原理有两个问题：</p>
<ul>
<li>一次数据传递需要经历：用户空间 –&gt; 内核缓存区 –&gt; 用户空间，需要 2 次数据拷贝，这样效率不高。</li>
<li>接收数据的缓存区由数据接收进程提供，但是接收进程并不知道需要多大的空间来存放将要传递过来的数据，因此只能开辟尽可能大的内存空间或者先调用API接收消息头来获取消息体的大小，浪费了空间或者时间。</li>
</ul>
<h1 id="Binder-IPC-如何通信的？"><a href="#Binder-IPC-如何通信的？" class="headerlink" title="Binder IPC 如何通信的？"></a>Binder IPC 如何通信的？</h1><p>跨进程通信是需要<strong>内核空间</strong>做支持的。传统的 <code>IPC</code> 机制如管道、<code>Socket</code> 都是内核的一部分，因此通过内核支持来实现进程间通信自然是没问题的。但是 <code>Binder</code> 并不是 <code>Linux</code> 系统内核的一部分，那怎么办呢？</p>
<p>这就得益于 <code>Linux</code> 的<strong>动态内核可加载模块</strong>（<code>Loadable Kernel Module，LKM</code>）的机制；</p>
<ul>
<li>模块是具有独立功能的程序，它可以被单独编译，但是不能独立运行。</li>
<li>它在运行时被链接到内核作为内核的一部分运行。</li>
</ul>
<p>这样，<code>Android</code> 系统就可以通过动态添加一个内核模块运行在内核空间，用户进程之间通过这个内核模块作为桥梁来实现通信。（在 <code>Android</code> 系统中，这个运行在内核空间，负责各个用户进程通过 <code>Binder</code> 实现通信的内核模块就叫 <strong>Binder 驱动</strong>（<code>Binder Dirver</code>）。）</p>
<p><strong>那 <code>Binder</code> 是如何做到减少数据拷贝的呢？</strong></p>
<p>这就得说一下 <code>Linux</code> 下的另一个概念：<strong>内存映射</strong>。</p>
<p><code>Binder IPC</code> 机制中涉及到的内存映射通过 <code>mmap()</code> 来实现，<code>mmap()</code> 是操作系统中一种内存映射的方法，通常是用在有物理介质的文件系统上的。</p>
<p>比如进程中的用户区域是不能直接和物理设备打交道的，如果想要把磁盘上的数据读取到进程的用户区域，需要两次拷贝（<code>磁盘--&gt;内核空间--&gt;用户空间</code>）；</p>
<p>通常在这种场景下 <code>mmap()</code> 就能发挥作用，通过在物理介质和用户空间之间建立映射，用户对这块内存区域的修改可以直接反应到内核空间；反之内核空间对这段区域的修改也能直接反应到用户空间。这样就可以减少数据拷贝次数，用内存读写取代 <code>I/O</code> 读写，提高文件读取效率，实现用户空间和内核空间的高效互动。</p>
<p>两个空间各自的修改能直接反映在映射的内存区域，从而被对方空间及时感知。也正因为如此，内存映射能够提供对进程间通信的支持。</p>
<p><strong>但是 <code>Binder</code> 并不存在物理介质！</strong></p>
<p>因此 <code>Binder</code> 驱动使用 <code>mmap()</code> 并不是为了在物理介质和用户空间之间建立映射，而是用来在内核空间创建<strong>数据接收的缓存空间</strong>。</p>
<ol>
<li>这样 <code>Binder</code> 驱动在内核空间创建一个数据接收缓存区；</li>
<li>接着在内核空间开辟一块内核缓存区，建立<strong>内核缓存区</strong>和<strong>内核中数据接收缓存区</strong>之间的映射关系，以及<strong>内核中数据接收缓存区</strong>和<strong>接收进程用户空间地址</strong>的映射关系；</li>
<li>发送方进程通过系统方法将数据 <code>copy</code> 到内核中的<strong>内核缓存区</strong>，由于内核缓存区和接收进程的用户空间存在内存映射，因此也就相当于把数据发送到了接收进程的用户空间，这样便完成了一次进程间的通信。</li>
</ol>
<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/android/android_binder_mmap.jpg" alt="图片来源于《写给 Android 应用工程师的 Binder 原理剖析》"></p>
<blockquote>
<p><strong>深入了解</strong></p>
<ul>
<li><strong>Binder 设备的初始化过程</strong></li>
</ul>
<p><code>Binder</code> 设备的初始化过程是在<code>Binder</code> 驱动程序的初始化函数 <code>binder_init</code> 中进行的。</p>
<p>它首先在目标设备上创建了一个 <code>/proc/binder/proc</code> 目录，每一个使用了 <code>Binder</code> 进程间通信机制的进程在该目录下都对应有一个文件，这些文件是以进程 <code>ID</code> 来命名的，通过它们就可以读取到各个进程的 <code>Binder</code> 线程池、<code>Binder</code> 实体对象、<code>Binder</code> 引用对象以及内核缓冲区等信息。然后调用函数 <code>misc_register</code> 来创建一个 <code>Binder</code> 设备，最后 <code>Binder</code> 驱动程序在目标设备上创建了一个 <code>Binder</code> 设备文件 <code>/dev/binder</code>，这个设备文件的操作方法列表是由全局变量 <code>binder_fops</code> 指定的。</p>
<p>全局变量 <code>binder_fops</code> 为 <code>Binder</code> 设备文件 <code>/dev/binder</code> 指定文件打开 (<code>binder_open</code>)，映射(<code>binder_mmap</code>)，数据操作(<code>binder_ioctl</code>)</p>
<ul>
<li><strong>binder_open 打开过程</strong></li>
</ul>
<p>一个进程在使用 <code>Binder</code> 进程间通信机制之前，首先要调用函数 <code>open</code> 打开设备文件 <code>/dev/binder</code> 来获得一个文件描述符，然后才能通过这个文件描述符来和 <code>Binder</code> 驱动程序交互，继而和其他进程执行 <code>Binder</code> 进程间通信。</p>
<p>当进程调用函数 <code>open</code> 打开设备文件 <code>/dev/binder</code> 时，<code>Binder</code> 驱动程序中的函数 <code>binder_open</code> 就会被调用，它会为进程创建一个 <code>binder_proc</code> 结构体 <code>proc</code>，并把它加入到一个全局 <code>hash</code> 队列 <code>binder_procs</code> 中。<code>Binder</code> 驱动程序将所有打开了设备文件 <code>dev/binder</code> 的进程都加入到全局 <code>hash</code> 队列 <code>binder_procs</code> 中。最后会在目标设备上的 <code>/proc/binder/proc</code> 目录下创建一个以进程 <code>ID</code> 为名称的只读文件，通过读取这个文件就可以获得进程 <code>PID</code> 的 <code>Binder</code> 线程池、<code>Binder</code> 实体对象、<code>Binder</code> 引用对象以及内核缓冲区等信息。</p>
<ul>
<li><strong>内存映射过程</strong></li>
</ul>
<p>进程打开了设备文件 <code>/dev/binder</code> 之后，还必须要调用函数 <code>mmap</code> 把这个设备文件映射到进程的地址空间，然后才可以使用 <code>Binder</code> 进程间通信机制。设备文件 <code>/dev/binder</code> 对应的是一个虚拟设备，将它映射到进程的地址空间的目的并不是对它的内容感兴趣，而是为了为进程分配内核缓冲区，以便它可以用来传输进程间通信数据。</p>
<p>当进程调用函数 <code>mmap</code> 将设备文件 <code>/dev/binder</code> 映射到自己的地址空间时，<code>Binder</code> 驱动程序中的函数 <code>binder_mmap</code> 就会被调用。</p>
<p><code>Binder</code> 驱动程序最多可以为进程分配 <code>4M</code> 内核缓冲区来传输进程间通信数据。<code>Binder</code> 驱动程序为进程分配的内核缓冲区在用户空间只可以读，而不可以写。</p>
<p><code>Binder</code> 驱动程序为进程分配的内核缓冲区有两个地址，其中一个是用户空间地址，另一个是内核空间地址。进程通过用户空间地址来访问这块内核缓冲区的内容，而 <code>Binder</code> 驱动程序通过内核空间地址来访问这块内核缓冲区的内容。由于它们是连续的，并且起始地址相差一个固定值，因此，只要知道其中的一个地址，就可以方便的计算出另外一个地址。</p>
<p><code>Binder</code> 驱动程序为进程分配的内核缓冲区即为一系列物理页面，它们分别被映射到进程的用户地址空间和内核地址空间。当 <code>Binder</code> 驱动程序需要将一块数据传输给一个进程时，它就可以先把这块数据保存在为该进程所分配的一块内核缓冲区中，然后再把这块内核缓冲区的用户空间地址告诉进程，最后进程就可以访问到里面的数据了。这样做的好处便是不需要将数据从内核空间复制到用户空间，从而提高了数据的传输效率。</p>
</blockquote>
<p>了解了 <code>Binder IPC</code> 的底层通信原理，再看看实现层面 <code>Binder</code> 架构是如何设计的。</p>
<h2 id="Binder-通信模型"><a href="#Binder-通信模型" class="headerlink" title="Binder 通信模型"></a>Binder 通信模型</h2><p>一次完整的进程间通信必然至少包含两个进程，通常我们称通信的双方分别为客户端进程 <code>（Client）</code> 和服务端进程 <code>（Server）</code> ，由于进程隔离机制的存在，通信双方必然需要借助 <code>Binder</code> 来实现。</p>
<p>从组件视角来说，<code>Binder</code> 包含 <code>Client</code> 、<code>Server</code>、<code>ServiceManager</code> 以及 <code>binder驱动</code> ，其中<code>ServiceManager</code> 用于管理系统中的各种服务</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/android/android_binder_ipc.jpg" alt="图片来源于《彻底理解 Android Binder 通信架构》"></p>
<p>其中 <code>Client(AMP)</code>、<code>Server(AMS)</code>、<code>Service Manager</code> 运行在用户空间，它们之间交互都是虚线表示，是由于它们彼此之间不是直接交互的，而是都通过与<code>Binder Driver</code> 进行交互的，<code>Binder</code> 驱动运行在内核空间。其中 <code>Service Manager</code> 和 <code>Binder</code> 驱动由系统提供是 <code>Android</code> 平台的基础架构，而 <code>Client</code>、<code>Server</code> 由应用程序来实现。<code>Client</code>、<code>Server</code> 和 <code>ServiceManager</code> 均是通过系统调用 <code>open</code>、<code>mmap</code> 和 <code>ioctl</code> 来访问设备文件 <code>/dev/binder</code>，从而实现与 <code>Binder</code> 驱动的交互来间接的实现跨进程通信。<code>( 此处的 Service Manager 是指 Native 层的 ServiceManager(C++)，并非指 framework 层的 ServiceManager(Java) )</code></p>
<p><code>Client</code>、<code>Server</code>、<code>ServiceManager</code>、<code>Binder</code> 驱动这几个组件在通信过程中扮演的角色就如同 互联网中服务器 <code>(Server)</code>、客户端 <code>(Client)</code> 、<code>DNS</code> 域名服务器 <code>(ServiceManager)</code> 以及路由器 (<code>Binder</code> 驱动) 之前的关系。</p>
<p>通常我们访问一个网页的步骤是这样的：首先在浏览器输入一个地址，如 <a href="https://link.zhihu.com/?target=http%3A//www.google.com">google.com</a> 然后按下回车键。但是并没有办法通过域名地址直接找到我们要访问的服务器，因此需要首先访问 <code>DNS</code> 域名服务器，域名服务器中保存了 <a href="https://link.zhihu.com/?target=http%3A//www.google.com">google.com</a> 对应的 <code>ip</code> 地址 <code>10.249.23.13</code>，然后通过这个 <code>ip</code> 地址才能访问到 <a href="https://link.zhihu.com/?target=http%3A//www.google.com">google.com</a> 对应的服务器。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/android/android_binder_ipc2.png" alt="图片来源于《写给 Android 应用工程师的 Binder 原理剖析》"></p>
<ul>
<li><p><strong>Binder 驱动</strong></p>
<p><code>Binder</code> 驱动就如同路由器一样，是整个通信的核心；驱动负责进程之间 <code>Binder</code> 通信的建立，<code>Binder</code> 在进程之间的传递，<code>Binder</code> 引用计数管理，数据包在进程之间的传递和交互等一系列底层支持。</p>
</li>
<li><p><strong>ServiceManager</strong></p>
<p><code>ServiceManager</code> 和 <code>DNS</code> 类似，作用是将字符形式的 <code>Binder</code> 名字转化成 <code>Client</code> 中对该 <code>Binder</code> 的引用，使得 <code>Client</code> 能够通过 <code>Binder</code> 的名字获得对 <code>Binder</code> 实体的引用。</p>
<ul>
<li><p><strong>实名 Binder</strong></p>
<p>注册了名字的 <code>Binder</code> 叫实名 <code>Binder</code>，就像网站一样除了除了有 <code>IP</code> 地址以外还有自己的网址。</p>
</li>
</ul>
</li>
</ul>
<p><strong>如何注册服务？</strong></p>
<p><code>Server</code> 创建了 <code>Binder</code>，并为它起一个字符形式，可读易记的名字，将这个 <code>Binder</code> 实体连同名字一起，以数据包的形式通过 <code>Binder</code> 驱动发送给 <code>ServiceManager</code> ，通知 <code>ServiceManager</code> 注册一个名为 <code>“xx”</code> 的 <code>Binder</code>，它位于某个 <code>Server</code> 中。驱动为这个穿越进程边界的 <code>Binder</code> ，创建位于内核中的实体节点，以及 <code>ServiceManager</code> 对实体的引用，将名字以及新建的引用打包传给 <code>ServiceManager</code>。</p>
<p><strong>但是！这里有个问题！</strong> <code>ServierManager</code> 是一个进程，<code>Server</code> 是另一个进程，<code>Server</code> 向 <code>ServiceManager</code> 中注册 <code>Binder</code> 必然涉及到进程间通信。<strong>我们在实现进程间通信的时候需要先用到进程间通信</strong>，这… 这就好像蛋可以孵出鸡的前提却是要先找只鸡下蛋！</p>
<p><strong>解决方法</strong>，<code>Binder</code> 的实现比较巧妙，就是<strong>预先创造一只鸡来下蛋</strong>。<code>ServiceManager</code> 和其他进程同样采用 <code>Bidner</code> 通信，<code>ServiceManager</code> 是 <code>Server</code> 端，有自己的 <code>Binder</code> 实体，其他进程都是 <code>Client</code>，需要通过这个 <code>Binder</code> 的引用来实现 <code>Binder</code> 的注册，查询和获取。</p>
<p><code>ServiceManger</code> 收到数据后从中 取出名字和引用 填入查找表。</p>
<p><code>ServiceManager</code> 提供的 <code>Binder</code> 比较特殊，它没有名字也不需要注册。当一个进程使用 <code>BINDER_SET_CONTEXT_MGR</code> 命令将自己注册成 <code>ServiceManager</code> 时，<code>Binder</code> 驱动会自动为它创建 <code>Binder</code> 实体（<strong>这就是那只预先造好的那只鸡</strong>）。这个 <code>Binder</code> 实体的引用在所有 <code>Client</code> 中都固定为 <code>0</code>， 无需通过其它手段获得。</p>
<p>也就是说，一个 <code>Server</code> 想要向 <code>ServiceManager</code> 注册自己的 <code>Binder</code> 就必须通过这个 <code>0</code> 号引用和 <code>ServiceManager</code> 的 <code>Binder</code> 通信。类比互联网，<code>0</code> 号引用就好比是域名服务器的地址，你必须预先动态或者手工配置好。还有需要注意的是，这里说的 <code>Client</code> 是相对于 <code>ServiceManager</code> 而言的，一个进程或者应用程序可能是提供服务的 <code>Server</code>，但对于 <code>ServiceManager</code> 来说它仍然是个 <code>Client</code>。</p>
<p><strong>怎么获取服务？</strong></p>
<p><code>Server</code> 向 <code>ServiceManager</code> 中注册了 <code>Binder</code> 以后，<code>Client</code> 就能通过名字获得 <code>Binder</code> 的引用了。<code>Client</code> 也利用保留的 <code>0</code> 号引用向 <code>ServiceManager</code> 请求访问某个 <code>Binder</code> 我申请访问名字叫 <code>“xx”</code> 的 <code>Binder</code> 引用。</p>
<p><code>ServiceManager</code> 收到这个请求后从请求数据包中取出 <code>Binder</code> 名称，在查找表里找到对应的条目，取出对应的 Binder 引用作为回复发送给发起请求的 <code>Client</code>。</p>
<p>从面向对象的角度看，<code>Server</code> 中的 <code>Binder</code> 实体现在有两个引用：一个位于 <code>ServiceManager</code> 中，一个位于发起请求的 <code>Client</code> 中。如果接下来有更多的 <code>Client</code> 请求该 <code>Binder</code>，系统中就会有更多的引用指向该 <code>Binder</code> ，就像 <code>Java</code> 中一个对象有多个引用一样。</p>
<h2 id="Binder-通信过程"><a href="#Binder-通信过程" class="headerlink" title="Binder 通信过程"></a>Binder 通信过程</h2><ol>
<li>首先，一个进程使用 <code>BINDER_SET_CONTEXT_MGR</code> 命令通过 <code>Binder</code> 驱动将自己注册成为 <code>ServiceManager</code>；</li>
<li><code>Server</code> 通过驱动向 <code>ServiceManager</code> 中注册 <code>Binder</code>（<code>Server</code> 中的 <code>Binder</code> 实体），表明可以对外提供服务。驱动为这个 <code>Binder</code> 创建位于内核中的实体节点，以及 <code>ServiceManager</code> 对实体的引用，将名字以及新建的引用打包传给 <code>ServiceManager</code>，<code>ServiceManger</code> 将其填入查找表。</li>
<li><code>Client</code> 通过名字，在 <code>Binder</code> 驱动的帮助下从 <code>ServiceManager</code> 中获取到对 <code>Binder</code> 实体的引用，通过这个引用就能实现和 <code>Server</code> 进程的通信。</li>
</ol>
<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/android/android_binder_ipc3.jpg" alt="图片来源于《写给 Android 应用工程师的 Binder 原理剖析》"></p>
<h2 id="Binder-通信中的代理模式"><a href="#Binder-通信中的代理模式" class="headerlink" title="Binder 通信中的代理模式"></a>Binder 通信中的代理模式</h2><p>我们已经解释清楚 <code>Client</code>、<code>Server</code> 借助 <code>Binder</code> 驱动完成跨进程通信的实现机制了，但是还有个问题会让我们困惑。</p>
<p><code>A</code> 进程想要 <code>B</code> 进程中某个对象（<code>object</code>）是如何实现的呢？毕竟它们分属不同的进程，<code>A</code> 进程 没法直接使用 <code>B</code> 进程中的 <code>object</code>。</p>
<p><strong>一次通信过程简述</strong></p>
<p>跨进程通信的过程都有 <code>Binder</code> 驱动的参与，因此在数据流经 <code>Binder</code> 驱动的时候驱动会对数据做一层转换。</p>
<p>当 <code>A</code> 进程想要获取 <code>B</code> 进程中的 <code>object</code> 时，驱动并不会真的把 <code>object</code> 返回给 <code>A</code>，而是返回了一个跟 <code>object</code> 看起来一模一样的代理对象 <code>objectProxy</code>，这个 <code>objectProxy</code> 具有和 <code>object</code> 一摸一样的方法，但是这些方法并没有 <code>B</code> 进程中 <code>object</code> 对象那些方法的能力，这些方法只需要把请求参数交给驱动即可。对于 <code>A</code> 进程来说和直接调用 <code>object</code> 中的方法是一样的。</p>
<p>当 <code>Binder</code> 驱动接收到 <code>A</code> 进程的消息后，发现这是个 <code>objectProxy</code> 就去查询自己维护的表单，一查发现这是 <code>B</code> 进程 <code>object</code> 的代理对象。于是就会去通知 <code>B</code> 进程调用 <code>object</code> 的方法，并要求 <code>B</code> 进程把返回结果发给自己。当驱动拿到 <code>B</code> 进程的返回结果后就会转发给 <code>A</code> 进程，一次通信就完成了。</p>
<p><strong><code>Binder</code> 中的具体调用如下：</strong></p>
<p>在 <code>Client</code> 进程和 <code>Server</code> 进程的一次通信过程中，涉及了四种类型的对象，它们分别是</p>
<ul>
<li>位于 <code>Binder</code> 驱动程序中的 <code>Binder</code> 实体对象 <code>（binder_node）</code> 和 <code>Binder</code> 引用对象 <code>（binder_ref）</code> </li>
<li>位于 <code>Binder</code> 库中的 <code>Binder</code> 本地对象 <code>（BBinder）</code> 和 <code>Binder</code> 代理对象 <code>（BpBinder）</code> </li>
</ul>
<p>它们的交互过程如下：</p>
<ol>
<li>运行在 <code>Client</code> 进程中的 <code>Binder</code> <strong>代理对象</strong>通过 <code>Binder</code> 驱动程序向运行在 <code>Server</code> 进程中的 <code>Binder</code> <strong>本地对象</strong>发出一个进程间通信请求，<code>Binder</code> 驱动程序接着就根据 <code>Client</code> 进程传递过来的 <code>Binder</code> <strong>代理对象</strong>的句柄值来找到对应的 <code>Binder</code> <strong>引用对象</strong>。</li>
<li><code>Binder</code> 驱动程序根据前面找到的 <code>Binder</code> <strong>引用对象</strong>找到对应的 <code>Binder</code> <strong>实体对象</strong>，并且创建一个事务 <code>（binder_transaction）</code> 来描述该次进程间通信过程。</li>
<li><code>Binder</code> 驱动程序根据前面找到的 <code>Binder</code> <strong>实体对象</strong>来找到运行在 <code>Server</code> 进程中的 <code>Binder</code> <strong>本地对象</strong>，并且将 <code>Client</code> 进程传递过来的通信数据发送给它处理。</li>
<li><code>Binder</code> <strong>本地对象</strong>处理完成 <code>Client</code> 进程的通信请求之后，就将通信结果返回给 <code>Binder</code> 驱动程序，<code>Binder</code> 驱动程序接着就找到前面所创建的一个事务。</li>
<li><code>Binder</code> 驱动程序根据前面找到的事务的相关属性来找到发出通信请求的 <code>Client</code> 进程，并且通知 <code>Client</code> 进程将通信结果返回给对应的 <code>Binder</code> <strong>代理对象</strong>处理。</li>
</ol>
<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/android/android_binder_ipc4.jpg" alt="图片来源于《写给 Android 应用工程师的 Binder 原理剖析》"></p>
<p>从这个过程就可以看出，<code>Binder</code> 代理对象依赖于 <code>Binder</code> 引用对象，而 <code>Binder</code> 引用对象又依赖于 <code>Binder</code> 实体对象，最后，<code>Binder</code> 实体对象又依赖于 <code>Binder</code> 本地对象。这样，<code>Binder</code> 进程间通信机制就必须采用一种技术措施来保证，不能销毁一个还被其他对象依赖着的对象。为了维护这些 <code>Binder</code> 对象的依赖关系，<code>Binder</code> 进程间通信机制采用了<strong>引用计数</strong>来维护每一个 <code>Binder</code> 对象的生命周期。</p>
<blockquote>
<p><strong>深入了解</strong></p>
<ul>
<li><strong>Binder 本地对象的生命周期</strong></li>
</ul>
<p><code>Binder</code> 本地对象是一个类型为 <code>BBinder</code> 的对象，它是在用户空间中创建的，并且运行在 <code>Server</code> 进程中。</p>
<p><code>Binder</code> 本地对象一方面会被运行在 <code>Server</code> 进程中的其他对象引用，另一方面也会被 <code>Binder</code> 驱动程序中的 <code>Binder</code> 实体对象引用。</p>
<p>由于 <code>BBinder</code> 类继承了 <code>RefBase</code> 类，因此，<code>Server</code> 进程中的其他对象可以简单的通过智能指针来引用这些 <code>Binder</code> 本地对象，以便可以控制它们的生命周期。</p>
<p>由于 <code>Binder</code> 驱动程序中的 <code>Binder</code> 实体对象是运行在内核空间的，它不能够通过智能指针来引用运行在用户空间的 <code>Binder</code> 本地对象，因此，<code>Binder</code> 驱动程序就需要和 <code>Server</code> 进程约定一套规则来维护它们的引用计数，避免它们在还被 <code>Binder</code> 实体对象引用的情况下销毁。</p>
<p><strong>如何保证本地对象在 <code>Binder</code> 实体对象引用的情况下不被销毁？</strong></p>
<p><code>Server</code> 进程将一个 <code>Binder</code> 本地对象注册到 <code>ServerManager</code> 时，<code>Binder</code> 驱动程序就会为它创建一个 <code>Binder</code> 实体对象。接下来，当 <code>Client</code> 进程通过 <code>ServerManager</code> 来查询一个 <code>Binder</code> 本地对象的代理对象接口时，<code>Binder</code> 驱动程序就会为它所对应的 <code>Binder</code> 实体对象创建一个 <code>Binder</code> 引用对象，接着在使用 <code>BR_INCREFS</code> 和 <code>BR_ACQUIRE</code> 协议来通知对应的 <code>Server</code> 进程增加对应的 <code>Binder</code> 本地对象的弱引用技术和强引用技术。这样就能保证 <code>Client</code> 进程中的 <code>Binder</code> 代理对象在引用一个 <code>Binder</code> 本地对象期间，该 <code>Binder</code> 本地对象不会被销毁。当没有任何 <code>Binder</code> 代理对象引用一个 <code>Binder</code> 本地对象时，<code>Binder</code> 驱动程序就会使用 <code>BR_DECREFS</code> 和 <code>BR_RELEASE</code> 协议来通知对应的 <code>Server</code> 进程减少对应的 <code>Binder</code> 本地对象的弱引用技术和强引用技术。</p>
<p>总结来说，<code>Binder</code> 驱动程序就是通过 <code>BR_INCREFS</code>、<code>BR_ACQUIRE</code>、<code>BR_DECREFS</code> 和 <code>BR_RELEASE</code> 协议来引用运行在 <code>Server</code> 进程中的 <code>Binder</code> 本地对象的，相关的代码实现在函数 <code>binder_thread_read</code> 中。</p>
<ul>
<li><strong>Binder 实体对象的生命周期</strong></li>
</ul>
<p><code>Binder</code> 实体对象是一个类型为 <code>binder_node</code> 的对象，它是在 <code>Binder</code> 驱动程序中创建的，并且被 <code>Binder</code> 驱动程序中的 <code>Binder</code> 引用对象所引用。</p>
<p>当 <code>Client</code> 进程第一次引用一个 <code>Binder</code> 实体对象时，<code>Binder</code> 驱动程序就会在内部为它创建一个 <code>Binder</code> 引用对象。例如，当 <code>Client</code> 进程通过 <code>ServerManager</code> 来获得一个 <code>Service</code> 组件的代理对象接口时，<code>Binder</code> 驱动程序就会找到与该 <code>Service</code> 组件对应的 <code>Binder</code> 实体对象，接着再创建一个 <code>Binder</code> 引用对象来引用它。这时候就需要增加被引用的 <code>Binder</code> 实体对象的引用计数。相应地，当 <code>Client</code> 进程不再引用一个 <code>Service</code> 组件时，它也会请求 <code>Binder</code> 驱动程序释放之前为它所创建的 <code>Binder</code> 引用对象。这时候就需要减少该 <code>Binder</code> 引用对象所引用的 <code>Binder</code>实体对象的引用计数。</p>
<ul>
<li><strong>Binder 引用对象的生命周期</strong></li>
</ul>
<p><code>Binder</code> 引用对象是一个类型为 <code>binder_ref</code> 的对象，它是在 <code>Binder</code> 驱动程序中创建的，并且被用户空间中的 <code>Binder</code> 代理对象所引用。</p>
<p>当 <code>Client</code> 进程引用了 <code>Server</code> 进程中的一个 <code>Binder</code> 本地对象时，<code>Binder</code> 驱动程序就会在内部为它创建一个 <code>Binder</code> 引用对象。由于 <code>Binder</code> 引用对象是运行在内核空间的，而引用了它的 <code>Binder</code> 代理对象是运行在用户空间的，因此，<code>Client</code> 进程和 <code>Binder</code> 驱动程序就需要约定一套规则来维护 <code>Binder</code> 引用对象的引用计数，避免它们在还被 <code>Binder</code> 代理对象引用的情况下被销毁。</p>
<p>这套规则可以划分为 <code>BC_ACQUIRE</code>、<code>BC_INCREFS</code>、<code>BC_RELEASE</code> 和 <code>BC_DECREFS</code> 四个协议，分别用来增加和减少一个 <code>Binder</code> 引用对象的强引用技术和弱引用技术。相关的代码实现在 <code>Binder</code> 驱动程序的函数<code>binder_thread_write</code> 中。</p>
<ul>
<li><strong>Binder 代理对象的生命周期</strong></li>
</ul>
<p><code>Binder</code> 代理对象是一个类型为 <code>BpBinder</code> 的对象，它是在用户空间中创建的，并且运行在 <code>Client</code> 进程中。</p>
<p>与 <code>Binder</code> 本地对象类似，<code>Binder</code> 代理对象一方面会被运行在 <code>Client</code> 进程中的其他对象引用，另一方面它也会引用 <code>Binder</code> 驱动程序中的 <code>Binder</code> 引用对象。</p>
<p>由于 <code>BpBinder</code> 类继承了 <code>RefBase</code> 类，因此，<code>Client</code> 进程中的其他对象可以简单地通过智能指针来引用这些 <code>Binder</code> 代理对象，以便可以控制它们的生命周期。</p>
<p>由于 <code>Binder</code> 驱动程序中的 <code>Binder</code> 引用对象是运行在内核空间的，<code>Binder</code> 代理对象就不能通过智能指针来引用它们，因此，<code>Client</code> 进程就需要通过 <code>BC_ACQUIRE</code>、<code>BC_INCREFS</code>、<code>BC_RELEASE</code> 和 <code>BC_DECREFS</code> 四个协议来引用 <code>Binder</code> 驱动程序中的 <code>Binder</code> 引用对象。</p>
<p>前面提到，每一个 <code>Binder</code> 代理对象都是通过一个句柄值来和一个 <code>Binder</code> 引用对象关联的，而 <code>Client</code> 进程就是通过这个句柄值来维护运行在它里面的 <code>Binder</code> 代理对象的。具体来说，就是 <code>Client</code> 进程会在内部创建一个 <code>handle_entry</code> 类型的 <code>Binder</code> 代理对象列表，它以句柄值作为关键字来维护它内部所有的 <code>Binder</code> 代理对象。</p>
<ul>
<li><strong>智能指针</strong></li>
</ul>
<p>智能指针是一种能够自动维护对象引用计数的技术，它是一个对象而不是一个指针，但是它引用了一个实际使用的对象。正是因为它是一个对象，因此它能够自动地维护实际对象的引用计数。简单来说，就是在智能指针构造时，增加它所引用的对象的引用计数；而在智能指针析构时，就减少它所引用的对象的引用计数。由于智能指针的构造和析构都是自动的，因此，它就很自然的实现了自动的对象引用计数技术。</p>
<p>但是这样并不能解决对象的相互引用问题，于是就需要采取一种稍微复杂的引用计数技术来维护对象的生周期了，这种引用计数技术将对象的引用计数分为强引用计数和弱引用计数两种，其中，对象的生命周期只受强引用计数控制。</p>
<p><code>Android</code> 系统提供了三种类型的 <code>C++</code> 智能指针，分别为轻量级指针（<code>Light Pointer</code>）、强指针（<code>Strong Pointer</code>）和弱指针（<code>Weak Pointer</code>）。</p>
</blockquote>
<h2 id="Binder-的完整定义"><a href="#Binder-的完整定义" class="headerlink" title="Binder 的完整定义"></a>Binder 的完整定义</h2><ul>
<li>从进程间通信的角度看，<code>Binder</code> 是一种进程间通信的机制；</li>
<li>从 <code>Server</code> 进程的角度看，<code>Binder</code> 指的是 <code>Server</code> 中的 <code>Binder</code> 实体对象；</li>
<li>从 <code>Client</code> 进程的角度看，<code>Binder</code> 指的是对 <code>Binder</code> 代理对象，是 <code>Binder</code> 实体对象的一个远程代理</li>
<li>从传输过程的角度看，<code>Binder</code> 是一个可以跨进程传输的对象；<code>Binder</code> 驱动会对这个跨越进程边界的对象对一点点特殊处理，自动完成代理对象和本地对象之间的转换。</li>
</ul>
<p><strong>简单 Demo</strong></p>
<p><a target="_blank" rel="noopener" href="https://github.com/CalmCenter/HelloBinder">HelloBinder</a></p>
<h1 id="感谢：本文收集整理自如下文章"><a href="#感谢：本文收集整理自如下文章" class="headerlink" title="感谢：本文收集整理自如下文章"></a><strong>感谢：本文收集整理自如下文章</strong></h1><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/35519585">写给 Android 应用工程师的 Binder 原理剖析</a></p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/39440766/answer/89210950">为什么 Android 要采用 Binder 作为 IPC 机制？</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/Omooo/Android-Notes/blob/master/blogs/Android/Framework/源代码情景分析">Binder 对象引用计数技术</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/Omooo/Android-Notes/blob/master/blogs/Android/Framework/源代码情景分析">Binder 设备文件的初始化、打开和内存映射过程</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903976819752968#comment">Android Binder原理（一）学习Binder前必须要了解的知识点</a></p>
<p><a target="_blank" rel="noopener" href="http://gityuan.com/2016/09/04/binder-start-service/">彻底理解Android Binder通信架构</a></p>
<p><a target="_blank" rel="noopener" href="http://gityuan.com/2015/10/31/binder-prepare/">Binder系列</a></p>
<h1 id="可能问到的问题"><a href="#可能问到的问题" class="headerlink" title="可能问到的问题"></a>可能问到的问题</h1><ul>
<li>进程间通信的方式？<ul>
<li>多进程间的通信 <code>IPC(InterProcess Communication)</code><ul>
<li>AIDL<code>（Android Interface Definition Language，Android接口定义语言）</code>：适合于多进程多线程，需要开发者自己实现线程安全.</li>
<li>Messenger ：基于消息的进程间通信的方式，适合于多进程单线程</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/ce1e35c84134">Android开发高级进阶——多进程间通信</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/hello_json/article/details/79815320"> Messenger 和 AIDL 的区别</a></li>
</ul>
</li>
<li>Binder机制的作用和原理？<ul>
<li>上文 Binder IPC 如何通信？</li>
</ul>
</li>
<li>简述IPC？</li>
<li>什么是AIDL？如何使用？<ul>
<li><code>AIDL(Android Interface Define Language)</code> 是 <code>IPC</code> 进程间通信方式的一种，用于生成可以在 <code>Android</code> 设备上两个进程之间进行进程间通信<code>(interprocess communication, IPC)</code> 的代码.</li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/a5c73da2e9be">AIDL使用解析</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/d1fac6ccee98">Android中AIDL的使用详解</a></li>
</ul>
</li>
<li>AIDL解决了什么问题？<ul>
<li><code>官方文档：
Note: Using AIDL is necessary only if you allow clients from different applications to access your service for IPC and want to handle multithreading in your service. If you do not need to perform concurrent IPC across different applications, you should create your interface by implementing a Binder or, if you want to perform IPC, but do not need to handle multithreading, implement your interface using a Messenger. Regardless, be sure that you understand Bound Services before implementing an AIDL.
“只有当你允许来自不同的客户端访问你的服务并且需要处理多线程问题时你才必须使用AIDL”</code></li>
</ul>
</li>
<li>Android 进程分类？<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhongshujunqia/article/details/72458271">Android-四种进程类型</a></li>
</ul>
</li>
<li>谈谈对进程共享和线程安全的认识?<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/oweixiao123/article/details/9057445">android的线程安全</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/android-blogs/p/5816922.html">Android开发中多进程共享数据</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/coding_glacier/article/details/8230159">Android中UID机制和共享进程</a></li>
<li>问你线程安全的时候，不止要回答主线程跟子线程之间的切换，还有数据结构处理的线程安全问题，多线程操作同一个数据的一致性问题，等等。</li>
</ul>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">CalmCenter</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://calmcenter.club/2020/android-framework-binder.html">https://calmcenter.club/2020/android-framework-binder.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://calmcenter.club" target="_blank">CalmCenter</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Android/">Android</a></div><div class="post_share"><div class="social-share" data-image="https://gitee.com/CalmCenter/Pic/raw/master/background/cover4.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.png" target="_blank"><img class="post-qr-code-img" data-lazy-src="/img/wechat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.png" target="_blank"><img class="post-qr-code-img" data-lazy-src="/img/alipay.png" alt="支付寶"/></a><div class="post-qr-code-desc">支付寶</div></li></ul></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/caoz01-gou-tong-mu-biao-ji-chang-jian-wu-qu-man-tan.html"><img class="prev-cover" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/bg2/cover5.webp" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">沟通目标及常见误区漫谈</div></div></a></div><div class="next-post pull-right"><a href="/2020/android-framework-activity.html"><img class="next-cover" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/bg2/cover6.webp" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Android 11 Activity 启动分析</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2019/performance-launch.html" title="App 初体验-启动优化💦"><img class="cover" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/bg2/cover5.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-12-24</div><div class="title">App 初体验-启动优化💦</div></div></a></div><div><a href="/2020/android-compilation-basis.html" title="Android 编译基础"><img class="cover" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/cover20.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-11-24</div><div class="title">Android 编译基础</div></div></a></div><div><a href="/2021/android-framework-process.html" title="Android 11 进程创建流程"><img class="cover" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/bg2/cover4.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-20</div><div class="title">Android 11 进程创建流程</div></div></a></div><div><a href="/2019/complete-works-of-android-performance.html" title="Android 性能优化篇"><img class="cover" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/20200228233120.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-12-01</div><div class="title">Android 性能优化篇</div></div></a></div><div><a href="/2020/network-optimization.html" title="App 网络优化🌞"><img class="cover" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/cover19.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-05-20</div><div class="title">App 网络优化🌞</div></div></a></div><div><a href="/2020/stability-optimization.html" title="稳定性优化"><img class="cover" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/cover26.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-06-02</div><div class="title">稳定性优化</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside_content" id="aside_content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><img class="avatar-img" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">CalmCenter</div><div class="author-info__description">目标设置到月球，即使陨落也是在群星之间！</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">58</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/CalmCenter"><i class="fab fa-github"></i><span>Follow Me</span></a></div></div><div class="card-widget card-announcement"><div class="card-content"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">不要努力成为一个成功的人，而要努力成为一个有价值的人。</div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Binder-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">Binder 是什么？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Binder-%E6%9C%89%E9%82%A3%E4%B9%88%E9%87%8D%E8%A6%81%E5%90%97"><span class="toc-text">Binder 有那么重要吗 ?</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E4%B8%AD%E4%BA%86-Binder-%E5%AE%9E%E7%8E%B0-IPC-%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-text">为什么选中了 Binder 实现 IPC 机制？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-%E4%BC%A0%E7%BB%9F-IPC-%E5%A6%82%E4%BD%95%E9%80%9A%E4%BF%A1%E7%9A%84%EF%BC%9F"><span class="toc-text">Linux 传统 IPC 如何通信的？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux-%E7%9A%84-IPC-%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86"><span class="toc-text">Linux 的 IPC 通信原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Binder-IPC-%E5%A6%82%E4%BD%95%E9%80%9A%E4%BF%A1%E7%9A%84%EF%BC%9F"><span class="toc-text">Binder IPC 如何通信的？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Binder-%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B"><span class="toc-text">Binder 通信模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Binder-%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B"><span class="toc-text">Binder 通信过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Binder-%E9%80%9A%E4%BF%A1%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="toc-text">Binder 通信中的代理模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Binder-%E7%9A%84%E5%AE%8C%E6%95%B4%E5%AE%9A%E4%B9%89"><span class="toc-text">Binder 的完整定义</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%84%9F%E8%B0%A2%EF%BC%9A%E6%9C%AC%E6%96%87%E6%94%B6%E9%9B%86%E6%95%B4%E7%90%86%E8%87%AA%E5%A6%82%E4%B8%8B%E6%96%87%E7%AB%A0"><span class="toc-text">感谢：本文收集整理自如下文章</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%AF%E8%83%BD%E9%97%AE%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">可能问到的问题</span></a></li></ol></div></div></div></div></div></main><footer id="footer" style="background-image: url(https://gitee.com/CalmCenter/Pic/raw/master/background/cover4.webp)"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By CalmCenter</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><link rel="stylesheet" href="/live2d/css/live2d.css"/></div><div id="landlord"><div class="message" style="opacity:0"></div><canvas class="live2d" id="live2d" width="240" height="250"></canvas><div class="hide-button">隐藏</div></div><script type="text/javascript" src="https://cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script><script type="text/javascript">var message_Path = '/live2d/'
var home_Path = 'https://calmcenter.club/'</script><script type="text/javascript" src="/live2d/js/live2d.js"></script><script type="text/javascript" src="/live2d/js/message.js"></script><script type="text/javascript">loadlive2d("live2d", "/live2d/model/xxb2/model.json");</script></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>function addGitalkSource () {
  const ele = document.createElement('link')
  ele.rel = 'stylesheet'
  ele.href= 'https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css'
  document.getElementsByTagName('head')[0].appendChild(ele)
}

function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk({
      clientID: '9b707b75b56f9e432b12',
      clientSecret: '6e2d5a012729aa6c9e8df3cc0a90d82f976a026e',
      repo: 'calmcenter.github.io',
      owner: 'CalmCenter',
      admin: ['CalmCenter'],
      id: 'c55bf7432af4a6cdaec512ed33f38bef',
      language: 'zh-CN',
      perPage: 10,
      distractionFreeMode: false,
      pagerDirection: 'last',
      createIssueManually: false,
      updateCountCallback: commentCount
    })
    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    addGitalkSource()
    $.getScript('https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js', initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !false) {
  if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></body></html>