<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>App 直观感受-卡顿优化🌈 | CalmCenter</title><meta name="keywords" content="Android"><meta name="author" content="CalmCenter"><meta name="copyright" content="CalmCenter"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="🌞页面直观反映，用户直观感受🌞页面卡顿问题，如何用 Linux 命令组合排查卡顿？有没有方便的 Android 卡顿排查工具？来这里寻找答案。">
<meta property="og:type" content="article">
<meta property="og:title" content="App 直观感受-卡顿优化🌈">
<meta property="og:url" content="https://calmcenter.club/2020/hobble-optimization.html">
<meta property="og:site_name" content="CalmCenter">
<meta property="og:description" content="🌞页面直观反映，用户直观感受🌞页面卡顿问题，如何用 Linux 命令组合排查卡顿？有没有方便的 Android 卡顿排查工具？来这里寻找答案。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://calmcenter.club/img/avatar.jpg">
<meta property="article:published_time" content="2020-04-20T04:59:00.000Z">
<meta property="article:modified_time" content="2020-04-20T04:59:00.000Z">
<meta property="article:author" content="CalmCenter">
<meta property="article:tag" content="Android">
<meta property="article:tag" content="性能优化">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://calmcenter.club/img/avatar.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://calmcenter.club/2020/hobble-optimization"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  ClickShowText: undefined,
  lightbox: 'mediumZoom',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"top-right"},
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2020-04-20 12:59:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><meta name="generator" content="Hexo 5.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" data-lazy-src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">43</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://gitee.com/CalmCenter/Pic/raw/master/cover25.webp)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">CalmCenter</a></span><span id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><h1 class="post-title">App 直观感受-卡顿优化🌈</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-04-20T04:59:00.000Z" title="发表于 2020-04-20 12:59:00">2020-04-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-04-20T04:59:00.000Z" title="更新于 2020-04-20 12:59:00">2020-04-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Android/">Android</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>22分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>对用户来说，<strong>内存占用高</strong>、<strong>耗费电量</strong>、<strong>耗费流量</strong> 可能不容易被发现，但是用户对 <strong>卡顿</strong> 特别敏感，很容易直观感受到。</p>
<p><strong>注意：如果出现图片不显示问题请移步</strong> <a href="https://calmcenter.club/2019/PicNotShow.html">图片不显示问题</a></p>
<h1 id="本文主要记载"><a href="#本文主要记载" class="headerlink" title="本文主要记载"></a>本文主要记载</h1><ul>
<li><strong>1 如何定义卡顿？</strong></li>
<li><strong>2 如何排查卡顿？</strong><ul>
<li>2.1 Linux 命令组合排查</li>
<li>2.2 使用 top 命令查看进程信息</li>
</ul>
</li>
<li><strong>3 有没有方便的 Android 卡顿排查工具？</strong><ul>
<li>3.1 TraceView</li>
<li>3.2 Nanoscope</li>
<li>3.3 systrace</li>
<li>3.4 Simpleperf</li>
<li>3.5 可视化方法(Android Studio Profiler)</li>
<li>3.6 Android Performance Montitor(BlockCanary)</li>
<li>3.7 Profilo</li>
</ul>
</li>
<li><strong>4 卡顿现场</strong><ul>
<li>4.1 获取 java 线程状态</li>
<li>4.2 获得所有线程堆栈</li>
<li>4.3 SIGQUIT 信号实现</li>
<li>4.4 Hook 实现</li>
</ul>
</li>
<li><strong>5 相关 Demo 学习</strong><ul>
<li>5.1 抓取 CPU 数据</li>
<li>5.2 PLTHook 监控 Thread 的创建</li>
<li>5.3 Loop 监控卡顿</li>
</ul>
</li>
<li>总结</li>
</ul>
<hr>
<h1 id="1-如何定义卡顿？"><a href="#1-如何定义卡顿？" class="headerlink" title="1 如何定义卡顿？"></a>1 如何定义卡顿？</h1><p><code>60帧</code> 每秒是目前最合适的图像显示速度，也是绝大部分 <code>Android</code> 设备设置的调试频率，如果在 <code>16ms</code> 内顺利完成界面刷新操作可以展示出流畅的画面，而由于任何原因导致接收到 <code>VSYNC</code> 信号的时候无法完成本次刷新操作，就会产生掉帧的现象，刷新帧率自然也就跟着下降(假定刷新帧率由正常的 <code>60fps</code> 降到 <code>30fps</code> ，用户就会明显感知到卡顿)。</p>
<p>卡顿的原因可以定义为 <code>UI 复杂度问题</code> ，<code>没有提前或异步初始化问题</code> ， <code>内存泄漏频繁 GC 的问题</code> 等，卡顿的解决思路是集结了 启动优化、内存优化、UI 优化 的所有知识点，所以这篇也是对之前的扩展补充。</p>
<p>造成卡顿的原因可能有千百种，不过最终都会反映到 CPU 时间上。</p>
<p>我们可以把 CPU 时间分为两种：</p>
<ol>
<li>用户时间：执行用户态应用程序代码所消耗的时间</li>
<li>系统时间：执行内核态系统调用所消耗的时间，包括 I/O、锁、中断以及其他系统调用的时间。</li>
</ol>
<hr>
<h1 id="2-如何排查卡顿"><a href="#2-如何排查卡顿" class="headerlink" title="2 如何排查卡顿"></a>2 如何排查卡顿</h1><h2 id="2-1-Linux-命令组合排查"><a href="#2-1-Linux-命令组合排查" class="headerlink" title="2.1 Linux 命令组合排查"></a>2.1 Linux 命令组合排查</h2><ol>
<li><strong>获取 <code>CPU</code> 核心数</strong></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;possible</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>获取某个 <code>CPU</code> 的频率</strong></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpu0&#x2F;cpufreq&#x2F;cpuinfo_max_freq</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/20200420172904.png" alt=""></p>
<p>我们需要根据设备 <code>CPU</code> 性能来 “看菜下饭” ，例如线程池使用线程数根据 <code>CPU</code> 的核心数，一些高级的 <code>AI</code> 功能只在主频比较高或者带有 <code>NPU</code> 的设备开启。</p>
<ol start="3">
<li><strong>查看 <code>CPU</code> 的使用率</strong></li>
</ol>
<p><strong>整个系统的 CPU 使用情况</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;proc&#x2F;stat</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;adb shell</span><br><span class="line">cat &#x2F;proc&#x2F;stat</span><br><span class="line">cpu  166492 36473 149538 7550789 34852 0 9110 0 0 0</span><br><span class="line">cpu0 31858 4048 34220 808812 5172 0 4604 0 0 0</span><br><span class="line">cpu1 22897 4439 25504 894380 7874 0 1514 0 0 0</span><br><span class="line">cpu2 29068 6317 27063 908505 7657 0 673 0 0 0</span><br><span class="line">cpu3 25916 6157 23508 931591 6625 0 259 0 0 0</span><br><span class="line">cpu4 28689 5321 22388 971414 2544 0 1030 0 0 0</span><br><span class="line">cpu5 10136 3778 6687 1009482 1551 0 606 0 0 0</span><br><span class="line">cpu6 8074 3398 5163 1014162 1489 0 218 0 0 0</span><br><span class="line">cpu7 9854 3015 5005 1012443 1940 0 206 0 0 0</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>第一行的数据表示的是 <code>CPU</code> 总的使用情况</p>
<ol>
<li><p>这些数值的单位都是 <code>jiffies</code>。<code>jiffies</code> 是内核中的一个全局变量，用来记录系统启动以来产生的节拍数，在 <code>Linux</code> 中，一个节拍大致可以理解为操作系统进程调度的最小时间片，不同的 <code>Linux</code> 系统内核这个值可能不同，通常在 <code>1ms</code> 到 <code>10ms</code> 之间。</p>
</li>
<li><p>cpu  166492 36473 149538 7550789 34852 0 9110 0 0 0</p>
<ul>
<li><code>user</code>(166492) 从系统启动开始累积到当前时刻，处于用户态的运行时间，不包含 nice 值为负的进程。</li>
<li><code>nice</code>(36473) 从系统启动开始累积到当前时刻，nice 值为负的进程所占用的 CPU 时间。</li>
<li><code>system</code>(149538) 从系统启动开始累积到当前时刻，处于核心态的运行时间。</li>
<li><code>idle</code>(7550789) 从系统启动开始累积到当前时刻，除 IO 等待时间以外的其他等待时间。</li>
<li><code>iowait</code>(34852) 从系统启动开始累积到当前时刻，IO 等待时间。(since 2.5.41)</li>
<li><code>irq</code>(0) 从系统启动开始累积到当前时刻，硬中断时间。(since 2.6.0-test4)</li>
<li><code>softirq</code>(9110) 从系统启动开始累积到当前时刻，软中断时间。(since 2.6.0-test4)</li>
<li><code>stealstolen</code>(0) 这是在虚拟环境中运行时在其他操作系统中花费的时间。(since 2.6.11)</li>
<li><code>guest</code>(0) 这是运行 Linux 内核控制下的来宾操作系统的虚拟 CPU 所花费的时间。(since 2.6.24)</li>
<li><code>guest_nice</code>(0) 运行 niced 客户端的时间( Linux 内核控制下的客户操作系统的虚拟CPU)。(since Linux 2.6.33)</li>
</ul>
<p>具体使用率计算请查看 <a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/71982">《Linux环境下进程的CPU占用率》</a> 还是有点麻烦的 ~ </p>
</li>
</ol>
<h2 id="2-2-使用-top-命令查看进程信息"><a href="#2-2-使用-top-命令查看进程信息" class="headerlink" title="2.2 使用 top 命令查看进程信息"></a>2.2 使用 top 命令查看进程信息</h2><ol>
<li><p>直接输入 <code>top</code> 可查看所有进程的 <code>cpu</code> 使用情况</p>
<p>几个常用的参数：</p>
<ul>
<li><code>-d</code>: 后面接秒数，就是整个进程画面更新的频率。默认是 5 秒。</li>
<li><code>-b</code>: 以批处理的方式执行 top，还有更多的参数可用。通常会搭配数据流重导向，将批处理的结果输出为文件。</li>
<li><code>-n</code>: 与 -b 搭配，意义是，需要进行几次 top 的输出结果。</li>
<li><code>-p</code>: 指定某个 PID 来进行观察监测。</li>
<li>在 top 执行过程中可以使用的按键命令：</li>
<li><code>?</code>: 显示在 top 中可以输入的按键命令。</li>
<li><code>P</code>: 按照 CPU 的使用资源排序显示。</li>
<li><code>M</code>: 按内存（Memory）的使用资源排序显示。</li>
<li><code>N</code>: 按 PID 来排序。</li>
<li><code>T</code>: 按该进程使用的 CPU 时间积累（TIME+）排序。</li>
<li><code>k</code>: 给某个 PID 一个信号（signal）。</li>
<li><code>r</code>: 给某个 PID 重新确定一个值。</li>
<li><code>1</code>: 显示所有 CPU 占用信息。</li>
</ul>
</li>
<li><p>监测进程 13620</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -d 2 -p 13620</span><br></pre></td></tr></table></figure>

<p>会一直输出进程 13620 的信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">top - 16:27:35 up 4 days, 7:43, 2 users, load average: 0.35, 0.47, 0.44</span><br><span class="line">Tasks: 1 total, 1 running, 0 sleeping, 0 stopped, 0 zombie</span><br><span class="line">Cpu(s): 0.1%us, 3.1%sy, 0.0%ni, 96.5%id, 0.0%wa, 0.0%hi, 0.3%si, 0.0%st</span><br><span class="line">Mem: 16320632k total, 1790796k used, 14529836k free, 233168k buffers</span><br><span class="line">Swap: 8232952k total, 0k used, 8232952k free, 941540k cached</span><br><span class="line"> </span><br><span class="line">PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND</span><br><span class="line">13620 test1370 20 0 11060 944 760 R 53.4 0.0 0:04.78 netperf</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="3-有没有方便的-Android-卡顿排查工具？"><a href="#3-有没有方便的-Android-卡顿排查工具？" class="headerlink" title="3 有没有方便的 Android 卡顿排查工具？"></a>3 有没有方便的 Android 卡顿排查工具？</h1><p>日常开发中比较熟悉的工具分为两个流派：</p>
<ul>
<li><p>instrument 流派</p>
<p>获取一段时间内所有函数的调用过程，可以通过分析这段时间内的函数调用流程，再进一步分析待优化的点。</p>
</li>
<li><p>sample 流派</p>
<p>有选择性或者采用抽样的方式观察某些函数调用过程，可以通过这些有限的信息推测出流程中的可疑点，然后再继续细化分析。</p>
</li>
</ul>
<h2 id="3-1-Traceview"><a href="#3-1-Traceview" class="headerlink" title="3.1 Traceview"></a>3.1 Traceview</h2><p>我在 <a href="https://calmcenter.club/2019/start-optimization.html#toc-heading-7">《App 初体验-启动优化 2.2.1 TraceView》</a> 中讲过 <code>TraceView</code>  的基本使用方法。<code>Traceview</code> 属于 <code>instrument</code> 类型，它利用 Android Runtime 函数调用的 event 事件，将函数运行的耗时和调用关系写入 trace 文件中，它可以用来查看整个过程有哪些函数调用。</p>
<p>工具本身带来的性能开销过大，有时无法反映真实的情况。在 <code>Android 5.0</code> 之后，新增了<code>startMethodTracingSampling</code> 方法，可以使用基于样本的方式进行分析，以减少分析对运行时的性能影响。新增了 sample 类型后，就需要我们在开销和信息丰富度之间做好权衡。</p>
<h2 id="3-2-Nanoscope"><a href="#3-2-Nanoscope" class="headerlink" title="3.2 Nanoscope"></a>3.2 Nanoscope</h2><p> <a href="https://calmcenter.club/2019/start-optimization.html#toc-heading-10">《App 初体验-启动优化 2.2.4 Nanoscope》</a> 查看原理即项目地址。它是在 <code>instrument</code> 类型的性能分析工具中性能损耗比较小的。</p>
<h2 id="3-3-systrace"><a href="#3-3-systrace" class="headerlink" title="3.3 systrace"></a>3.3 systrace</h2><p> <a href="https://calmcenter.club/2019/start-optimization.html#toc-heading-8">《App 初体验-启动优化 2.2.2 systrace》</a> 查看具体使用方法。其中还讲到了 <code>systrace + 函数插桩 AOP</code></p>
<p><code>systrace</code> 工具只能监控特定系统调用的耗时情况，所以它是属于 <code>sample</code> 类型，而且性能开销非常低。但是它不支持应用程序代码的耗时分析，所以在使用时有一些局限性。</p>
<h2 id="3-4-Simpleperf"><a href="#3-4-Simpleperf" class="headerlink" title="3.4 Simpleperf"></a>3.4 Simpleperf</h2><p>分析 <code>Native</code> 函数时使用的工具，在 <code>Android Studio 3.2</code> 也在 <code>Profiler</code> 中直接支持 <code>Simpleperf</code>。</p>
<p><code>Simpleperf</code> 属于 <code>sample</code> 类型，它的性能开销非常低，使用火焰图展示分析结果。</p>
<p><strong>总结：</strong></p>
<p>选择哪种工具，需要看具体的场景。如果需要分析 <code>Native</code> 代码的耗时，可以选择 <code>Simpleperf</code>；如果想分析系统调用，可以选择 <code>systrace</code>；如果想分析整个程序执行流程的耗时，可以选择 <code>Traceview</code> 或者<code>插桩版本的 systrace</code>。<br><code>systrace</code> 利用了 <code>Linux</code> 的 <a target="_blank" rel="noopener" href="http://source.android.com/devices/tech/debug/ftrace">ftrace</a> 调试工具，相当于在系统各个关键位置都添加了一些性能探针，也就是在代码里加了一些性能监控的埋点。<code>Android</code> 在 <code>ftrace</code> 的基础上封装了<code>atrace</code>，并增加了更多特有的探针，例如 <code>Graphics</code>、<code>Activity Manager</code>、<code>Dalvik VM</code>、<code>System Server</code> 等。</p>
<h2 id="3-5-可视化方法（Android-Studio-Profiler）"><a href="#3-5-可视化方法（Android-Studio-Profiler）" class="headerlink" title="3.5 可视化方法（Android Studio Profiler）"></a>3.5 可视化方法（Android Studio Profiler）</h2><p>在 <code>Android Studio 3.2</code> 的 <code>CPU Profiler</code> 中直接集成了几种性能分析工具</p>
<ul>
<li><strong>Sample Java Methods</strong> 的功能类似于 <code>Traceview</code> 的 <code>sample</code> 类型。</li>
<li><strong>Trace Java Methods</strong> 的功能类似于 <code>Traceview</code> 的 <code>instrument</code> 类型。</li>
<li><strong>Trace System Calls</strong> 的功能类似于 <code>systrace</code>。</li>
<li><strong>SampleNative</strong> (API Level 26+) 的功能类似于 <code>Simpleperf</code>。</li>
</ul>
<p>这些分析工具都支持了 <code>Call Chart</code> 和 <code>Flame Chart</code> 两种展示方式。</p>
<ol>
<li><p><strong>Call Chart</strong></p>
<p><code>Call Chart</code> 是 <code>Traceview</code> 和 <code>systrace</code> 默认使用的展示方式。它按照应用程序的函数执行顺序来展示，适合用于分析整个流程的调用。举一个最简单的例子，A 函数调用 B 函数，B 函数调用 C 函数，循环三次，就得到了下面的 <code>Call Chart</code>。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://static001.geekbang.org/resource/image/db/3e/db3612f661d29efe59854df2e6c2383e.jpg" alt="图片来源于 Android开发高手课"></p>
<p><code>Call Chart</code> 就像给应用程序做一个心电图，我们可以看到在这一段时间内，各个线程的具体工作，比如是否存在线程间的锁、主线程是否存在长时间的 <code>I/O</code> 操作、是否存在空闲等。</p>
</li>
<li><p><strong>Flame Chart</strong></p>
</li>
</ol>
<p>Flame Chart 也就是<strong>火焰图</strong>。它跟 Call Chart 不同的是，Flame Chart 以一个全局的视野来看待一段时间的调用分布，它就像给应用程序拍 X 光片，可以很自然地把时间和空间两个维度上的信息融合在一张图上。</p>
<p>上面函数调用的例子，换成火焰图的展示结果如下。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://static001.geekbang.org/resource/image/6c/01/6ca232173daf9e71f06ac22252d65d01.jpg" alt="图片来源于 Android开发高手课"></p>
<p>当我们不想知道应用程序的整个调用流程，只想直观看出哪些代码路径花费的 <code>CPU</code> 时间较多时，火焰图就是一个非常好的选择。</p>
<p>火焰图还可以使用在各种各样的维度，例如内存、I/O 的分析。有些内存可能非常缓慢地泄漏，通过一个内存的火焰图，我们就知道哪些路径申请的内存最多，有了火焰图我们根本不需要分析源代码，也不需要分析整个流程。</p>
<h2 id="3-6-Android-Performance-Monitor（BlockCanary）"><a href="#3-6-Android-Performance-Monitor（BlockCanary）" class="headerlink" title="3.6 Android Performance Monitor（BlockCanary）"></a>3.6 Android Performance Monitor（BlockCanary）</h2><p><a target="_blank" rel="noopener" href="https://github.com/markzhai/AndroidPerformanceMonitor">AndroidPerformanceMonitor</a> 是一个Android平台的一个非侵入式的性能监控组件，应用只需要实现一个抽象类，提供一些该组件需要的上下文环境，就可以在平时使用应用的时候检测主线程上的各种卡慢问题，并通过组件提供的各种信息分析出原因并进行修复。</p>
<h2 id="3-7-Profilo"><a href="#3-7-Profilo" class="headerlink" title="3.7 Profilo"></a>3.7 Profilo</h2><p>2018 年 3 月，<code>Facebook</code> 开源了一个叫 <a target="_blank" rel="noopener" href="https://github.com/facebookincubator/profilo">Profilo</a> 的库， 它收集了各大方案的优点。</p>
<ol>
<li><p><strong>集成 atrace 功能</strong>。</p>
<p>这样所有 <code>systrace</code> 的探针我们都可以拿到，例如四大组件生命周期、锁等待时间、类校验、<code>GC</code> 时间等。</p>
</li>
<li><p><strong>快速获取 Java 堆栈</strong></p>
<p>这里有一个误区，大家都觉得在某个线程不断地获取主线程堆栈是不耗时的。但是事实上获取堆栈的代价是巨大的，它要暂停主线程的运行。</p>
<p>而 <code>profilo</code> 巧妙的解决的这个问题，可以实现线程一边继续跑步，我们还可以帮它做检查，而且耗时基本忽略不计。</p>
</li>
</ol>
<p>不用插桩、性能基本没有影响、捕捉信息还全，那 <code>Profilo</code> 不就是完美的化身吗？当然由于它利用了大量的黑科技，兼容性是需要注意的问题。它内部实现有大量函数的 <code>Hook</code>，<code>unwind</code> 也需要强依赖 <code>Android Runtime</code> 实现。<code>Facebook</code> 已经将 <code>Profilo</code> 投入到线上使用，但由于目前 <code>Profilo</code> 快速获取堆栈功能依然不支持 <code>Android 8.0</code> 和 <code>Android 9.0</code>，鉴于稳定性问题，建议采取抽样部分用户的方式来开启该功能。</p>
<p><strong>帮助理解</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/linux/l-cn-ftrace/index.html">ftrace 简介</a>、<a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/linux/l-cn-ftrace1/index.html">ftrace 使用（上）</a>、<a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/linux/l-cn-ftrace2/index.html">frace 使用（下）</a></li>
<li><a target="_blank" rel="noopener" href="http://source.android.com/devices/tech/debug/ftrace">atrace 介绍</a>、<a target="_blank" rel="noopener" href="http://android.googlesource.com/platform/frameworks/native/+/master/cmds/atrace/atrace.cpp">atrace 实现</a></li>
</ul>
<p>每个工具都可以生成不同的展示方式，我们需要根据不同的使用场景选择合适的方式。</p>
<hr>
<h1 id="4-卡顿现场"><a href="#4-卡顿现场" class="headerlink" title="4 卡顿现场"></a>4 卡顿现场</h1><h2 id="4-1-获取-java-线程状态"><a href="#4-1-获取-java-线程状态" class="headerlink" title="4.1 获取 java 线程状态"></a>4.1 获取 java 线程状态</h2><p>通过 <code>Thread</code> 的 <code>getState</code> 方法可以获取线程状态，<strong>WAITING</strong>、<strong>TIME_WAITING</strong> 和 <strong>BLOCKED</strong> 都是需要特别注意的状态。</p>
<p>BLOCKED: 是指线程正在等待获取锁，对应的是下面代码中的情况一；</p>
<p>WAITING: 是指线程正在等待其他线程的“唤醒动作”，对应的是代码中的情况二。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (object)  &#123;     <span class="comment">// 情况一：在这里卡住 --&gt; BLOCKED</span></span><br><span class="line">    object.wait();           <span class="comment">// 情况二：在这里卡住 --&gt; WAITING</span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>不过当一个线程进入 WAITING 状态时，它不仅会释放 CPU 资源，还会将持有的 object 锁也同时释放。</p>
<p>更多相关资料 <a target="_blank" rel="noopener" href="https://juejin.im/post/5b31b510e51d4558a426f7e9">《Java 线程 Dump 分析》</a></p>
<h2 id="4-2-获得所有线程堆栈"><a href="#4-2-获得所有线程堆栈" class="headerlink" title="4.2 获得所有线程堆栈"></a>4.2 获得所有线程堆栈</h2><p>当我们发现有个线程导致主线程 <code>BLOCKED</code> ，需要通过 <code>Thread.getAllStackTraces()</code> 拿所有线程的堆栈，需要注意的是在 <code>Android 7.0</code>，<code>getAllStackTraces</code>是不会返回主线程的堆栈的。</p>
<h2 id="4-4-SIGQUIT-信号实现"><a href="#4-4-SIGQUIT-信号实现" class="headerlink" title="4.4 SIGQUIT 信号实现"></a>4.4 SIGQUIT 信号实现</h2><p>注：需要 <code>root</code> </p>
<p><code>Android</code> 应用发生 <code>ANR</code> 时，系统会发出 <code>SIGQUIT</code> 信号给发生 <code>ANR</code> 进程。系统信号捕捉线程触发输出<code>/data/anr/traces.txt</code> 文件，记录问题产生虚拟机、线程堆栈相关信息。这个 <code>trace</code> 文件中包含了线程信息和锁的信息，借助这个 <code>trace</code> 文件可以分析卡死的原因。</p>
<p>由此，如果利用这个系统原有的机制，自己在线程卡死时候触发traces文件的形成进行上报，便可以把线程卡死的关键进行进行上报。本监控方案便是<strong>利用系统机制进行卡死信息的抓取</strong>：</p>
<ol>
<li><p>当监控线程发现被监控线程卡死时，主动向系统发送 <code>SIGQUIT</code> 信号。</p>
</li>
<li><p>等待 <code>/data/anr/traces.txt</code> 文件生成。</p>
</li>
<li><p>文件生成以后进行上报。</p>
</li>
</ol>
<p>分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程名称; 优先级; 线程id; 线程状态</span></span><br><span class="line"><span class="string">&quot;main&quot;</span> prio=<span class="number">5</span> tid=<span class="number">1</span> Suspended</span><br><span class="line">  <span class="comment">// 线程组;  线程suspend计数; 线程debug suspend计数; </span></span><br><span class="line">  | group=<span class="string">&quot;main&quot;</span> sCount=<span class="number">1</span> dsCount=<span class="number">0</span> obj=<span class="number">0x74746000</span> self=<span class="number">0xf4827400</span></span><br><span class="line">  <span class="comment">// 线程native id; 进程优先级; 调度者优先级;</span></span><br><span class="line">  | sysTid=<span class="number">28661</span> nice=-<span class="number">4</span> cgrp=<span class="keyword">default</span> sched=<span class="number">0</span>/<span class="number">0</span> handle=<span class="number">0xf72cbbec</span></span><br><span class="line">  <span class="comment">// native线程状态; 调度者状态; 用户时间utime; 系统时间stime; 调度的CPU</span></span><br><span class="line">  | state=D schedstat=( <span class="number">3137222937</span> <span class="number">94427228</span> <span class="number">5819</span> ) utm=<span class="number">218</span> stm=<span class="number">95</span> core=<span class="number">2</span> HZ=<span class="number">100</span></span><br><span class="line">  <span class="comment">// stack相关信息</span></span><br><span class="line">  | stack=<span class="number">0xff717000</span>-<span class="number">0xff719000</span> stackSize=<span class="number">8</span>MB</span><br></pre></td></tr></table></figure>

<p>其中 <code>utm</code> 代表 <code>utime</code>，<code>HZ</code> 代表 <code>CPU</code> 的时钟频率，将 <code>utime</code> 转换为毫秒的公式是 <code>time * 1000/HZ</code>。例子中 <code>utm=218</code>，也就是 <code>218*1000/100=2180</code> 毫秒。</p>
<h2 id="4-5-Hook-实现"><a href="#4-5-Hook-实现" class="headerlink" title="4.5 Hook 实现"></a>4.5 Hook 实现</h2><p>用 <code>SIGQUIT</code> 信号量获取 <code>ANR</code> 日志，从而拿到所有线程的各种信息，这套方案看起来很美好。但事实上，它存在这几个问题：</p>
<ol>
<li><strong>可行性。</strong> 高版本系统已经没有权限读取 <code>/data/anr/traces.txt</code> 文件。需要 <code>root</code> 手机</li>
<li><strong>性能。</strong>获取所有线程堆栈以及各种信息非常耗时，对于卡顿场景不一定合适，它可能会进一步加剧用户的卡顿。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/f406d535a8bc">Android trace文件抓取原理</a>   <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/g-WzYF3wWAljok1XjPoo7w?">Android 平台 Native 代码的崩溃捕获机制及实现</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/oujunli/article/details/9102101">通过Android trace文件分析死锁ANR</a> </p>
<p>能力有限，还在研究中。。</p>
<p><strong>思路：</strong> <code>hook libart.so</code> 。通过<code>hook ThreadList</code> 和 <code>Thread</code> 的函数，获得跟 <code>ANR</code> 一样的堆栈。为了稳定性，我们会在 <code>fork</code> 子进程执行。</p>
<p>  优点：信息很全，基本跟 <code>ANR</code> 的日志一样，有 <code>native</code> 线程状态，锁信息等等。<br>  缺点：黑科技的兼容性问题，失败时可以用 <code>Thread.getAllStackTraces()</code> 兜底</p>
<p>获取Java堆栈的方法还可以用在卡顿时，因为使用fork进程，所以可以做到完全不卡主进程。</p>
<p><code>Breakpad</code> 使用了 <code>fork</code> 子进程甚至孙进程的方式去收集崩溃现场，即便出现二次崩溃，也只是这部分信息丢失。</p>
<h1 id="5-Demo-相关-Demo-学习"><a href="#5-Demo-相关-Demo-学习" class="headerlink" title="5 Demo 相关 Demo 学习"></a>5 Demo 相关 Demo 学习</h1><h2 id="5-1-抓取-CPU-数据"><a href="#5-1-抓取-CPU-数据" class="headerlink" title="5.1 抓取 CPU 数据"></a>5.1 抓取 CPU 数据</h2><p><a target="_blank" rel="noopener" href="https://github.com/AndroidAdvanceWithGeektime/Chapter05">Chapter05</a> </p>
<p>模仿 <a target="_blank" rel="noopener" href="http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/java/com/android/internal/os/ProcessCpuTracker.java">ProcessCpuTracker.java</a> 拿到一段时间内各个线程的耗时占比</p>
<p>示例的日志数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">usage: CPU usage <span class="number">5000</span>ms(from <span class="number">23</span>:<span class="number">23</span>:<span class="number">33.000</span> to <span class="number">23</span>:<span class="number">23</span>:<span class="number">38.000</span>):</span><br><span class="line">System TOTAL: <span class="number">2.1</span>% user + <span class="number">16</span>% kernel + <span class="number">9.2</span>% iowait + <span class="number">0.2</span>% irq + <span class="number">0.1</span>% softirq + <span class="number">72</span>% idle</span><br><span class="line">CPU Core: <span class="number">8</span></span><br><span class="line">Load Average: <span class="number">8.74</span> / <span class="number">7.74</span> / <span class="number">7.36</span></span><br><span class="line"></span><br><span class="line">Process:com.sample.app </span><br><span class="line">  <span class="number">50</span>% <span class="number">23468</span>/com.sample.app(S): <span class="number">11</span>% user + <span class="number">38</span>% kernel faults:<span class="number">4965</span></span><br><span class="line"></span><br><span class="line">Threads:</span><br><span class="line">  <span class="number">43</span>% <span class="number">23493</span>/singleThread(R): <span class="number">6.5</span>% user + <span class="number">36</span>% kernel faults：<span class="number">3094</span></span><br><span class="line">  <span class="number">3.2</span>% <span class="number">23485</span>/RenderThread(S): <span class="number">2.1</span>% user + <span class="number">1</span>% kernel faults：<span class="number">329</span></span><br><span class="line">  <span class="number">0.3</span>% <span class="number">23468</span>/.sample.app(S): <span class="number">0.3</span>% user + <span class="number">0</span>% kernel faults：<span class="number">6</span></span><br><span class="line">  <span class="number">0.3</span>% <span class="number">23479</span>/HeapTaskDaemon(S): <span class="number">0.3</span>% user + <span class="number">0</span>% kernel faults：<span class="number">982</span></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>

<ol>
<li>在 <code>System Total</code> 部分 <code>user</code> 占用不多，<code>CPU idle</code> 很高，消耗多在 <code>kernel</code> 和 <code>iowait</code>。</li>
<li><code>CPU</code> 是 8 核的，<code>Load Average</code> 大约也是 8，表示 <code>CPU</code> 并不处于高负载情况。</li>
<li>在 <code>Process</code> 里展示了这段时间内 <code>sample app</code> 的 <code>CPU</code> 使用情况：<code>user</code> 低，<code>kernel</code> 高，并且有 <code>4965</code> 次 <code>page faults</code>。<ol>
<li><code>page faluts</code> 分为三种：<code>minor page fault</code>、<code>major page fault</code> 和 <code>invalid page fault</code></li>
</ol>
</li>
<li>在 <code>Threads</code> 里展示了每个线程的 <code>usage</code> 情况，当前只有 <code>singleThread</code> 处于 <code>R</code> 状态，并且当前线程产生了 3096 次 <code>page faults</code>，其他的线程包括主线程（<code>Sample</code> 日志里可见的）都是处于 <code>S</code>状态。<ol>
<li><code>R</code>：代表线程处于 <code>Running</code> 或者 <code>Runnable</code> 状态。<code>Running</code> 状态说明线程当前被某个 <code>Core</code> 执行，<code>Runnable</code> 状态说明线程当前正在处于等待队列中等待某个 <code>Core</code> 空闲下来去执行。</li>
<li><code>S</code>： <code>TASK_INTERRUPTIBLE（可中断）</code>  发生这种状态是线程主动让出了 <code>CPU</code>，如果线程调用了 <code>sleep</code> 或者其他情况导致了自愿式的上下文切换就会处于 <code>S</code> 状态。</li>
</ol>
</li>
</ol>
<p><code>Demo</code> 中执行 <code>Test</code> 抓取数据如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CPU usage from <span class="number">5137</span>ms to <span class="number">81</span><span class="function">ms <span class="title">ago</span> <span class="params">(<span class="number">2020</span><span class="number">-05</span><span class="number">-13</span> <span class="number">21</span>:<span class="number">57</span>:<span class="number">32.764</span> to <span class="number">2020</span><span class="number">-05</span><span class="number">-13</span> <span class="number">21</span>:<span class="number">57</span>:<span class="number">37.819</span>)</span>:</span></span><br><span class="line"><span class="function">16% 15921/com.sample.<span class="title">processtracker</span><span class="params">(R)</span>: 6.3% user + 9.6% kernel / faults: 3332 minor</span></span><br><span class="line"><span class="function">thread stats:</span></span><br><span class="line"><span class="function">15% 16145/<span class="title">SingleThread</span><span class="params">(S)</span>: 1.9% user + 13% kernel / faults: 3014 minor</span></span><br><span class="line"><span class="function">13% 17088/<span class="title">SingleThread</span><span class="params">(S)</span>: 1.3% user + 12% kernel / faults: 3016 minor</span></span><br><span class="line"><span class="function">1.3% 15921/.<span class="title">processtracker</span><span class="params">(R)</span>: 0.9% user + 0.3% kernel / faults: 40 minor</span></span><br><span class="line"><span class="function">0.5% 16002/<span class="title">RenderThread</span><span class="params">(S)</span>: 0.1% user + 0.3% kernel / faults: 37 minor</span></span><br><span class="line"><span class="function">0.1% 15942/Jit thread <span class="title">pool</span><span class="params">(S)</span>: 0.1% user + 0% kernel / faults: 222 minor</span></span><br><span class="line"><span class="function">0% 15949/<span class="title">HeapTaskDaemon</span><span class="params">(S)</span>: 0% user + 0% kernel</span></span><br><span class="line"><span class="function">...</span></span><br><span class="line"><span class="function">0% <span class="title">TOTAL</span><span class="params">()</span>: 0% user + 0% kernel</span></span><br><span class="line"><span class="function">Load: 0.0 / 0.0 / 0.0</span></span><br></pre></td></tr></table></figure>

<p>这里不太清楚为什么后面的数据都是 0 ，最后应该输出 <code>iowait</code> 才对。</p>
<p>极客时间原文例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CPU usage from <span class="number">5187</span>ms to <span class="number">121</span><span class="function">ms <span class="title">ago</span> <span class="params">(<span class="number">2018</span><span class="number">-12</span><span class="number">-28</span> <span class="number">08</span>:<span class="number">28</span>:<span class="number">27.186</span> to <span class="number">2018</span><span class="number">-12</span><span class="number">-28</span> <span class="number">08</span>:<span class="number">28</span>:<span class="number">32.252</span>)</span>:</span></span><br><span class="line"><span class="function">40% 24155/com.sample.<span class="title">processtracker</span><span class="params">(R)</span>: 14% user + 26% kernel / faults: 5286 minor</span></span><br><span class="line"><span class="function">thread stats:</span></span><br><span class="line"><span class="function">35% 24184/<span class="title">SingleThread</span><span class="params">(S)</span>: 11% user + 24% kernel / faults: 3055 minor</span></span><br><span class="line"><span class="function">2.1% 24174/<span class="title">RenderThread</span><span class="params">(S)</span>: 1.3% user + 0.7% kernel / faults: 384 minor</span></span><br><span class="line"><span class="function">1.5% 24155/.<span class="title">processtracker</span><span class="params">(R)</span>: 1.1% user + 0.3% kernel / faults: 95 minor</span></span><br><span class="line"><span class="function">0.1% 24166/<span class="title">HeapTaskDaemon</span><span class="params">(S)</span>: 0.1% user + 0% kernel / faults: 1070 minor</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">100% <span class="title">TOTAL</span><span class="params">()</span>: 3.8% user + 7.8% kernel + 11% iowait + 0.1% irq + 0% softirq + 76% idle</span></span><br><span class="line"><span class="function">Load: 6.31 / 6.52 / 6.66</span></span><br></pre></td></tr></table></figure>

<p>如果有大佬知道原因，还请告知。</p>
<p>如果产生大量的 <code>faults</code> 其实是不太正常的，或者 <code>iowait</code> 过高就需要关注是否有很密集的 <code>I/O</code> 操作。</p>
<p><a target="_blank" rel="noopener" href="https://yq.aliyun.com/articles/55820">《page fault 带来的性能问题》</a> </p>
<p><a target="_blank" rel="noopener" href="http://oenhan.com/iowait-wa-vmstat">《iowait 的形成原因和内核分析》</a></p>
<h2 id="5-2-PLTHook-监控-Thread-的创建"><a href="#5-2-PLTHook-监控-Thread-的创建" class="headerlink" title="5.2 PLTHook 监控 Thread 的创建"></a>5.2 PLTHook 监控 Thread 的创建</h2><p><a target="_blank" rel="noopener" href="https://github.com/AndroidAdvanceWithGeektime/Chapter06-plus">Chapter06-plus</a> 这个 <code>Demo</code> 与 <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/a26d11502ec8">Android线程的创建过程</a>  结合，了解 <code>PLTHook</code> 的使用，以及 <code>Thread</code> 状态知识、如何创建的。</p>
<h2 id="5-3-Loop-监控卡顿"><a href="#5-3-Loop-监控卡顿" class="headerlink" title="5.3 Loop 监控卡顿"></a>5.3 Loop 监控卡顿</h2><p>在 <code>Android UI</code> 线程中有个 <code>Looper</code>，在其 <code>loop</code> 方法中会不断取出 <code>Message</code>，调用其绑定的 <code>Handler</code> 在 <code>UI</code> 线程进行执行。</p>
<p>部分代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Looper me = myLooper();</span><br><span class="line">    <span class="keyword">final</span> MessageQueue queue = me.mQueue;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Message msg = queue.next(); <span class="comment">// might block</span></span><br><span class="line">        <span class="comment">// This must be in a local variable, in case a UI event sets the logger</span></span><br><span class="line">        <span class="keyword">final</span> Printer logging = me.mLogging;</span><br><span class="line">        <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">            logging.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot;</span> + msg.target + <span class="string">&quot; &quot;</span> +</span><br><span class="line">                            msg.callback + <span class="string">&quot;: &quot;</span> + msg.what);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            msg.target.dispatchMessage(msg);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">            logging.println(<span class="string">&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot;</span> + msg.target + <span class="string">&quot; &quot;</span> + msg.callback);</span><br><span class="line">        &#125;</span><br><span class="line">        msg.recycleUnchecked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到在执行此代码前后，如果设置了 <code>logging</code>，会分别打印出 <code>&gt;&gt;&gt;&gt;&gt; Dispatching to</code>和 <code>&lt;&lt;&lt;&lt;&lt; Finished to</code> 这样的<code>log</code> 。</p>
<p>我们可以通过计算两次 <code>log</code> 之间的时间差值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Looper.getMainLooper().setMessageLogging(<span class="keyword">new</span> Printer() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String START = <span class="string">&quot;&gt;&gt;&gt;&gt;&gt; Dispatching&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String END = <span class="string">&quot;&lt;&lt;&lt;&lt;&lt; Finished&quot;</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(String x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x.startsWith(START)) &#123;</span><br><span class="line">            LogMonitor.getInstance().startMonitor();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x.startsWith(END)) &#123;</span><br><span class="line">            LogMonitor.getInstance().removeMonitor();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>假设我们的阈值是 <code>1000ms</code>，当我在匹配到 <code>&gt;&gt;&gt;&gt;&gt; Dispatching</code> 时，我会在 <code>1000ms</code> 毫秒后执行一个任务（打印出 <code>UI</code> 线程的堆栈信息，会在非 <code>UI</code> 线程中进行）；</p>
<p>正常情况下，肯定是低于 <code>1000ms</code> 执行完成的，所以当我匹配到 <code>&lt;&lt;&lt;&lt;&lt; Finished</code> ，会移除该任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogMonitor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LogMonitor sInstance = <span class="keyword">new</span> LogMonitor();</span><br><span class="line">    <span class="keyword">private</span> Handler mIoHandler;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> TIME_BLOCK = <span class="number">1000L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LogMonitor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HandlerThread mLogThread = <span class="keyword">new</span> HandlerThread(<span class="string">&quot;log&quot;</span>);</span><br><span class="line">        mLogThread.start();</span><br><span class="line">        mIoHandler = <span class="keyword">new</span> Handler(mLogThread.getLooper());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Runnable mLogRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            StackTraceElement[] stackTrace = Looper.getMainLooper().getThread().getStackTrace();</span><br><span class="line">            <span class="keyword">for</span> (StackTraceElement s : stackTrace) &#123;</span><br><span class="line">                sb.append(s.toString() + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Log.e(<span class="string">&quot;TAG&quot;</span>,sb.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LogMonitor <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMonitor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; handlerClass = Class.forName(<span class="string">&quot;android.os.Handler&quot;</span>);</span><br><span class="line">            java.lang.reflect.Method method = handlerClass.getMethod(<span class="string">&quot;hasCallbacks&quot;</span>, Runnable.class);</span><br><span class="line">            Boolean ret = (Boolean) method.invoke(mIoHandler, mLogRunnable);</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startMonitor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        mIoHandler.postDelayed(mLogRunnable,TIME_BLOCK);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeMonitor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        mIoHandler.removeCallbacks(mLogRunnable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们利用了 <code>HandlerThread</code> 这个类，同样利用了 <code>Looper</code> 机制，只不过在非UI线程中，如果执行耗时达到我们设置的阈值，则会执行 <code>mLogRunnable</code> ，打印出 <code>UI</code> 线程当前的堆栈信息；如果你阈值时间之内完成，则会 <code>remove</code> 掉该 <code>runnable</code>。</p>
<p><a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fmarkzhai%2FAndroidPerformanceMonitor">BlockCanary 16 年原理分析</a>   </p>
<p>代码修改自于 <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&mid=2650822205&idx=1&sn=6b8e78bc1d71eb79a199667cf132acf7&chksm=80b782a3b7c00bb5c12437556fca68136c75409855e9252e395b545621319edf23959942b67c&scene=21#wechat_redirect">Android UI性能优化 检测应用中的UI卡顿</a> 修改了 <code>hasCallbacks</code> 调用方式</p>
<p><strong>这个方法的缺点：</strong> 大量字符串拼接导致性能损耗严重，快速滑动时会降低帧数。</p>
<ul>
<li><strong>消息队列</strong></li>
</ul>
<p>可以通过一个监控线程，每隔 1 秒向主线程消息队列的头部插入一条空消息。假设 1 秒后这个消息并没有被主线程消费掉，说明阻塞消息运行的时间在 0～1 秒之间。换句话说，如果我们需要监控 3 秒卡顿，那在第 4 次轮询中头部消息依然没有被消费的话，就可以确定主线程出现了一次 3 秒以上的卡顿。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://static001.geekbang.org/resource/image/b0/56/b06d5aa439e8bb75885a338df9a25f56.png" alt="图片来源于 Android开发高手课"></p>
<p>这个方案也存在一定的误差，那就是发送空消息的间隔时间。但这个间隔时间也不能太小，因为监控线程和主线程处理空消息都会带来一些性能损耗，但基本影响不大。</p>
<p><strong>这个方法的缺点：</strong> 基于消息队列的卡顿监控并不准确，正在运行的函数有可能并不是真正耗时的函数。</p>
<ul>
<li><strong>插桩</strong></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FTencent%2Fmatrix">参考 微信 开源库 matrix</a></p>
<p><strong>避免方法数暴增。</strong>在函数的入口和出口应该插入相同的函数，在编译时提前给代码中每个方法分配一个独立的 <code>ID</code> 作为参数。</p>
<p><strong>过滤简单的函数。</strong>过滤一些类似直接 <code>return</code>、<code>i++</code> 这样的简单函数，并且支持黑名单配置。对一些调用非常频繁的函数，需要添加到黑名单中来降低整个方案对性能的损耗。</p>
<p>基于性能的考虑，线上只会监控主线程的耗时。最终安装包体积只增大 1～2%，平均帧率下降也在 2 帧以内。</p>
<p>插桩方案看起来美好，它也有自己的短板，那就是只能监控应用内自身的函数耗时，无法监控系统的函数调用，整个堆栈看起来好像 “缺失了” 一部分。</p>
<h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h1><blockquote>
<p><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/74044">极客时间 Android开发高手课</a>  </p>
<p><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/71982">《Linux环境下进程的CPU占用率》</a></p>
<p><a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man5/proc.5.html">《Linux 文档》</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5b31b510e51d4558a426f7e9">《Java线程Dump分析》</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1064396">《手Q Android线程死锁监控与自动化分析实践》</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&mid=2650822205&idx=1&sn=6b8e78bc1d71eb79a199667cf132acf7&chksm=80b782a3b7c00bb5c12437556fca68136c75409855e9252e395b545621319edf23959942b67c&scene=21#wechat_redirect">Android UI性能优化 检测应用中的UI卡顿</a></p>
<p>以及上文中的链接</p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">CalmCenter</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://calmcenter.club/2020/hobble-optimization.html">https://calmcenter.club/2020/hobble-optimization.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://calmcenter.club" target="_blank">CalmCenter</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Android/">Android</a><a class="post-meta__tags" href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">性能优化</a></div><div class="post_share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.png" target="_blank"><img class="post-qr-code-img" data-lazy-src="/img/wechat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.png" target="_blank"><img class="post-qr-code-img" data-lazy-src="/img/alipay.png" alt="支付寶"/></a><div class="post-qr-code-desc">支付寶</div></li></ul></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/power-optimization.html"><img class="prev-cover" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/cover13.webp" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">App 电量优化</div></div></a></div><div class="next-post pull-right"><a href="/2020/ui-optimization.html"><img class="next-cover" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/cover32.webp" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">App UI优化💦</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2020/power-optimization.html" title="App 电量优化"><img class="cover" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/cover13.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-05-10</div><div class="title">App 电量优化</div></div></a></div><div><a href="/2019/complete-works-of-android-performance.html" title="Android 性能优化篇"><img class="cover" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/20200228233120.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-12-01</div><div class="title">Android 性能优化篇</div></div></a></div><div><a href="/2020/stability-optimization.html" title="稳定性优化"><img class="cover" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/cover26.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-06-02</div><div class="title">稳定性优化</div></div></a></div><div><a href="/2020/memory-optimization2.html" title="App 内存检测优化💦"><img class="cover" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/cover12.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-02-29</div><div class="title">App 内存检测优化💦</div></div></a></div><div><a href="/2020/memory-optimization.html" title="App 内存知识介绍💦"><img class="cover" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/cover35.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-02-28</div><div class="title">App 内存知识介绍💦</div></div></a></div><div><a href="/2020/network-optimization.html" title="App 网络优化🌞"><img class="cover" data-lazy-src="https://gitee.com/CalmCenter/Pic/raw/master/cover19.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-05-20</div><div class="title">App 网络优化🌞</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside_content" id="aside_content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><img class="avatar-img" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">CalmCenter</div><div class="author-info__description">目标设置到月球，即使陨落也是在群星之间！</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">43</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/CalmCenter"><i class="fab fa-github"></i><span>Follow Me</span></a></div></div><div class="card-widget card-announcement"><div class="card-content"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">不要努力成为一个成功的人，而要努力成为一个有价值的人。</div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%AC%E6%96%87%E4%B8%BB%E8%A6%81%E8%AE%B0%E8%BD%BD"><span class="toc-text">本文主要记载</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E5%8D%A1%E9%A1%BF%EF%BC%9F"><span class="toc-text">1 如何定义卡顿？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5%E5%8D%A1%E9%A1%BF"><span class="toc-text">2 如何排查卡顿</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-Linux-%E5%91%BD%E4%BB%A4%E7%BB%84%E5%90%88%E6%8E%92%E6%9F%A5"><span class="toc-text">2.1 Linux 命令组合排查</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E4%BD%BF%E7%94%A8-top-%E5%91%BD%E4%BB%A4%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%E4%BF%A1%E6%81%AF"><span class="toc-text">2.2 使用 top 命令查看进程信息</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E6%9C%89%E6%B2%A1%E6%9C%89%E6%96%B9%E4%BE%BF%E7%9A%84-Android-%E5%8D%A1%E9%A1%BF%E6%8E%92%E6%9F%A5%E5%B7%A5%E5%85%B7%EF%BC%9F"><span class="toc-text">3 有没有方便的 Android 卡顿排查工具？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-Traceview"><span class="toc-text">3.1 Traceview</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-Nanoscope"><span class="toc-text">3.2 Nanoscope</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-systrace"><span class="toc-text">3.3 systrace</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-Simpleperf"><span class="toc-text">3.4 Simpleperf</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-%E5%8F%AF%E8%A7%86%E5%8C%96%E6%96%B9%E6%B3%95%EF%BC%88Android-Studio-Profiler%EF%BC%89"><span class="toc-text">3.5 可视化方法（Android Studio Profiler）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-Android-Performance-Monitor%EF%BC%88BlockCanary%EF%BC%89"><span class="toc-text">3.6 Android Performance Monitor（BlockCanary）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-7-Profilo"><span class="toc-text">3.7 Profilo</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E5%8D%A1%E9%A1%BF%E7%8E%B0%E5%9C%BA"><span class="toc-text">4 卡顿现场</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E8%8E%B7%E5%8F%96-java-%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="toc-text">4.1 获取 java 线程状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E8%8E%B7%E5%BE%97%E6%89%80%E6%9C%89%E7%BA%BF%E7%A8%8B%E5%A0%86%E6%A0%88"><span class="toc-text">4.2 获得所有线程堆栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-SIGQUIT-%E4%BF%A1%E5%8F%B7%E5%AE%9E%E7%8E%B0"><span class="toc-text">4.4 SIGQUIT 信号实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-Hook-%E5%AE%9E%E7%8E%B0"><span class="toc-text">4.5 Hook 实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-Demo-%E7%9B%B8%E5%85%B3-Demo-%E5%AD%A6%E4%B9%A0"><span class="toc-text">5 Demo 相关 Demo 学习</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E6%8A%93%E5%8F%96-CPU-%E6%95%B0%E6%8D%AE"><span class="toc-text">5.1 抓取 CPU 数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-PLTHook-%E7%9B%91%E6%8E%A7-Thread-%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-text">5.2 PLTHook 监控 Thread 的创建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-Loop-%E7%9B%91%E6%8E%A7%E5%8D%A1%E9%A1%BF"><span class="toc-text">5.3 Loop 监控卡顿</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%84%9F%E8%B0%A2"><span class="toc-text">感谢</span></a></li></ol></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 By CalmCenter</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>function addGitalkSource () {
  const ele = document.createElement('link')
  ele.rel = 'stylesheet'
  ele.href= 'https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css'
  document.getElementsByTagName('head')[0].appendChild(ele)
}

function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk({
      clientID: '9b707b75b56f9e432b12',
      clientSecret: '6e2d5a012729aa6c9e8df3cc0a90d82f976a026e',
      repo: 'calmcenter.github.io',
      owner: 'CalmCenter',
      admin: ['CalmCenter'],
      id: 'a536ee7abd00881e26e700dbafc71674',
      language: 'zh-CN',
      perPage: 10,
      distractionFreeMode: false,
      pagerDirection: 'last',
      createIssueManually: false,
      updateCountCallback: commentCount
    })
    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    addGitalkSource()
    $.getScript('https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js', initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !false) {
  if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script></div></body></html>