<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>App 直观感受-卡顿优化🌈 | CalmCenter</title><meta name="description" content="🌞页面直观反映，用户直观感受🌞页面卡顿问题，如何用 Linux 命令组合排查卡顿？有没有方便的 Android 卡顿排查工具？来这里寻找答案。"><meta name="keywords" content="Android"><meta name="author" content="CalmCenter"><meta name="copyright" content="CalmCenter"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = 'false'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="canonical" href="https://calmcenter.club/2020/hobble-optimization.html"><link rel="prev" title="App 电量优化" href="https://calmcenter.club/2020/power-optimization.html"><link rel="next" title="App UI优化💦" href="https://calmcenter.club/2020/ui-optimization.html"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: true,
  fancybox: false,
  Snackbar: {"bookmark":{"message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"top-right"},
  baiduPush: false,
  highlightCopy: true,
  highlightLang: false,
  highlightShrink: 'none',
  isFontAwesomeV5: false,
  isPhotoFigcaption: true,
  islazyload: true,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">24</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">17</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">5</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友情链接</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#本文主要记载"><span class="toc-text">本文主要记载</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-如何定义卡顿？"><span class="toc-text">1 如何定义卡顿？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-如何排查卡顿"><span class="toc-text">2 如何排查卡顿</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-Linux-命令组合排查"><span class="toc-text">2.1 Linux 命令组合排查</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-使用-top-命令查看进程信息"><span class="toc-text">2.2 使用 top 命令查看进程信息</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-有没有方便的-Android-卡顿排查工具？"><span class="toc-text">3 有没有方便的 Android 卡顿排查工具？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-Traceview"><span class="toc-text">3.1 Traceview</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-Nanoscope"><span class="toc-text">3.2 Nanoscope</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-systrace"><span class="toc-text">3.3 systrace</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-Simpleperf"><span class="toc-text">3.4 Simpleperf</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-可视化方法（Android-Studio-Profiler）"><span class="toc-text">3.5 可视化方法（Android Studio Profiler）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-Android-Performance-Monitor（BlockCanary）"><span class="toc-text">3.6 Android Performance Monitor（BlockCanary）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-7-Profilo"><span class="toc-text">3.7 Profilo</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-卡顿现场"><span class="toc-text">4 卡顿现场</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-获取-java-线程状态"><span class="toc-text">4.1 获取 java 线程状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-获得所有线程堆栈"><span class="toc-text">4.2 获得所有线程堆栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-SIGQUIT-信号实现"><span class="toc-text">4.4 SIGQUIT 信号实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-Hook-实现"><span class="toc-text">4.5 Hook 实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-Demo-相关-Demo-学习"><span class="toc-text">5 Demo 相关 Demo 学习</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-抓取-CPU-数据"><span class="toc-text">5.1 抓取 CPU 数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-PLTHook-监控-Thread-的创建"><span class="toc-text">5.2 PLTHook 监控 Thread 的创建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-Loop-监控卡顿"><span class="toc-text">5.3 Loop 监控卡顿</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#感谢"><span class="toc-text">感谢</span></a></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://gitee.com/CalmCenter/Pic/raw/master/cover20.webp)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">CalmCenter</a></span><span class="pull_right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友情链接</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">App 直观感受-卡顿优化🌈</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-04-20 12:59:00"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-04-20</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-06-05 15:06:43"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-06-05</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Android/">Android</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="post-meta__icon fa fa-file-word-o" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">6.1k</span><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-clock-o" aria-hidden="true"></i><span>阅读时长: 22 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><p>对用户来说，<strong>内存占用高</strong>、<strong>耗费电量</strong>、<strong>耗费流量</strong> 可能不容易被发现，但是用户对 <strong>卡顿</strong> 特别敏感，很容易直观感受到。</p>
<p><strong>注意：如果出现图片不显示问题请移步</strong> <a href="https://calmcenter.club/2019/PicNotShow.html">图片不显示问题</a></p>
<h1 id="本文主要记载"><a href="#本文主要记载" class="headerlink" title="本文主要记载"></a>本文主要记载</h1><ul>
<li><strong>1 如何定义卡顿？</strong></li>
<li><strong>2 如何排查卡顿？</strong><ul>
<li>2.1 Linux 命令组合排查</li>
<li>2.2 使用 top 命令查看进程信息</li>
</ul>
</li>
<li><strong>3 有没有方便的 Android 卡顿排查工具？</strong><ul>
<li>3.1 TraceView</li>
<li>3.2 Nanoscope</li>
<li>3.3 systrace</li>
<li>3.4 Simpleperf</li>
<li>3.5 可视化方法(Android Studio Profiler)</li>
<li>3.6 Android Performance Montitor(BlockCanary)</li>
<li>3.7 Profilo</li>
</ul>
</li>
<li><strong>4 卡顿现场</strong><ul>
<li>4.1 获取 java 线程状态</li>
<li>4.2 获得所有线程堆栈</li>
<li>4.3 SIGQUIT 信号实现</li>
<li>4.4 Hook 实现</li>
</ul>
</li>
<li><strong>5 相关 Demo 学习</strong><ul>
<li>5.1 抓取 CPU 数据</li>
<li>5.2 PLTHook 监控 Thread 的创建</li>
<li>5.3 Loop 监控卡顿</li>
</ul>
</li>
<li>总结</li>
</ul>
<hr>
<h1 id="1-如何定义卡顿？"><a href="#1-如何定义卡顿？" class="headerlink" title="1 如何定义卡顿？"></a>1 如何定义卡顿？</h1><p><code>60帧</code> 每秒是目前最合适的图像显示速度，也是绝大部分 <code>Android</code> 设备设置的调试频率，如果在 <code>16ms</code> 内顺利完成界面刷新操作可以展示出流畅的画面，而由于任何原因导致接收到 <code>VSYNC</code> 信号的时候无法完成本次刷新操作，就会产生掉帧的现象，刷新帧率自然也就跟着下降(假定刷新帧率由正常的 <code>60fps</code> 降到 <code>30fps</code> ，用户就会明显感知到卡顿)。</p>
<p>卡顿的原因可以定义为 <code>UI 复杂度问题</code> ，<code>没有提前或异步初始化问题</code> ， <code>内存泄漏频繁 GC 的问题</code> 等，卡顿的解决思路是集结了 启动优化、内存优化、UI 优化 的所有知识点，所以这篇也是对之前的扩展补充。</p>
<p>造成卡顿的原因可能有千百种，不过最终都会反映到 CPU 时间上。</p>
<p>我们可以把 CPU 时间分为两种：</p>
<ol>
<li>用户时间：执行用户态应用程序代码所消耗的时间</li>
<li>系统时间：执行内核态系统调用所消耗的时间，包括 I/O、锁、中断以及其他系统调用的时间。</li>
</ol>
<hr>
<h1 id="2-如何排查卡顿"><a href="#2-如何排查卡顿" class="headerlink" title="2 如何排查卡顿"></a>2 如何排查卡顿</h1><h2 id="2-1-Linux-命令组合排查"><a href="#2-1-Linux-命令组合排查" class="headerlink" title="2.1 Linux 命令组合排查"></a>2.1 Linux 命令组合排查</h2><ol>
<li><strong>获取 <code>CPU</code> 核心数</strong></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;possible</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>获取某个 <code>CPU</code> 的频率</strong></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpu0&#x2F;cpufreq&#x2F;cpuinfo_max_freq</span><br></pre></td></tr></table></figure>

<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://gitee.com/CalmCenter/Pic/raw/master/20200420172904.png" alt=""></p>
<p>我们需要根据设备 <code>CPU</code> 性能来 “看菜下饭” ，例如线程池使用线程数根据 <code>CPU</code> 的核心数，一些高级的 <code>AI</code> 功能只在主频比较高或者带有 <code>NPU</code> 的设备开启。</p>
<ol start="3">
<li><strong>查看 <code>CPU</code> 的使用率</strong></li>
</ol>
<p><strong>整个系统的 CPU 使用情况</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;proc&#x2F;stat</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;adb shell</span><br><span class="line">cat &#x2F;proc&#x2F;stat</span><br><span class="line">cpu  166492 36473 149538 7550789 34852 0 9110 0 0 0</span><br><span class="line">cpu0 31858 4048 34220 808812 5172 0 4604 0 0 0</span><br><span class="line">cpu1 22897 4439 25504 894380 7874 0 1514 0 0 0</span><br><span class="line">cpu2 29068 6317 27063 908505 7657 0 673 0 0 0</span><br><span class="line">cpu3 25916 6157 23508 931591 6625 0 259 0 0 0</span><br><span class="line">cpu4 28689 5321 22388 971414 2544 0 1030 0 0 0</span><br><span class="line">cpu5 10136 3778 6687 1009482 1551 0 606 0 0 0</span><br><span class="line">cpu6 8074 3398 5163 1014162 1489 0 218 0 0 0</span><br><span class="line">cpu7 9854 3015 5005 1012443 1940 0 206 0 0 0</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>第一行的数据表示的是 <code>CPU</code> 总的使用情况</p>
<ol>
<li><p>这些数值的单位都是 <code>jiffies</code>。<code>jiffies</code> 是内核中的一个全局变量，用来记录系统启动以来产生的节拍数，在 <code>Linux</code> 中，一个节拍大致可以理解为操作系统进程调度的最小时间片，不同的 <code>Linux</code> 系统内核这个值可能不同，通常在 <code>1ms</code> 到 <code>10ms</code> 之间。</p>
</li>
<li><p>cpu  166492 36473 149538 7550789 34852 0 9110 0 0 0</p>
<ul>
<li><code>user</code>(166492) 从系统启动开始累积到当前时刻，处于用户态的运行时间，不包含 nice 值为负的进程。</li>
<li><code>nice</code>(36473) 从系统启动开始累积到当前时刻，nice 值为负的进程所占用的 CPU 时间。</li>
<li><code>system</code>(149538) 从系统启动开始累积到当前时刻，处于核心态的运行时间。</li>
<li><code>idle</code>(7550789) 从系统启动开始累积到当前时刻，除 IO 等待时间以外的其他等待时间。</li>
<li><code>iowait</code>(34852) 从系统启动开始累积到当前时刻，IO 等待时间。(since 2.5.41)</li>
<li><code>irq</code>(0) 从系统启动开始累积到当前时刻，硬中断时间。(since 2.6.0-test4)</li>
<li><code>softirq</code>(9110) 从系统启动开始累积到当前时刻，软中断时间。(since 2.6.0-test4)</li>
<li><code>stealstolen</code>(0) 这是在虚拟环境中运行时在其他操作系统中花费的时间。(since 2.6.11)</li>
<li><code>guest</code>(0) 这是运行 Linux 内核控制下的来宾操作系统的虚拟 CPU 所花费的时间。(since 2.6.24)</li>
<li><code>guest_nice</code>(0) 运行 niced 客户端的时间( Linux 内核控制下的客户操作系统的虚拟CPU)。(since Linux 2.6.33)</li>
</ul>
<p>具体使用率计算请查看 <a href="https://time.geekbang.org/column/article/71982" target="_blank" rel="noopener">《Linux环境下进程的CPU占用率》</a> 还是有点麻烦的 ~ </p>
</li>
</ol>
<h2 id="2-2-使用-top-命令查看进程信息"><a href="#2-2-使用-top-命令查看进程信息" class="headerlink" title="2.2 使用 top 命令查看进程信息"></a>2.2 使用 top 命令查看进程信息</h2><ol>
<li><p>直接输入 <code>top</code> 可查看所有进程的 <code>cpu</code> 使用情况</p>
<p>几个常用的参数：</p>
<ul>
<li><code>-d</code>: 后面接秒数，就是整个进程画面更新的频率。默认是 5 秒。</li>
<li><code>-b</code>: 以批处理的方式执行 top，还有更多的参数可用。通常会搭配数据流重导向，将批处理的结果输出为文件。</li>
<li><code>-n</code>: 与 -b 搭配，意义是，需要进行几次 top 的输出结果。</li>
<li><code>-p</code>: 指定某个 PID 来进行观察监测。</li>
<li>在 top 执行过程中可以使用的按键命令：</li>
<li><code>?</code>: 显示在 top 中可以输入的按键命令。</li>
<li><code>P</code>: 按照 CPU 的使用资源排序显示。</li>
<li><code>M</code>: 按内存（Memory）的使用资源排序显示。</li>
<li><code>N</code>: 按 PID 来排序。</li>
<li><code>T</code>: 按该进程使用的 CPU 时间积累（TIME+）排序。</li>
<li><code>k</code>: 给某个 PID 一个信号（signal）。</li>
<li><code>r</code>: 给某个 PID 重新确定一个值。</li>
<li><code>1</code>: 显示所有 CPU 占用信息。</li>
</ul>
</li>
<li><p>监测进程 13620</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -d 2 -p 13620</span><br></pre></td></tr></table></figure>

<p>会一直输出进程 13620 的信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">top - 16:27:35 up 4 days, 7:43, 2 users, load average: 0.35, 0.47, 0.44</span><br><span class="line">Tasks: 1 total, 1 running, 0 sleeping, 0 stopped, 0 zombie</span><br><span class="line">Cpu(s): 0.1%us, 3.1%sy, 0.0%ni, 96.5%id, 0.0%wa, 0.0%hi, 0.3%si, 0.0%st</span><br><span class="line">Mem: 16320632k total, 1790796k used, 14529836k free, 233168k buffers</span><br><span class="line">Swap: 8232952k total, 0k used, 8232952k free, 941540k cached</span><br><span class="line"> </span><br><span class="line">PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND</span><br><span class="line">13620 test1370 20 0 11060 944 760 R 53.4 0.0 0:04.78 netperf</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="3-有没有方便的-Android-卡顿排查工具？"><a href="#3-有没有方便的-Android-卡顿排查工具？" class="headerlink" title="3 有没有方便的 Android 卡顿排查工具？"></a>3 有没有方便的 Android 卡顿排查工具？</h1><p>日常开发中比较熟悉的工具分为两个流派：</p>
<ul>
<li><p>instrument 流派</p>
<p>获取一段时间内所有函数的调用过程，可以通过分析这段时间内的函数调用流程，再进一步分析待优化的点。</p>
</li>
<li><p>sample 流派</p>
<p>有选择性或者采用抽样的方式观察某些函数调用过程，可以通过这些有限的信息推测出流程中的可疑点，然后再继续细化分析。</p>
</li>
</ul>
<h2 id="3-1-Traceview"><a href="#3-1-Traceview" class="headerlink" title="3.1 Traceview"></a>3.1 Traceview</h2><p>我在 <a href="https://calmcenter.club/2019/start-optimization.html#toc-heading-7">《App 初体验-启动优化 2.2.1 TraceView》</a> 中讲过 <code>TraceView</code>  的基本使用方法。<code>Traceview</code> 属于 <code>instrument</code> 类型，它利用 Android Runtime 函数调用的 event 事件，将函数运行的耗时和调用关系写入 trace 文件中，它可以用来查看整个过程有哪些函数调用。</p>
<p>工具本身带来的性能开销过大，有时无法反映真实的情况。在 <code>Android 5.0</code> 之后，新增了<code>startMethodTracingSampling</code> 方法，可以使用基于样本的方式进行分析，以减少分析对运行时的性能影响。新增了 sample 类型后，就需要我们在开销和信息丰富度之间做好权衡。</p>
<h2 id="3-2-Nanoscope"><a href="#3-2-Nanoscope" class="headerlink" title="3.2 Nanoscope"></a>3.2 Nanoscope</h2><p> <a href="https://calmcenter.club/2019/start-optimization.html#toc-heading-10">《App 初体验-启动优化 2.2.4 Nanoscope》</a> 查看原理即项目地址。它是在 <code>instrument</code> 类型的性能分析工具中性能损耗比较小的。</p>
<h2 id="3-3-systrace"><a href="#3-3-systrace" class="headerlink" title="3.3 systrace"></a>3.3 systrace</h2><p> <a href="https://calmcenter.club/2019/start-optimization.html#toc-heading-8">《App 初体验-启动优化 2.2.2 systrace》</a> 查看具体使用方法。其中还讲到了 <code>systrace + 函数插桩 AOP</code></p>
<p><code>systrace</code> 工具只能监控特定系统调用的耗时情况，所以它是属于 <code>sample</code> 类型，而且性能开销非常低。但是它不支持应用程序代码的耗时分析，所以在使用时有一些局限性。</p>
<h2 id="3-4-Simpleperf"><a href="#3-4-Simpleperf" class="headerlink" title="3.4 Simpleperf"></a>3.4 Simpleperf</h2><p>分析 <code>Native</code> 函数时使用的工具，在 <code>Android Studio 3.2</code> 也在 <code>Profiler</code> 中直接支持 <code>Simpleperf</code>。</p>
<p><code>Simpleperf</code> 属于 <code>sample</code> 类型，它的性能开销非常低，使用火焰图展示分析结果。</p>
<p><strong>总结：</strong></p>
<p>选择哪种工具，需要看具体的场景。如果需要分析 <code>Native</code> 代码的耗时，可以选择 <code>Simpleperf</code>；如果想分析系统调用，可以选择 <code>systrace</code>；如果想分析整个程序执行流程的耗时，可以选择 <code>Traceview</code> 或者<code>插桩版本的 systrace</code>。<br><code>systrace</code> 利用了 <code>Linux</code> 的 <a href="http://source.android.com/devices/tech/debug/ftrace" target="_blank" rel="noopener">ftrace</a> 调试工具，相当于在系统各个关键位置都添加了一些性能探针，也就是在代码里加了一些性能监控的埋点。<code>Android</code> 在 <code>ftrace</code> 的基础上封装了<code>atrace</code>，并增加了更多特有的探针，例如 <code>Graphics</code>、<code>Activity Manager</code>、<code>Dalvik VM</code>、<code>System Server</code> 等。</p>
<h2 id="3-5-可视化方法（Android-Studio-Profiler）"><a href="#3-5-可视化方法（Android-Studio-Profiler）" class="headerlink" title="3.5 可视化方法（Android Studio Profiler）"></a>3.5 可视化方法（Android Studio Profiler）</h2><p>在 <code>Android Studio 3.2</code> 的 <code>CPU Profiler</code> 中直接集成了几种性能分析工具</p>
<ul>
<li><strong>Sample Java Methods</strong> 的功能类似于 <code>Traceview</code> 的 <code>sample</code> 类型。</li>
<li><strong>Trace Java Methods</strong> 的功能类似于 <code>Traceview</code> 的 <code>instrument</code> 类型。</li>
<li><strong>Trace System Calls</strong> 的功能类似于 <code>systrace</code>。</li>
<li><strong>SampleNative</strong> (API Level 26+) 的功能类似于 <code>Simpleperf</code>。</li>
</ul>
<p>这些分析工具都支持了 <code>Call Chart</code> 和 <code>Flame Chart</code> 两种展示方式。</p>
<ol>
<li><p><strong>Call Chart</strong></p>
<p><code>Call Chart</code> 是 <code>Traceview</code> 和 <code>systrace</code> 默认使用的展示方式。它按照应用程序的函数执行顺序来展示，适合用于分析整个流程的调用。举一个最简单的例子，A 函数调用 B 函数，B 函数调用 C 函数，循环三次，就得到了下面的 <code>Call Chart</code>。</p>
<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://static001.geekbang.org/resource/image/db/3e/db3612f661d29efe59854df2e6c2383e.jpg" alt="图片来源于 Android开发高手课"></p>
<p><code>Call Chart</code> 就像给应用程序做一个心电图，我们可以看到在这一段时间内，各个线程的具体工作，比如是否存在线程间的锁、主线程是否存在长时间的 <code>I/O</code> 操作、是否存在空闲等。</p>
</li>
<li><p><strong>Flame Chart</strong></p>
</li>
</ol>
<p>Flame Chart 也就是<strong>火焰图</strong>。它跟 Call Chart 不同的是，Flame Chart 以一个全局的视野来看待一段时间的调用分布，它就像给应用程序拍 X 光片，可以很自然地把时间和空间两个维度上的信息融合在一张图上。</p>
<p>上面函数调用的例子，换成火焰图的展示结果如下。</p>
<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://static001.geekbang.org/resource/image/6c/01/6ca232173daf9e71f06ac22252d65d01.jpg" alt="图片来源于 Android开发高手课"></p>
<p>当我们不想知道应用程序的整个调用流程，只想直观看出哪些代码路径花费的 <code>CPU</code> 时间较多时，火焰图就是一个非常好的选择。</p>
<p>火焰图还可以使用在各种各样的维度，例如内存、I/O 的分析。有些内存可能非常缓慢地泄漏，通过一个内存的火焰图，我们就知道哪些路径申请的内存最多，有了火焰图我们根本不需要分析源代码，也不需要分析整个流程。</p>
<h2 id="3-6-Android-Performance-Monitor（BlockCanary）"><a href="#3-6-Android-Performance-Monitor（BlockCanary）" class="headerlink" title="3.6 Android Performance Monitor（BlockCanary）"></a>3.6 Android Performance Monitor（BlockCanary）</h2><p><a href="https://github.com/markzhai/AndroidPerformanceMonitor" target="_blank" rel="noopener">AndroidPerformanceMonitor</a> 是一个Android平台的一个非侵入式的性能监控组件，应用只需要实现一个抽象类，提供一些该组件需要的上下文环境，就可以在平时使用应用的时候检测主线程上的各种卡慢问题，并通过组件提供的各种信息分析出原因并进行修复。</p>
<h2 id="3-7-Profilo"><a href="#3-7-Profilo" class="headerlink" title="3.7 Profilo"></a>3.7 Profilo</h2><p>2018 年 3 月，<code>Facebook</code> 开源了一个叫 <a href="https://github.com/facebookincubator/profilo" target="_blank" rel="noopener">Profilo</a> 的库， 它收集了各大方案的优点。</p>
<ol>
<li><p><strong>集成 atrace 功能</strong>。</p>
<p>这样所有 <code>systrace</code> 的探针我们都可以拿到，例如四大组件生命周期、锁等待时间、类校验、<code>GC</code> 时间等。</p>
</li>
<li><p><strong>快速获取 Java 堆栈</strong></p>
<p>这里有一个误区，大家都觉得在某个线程不断地获取主线程堆栈是不耗时的。但是事实上获取堆栈的代价是巨大的，它要暂停主线程的运行。</p>
<p>而 <code>profilo</code> 巧妙的解决的这个问题，可以实现线程一边继续跑步，我们还可以帮它做检查，而且耗时基本忽略不计。</p>
</li>
</ol>
<p>不用插桩、性能基本没有影响、捕捉信息还全，那 <code>Profilo</code> 不就是完美的化身吗？当然由于它利用了大量的黑科技，兼容性是需要注意的问题。它内部实现有大量函数的 <code>Hook</code>，<code>unwind</code> 也需要强依赖 <code>Android Runtime</code> 实现。<code>Facebook</code> 已经将 <code>Profilo</code> 投入到线上使用，但由于目前 <code>Profilo</code> 快速获取堆栈功能依然不支持 <code>Android 8.0</code> 和 <code>Android 9.0</code>，鉴于稳定性问题，建议采取抽样部分用户的方式来开启该功能。</p>
<p><strong>帮助理解</strong></p>
<ul>
<li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-ftrace/index.html" target="_blank" rel="noopener">ftrace 简介</a>、<a href="https://www.ibm.com/developerworks/cn/linux/l-cn-ftrace1/index.html" target="_blank" rel="noopener">ftrace 使用（上）</a>、<a href="https://www.ibm.com/developerworks/cn/linux/l-cn-ftrace2/index.html" target="_blank" rel="noopener">frace 使用（下）</a></li>
<li><a href="http://source.android.com/devices/tech/debug/ftrace" target="_blank" rel="noopener">atrace 介绍</a>、<a href="http://android.googlesource.com/platform/frameworks/native/+/master/cmds/atrace/atrace.cpp" target="_blank" rel="noopener">atrace 实现</a></li>
</ul>
<p>每个工具都可以生成不同的展示方式，我们需要根据不同的使用场景选择合适的方式。</p>
<hr>
<h1 id="4-卡顿现场"><a href="#4-卡顿现场" class="headerlink" title="4 卡顿现场"></a>4 卡顿现场</h1><h2 id="4-1-获取-java-线程状态"><a href="#4-1-获取-java-线程状态" class="headerlink" title="4.1 获取 java 线程状态"></a>4.1 获取 java 线程状态</h2><p>通过 <code>Thread</code> 的 <code>getState</code> 方法可以获取线程状态，<strong>WAITING</strong>、<strong>TIME_WAITING</strong> 和 <strong>BLOCKED</strong> 都是需要特别注意的状态。</p>
<p>BLOCKED: 是指线程正在等待获取锁，对应的是下面代码中的情况一；</p>
<p>WAITING: 是指线程正在等待其他线程的“唤醒动作”，对应的是代码中的情况二。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (object)  &#123;     <span class="comment">// 情况一：在这里卡住 --&gt; BLOCKED</span></span><br><span class="line">    object.wait();           <span class="comment">// 情况二：在这里卡住 --&gt; WAITING</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过当一个线程进入 WAITING 状态时，它不仅会释放 CPU 资源，还会将持有的 object 锁也同时释放。</p>
<p>更多相关资料 <a href="https://juejin.im/post/5b31b510e51d4558a426f7e9" target="_blank" rel="noopener">《Java 线程 Dump 分析》</a></p>
<h2 id="4-2-获得所有线程堆栈"><a href="#4-2-获得所有线程堆栈" class="headerlink" title="4.2 获得所有线程堆栈"></a>4.2 获得所有线程堆栈</h2><p>当我们发现有个线程导致主线程 <code>BLOCKED</code> ，需要通过 <code>Thread.getAllStackTraces()</code> 拿所有线程的堆栈，需要注意的是在 <code>Android 7.0</code>，<code>getAllStackTraces</code>是不会返回主线程的堆栈的。</p>
<h2 id="4-4-SIGQUIT-信号实现"><a href="#4-4-SIGQUIT-信号实现" class="headerlink" title="4.4 SIGQUIT 信号实现"></a>4.4 SIGQUIT 信号实现</h2><p>注：需要 <code>root</code> </p>
<p><code>Android</code> 应用发生 <code>ANR</code> 时，系统会发出 <code>SIGQUIT</code> 信号给发生 <code>ANR</code> 进程。系统信号捕捉线程触发输出<code>/data/anr/traces.txt</code> 文件，记录问题产生虚拟机、线程堆栈相关信息。这个 <code>trace</code> 文件中包含了线程信息和锁的信息，借助这个 <code>trace</code> 文件可以分析卡死的原因。</p>
<p>由此，如果利用这个系统原有的机制，自己在线程卡死时候触发traces文件的形成进行上报，便可以把线程卡死的关键进行进行上报。本监控方案便是<strong>利用系统机制进行卡死信息的抓取</strong>：</p>
<ol>
<li><p>当监控线程发现被监控线程卡死时，主动向系统发送 <code>SIGQUIT</code> 信号。</p>
</li>
<li><p>等待 <code>/data/anr/traces.txt</code> 文件生成。</p>
</li>
<li><p>文件生成以后进行上报。</p>
</li>
</ol>
<p>分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程名称; 优先级; 线程id; 线程状态</span></span><br><span class="line"><span class="string">"main"</span> prio=<span class="number">5</span> tid=<span class="number">1</span> Suspended</span><br><span class="line">  <span class="comment">// 线程组;  线程suspend计数; 线程debug suspend计数; </span></span><br><span class="line">  | group=<span class="string">"main"</span> sCount=<span class="number">1</span> dsCount=<span class="number">0</span> obj=<span class="number">0x74746000</span> self=<span class="number">0xf4827400</span></span><br><span class="line">  <span class="comment">// 线程native id; 进程优先级; 调度者优先级;</span></span><br><span class="line">  | sysTid=<span class="number">28661</span> nice=-<span class="number">4</span> cgrp=<span class="keyword">default</span> sched=<span class="number">0</span>/<span class="number">0</span> handle=<span class="number">0xf72cbbec</span></span><br><span class="line">  <span class="comment">// native线程状态; 调度者状态; 用户时间utime; 系统时间stime; 调度的CPU</span></span><br><span class="line">  | state=D schedstat=( <span class="number">3137222937</span> <span class="number">94427228</span> <span class="number">5819</span> ) utm=<span class="number">218</span> stm=<span class="number">95</span> core=<span class="number">2</span> HZ=<span class="number">100</span></span><br><span class="line">  <span class="comment">// stack相关信息</span></span><br><span class="line">  | stack=<span class="number">0xff717000</span>-<span class="number">0xff719000</span> stackSize=<span class="number">8</span>MB</span><br></pre></td></tr></table></figure>

<p>其中 <code>utm</code> 代表 <code>utime</code>，<code>HZ</code> 代表 <code>CPU</code> 的时钟频率，将 <code>utime</code> 转换为毫秒的公式是 <code>time * 1000/HZ</code>。例子中 <code>utm=218</code>，也就是 <code>218*1000/100=2180</code> 毫秒。</p>
<h2 id="4-5-Hook-实现"><a href="#4-5-Hook-实现" class="headerlink" title="4.5 Hook 实现"></a>4.5 Hook 实现</h2><p>用 <code>SIGQUIT</code> 信号量获取 <code>ANR</code> 日志，从而拿到所有线程的各种信息，这套方案看起来很美好。但事实上，它存在这几个问题：</p>
<ol>
<li><strong>可行性。</strong> 高版本系统已经没有权限读取 <code>/data/anr/traces.txt</code> 文件。需要 <code>root</code> 手机</li>
<li><strong>性能。</strong>获取所有线程堆栈以及各种信息非常耗时，对于卡顿场景不一定合适，它可能会进一步加剧用户的卡顿。</li>
</ol>
<p><a href="https://www.jianshu.com/p/f406d535a8bc" target="_blank" rel="noopener">Android trace文件抓取原理</a>   <a href="https://mp.weixin.qq.com/s/g-WzYF3wWAljok1XjPoo7w?" target="_blank" rel="noopener">Android 平台 Native 代码的崩溃捕获机制及实现</a></p>
<p><a href="https://blog.csdn.net/oujunli/article/details/9102101" target="_blank" rel="noopener">通过Android trace文件分析死锁ANR</a> </p>
<p>能力有限，还在研究中。。</p>
<p><strong>思路：</strong> <code>hook libart.so</code> 。通过<code>hook ThreadList</code> 和 <code>Thread</code> 的函数，获得跟 <code>ANR</code> 一样的堆栈。为了稳定性，我们会在 <code>fork</code> 子进程执行。</p>
<p>  优点：信息很全，基本跟 <code>ANR</code> 的日志一样，有 <code>native</code> 线程状态，锁信息等等。<br>  缺点：黑科技的兼容性问题，失败时可以用 <code>Thread.getAllStackTraces()</code> 兜底</p>
<p>获取Java堆栈的方法还可以用在卡顿时，因为使用fork进程，所以可以做到完全不卡主进程。</p>
<p><code>Breakpad</code> 使用了 <code>fork</code> 子进程甚至孙进程的方式去收集崩溃现场，即便出现二次崩溃，也只是这部分信息丢失。</p>
<h1 id="5-Demo-相关-Demo-学习"><a href="#5-Demo-相关-Demo-学习" class="headerlink" title="5 Demo 相关 Demo 学习"></a>5 Demo 相关 Demo 学习</h1><h2 id="5-1-抓取-CPU-数据"><a href="#5-1-抓取-CPU-数据" class="headerlink" title="5.1 抓取 CPU 数据"></a>5.1 抓取 CPU 数据</h2><p><a href="https://github.com/AndroidAdvanceWithGeektime/Chapter05" target="_blank" rel="noopener">Chapter05</a> </p>
<p>模仿 <a href="http://androidxref.com/9.0.0_r3/xref/frameworks/base/core/java/com/android/internal/os/ProcessCpuTracker.java" target="_blank" rel="noopener">ProcessCpuTracker.java</a> 拿到一段时间内各个线程的耗时占比</p>
<p>示例的日志数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">usage: CPU usage <span class="number">5000</span>ms(from <span class="number">23</span>:<span class="number">23</span>:<span class="number">33.000</span> to <span class="number">23</span>:<span class="number">23</span>:<span class="number">38.000</span>):</span><br><span class="line">System TOTAL: <span class="number">2.1</span>% user + <span class="number">16</span>% kernel + <span class="number">9.2</span>% iowait + <span class="number">0.2</span>% irq + <span class="number">0.1</span>% softirq + <span class="number">72</span>% idle</span><br><span class="line">CPU Core: <span class="number">8</span></span><br><span class="line">Load Average: <span class="number">8.74</span> / <span class="number">7.74</span> / <span class="number">7.36</span></span><br><span class="line"></span><br><span class="line">Process:com.sample.app </span><br><span class="line">  <span class="number">50</span>% <span class="number">23468</span>/com.sample.app(S): <span class="number">11</span>% user + <span class="number">38</span>% kernel faults:<span class="number">4965</span></span><br><span class="line"></span><br><span class="line">Threads:</span><br><span class="line">  <span class="number">43</span>% <span class="number">23493</span>/singleThread(R): <span class="number">6.5</span>% user + <span class="number">36</span>% kernel faults：<span class="number">3094</span></span><br><span class="line">  <span class="number">3.2</span>% <span class="number">23485</span>/RenderThread(S): <span class="number">2.1</span>% user + <span class="number">1</span>% kernel faults：<span class="number">329</span></span><br><span class="line">  <span class="number">0.3</span>% <span class="number">23468</span>/.sample.app(S): <span class="number">0.3</span>% user + <span class="number">0</span>% kernel faults：<span class="number">6</span></span><br><span class="line">  <span class="number">0.3</span>% <span class="number">23479</span>/HeapTaskDaemon(S): <span class="number">0.3</span>% user + <span class="number">0</span>% kernel faults：<span class="number">982</span></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>

<ol>
<li>在 <code>System Total</code> 部分 <code>user</code> 占用不多，<code>CPU idle</code> 很高，消耗多在 <code>kernel</code> 和 <code>iowait</code>。</li>
<li><code>CPU</code> 是 8 核的，<code>Load Average</code> 大约也是 8，表示 <code>CPU</code> 并不处于高负载情况。</li>
<li>在 <code>Process</code> 里展示了这段时间内 <code>sample app</code> 的 <code>CPU</code> 使用情况：<code>user</code> 低，<code>kernel</code> 高，并且有 <code>4965</code> 次 <code>page faults</code>。<ol>
<li><code>page faluts</code> 分为三种：<code>minor page fault</code>、<code>major page fault</code> 和 <code>invalid page fault</code></li>
</ol>
</li>
<li>在 <code>Threads</code> 里展示了每个线程的 <code>usage</code> 情况，当前只有 <code>singleThread</code> 处于 <code>R</code> 状态，并且当前线程产生了 3096 次 <code>page faults</code>，其他的线程包括主线程（<code>Sample</code> 日志里可见的）都是处于 <code>S</code>状态。<ol>
<li><code>R</code>：代表线程处于 <code>Running</code> 或者 <code>Runnable</code> 状态。<code>Running</code> 状态说明线程当前被某个 <code>Core</code> 执行，<code>Runnable</code> 状态说明线程当前正在处于等待队列中等待某个 <code>Core</code> 空闲下来去执行。</li>
<li><code>S</code>： <code>TASK_INTERRUPTIBLE（可中断）</code>  发生这种状态是线程主动让出了 <code>CPU</code>，如果线程调用了 <code>sleep</code> 或者其他情况导致了自愿式的上下文切换就会处于 <code>S</code> 状态。</li>
</ol>
</li>
</ol>
<p><code>Demo</code> 中执行 <code>Test</code> 抓取数据如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CPU usage from <span class="number">5137</span>ms to <span class="number">81</span><span class="function">ms <span class="title">ago</span> <span class="params">(<span class="number">2020</span><span class="number">-05</span><span class="number">-13</span> <span class="number">21</span>:<span class="number">57</span>:<span class="number">32.764</span> to <span class="number">2020</span><span class="number">-05</span><span class="number">-13</span> <span class="number">21</span>:<span class="number">57</span>:<span class="number">37.819</span>)</span>:</span></span><br><span class="line"><span class="function">16% 15921/com.sample.<span class="title">processtracker</span><span class="params">(R)</span>: 6.3% user + 9.6% kernel / faults: 3332 minor</span></span><br><span class="line"><span class="function">thread stats:</span></span><br><span class="line"><span class="function">15% 16145/<span class="title">SingleThread</span><span class="params">(S)</span>: 1.9% user + 13% kernel / faults: 3014 minor</span></span><br><span class="line"><span class="function">13% 17088/<span class="title">SingleThread</span><span class="params">(S)</span>: 1.3% user + 12% kernel / faults: 3016 minor</span></span><br><span class="line"><span class="function">1.3% 15921/.<span class="title">processtracker</span><span class="params">(R)</span>: 0.9% user + 0.3% kernel / faults: 40 minor</span></span><br><span class="line"><span class="function">0.5% 16002/<span class="title">RenderThread</span><span class="params">(S)</span>: 0.1% user + 0.3% kernel / faults: 37 minor</span></span><br><span class="line"><span class="function">0.1% 15942/Jit thread <span class="title">pool</span><span class="params">(S)</span>: 0.1% user + 0% kernel / faults: 222 minor</span></span><br><span class="line"><span class="function">0% 15949/<span class="title">HeapTaskDaemon</span><span class="params">(S)</span>: 0% user + 0% kernel</span></span><br><span class="line"><span class="function">...</span></span><br><span class="line"><span class="function">0% <span class="title">TOTAL</span><span class="params">()</span>: 0% user + 0% kernel</span></span><br><span class="line"><span class="function">Load: 0.0 / 0.0 / 0.0</span></span><br></pre></td></tr></table></figure>

<p>这里不太清楚为什么后面的数据都是 0 ，最后应该输出 <code>iowait</code> 才对。</p>
<p>极客时间原文例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CPU usage from <span class="number">5187</span>ms to <span class="number">121</span><span class="function">ms <span class="title">ago</span> <span class="params">(<span class="number">2018</span><span class="number">-12</span><span class="number">-28</span> <span class="number">08</span>:<span class="number">28</span>:<span class="number">27.186</span> to <span class="number">2018</span><span class="number">-12</span><span class="number">-28</span> <span class="number">08</span>:<span class="number">28</span>:<span class="number">32.252</span>)</span>:</span></span><br><span class="line"><span class="function">40% 24155/com.sample.<span class="title">processtracker</span><span class="params">(R)</span>: 14% user + 26% kernel / faults: 5286 minor</span></span><br><span class="line"><span class="function">thread stats:</span></span><br><span class="line"><span class="function">35% 24184/<span class="title">SingleThread</span><span class="params">(S)</span>: 11% user + 24% kernel / faults: 3055 minor</span></span><br><span class="line"><span class="function">2.1% 24174/<span class="title">RenderThread</span><span class="params">(S)</span>: 1.3% user + 0.7% kernel / faults: 384 minor</span></span><br><span class="line"><span class="function">1.5% 24155/.<span class="title">processtracker</span><span class="params">(R)</span>: 1.1% user + 0.3% kernel / faults: 95 minor</span></span><br><span class="line"><span class="function">0.1% 24166/<span class="title">HeapTaskDaemon</span><span class="params">(S)</span>: 0.1% user + 0% kernel / faults: 1070 minor</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">100% <span class="title">TOTAL</span><span class="params">()</span>: 3.8% user + 7.8% kernel + 11% iowait + 0.1% irq + 0% softirq + 76% idle</span></span><br><span class="line"><span class="function">Load: 6.31 / 6.52 / 6.66</span></span><br></pre></td></tr></table></figure>

<p>如果有大佬知道原因，还请告知。</p>
<p>如果产生大量的 <code>faults</code> 其实是不太正常的，或者 <code>iowait</code> 过高就需要关注是否有很密集的 <code>I/O</code> 操作。</p>
<p><a href="https://yq.aliyun.com/articles/55820" target="_blank" rel="noopener">《page fault 带来的性能问题》</a> </p>
<p><a href="http://oenhan.com/iowait-wa-vmstat" target="_blank" rel="noopener">《iowait 的形成原因和内核分析》</a></p>
<h2 id="5-2-PLTHook-监控-Thread-的创建"><a href="#5-2-PLTHook-监控-Thread-的创建" class="headerlink" title="5.2 PLTHook 监控 Thread 的创建"></a>5.2 PLTHook 监控 Thread 的创建</h2><p><a href="https://github.com/AndroidAdvanceWithGeektime/Chapter06-plus" target="_blank" rel="noopener">Chapter06-plus</a> 这个 <code>Demo</code> 与 <a href="https://www.jianshu.com/p/a26d11502ec8" target="_blank" rel="noopener">Android线程的创建过程</a>  结合，了解 <code>PLTHook</code> 的使用，以及 <code>Thread</code> 状态知识、如何创建的。</p>
<h2 id="5-3-Loop-监控卡顿"><a href="#5-3-Loop-监控卡顿" class="headerlink" title="5.3 Loop 监控卡顿"></a>5.3 Loop 监控卡顿</h2><p>在 <code>Android UI</code> 线程中有个 <code>Looper</code>，在其 <code>loop</code> 方法中会不断取出 <code>Message</code>，调用其绑定的 <code>Handler</code> 在 <code>UI</code> 线程进行执行。</p>
<p>部分代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Looper me = myLooper();</span><br><span class="line">    <span class="keyword">final</span> MessageQueue queue = me.mQueue;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Message msg = queue.next(); <span class="comment">// might block</span></span><br><span class="line">        <span class="comment">// This must be in a local variable, in case a UI event sets the logger</span></span><br><span class="line">        <span class="keyword">final</span> Printer logging = me.mLogging;</span><br><span class="line">        <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">            logging.println(<span class="string">"&gt;&gt;&gt;&gt;&gt; Dispatching to "</span> + msg.target + <span class="string">" "</span> +</span><br><span class="line">                            msg.callback + <span class="string">": "</span> + msg.what);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            msg.target.dispatchMessage(msg);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">            logging.println(<span class="string">"&lt;&lt;&lt;&lt;&lt; Finished to "</span> + msg.target + <span class="string">" "</span> + msg.callback);</span><br><span class="line">        &#125;</span><br><span class="line">        msg.recycleUnchecked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到在执行此代码前后，如果设置了 <code>logging</code>，会分别打印出 <code>&gt;&gt;&gt;&gt;&gt; Dispatching to</code>和 <code>&lt;&lt;&lt;&lt;&lt; Finished to</code> 这样的<code>log</code> 。</p>
<p>我们可以通过计算两次 <code>log</code> 之间的时间差值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Looper.getMainLooper().setMessageLogging(<span class="keyword">new</span> Printer() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String START = <span class="string">"&gt;&gt;&gt;&gt;&gt; Dispatching"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String END = <span class="string">"&lt;&lt;&lt;&lt;&lt; Finished"</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(String x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x.startsWith(START)) &#123;</span><br><span class="line">            LogMonitor.getInstance().startMonitor();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x.startsWith(END)) &#123;</span><br><span class="line">            LogMonitor.getInstance().removeMonitor();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>假设我们的阈值是 <code>1000ms</code>，当我在匹配到 <code>&gt;&gt;&gt;&gt;&gt; Dispatching</code> 时，我会在 <code>1000ms</code> 毫秒后执行一个任务（打印出 <code>UI</code> 线程的堆栈信息，会在非 <code>UI</code> 线程中进行）；</p>
<p>正常情况下，肯定是低于 <code>1000ms</code> 执行完成的，所以当我匹配到 <code>&lt;&lt;&lt;&lt;&lt; Finished</code> ，会移除该任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogMonitor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LogMonitor sInstance = <span class="keyword">new</span> LogMonitor();</span><br><span class="line">    <span class="keyword">private</span> Handler mIoHandler;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> TIME_BLOCK = <span class="number">1000L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LogMonitor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HandlerThread mLogThread = <span class="keyword">new</span> HandlerThread(<span class="string">"log"</span>);</span><br><span class="line">        mLogThread.start();</span><br><span class="line">        mIoHandler = <span class="keyword">new</span> Handler(mLogThread.getLooper());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Runnable mLogRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            StackTraceElement[] stackTrace = Looper.getMainLooper().getThread().getStackTrace();</span><br><span class="line">            <span class="keyword">for</span> (StackTraceElement s : stackTrace) &#123;</span><br><span class="line">                sb.append(s.toString() + <span class="string">"\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Log.e(<span class="string">"TAG"</span>,sb.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LogMonitor <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMonitor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; handlerClass = Class.forName(<span class="string">"android.os.Handler"</span>);</span><br><span class="line">            java.lang.reflect.Method method = handlerClass.getMethod(<span class="string">"hasCallbacks"</span>, Runnable<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            Boolean ret = (Boolean) method.invoke(mIoHandler, mLogRunnable);</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startMonitor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        mIoHandler.postDelayed(mLogRunnable,TIME_BLOCK);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeMonitor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        mIoHandler.removeCallbacks(mLogRunnable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们利用了 <code>HandlerThread</code> 这个类，同样利用了 <code>Looper</code> 机制，只不过在非UI线程中，如果执行耗时达到我们设置的阈值，则会执行 <code>mLogRunnable</code> ，打印出 <code>UI</code> 线程当前的堆栈信息；如果你阈值时间之内完成，则会 <code>remove</code> 掉该 <code>runnable</code>。</p>
<p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fmarkzhai%2FAndroidPerformanceMonitor" target="_blank" rel="noopener">BlockCanary 16 年原理分析</a>   </p>
<p>代码修改自于 <a href="https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&mid=2650822205&idx=1&sn=6b8e78bc1d71eb79a199667cf132acf7&chksm=80b782a3b7c00bb5c12437556fca68136c75409855e9252e395b545621319edf23959942b67c&scene=21#wechat_redirect" target="_blank" rel="noopener">Android UI性能优化 检测应用中的UI卡顿</a> 修改了 <code>hasCallbacks</code> 调用方式</p>
<p><strong>这个方法的缺点：</strong> 大量字符串拼接导致性能损耗严重，快速滑动时会降低帧数。</p>
<ul>
<li><strong>消息队列</strong></li>
</ul>
<p>可以通过一个监控线程，每隔 1 秒向主线程消息队列的头部插入一条空消息。假设 1 秒后这个消息并没有被主线程消费掉，说明阻塞消息运行的时间在 0～1 秒之间。换句话说，如果我们需要监控 3 秒卡顿，那在第 4 次轮询中头部消息依然没有被消费的话，就可以确定主线程出现了一次 3 秒以上的卡顿。</p>
<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://static001.geekbang.org/resource/image/b0/56/b06d5aa439e8bb75885a338df9a25f56.png" alt="图片来源于 Android开发高手课"></p>
<p>这个方案也存在一定的误差，那就是发送空消息的间隔时间。但这个间隔时间也不能太小，因为监控线程和主线程处理空消息都会带来一些性能损耗，但基本影响不大。</p>
<p><strong>这个方法的缺点：</strong> 基于消息队列的卡顿监控并不准确，正在运行的函数有可能并不是真正耗时的函数。</p>
<ul>
<li><strong>插桩</strong></li>
</ul>
<p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FTencent%2Fmatrix" target="_blank" rel="noopener">参考 微信 开源库 matrix</a></p>
<p><strong>避免方法数暴增。</strong>在函数的入口和出口应该插入相同的函数，在编译时提前给代码中每个方法分配一个独立的 <code>ID</code> 作为参数。</p>
<p><strong>过滤简单的函数。</strong>过滤一些类似直接 <code>return</code>、<code>i++</code> 这样的简单函数，并且支持黑名单配置。对一些调用非常频繁的函数，需要添加到黑名单中来降低整个方案对性能的损耗。</p>
<p>基于性能的考虑，线上只会监控主线程的耗时。最终安装包体积只增大 1～2%，平均帧率下降也在 2 帧以内。</p>
<p>插桩方案看起来美好，它也有自己的短板，那就是只能监控应用内自身的函数耗时，无法监控系统的函数调用，整个堆栈看起来好像 “缺失了” 一部分。</p>
<h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h1><blockquote>
<p><a href="https://time.geekbang.org/column/article/74044" target="_blank" rel="noopener">极客时间 Android开发高手课</a>  </p>
<p><a href="https://time.geekbang.org/column/article/71982" target="_blank" rel="noopener">《Linux环境下进程的CPU占用率》</a></p>
<p><a href="http://man7.org/linux/man-pages/man5/proc.5.html" target="_blank" rel="noopener">《Linux 文档》</a></p>
<p><a href="https://juejin.im/post/5b31b510e51d4558a426f7e9" target="_blank" rel="noopener">《Java线程Dump分析》</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1064396" target="_blank" rel="noopener">《手Q Android线程死锁监控与自动化分析实践》</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&mid=2650822205&idx=1&sn=6b8e78bc1d71eb79a199667cf132acf7&chksm=80b782a3b7c00bb5c12437556fca68136c75409855e9252e395b545621319edf23959942b67c&scene=21#wechat_redirect" target="_blank" rel="noopener">Android UI性能优化 检测应用中的UI卡顿</a></p>
<p>以及上文中的链接</p>
</blockquote>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">CalmCenter</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://calmcenter.club/2020/hobble-optimization.html">https://calmcenter.club/2020/hobble-optimization.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://calmcenter.club" target="_blank">CalmCenter</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Android/">Android</a><a class="post-meta__tags" href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">性能优化</a></div><div class="post_share"></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="/img/wechat.png" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="post-qr-code__img" src="/img/alipay.png" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/power-optimization.html"><img class="prev_cover" data-src="https://gitee.com/CalmCenter/Pic/raw/master/cover13.webp" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">App 电量优化</div></div></a></div><div class="next-post pull_right"><a href="/2020/ui-optimization.html"><img class="next_cover" data-src="https://gitee.com/CalmCenter/Pic/raw/master/cover32.webp" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">App UI优化💦</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/ui-optimization.html" title="App UI优化💦"><img class="relatedPosts_cover" data-src="https://gitee.com/CalmCenter/Pic/raw/master/cover32.webp"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-04-15</div><div class="relatedPosts_title">App UI优化💦</div></div></a></div><div class="relatedPosts_item"><a href="/2019/complete-works-of-android-performance.html" title="Android 性能优化篇"><img class="relatedPosts_cover" data-src="https://gitee.com/CalmCenter/Pic/raw/master/20200228233120.webp"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2019-12-01</div><div class="relatedPosts_title">Android 性能优化篇</div></div></a></div><div class="relatedPosts_item"><a href="/2020/memory-optimization2.html" title="App 内存检测优化💦"><img class="relatedPosts_cover" data-src="https://gitee.com/CalmCenter/Pic/raw/master/cover11.webp"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-02-29</div><div class="relatedPosts_title">App 内存检测优化💦</div></div></a></div><div class="relatedPosts_item"><a href="/2020/network-optimization.html" title="App 网络优化🌞"><img class="relatedPosts_cover" data-src="https://gitee.com/CalmCenter/Pic/raw/master/cover19.webp"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-05-20</div><div class="relatedPosts_title">App 网络优化🌞</div></div></a></div><div class="relatedPosts_item"><a href="/2020/power-optimization.html" title="App 电量优化"><img class="relatedPosts_cover" data-src="https://gitee.com/CalmCenter/Pic/raw/master/cover13.webp"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-05-10</div><div class="relatedPosts_title">App 电量优化</div></div></a></div><div class="relatedPosts_item"><a href="/2020/stability-optimization.html" title="稳定性优化"><img class="relatedPosts_cover" data-src="https://gitee.com/CalmCenter/Pic/raw/master/cover26.webp"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-06-02</div><div class="relatedPosts_title">稳定性优化</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var requestSetting = function (from,set) {
  var from = from
  var setting = set.split(',').filter(function(item){
  return from.indexOf(item) > -1
  });
  setting = setting.length == 0 ? from :setting;
  return setting
}

var guestInfo = requestSetting(['nick','mail','link'],'nick,mail,link')
var requiredFields = requestSetting(['nick','mail','link'],'nick,mail')

window.valine = new Valine({
  el:'#vcomment',
  appId: 'KiQHU70TUHYrumpFuuhC3UEg-gzGzoHsz',
  appKey: 'wX1m2ATu8q4CyeRhOQ3FUucn',
  notify: true,
  verify: true,
  placeholder: '💦💦既然来了何不留下你的足迹(支持 Markdown 哦~)',
  avatar: 'robohash',
  meta: guestInfo,
  pageSize: '10',
  lang: 'zh-CN',
  recordIP: false,
  serverURLs: '',
  emojiCDN: '',
  emojiMaps: "",
  enableQQ: false,
  requiredFields: requiredFields
});</script></div></article></main><footer id="footer" style="background-image: url(https://gitee.com/CalmCenter/Pic/raw/master/cover20.webp)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 By CalmCenter</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div><div id="landlord"><div class="message" style="opacity:0"></div><canvas class="live2d" id="live2d" width="240" height="250"></canvas><div class="hide-button">隐藏</div></div><script type="text/javascript" src="https://cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script><script type="text/javascript">var message_Path = '/live2d/'
var home_Path = 'https://calmcenter.club/'</script><script type="text/javascript" src="/live2d/js/live2d.js"></script><script type="text/javascript" src="/live2d/js/message.js"></script><script type="text/javascript">loadlive2d("live2d", "/live2d/model/xxb2/model.json");</script><link rel="stylesheet" href="/live2d/css/live2d.css"/></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script id="ribbon_piao" mobile="true" src="/js/third-party/piao.js"></script><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script src="/js/search/local-search.js"></script></body></html>